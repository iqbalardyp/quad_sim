// Generated by the protocol buffer compiler.  DO NOT EDIT!
// source: mw.internal.robotics.gazebotransport.CoSimMsgs.proto

#define INTERNAL_SUPPRESS_PROTOBUF_FIELD_DEPRECATION
#include "mw.internal.robotics.gazebotransport.CoSimMsgs.pb.h"

#include <algorithm>

#include <google/protobuf/stubs/common.h>
#include <google/protobuf/stubs/port.h>
#include <google/protobuf/stubs/once.h>
#include <google/protobuf/io/coded_stream.h>
#include <google/protobuf/wire_format_lite_inl.h>
#include <google/protobuf/descriptor.h>
#include <google/protobuf/generated_message_reflection.h>
#include <google/protobuf/reflection_ops.h>
#include <google/protobuf/wire_format.h>
// @@protoc_insertion_point(includes)

namespace mw {
namespace internal {
namespace robotics {
namespace gazebotransport {

namespace {

const ::google::protobuf::Descriptor* PluginVersion_descriptor_ = NULL;
const ::google::protobuf::internal::GeneratedMessageReflection*
  PluginVersion_reflection_ = NULL;
const ::google::protobuf::Descriptor* Time_descriptor_ = NULL;
const ::google::protobuf::internal::GeneratedMessageReflection*
  Time_reflection_ = NULL;
const ::google::protobuf::Descriptor* PacketHeader_descriptor_ = NULL;
const ::google::protobuf::internal::GeneratedMessageReflection*
  PacketHeader_reflection_ = NULL;
const ::google::protobuf::EnumDescriptor* PacketHeader_MsgID_descriptor_ = NULL;
const ::google::protobuf::Descriptor* Packet_descriptor_ = NULL;
const ::google::protobuf::internal::GeneratedMessageReflection*
  Packet_reflection_ = NULL;
struct PacketOneofInstance {
  int status_;
  const ::mw::internal::robotics::gazebotransport::StepSimulation* step_simulation_;
  const ::mw::internal::robotics::gazebotransport::ResetSimulation* reset_simulation_;
  const ::mw::internal::robotics::gazebotransport::Image* image_;
  const ::mw::internal::robotics::gazebotransport::RequestImage* request_image_;
  const ::mw::internal::robotics::gazebotransport::RequestCoSim* request_cosim_;
  const ::mw::internal::robotics::gazebotransport::StopCoSim* stop_cosim_;
  const ::mw::internal::robotics::gazebotransport::GetGroundTruthWorldPose* get_ground_truth_world_pose_;
  const ::mw::internal::robotics::gazebotransport::Pose* pose_;
  const ::mw::internal::robotics::gazebotransport::StopSimulation* stop_simulation_;
  const ::mw::internal::robotics::gazebotransport::LaserData* laser_data_;
  const ::mw::internal::robotics::gazebotransport::RequestLaser* request_laser_;
  const ::mw::internal::robotics::gazebotransport::ImuData* imu_data_;
  const ::mw::internal::robotics::gazebotransport::RequestImu* request_imu_;
  const ::mw::internal::robotics::gazebotransport::SubscribeImage* subscribe_image_;
  const ::mw::internal::robotics::gazebotransport::SubscribeLaser* subscribe_laser_;
  const ::mw::internal::robotics::gazebotransport::SubscribeImu* subscribe_imu_;
  const ::mw::internal::robotics::gazebotransport::ApplyJointTorque* apply_joint_torque_;
  const ::mw::internal::robotics::gazebotransport::GetPose* get_pose_;
  const ::mw::internal::robotics::gazebotransport::GetTopicList* get_topic_list_;
  const ::mw::internal::robotics::gazebotransport::TopicList* topic_list_;
  const ::mw::internal::robotics::gazebotransport::GetModelInfo* get_model_info_;
  const ::mw::internal::robotics::gazebotransport::ModelInfo* model_info_;
  const ::mw::internal::robotics::gazebotransport::ApplyLinkWrench* apply_link_wrench_;
  const ::mw::internal::robotics::gazebotransport::MaxStepSize* max_step_size_;
  const ::mw::internal::robotics::gazebotransport::CustomMessageSupport* custom_message_support_;
  const ::mw::internal::robotics::gazebotransport::InitCustomPublisher* init_custom_publisher_;
  const ::mw::internal::robotics::gazebotransport::InitCustomSubscriber* init_custom_subscriber_;
  const ::mw::internal::robotics::gazebotransport::RequestCustomMessageSupport* request_custom_message_support_;
  const ::mw::internal::robotics::gazebotransport::SetJointPosition* set_joint_position_;
  const ::mw::internal::robotics::gazebotransport::SetJointVelocity* set_joint_velocity_;
  const ::mw::internal::robotics::gazebotransport::GetJointState* get_joint_state_;
  const ::mw::internal::robotics::gazebotransport::JointState* joint_state_;
  const ::mw::internal::robotics::gazebotransport::SetLinkWorldPose* set_link_world_pose_;
  const ::mw::internal::robotics::gazebotransport::SetLinkLinearVelocity* set_link_linear_velocity_;
  const ::mw::internal::robotics::gazebotransport::SetLinkAngularVelocity* set_link_angular_velocity_;
  const ::mw::internal::robotics::gazebotransport::GetLinkState* get_link_state_;
  const ::mw::internal::robotics::gazebotransport::LinkState* link_state_;
  const ::mw::internal::robotics::gazebotransport::Gazebomodel* gazebo_model_;
  const ::mw::internal::robotics::gazebotransport::GetGazeboModelParam* get_gazebo_model_param_;
  const ::mw::internal::robotics::gazebotransport::GazeboModelSDF* gazebo_model_sdf_;
  const ::mw::internal::robotics::gazebotransport::GetGazeboModelSDF* get_gazebo_model_sdf_;
}* Packet_default_oneof_instance_ = NULL;
const ::google::protobuf::EnumDescriptor* Packet_CoSimError_descriptor_ = NULL;
const ::google::protobuf::Descriptor* StepSimulation_descriptor_ = NULL;
const ::google::protobuf::internal::GeneratedMessageReflection*
  StepSimulation_reflection_ = NULL;
const ::google::protobuf::Descriptor* ResetSimulation_descriptor_ = NULL;
const ::google::protobuf::internal::GeneratedMessageReflection*
  ResetSimulation_reflection_ = NULL;
const ::google::protobuf::EnumDescriptor* ResetSimulation_ResetBehavior_descriptor_ = NULL;
const ::google::protobuf::Descriptor* Image_descriptor_ = NULL;
const ::google::protobuf::internal::GeneratedMessageReflection*
  Image_reflection_ = NULL;
const ::google::protobuf::Descriptor* RequestImage_descriptor_ = NULL;
const ::google::protobuf::internal::GeneratedMessageReflection*
  RequestImage_reflection_ = NULL;
const ::google::protobuf::Descriptor* RequestCoSim_descriptor_ = NULL;
const ::google::protobuf::internal::GeneratedMessageReflection*
  RequestCoSim_reflection_ = NULL;
const ::google::protobuf::Descriptor* StopCoSim_descriptor_ = NULL;
const ::google::protobuf::internal::GeneratedMessageReflection*
  StopCoSim_reflection_ = NULL;
const ::google::protobuf::Descriptor* GetGroundTruthWorldPose_descriptor_ = NULL;
const ::google::protobuf::internal::GeneratedMessageReflection*
  GetGroundTruthWorldPose_reflection_ = NULL;
const ::google::protobuf::Descriptor* Point_descriptor_ = NULL;
const ::google::protobuf::internal::GeneratedMessageReflection*
  Point_reflection_ = NULL;
const ::google::protobuf::Descriptor* Quaternion_descriptor_ = NULL;
const ::google::protobuf::internal::GeneratedMessageReflection*
  Quaternion_reflection_ = NULL;
const ::google::protobuf::Descriptor* Pose_descriptor_ = NULL;
const ::google::protobuf::internal::GeneratedMessageReflection*
  Pose_reflection_ = NULL;
const ::google::protobuf::Descriptor* StopSimulation_descriptor_ = NULL;
const ::google::protobuf::internal::GeneratedMessageReflection*
  StopSimulation_reflection_ = NULL;
const ::google::protobuf::Descriptor* LaserData_descriptor_ = NULL;
const ::google::protobuf::internal::GeneratedMessageReflection*
  LaserData_reflection_ = NULL;
const ::google::protobuf::Descriptor* RequestLaser_descriptor_ = NULL;
const ::google::protobuf::internal::GeneratedMessageReflection*
  RequestLaser_reflection_ = NULL;
const ::google::protobuf::Descriptor* ImuData_descriptor_ = NULL;
const ::google::protobuf::internal::GeneratedMessageReflection*
  ImuData_reflection_ = NULL;
const ::google::protobuf::Descriptor* RequestImu_descriptor_ = NULL;
const ::google::protobuf::internal::GeneratedMessageReflection*
  RequestImu_reflection_ = NULL;
const ::google::protobuf::Descriptor* SubscribeImage_descriptor_ = NULL;
const ::google::protobuf::internal::GeneratedMessageReflection*
  SubscribeImage_reflection_ = NULL;
const ::google::protobuf::Descriptor* SubscribeLaser_descriptor_ = NULL;
const ::google::protobuf::internal::GeneratedMessageReflection*
  SubscribeLaser_reflection_ = NULL;
const ::google::protobuf::Descriptor* SubscribeImu_descriptor_ = NULL;
const ::google::protobuf::internal::GeneratedMessageReflection*
  SubscribeImu_reflection_ = NULL;
const ::google::protobuf::Descriptor* ApplyLinkWrench_descriptor_ = NULL;
const ::google::protobuf::internal::GeneratedMessageReflection*
  ApplyLinkWrench_reflection_ = NULL;
const ::google::protobuf::Descriptor* ApplyJointTorque_descriptor_ = NULL;
const ::google::protobuf::internal::GeneratedMessageReflection*
  ApplyJointTorque_reflection_ = NULL;
const ::google::protobuf::Descriptor* GetPose_descriptor_ = NULL;
const ::google::protobuf::internal::GeneratedMessageReflection*
  GetPose_reflection_ = NULL;
const ::google::protobuf::Descriptor* GetTopicList_descriptor_ = NULL;
const ::google::protobuf::internal::GeneratedMessageReflection*
  GetTopicList_reflection_ = NULL;
const ::google::protobuf::Descriptor* TopicList_descriptor_ = NULL;
const ::google::protobuf::internal::GeneratedMessageReflection*
  TopicList_reflection_ = NULL;
const ::google::protobuf::Descriptor* TopicList_TopicInfo_descriptor_ = NULL;
const ::google::protobuf::internal::GeneratedMessageReflection*
  TopicList_TopicInfo_reflection_ = NULL;
const ::google::protobuf::Descriptor* GetModelInfo_descriptor_ = NULL;
const ::google::protobuf::internal::GeneratedMessageReflection*
  GetModelInfo_reflection_ = NULL;
const ::google::protobuf::Descriptor* ModelInfo_descriptor_ = NULL;
const ::google::protobuf::internal::GeneratedMessageReflection*
  ModelInfo_reflection_ = NULL;
const ::google::protobuf::Descriptor* ModelInfo_LINKS_descriptor_ = NULL;
const ::google::protobuf::internal::GeneratedMessageReflection*
  ModelInfo_LINKS_reflection_ = NULL;
const ::google::protobuf::Descriptor* ModelInfo_JOINTS_descriptor_ = NULL;
const ::google::protobuf::internal::GeneratedMessageReflection*
  ModelInfo_JOINTS_reflection_ = NULL;
const ::google::protobuf::Descriptor* ModelInfo_Model_descriptor_ = NULL;
const ::google::protobuf::internal::GeneratedMessageReflection*
  ModelInfo_Model_reflection_ = NULL;
const ::google::protobuf::Descriptor* MaxStepSize_descriptor_ = NULL;
const ::google::protobuf::internal::GeneratedMessageReflection*
  MaxStepSize_reflection_ = NULL;
const ::google::protobuf::EnumDescriptor* MaxStepSize_TYPE_descriptor_ = NULL;
const ::google::protobuf::Descriptor* InitCustomPublisher_descriptor_ = NULL;
const ::google::protobuf::internal::GeneratedMessageReflection*
  InitCustomPublisher_reflection_ = NULL;
const ::google::protobuf::Descriptor* InitCustomSubscriber_descriptor_ = NULL;
const ::google::protobuf::internal::GeneratedMessageReflection*
  InitCustomSubscriber_reflection_ = NULL;
const ::google::protobuf::Descriptor* CustomMessageSupport_descriptor_ = NULL;
const ::google::protobuf::internal::GeneratedMessageReflection*
  CustomMessageSupport_reflection_ = NULL;
const ::google::protobuf::Descriptor* RequestCustomMessageSupport_descriptor_ = NULL;
const ::google::protobuf::internal::GeneratedMessageReflection*
  RequestCustomMessageSupport_reflection_ = NULL;
const ::google::protobuf::Descriptor* SetJointPosition_descriptor_ = NULL;
const ::google::protobuf::internal::GeneratedMessageReflection*
  SetJointPosition_reflection_ = NULL;
const ::google::protobuf::Descriptor* SetJointVelocity_descriptor_ = NULL;
const ::google::protobuf::internal::GeneratedMessageReflection*
  SetJointVelocity_reflection_ = NULL;
const ::google::protobuf::Descriptor* GetJointState_descriptor_ = NULL;
const ::google::protobuf::internal::GeneratedMessageReflection*
  GetJointState_reflection_ = NULL;
const ::google::protobuf::Descriptor* Axis_descriptor_ = NULL;
const ::google::protobuf::internal::GeneratedMessageReflection*
  Axis_reflection_ = NULL;
const ::google::protobuf::Descriptor* JointState_descriptor_ = NULL;
const ::google::protobuf::internal::GeneratedMessageReflection*
  JointState_reflection_ = NULL;
const ::google::protobuf::EnumDescriptor* JointState_Joint_Type_descriptor_ = NULL;
const ::google::protobuf::Descriptor* SetLinkWorldPose_descriptor_ = NULL;
const ::google::protobuf::internal::GeneratedMessageReflection*
  SetLinkWorldPose_reflection_ = NULL;
const ::google::protobuf::Descriptor* SetLinkLinearVelocity_descriptor_ = NULL;
const ::google::protobuf::internal::GeneratedMessageReflection*
  SetLinkLinearVelocity_reflection_ = NULL;
const ::google::protobuf::Descriptor* SetLinkAngularVelocity_descriptor_ = NULL;
const ::google::protobuf::internal::GeneratedMessageReflection*
  SetLinkAngularVelocity_reflection_ = NULL;
const ::google::protobuf::Descriptor* GetLinkState_descriptor_ = NULL;
const ::google::protobuf::internal::GeneratedMessageReflection*
  GetLinkState_reflection_ = NULL;
const ::google::protobuf::Descriptor* LinkState_descriptor_ = NULL;
const ::google::protobuf::internal::GeneratedMessageReflection*
  LinkState_reflection_ = NULL;
const ::google::protobuf::Descriptor* ML_Cord_descriptor_ = NULL;
const ::google::protobuf::internal::GeneratedMessageReflection*
  ML_Cord_reflection_ = NULL;
const ::google::protobuf::Descriptor* ML_Point_descriptor_ = NULL;
const ::google::protobuf::internal::GeneratedMessageReflection*
  ML_Point_reflection_ = NULL;
const ::google::protobuf::Descriptor* ML_Quat_descriptor_ = NULL;
const ::google::protobuf::internal::GeneratedMessageReflection*
  ML_Quat_reflection_ = NULL;
const ::google::protobuf::Descriptor* ML_Pose_descriptor_ = NULL;
const ::google::protobuf::internal::GeneratedMessageReflection*
  ML_Pose_reflection_ = NULL;
const ::google::protobuf::Descriptor* ML_Inertial_descriptor_ = NULL;
const ::google::protobuf::internal::GeneratedMessageReflection*
  ML_Inertial_reflection_ = NULL;
const ::google::protobuf::Descriptor* ML_Links_descriptor_ = NULL;
const ::google::protobuf::internal::GeneratedMessageReflection*
  ML_Links_reflection_ = NULL;
const ::google::protobuf::Descriptor* ML_Axis_descriptor_ = NULL;
const ::google::protobuf::internal::GeneratedMessageReflection*
  ML_Axis_reflection_ = NULL;
const ::google::protobuf::Descriptor* ML_Joints_descriptor_ = NULL;
const ::google::protobuf::internal::GeneratedMessageReflection*
  ML_Joints_reflection_ = NULL;
const ::google::protobuf::Descriptor* Gazebomodel_descriptor_ = NULL;
const ::google::protobuf::internal::GeneratedMessageReflection*
  Gazebomodel_reflection_ = NULL;
const ::google::protobuf::Descriptor* GetGazeboModelParam_descriptor_ = NULL;
const ::google::protobuf::internal::GeneratedMessageReflection*
  GetGazeboModelParam_reflection_ = NULL;
const ::google::protobuf::Descriptor* GazeboModelSDF_descriptor_ = NULL;
const ::google::protobuf::internal::GeneratedMessageReflection*
  GazeboModelSDF_reflection_ = NULL;
const ::google::protobuf::Descriptor* GetGazeboModelSDF_descriptor_ = NULL;
const ::google::protobuf::internal::GeneratedMessageReflection*
  GetGazeboModelSDF_reflection_ = NULL;

}  // namespace


void protobuf_AssignDesc_mw_2einternal_2erobotics_2egazebotransport_2eCoSimMsgs_2eproto() GOOGLE_ATTRIBUTE_COLD;
void protobuf_AssignDesc_mw_2einternal_2erobotics_2egazebotransport_2eCoSimMsgs_2eproto() {
  protobuf_AddDesc_mw_2einternal_2erobotics_2egazebotransport_2eCoSimMsgs_2eproto();
  const ::google::protobuf::FileDescriptor* file =
    ::google::protobuf::DescriptorPool::generated_pool()->FindFileByName(
      "mw.internal.robotics.gazebotransport.CoSimMsgs.proto");
  GOOGLE_CHECK(file != NULL);
  PluginVersion_descriptor_ = file->message_type(0);
  static const int PluginVersion_offsets_[1] = {
    GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(PluginVersion, version_),
  };
  PluginVersion_reflection_ =
    ::google::protobuf::internal::GeneratedMessageReflection::NewGeneratedMessageReflection(
      PluginVersion_descriptor_,
      PluginVersion::default_instance_,
      PluginVersion_offsets_,
      GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(PluginVersion, _has_bits_[0]),
      -1,
      -1,
      sizeof(PluginVersion),
      GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(PluginVersion, _internal_metadata_),
      -1);
  Time_descriptor_ = file->message_type(1);
  static const int Time_offsets_[2] = {
    GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(Time, seconds_),
    GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(Time, nano_seconds_),
  };
  Time_reflection_ =
    ::google::protobuf::internal::GeneratedMessageReflection::NewGeneratedMessageReflection(
      Time_descriptor_,
      Time::default_instance_,
      Time_offsets_,
      GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(Time, _has_bits_[0]),
      -1,
      -1,
      sizeof(Time),
      GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(Time, _internal_metadata_),
      -1);
  PacketHeader_descriptor_ = file->message_type(2);
  static const int PacketHeader_offsets_[2] = {
    GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(PacketHeader, id_),
    GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(PacketHeader, time_stamp_),
  };
  PacketHeader_reflection_ =
    ::google::protobuf::internal::GeneratedMessageReflection::NewGeneratedMessageReflection(
      PacketHeader_descriptor_,
      PacketHeader::default_instance_,
      PacketHeader_offsets_,
      GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(PacketHeader, _has_bits_[0]),
      -1,
      -1,
      sizeof(PacketHeader),
      GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(PacketHeader, _internal_metadata_),
      -1);
  PacketHeader_MsgID_descriptor_ = PacketHeader_descriptor_->enum_type(0);
  Packet_descriptor_ = file->message_type(3);
  static const int Packet_offsets_[45] = {
    GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(Packet, header_),
    PROTO2_GENERATED_DEFAULT_ONEOF_FIELD_OFFSET(Packet_default_oneof_instance_, status_),
    PROTO2_GENERATED_DEFAULT_ONEOF_FIELD_OFFSET(Packet_default_oneof_instance_, step_simulation_),
    PROTO2_GENERATED_DEFAULT_ONEOF_FIELD_OFFSET(Packet_default_oneof_instance_, reset_simulation_),
    PROTO2_GENERATED_DEFAULT_ONEOF_FIELD_OFFSET(Packet_default_oneof_instance_, image_),
    PROTO2_GENERATED_DEFAULT_ONEOF_FIELD_OFFSET(Packet_default_oneof_instance_, request_image_),
    PROTO2_GENERATED_DEFAULT_ONEOF_FIELD_OFFSET(Packet_default_oneof_instance_, request_cosim_),
    PROTO2_GENERATED_DEFAULT_ONEOF_FIELD_OFFSET(Packet_default_oneof_instance_, stop_cosim_),
    PROTO2_GENERATED_DEFAULT_ONEOF_FIELD_OFFSET(Packet_default_oneof_instance_, get_ground_truth_world_pose_),
    PROTO2_GENERATED_DEFAULT_ONEOF_FIELD_OFFSET(Packet_default_oneof_instance_, pose_),
    PROTO2_GENERATED_DEFAULT_ONEOF_FIELD_OFFSET(Packet_default_oneof_instance_, stop_simulation_),
    PROTO2_GENERATED_DEFAULT_ONEOF_FIELD_OFFSET(Packet_default_oneof_instance_, laser_data_),
    PROTO2_GENERATED_DEFAULT_ONEOF_FIELD_OFFSET(Packet_default_oneof_instance_, request_laser_),
    PROTO2_GENERATED_DEFAULT_ONEOF_FIELD_OFFSET(Packet_default_oneof_instance_, imu_data_),
    PROTO2_GENERATED_DEFAULT_ONEOF_FIELD_OFFSET(Packet_default_oneof_instance_, request_imu_),
    PROTO2_GENERATED_DEFAULT_ONEOF_FIELD_OFFSET(Packet_default_oneof_instance_, subscribe_image_),
    PROTO2_GENERATED_DEFAULT_ONEOF_FIELD_OFFSET(Packet_default_oneof_instance_, subscribe_laser_),
    PROTO2_GENERATED_DEFAULT_ONEOF_FIELD_OFFSET(Packet_default_oneof_instance_, subscribe_imu_),
    PROTO2_GENERATED_DEFAULT_ONEOF_FIELD_OFFSET(Packet_default_oneof_instance_, apply_joint_torque_),
    PROTO2_GENERATED_DEFAULT_ONEOF_FIELD_OFFSET(Packet_default_oneof_instance_, get_pose_),
    PROTO2_GENERATED_DEFAULT_ONEOF_FIELD_OFFSET(Packet_default_oneof_instance_, get_topic_list_),
    PROTO2_GENERATED_DEFAULT_ONEOF_FIELD_OFFSET(Packet_default_oneof_instance_, topic_list_),
    PROTO2_GENERATED_DEFAULT_ONEOF_FIELD_OFFSET(Packet_default_oneof_instance_, get_model_info_),
    PROTO2_GENERATED_DEFAULT_ONEOF_FIELD_OFFSET(Packet_default_oneof_instance_, model_info_),
    PROTO2_GENERATED_DEFAULT_ONEOF_FIELD_OFFSET(Packet_default_oneof_instance_, apply_link_wrench_),
    PROTO2_GENERATED_DEFAULT_ONEOF_FIELD_OFFSET(Packet_default_oneof_instance_, max_step_size_),
    PROTO2_GENERATED_DEFAULT_ONEOF_FIELD_OFFSET(Packet_default_oneof_instance_, custom_message_support_),
    PROTO2_GENERATED_DEFAULT_ONEOF_FIELD_OFFSET(Packet_default_oneof_instance_, init_custom_publisher_),
    PROTO2_GENERATED_DEFAULT_ONEOF_FIELD_OFFSET(Packet_default_oneof_instance_, init_custom_subscriber_),
    PROTO2_GENERATED_DEFAULT_ONEOF_FIELD_OFFSET(Packet_default_oneof_instance_, request_custom_message_support_),
    PROTO2_GENERATED_DEFAULT_ONEOF_FIELD_OFFSET(Packet_default_oneof_instance_, set_joint_position_),
    PROTO2_GENERATED_DEFAULT_ONEOF_FIELD_OFFSET(Packet_default_oneof_instance_, set_joint_velocity_),
    PROTO2_GENERATED_DEFAULT_ONEOF_FIELD_OFFSET(Packet_default_oneof_instance_, get_joint_state_),
    PROTO2_GENERATED_DEFAULT_ONEOF_FIELD_OFFSET(Packet_default_oneof_instance_, joint_state_),
    PROTO2_GENERATED_DEFAULT_ONEOF_FIELD_OFFSET(Packet_default_oneof_instance_, set_link_world_pose_),
    PROTO2_GENERATED_DEFAULT_ONEOF_FIELD_OFFSET(Packet_default_oneof_instance_, set_link_linear_velocity_),
    PROTO2_GENERATED_DEFAULT_ONEOF_FIELD_OFFSET(Packet_default_oneof_instance_, set_link_angular_velocity_),
    PROTO2_GENERATED_DEFAULT_ONEOF_FIELD_OFFSET(Packet_default_oneof_instance_, get_link_state_),
    PROTO2_GENERATED_DEFAULT_ONEOF_FIELD_OFFSET(Packet_default_oneof_instance_, link_state_),
    PROTO2_GENERATED_DEFAULT_ONEOF_FIELD_OFFSET(Packet_default_oneof_instance_, gazebo_model_),
    PROTO2_GENERATED_DEFAULT_ONEOF_FIELD_OFFSET(Packet_default_oneof_instance_, get_gazebo_model_param_),
    PROTO2_GENERATED_DEFAULT_ONEOF_FIELD_OFFSET(Packet_default_oneof_instance_, gazebo_model_sdf_),
    PROTO2_GENERATED_DEFAULT_ONEOF_FIELD_OFFSET(Packet_default_oneof_instance_, get_gazebo_model_sdf_),
    GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(Packet, error_message_),
    GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(Packet, payload_),
  };
  Packet_reflection_ =
    ::google::protobuf::internal::GeneratedMessageReflection::NewGeneratedMessageReflection(
      Packet_descriptor_,
      Packet::default_instance_,
      Packet_offsets_,
      GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(Packet, _has_bits_[0]),
      -1,
      -1,
      Packet_default_oneof_instance_,
      GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(Packet, _oneof_case_[0]),
      sizeof(Packet),
      GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(Packet, _internal_metadata_),
      -1);
  Packet_CoSimError_descriptor_ = Packet_descriptor_->enum_type(0);
  StepSimulation_descriptor_ = file->message_type(4);
  static const int StepSimulation_offsets_[1] = {
    GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(StepSimulation, num_steps_),
  };
  StepSimulation_reflection_ =
    ::google::protobuf::internal::GeneratedMessageReflection::NewGeneratedMessageReflection(
      StepSimulation_descriptor_,
      StepSimulation::default_instance_,
      StepSimulation_offsets_,
      GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(StepSimulation, _has_bits_[0]),
      -1,
      -1,
      sizeof(StepSimulation),
      GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(StepSimulation, _internal_metadata_),
      -1);
  ResetSimulation_descriptor_ = file->message_type(5);
  static const int ResetSimulation_offsets_[1] = {
    GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(ResetSimulation, behavior_),
  };
  ResetSimulation_reflection_ =
    ::google::protobuf::internal::GeneratedMessageReflection::NewGeneratedMessageReflection(
      ResetSimulation_descriptor_,
      ResetSimulation::default_instance_,
      ResetSimulation_offsets_,
      GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(ResetSimulation, _has_bits_[0]),
      -1,
      -1,
      sizeof(ResetSimulation),
      GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(ResetSimulation, _internal_metadata_),
      -1);
  ResetSimulation_ResetBehavior_descriptor_ = ResetSimulation_descriptor_->enum_type(0);
  Image_descriptor_ = file->message_type(6);
  static const int Image_offsets_[4] = {
    GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(Image, width_),
    GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(Image, height_),
    GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(Image, data_),
    GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(Image, data_type_),
  };
  Image_reflection_ =
    ::google::protobuf::internal::GeneratedMessageReflection::NewGeneratedMessageReflection(
      Image_descriptor_,
      Image::default_instance_,
      Image_offsets_,
      GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(Image, _has_bits_[0]),
      -1,
      -1,
      sizeof(Image),
      GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(Image, _internal_metadata_),
      -1);
  RequestImage_descriptor_ = file->message_type(7);
  static const int RequestImage_offsets_[1] = {
    GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(RequestImage, topic_name_),
  };
  RequestImage_reflection_ =
    ::google::protobuf::internal::GeneratedMessageReflection::NewGeneratedMessageReflection(
      RequestImage_descriptor_,
      RequestImage::default_instance_,
      RequestImage_offsets_,
      GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(RequestImage, _has_bits_[0]),
      -1,
      -1,
      sizeof(RequestImage),
      GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(RequestImage, _internal_metadata_),
      -1);
  RequestCoSim_descriptor_ = file->message_type(8);
  static const int RequestCoSim_offsets_[2] = {
    GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(RequestCoSim, client_id_),
    GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(RequestCoSim, duration_),
  };
  RequestCoSim_reflection_ =
    ::google::protobuf::internal::GeneratedMessageReflection::NewGeneratedMessageReflection(
      RequestCoSim_descriptor_,
      RequestCoSim::default_instance_,
      RequestCoSim_offsets_,
      GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(RequestCoSim, _has_bits_[0]),
      -1,
      -1,
      sizeof(RequestCoSim),
      GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(RequestCoSim, _internal_metadata_),
      -1);
  StopCoSim_descriptor_ = file->message_type(9);
  static const int StopCoSim_offsets_[1] = {
    GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(StopCoSim, client_id_),
  };
  StopCoSim_reflection_ =
    ::google::protobuf::internal::GeneratedMessageReflection::NewGeneratedMessageReflection(
      StopCoSim_descriptor_,
      StopCoSim::default_instance_,
      StopCoSim_offsets_,
      GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(StopCoSim, _has_bits_[0]),
      -1,
      -1,
      sizeof(StopCoSim),
      GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(StopCoSim, _internal_metadata_),
      -1);
  GetGroundTruthWorldPose_descriptor_ = file->message_type(10);
  static const int GetGroundTruthWorldPose_offsets_[2] = {
    GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(GetGroundTruthWorldPose, model_name_),
    GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(GetGroundTruthWorldPose, link_name_),
  };
  GetGroundTruthWorldPose_reflection_ =
    ::google::protobuf::internal::GeneratedMessageReflection::NewGeneratedMessageReflection(
      GetGroundTruthWorldPose_descriptor_,
      GetGroundTruthWorldPose::default_instance_,
      GetGroundTruthWorldPose_offsets_,
      GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(GetGroundTruthWorldPose, _has_bits_[0]),
      -1,
      -1,
      sizeof(GetGroundTruthWorldPose),
      GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(GetGroundTruthWorldPose, _internal_metadata_),
      -1);
  Point_descriptor_ = file->message_type(11);
  static const int Point_offsets_[3] = {
    GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(Point, x_),
    GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(Point, y_),
    GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(Point, z_),
  };
  Point_reflection_ =
    ::google::protobuf::internal::GeneratedMessageReflection::NewGeneratedMessageReflection(
      Point_descriptor_,
      Point::default_instance_,
      Point_offsets_,
      GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(Point, _has_bits_[0]),
      -1,
      -1,
      sizeof(Point),
      GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(Point, _internal_metadata_),
      -1);
  Quaternion_descriptor_ = file->message_type(12);
  static const int Quaternion_offsets_[4] = {
    GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(Quaternion, x_),
    GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(Quaternion, y_),
    GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(Quaternion, z_),
    GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(Quaternion, w_),
  };
  Quaternion_reflection_ =
    ::google::protobuf::internal::GeneratedMessageReflection::NewGeneratedMessageReflection(
      Quaternion_descriptor_,
      Quaternion::default_instance_,
      Quaternion_offsets_,
      GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(Quaternion, _has_bits_[0]),
      -1,
      -1,
      sizeof(Quaternion),
      GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(Quaternion, _internal_metadata_),
      -1);
  Pose_descriptor_ = file->message_type(13);
  static const int Pose_offsets_[2] = {
    GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(Pose, position_),
    GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(Pose, orientation_),
  };
  Pose_reflection_ =
    ::google::protobuf::internal::GeneratedMessageReflection::NewGeneratedMessageReflection(
      Pose_descriptor_,
      Pose::default_instance_,
      Pose_offsets_,
      GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(Pose, _has_bits_[0]),
      -1,
      -1,
      sizeof(Pose),
      GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(Pose, _internal_metadata_),
      -1);
  StopSimulation_descriptor_ = file->message_type(14);
  static const int StopSimulation_offsets_[1] = {
    GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(StopSimulation, stop_scene_),
  };
  StopSimulation_reflection_ =
    ::google::protobuf::internal::GeneratedMessageReflection::NewGeneratedMessageReflection(
      StopSimulation_descriptor_,
      StopSimulation::default_instance_,
      StopSimulation_offsets_,
      GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(StopSimulation, _has_bits_[0]),
      -1,
      -1,
      sizeof(StopSimulation),
      GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(StopSimulation, _internal_metadata_),
      -1);
  LaserData_descriptor_ = file->message_type(15);
  static const int LaserData_offsets_[11] = {
    GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(LaserData, angle_min_),
    GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(LaserData, angle_max_),
    GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(LaserData, angle_step_),
    GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(LaserData, range_min_),
    GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(LaserData, range_max_),
    GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(LaserData, count_),
    GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(LaserData, vertical_angle_min_),
    GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(LaserData, vertical_angle_max_),
    GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(LaserData, vertical_angle_step_),
    GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(LaserData, range_),
    GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(LaserData, intensities_),
  };
  LaserData_reflection_ =
    ::google::protobuf::internal::GeneratedMessageReflection::NewGeneratedMessageReflection(
      LaserData_descriptor_,
      LaserData::default_instance_,
      LaserData_offsets_,
      GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(LaserData, _has_bits_[0]),
      -1,
      -1,
      sizeof(LaserData),
      GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(LaserData, _internal_metadata_),
      -1);
  RequestLaser_descriptor_ = file->message_type(16);
  static const int RequestLaser_offsets_[1] = {
    GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(RequestLaser, topic_name_),
  };
  RequestLaser_reflection_ =
    ::google::protobuf::internal::GeneratedMessageReflection::NewGeneratedMessageReflection(
      RequestLaser_descriptor_,
      RequestLaser::default_instance_,
      RequestLaser_offsets_,
      GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(RequestLaser, _has_bits_[0]),
      -1,
      -1,
      sizeof(RequestLaser),
      GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(RequestLaser, _internal_metadata_),
      -1);
  ImuData_descriptor_ = file->message_type(17);
  static const int ImuData_offsets_[3] = {
    GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(ImuData, linear_acceleration_),
    GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(ImuData, angular_velocity_),
    GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(ImuData, orientation_),
  };
  ImuData_reflection_ =
    ::google::protobuf::internal::GeneratedMessageReflection::NewGeneratedMessageReflection(
      ImuData_descriptor_,
      ImuData::default_instance_,
      ImuData_offsets_,
      GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(ImuData, _has_bits_[0]),
      -1,
      -1,
      sizeof(ImuData),
      GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(ImuData, _internal_metadata_),
      -1);
  RequestImu_descriptor_ = file->message_type(18);
  static const int RequestImu_offsets_[1] = {
    GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(RequestImu, topic_name_),
  };
  RequestImu_reflection_ =
    ::google::protobuf::internal::GeneratedMessageReflection::NewGeneratedMessageReflection(
      RequestImu_descriptor_,
      RequestImu::default_instance_,
      RequestImu_offsets_,
      GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(RequestImu, _has_bits_[0]),
      -1,
      -1,
      sizeof(RequestImu),
      GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(RequestImu, _internal_metadata_),
      -1);
  SubscribeImage_descriptor_ = file->message_type(19);
  static const int SubscribeImage_offsets_[1] = {
    GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(SubscribeImage, topic_name_),
  };
  SubscribeImage_reflection_ =
    ::google::protobuf::internal::GeneratedMessageReflection::NewGeneratedMessageReflection(
      SubscribeImage_descriptor_,
      SubscribeImage::default_instance_,
      SubscribeImage_offsets_,
      GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(SubscribeImage, _has_bits_[0]),
      -1,
      -1,
      sizeof(SubscribeImage),
      GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(SubscribeImage, _internal_metadata_),
      -1);
  SubscribeLaser_descriptor_ = file->message_type(20);
  static const int SubscribeLaser_offsets_[1] = {
    GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(SubscribeLaser, topic_name_),
  };
  SubscribeLaser_reflection_ =
    ::google::protobuf::internal::GeneratedMessageReflection::NewGeneratedMessageReflection(
      SubscribeLaser_descriptor_,
      SubscribeLaser::default_instance_,
      SubscribeLaser_offsets_,
      GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(SubscribeLaser, _has_bits_[0]),
      -1,
      -1,
      sizeof(SubscribeLaser),
      GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(SubscribeLaser, _internal_metadata_),
      -1);
  SubscribeImu_descriptor_ = file->message_type(21);
  static const int SubscribeImu_offsets_[1] = {
    GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(SubscribeImu, topic_name_),
  };
  SubscribeImu_reflection_ =
    ::google::protobuf::internal::GeneratedMessageReflection::NewGeneratedMessageReflection(
      SubscribeImu_descriptor_,
      SubscribeImu::default_instance_,
      SubscribeImu_offsets_,
      GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(SubscribeImu, _has_bits_[0]),
      -1,
      -1,
      sizeof(SubscribeImu),
      GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(SubscribeImu, _internal_metadata_),
      -1);
  ApplyLinkWrench_descriptor_ = file->message_type(22);
  static const int ApplyLinkWrench_offsets_[11] = {
    GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(ApplyLinkWrench, model_name_),
    GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(ApplyLinkWrench, link_name_),
    GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(ApplyLinkWrench, force_type_),
    GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(ApplyLinkWrench, fx_),
    GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(ApplyLinkWrench, fy_),
    GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(ApplyLinkWrench, fz_),
    GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(ApplyLinkWrench, torque_type_),
    GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(ApplyLinkWrench, tx_),
    GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(ApplyLinkWrench, ty_),
    GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(ApplyLinkWrench, tz_),
    GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(ApplyLinkWrench, duration_),
  };
  ApplyLinkWrench_reflection_ =
    ::google::protobuf::internal::GeneratedMessageReflection::NewGeneratedMessageReflection(
      ApplyLinkWrench_descriptor_,
      ApplyLinkWrench::default_instance_,
      ApplyLinkWrench_offsets_,
      GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(ApplyLinkWrench, _has_bits_[0]),
      -1,
      -1,
      sizeof(ApplyLinkWrench),
      GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(ApplyLinkWrench, _internal_metadata_),
      -1);
  ApplyJointTorque_descriptor_ = file->message_type(23);
  static const int ApplyJointTorque_offsets_[5] = {
    GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(ApplyJointTorque, model_name_),
    GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(ApplyJointTorque, joint_name_),
    GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(ApplyJointTorque, index_),
    GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(ApplyJointTorque, effort_),
    GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(ApplyJointTorque, duration_),
  };
  ApplyJointTorque_reflection_ =
    ::google::protobuf::internal::GeneratedMessageReflection::NewGeneratedMessageReflection(
      ApplyJointTorque_descriptor_,
      ApplyJointTorque::default_instance_,
      ApplyJointTorque_offsets_,
      GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(ApplyJointTorque, _has_bits_[0]),
      -1,
      -1,
      sizeof(ApplyJointTorque),
      GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(ApplyJointTorque, _internal_metadata_),
      -1);
  GetPose_descriptor_ = file->message_type(24);
  static const int GetPose_offsets_[1] = {
    GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(GetPose, model_name_),
  };
  GetPose_reflection_ =
    ::google::protobuf::internal::GeneratedMessageReflection::NewGeneratedMessageReflection(
      GetPose_descriptor_,
      GetPose::default_instance_,
      GetPose_offsets_,
      GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(GetPose, _has_bits_[0]),
      -1,
      -1,
      sizeof(GetPose),
      GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(GetPose, _internal_metadata_),
      -1);
  GetTopicList_descriptor_ = file->message_type(25);
  static const int GetTopicList_offsets_[1] = {
    GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(GetTopicList, topic_name_),
  };
  GetTopicList_reflection_ =
    ::google::protobuf::internal::GeneratedMessageReflection::NewGeneratedMessageReflection(
      GetTopicList_descriptor_,
      GetTopicList::default_instance_,
      GetTopicList_offsets_,
      GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(GetTopicList, _has_bits_[0]),
      -1,
      -1,
      sizeof(GetTopicList),
      GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(GetTopicList, _internal_metadata_),
      -1);
  TopicList_descriptor_ = file->message_type(26);
  static const int TopicList_offsets_[1] = {
    GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(TopicList, data_),
  };
  TopicList_reflection_ =
    ::google::protobuf::internal::GeneratedMessageReflection::NewGeneratedMessageReflection(
      TopicList_descriptor_,
      TopicList::default_instance_,
      TopicList_offsets_,
      GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(TopicList, _has_bits_[0]),
      -1,
      -1,
      sizeof(TopicList),
      GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(TopicList, _internal_metadata_),
      -1);
  TopicList_TopicInfo_descriptor_ = TopicList_descriptor_->nested_type(0);
  static const int TopicList_TopicInfo_offsets_[2] = {
    GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(TopicList_TopicInfo, name_),
    GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(TopicList_TopicInfo, type_),
  };
  TopicList_TopicInfo_reflection_ =
    ::google::protobuf::internal::GeneratedMessageReflection::NewGeneratedMessageReflection(
      TopicList_TopicInfo_descriptor_,
      TopicList_TopicInfo::default_instance_,
      TopicList_TopicInfo_offsets_,
      GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(TopicList_TopicInfo, _has_bits_[0]),
      -1,
      -1,
      sizeof(TopicList_TopicInfo),
      GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(TopicList_TopicInfo, _internal_metadata_),
      -1);
  GetModelInfo_descriptor_ = file->message_type(27);
  static const int GetModelInfo_offsets_[1] = {
    GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(GetModelInfo, topic_name_),
  };
  GetModelInfo_reflection_ =
    ::google::protobuf::internal::GeneratedMessageReflection::NewGeneratedMessageReflection(
      GetModelInfo_descriptor_,
      GetModelInfo::default_instance_,
      GetModelInfo_offsets_,
      GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(GetModelInfo, _has_bits_[0]),
      -1,
      -1,
      sizeof(GetModelInfo),
      GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(GetModelInfo, _internal_metadata_),
      -1);
  ModelInfo_descriptor_ = file->message_type(28);
  static const int ModelInfo_offsets_[1] = {
    GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(ModelInfo, model_data_),
  };
  ModelInfo_reflection_ =
    ::google::protobuf::internal::GeneratedMessageReflection::NewGeneratedMessageReflection(
      ModelInfo_descriptor_,
      ModelInfo::default_instance_,
      ModelInfo_offsets_,
      GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(ModelInfo, _has_bits_[0]),
      -1,
      -1,
      sizeof(ModelInfo),
      GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(ModelInfo, _internal_metadata_),
      -1);
  ModelInfo_LINKS_descriptor_ = ModelInfo_descriptor_->nested_type(0);
  static const int ModelInfo_LINKS_offsets_[1] = {
    GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(ModelInfo_LINKS, link_name_),
  };
  ModelInfo_LINKS_reflection_ =
    ::google::protobuf::internal::GeneratedMessageReflection::NewGeneratedMessageReflection(
      ModelInfo_LINKS_descriptor_,
      ModelInfo_LINKS::default_instance_,
      ModelInfo_LINKS_offsets_,
      GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(ModelInfo_LINKS, _has_bits_[0]),
      -1,
      -1,
      sizeof(ModelInfo_LINKS),
      GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(ModelInfo_LINKS, _internal_metadata_),
      -1);
  ModelInfo_JOINTS_descriptor_ = ModelInfo_descriptor_->nested_type(1);
  static const int ModelInfo_JOINTS_offsets_[1] = {
    GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(ModelInfo_JOINTS, joint_name_),
  };
  ModelInfo_JOINTS_reflection_ =
    ::google::protobuf::internal::GeneratedMessageReflection::NewGeneratedMessageReflection(
      ModelInfo_JOINTS_descriptor_,
      ModelInfo_JOINTS::default_instance_,
      ModelInfo_JOINTS_offsets_,
      GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(ModelInfo_JOINTS, _has_bits_[0]),
      -1,
      -1,
      sizeof(ModelInfo_JOINTS),
      GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(ModelInfo_JOINTS, _internal_metadata_),
      -1);
  ModelInfo_Model_descriptor_ = ModelInfo_descriptor_->nested_type(2);
  static const int ModelInfo_Model_offsets_[3] = {
    GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(ModelInfo_Model, model_name_),
    GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(ModelInfo_Model, links_),
    GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(ModelInfo_Model, joints_),
  };
  ModelInfo_Model_reflection_ =
    ::google::protobuf::internal::GeneratedMessageReflection::NewGeneratedMessageReflection(
      ModelInfo_Model_descriptor_,
      ModelInfo_Model::default_instance_,
      ModelInfo_Model_offsets_,
      GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(ModelInfo_Model, _has_bits_[0]),
      -1,
      -1,
      sizeof(ModelInfo_Model),
      GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(ModelInfo_Model, _internal_metadata_),
      -1);
  MaxStepSize_descriptor_ = file->message_type(29);
  static const int MaxStepSize_offsets_[2] = {
    GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(MaxStepSize, type_),
    GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(MaxStepSize, size_),
  };
  MaxStepSize_reflection_ =
    ::google::protobuf::internal::GeneratedMessageReflection::NewGeneratedMessageReflection(
      MaxStepSize_descriptor_,
      MaxStepSize::default_instance_,
      MaxStepSize_offsets_,
      GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(MaxStepSize, _has_bits_[0]),
      -1,
      -1,
      sizeof(MaxStepSize),
      GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(MaxStepSize, _internal_metadata_),
      -1);
  MaxStepSize_TYPE_descriptor_ = MaxStepSize_descriptor_->enum_type(0);
  InitCustomPublisher_descriptor_ = file->message_type(30);
  static const int InitCustomPublisher_offsets_[2] = {
    GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(InitCustomPublisher, topic_name_),
    GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(InitCustomPublisher, message_type_),
  };
  InitCustomPublisher_reflection_ =
    ::google::protobuf::internal::GeneratedMessageReflection::NewGeneratedMessageReflection(
      InitCustomPublisher_descriptor_,
      InitCustomPublisher::default_instance_,
      InitCustomPublisher_offsets_,
      GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(InitCustomPublisher, _has_bits_[0]),
      -1,
      -1,
      sizeof(InitCustomPublisher),
      GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(InitCustomPublisher, _internal_metadata_),
      -1);
  InitCustomSubscriber_descriptor_ = file->message_type(31);
  static const int InitCustomSubscriber_offsets_[2] = {
    GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(InitCustomSubscriber, topic_name_),
    GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(InitCustomSubscriber, message_type_),
  };
  InitCustomSubscriber_reflection_ =
    ::google::protobuf::internal::GeneratedMessageReflection::NewGeneratedMessageReflection(
      InitCustomSubscriber_descriptor_,
      InitCustomSubscriber::default_instance_,
      InitCustomSubscriber_offsets_,
      GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(InitCustomSubscriber, _has_bits_[0]),
      -1,
      -1,
      sizeof(InitCustomSubscriber),
      GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(InitCustomSubscriber, _internal_metadata_),
      -1);
  CustomMessageSupport_descriptor_ = file->message_type(32);
  static const int CustomMessageSupport_offsets_[4] = {
    GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(CustomMessageSupport, topic_name_),
    GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(CustomMessageSupport, message_type_),
    GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(CustomMessageSupport, data_),
    GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(CustomMessageSupport, is_new_),
  };
  CustomMessageSupport_reflection_ =
    ::google::protobuf::internal::GeneratedMessageReflection::NewGeneratedMessageReflection(
      CustomMessageSupport_descriptor_,
      CustomMessageSupport::default_instance_,
      CustomMessageSupport_offsets_,
      GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(CustomMessageSupport, _has_bits_[0]),
      -1,
      -1,
      sizeof(CustomMessageSupport),
      GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(CustomMessageSupport, _internal_metadata_),
      -1);
  RequestCustomMessageSupport_descriptor_ = file->message_type(33);
  static const int RequestCustomMessageSupport_offsets_[2] = {
    GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(RequestCustomMessageSupport, topic_name_),
    GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(RequestCustomMessageSupport, message_type_),
  };
  RequestCustomMessageSupport_reflection_ =
    ::google::protobuf::internal::GeneratedMessageReflection::NewGeneratedMessageReflection(
      RequestCustomMessageSupport_descriptor_,
      RequestCustomMessageSupport::default_instance_,
      RequestCustomMessageSupport_offsets_,
      GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(RequestCustomMessageSupport, _has_bits_[0]),
      -1,
      -1,
      sizeof(RequestCustomMessageSupport),
      GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(RequestCustomMessageSupport, _internal_metadata_),
      -1);
  SetJointPosition_descriptor_ = file->message_type(34);
  static const int SetJointPosition_offsets_[5] = {
    GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(SetJointPosition, model_name_),
    GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(SetJointPosition, joint_name_),
    GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(SetJointPosition, index_),
    GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(SetJointPosition, position_),
    GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(SetJointPosition, duration_),
  };
  SetJointPosition_reflection_ =
    ::google::protobuf::internal::GeneratedMessageReflection::NewGeneratedMessageReflection(
      SetJointPosition_descriptor_,
      SetJointPosition::default_instance_,
      SetJointPosition_offsets_,
      GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(SetJointPosition, _has_bits_[0]),
      -1,
      -1,
      sizeof(SetJointPosition),
      GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(SetJointPosition, _internal_metadata_),
      -1);
  SetJointVelocity_descriptor_ = file->message_type(35);
  static const int SetJointVelocity_offsets_[5] = {
    GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(SetJointVelocity, model_name_),
    GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(SetJointVelocity, joint_name_),
    GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(SetJointVelocity, index_),
    GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(SetJointVelocity, velocity_),
    GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(SetJointVelocity, duration_),
  };
  SetJointVelocity_reflection_ =
    ::google::protobuf::internal::GeneratedMessageReflection::NewGeneratedMessageReflection(
      SetJointVelocity_descriptor_,
      SetJointVelocity::default_instance_,
      SetJointVelocity_offsets_,
      GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(SetJointVelocity, _has_bits_[0]),
      -1,
      -1,
      sizeof(SetJointVelocity),
      GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(SetJointVelocity, _internal_metadata_),
      -1);
  GetJointState_descriptor_ = file->message_type(36);
  static const int GetJointState_offsets_[2] = {
    GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(GetJointState, model_name_),
    GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(GetJointState, joint_name_),
  };
  GetJointState_reflection_ =
    ::google::protobuf::internal::GeneratedMessageReflection::NewGeneratedMessageReflection(
      GetJointState_descriptor_,
      GetJointState::default_instance_,
      GetJointState_offsets_,
      GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(GetJointState, _has_bits_[0]),
      -1,
      -1,
      sizeof(GetJointState),
      GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(GetJointState, _internal_metadata_),
      -1);
  Axis_descriptor_ = file->message_type(37);
  static const int Axis_offsets_[8] = {
    GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(Axis, xyz_),
    GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(Axis, limit_lower_),
    GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(Axis, limit_upper_),
    GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(Axis, limit_effort_),
    GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(Axis, limit_velocity_),
    GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(Axis, damping_),
    GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(Axis, friction_),
    GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(Axis, use_parent_model_frame_),
  };
  Axis_reflection_ =
    ::google::protobuf::internal::GeneratedMessageReflection::NewGeneratedMessageReflection(
      Axis_descriptor_,
      Axis::default_instance_,
      Axis_offsets_,
      GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(Axis, _has_bits_[0]),
      -1,
      -1,
      sizeof(Axis),
      GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(Axis, _internal_metadata_),
      -1);
  JointState_descriptor_ = file->message_type(38);
  static const int JointState_offsets_[14] = {
    GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(JointState, model_name_),
    GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(JointState, joint_name_),
    GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(JointState, joint_id_),
    GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(JointState, joint_position_),
    GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(JointState, joint_velocity_),
    GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(JointState, joint_type_),
    GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(JointState, parent_name_),
    GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(JointState, parent_id_),
    GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(JointState, child_name_),
    GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(JointState, child_id_),
    GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(JointState, initial_anchor_pose_),
    GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(JointState, world_pose_),
    GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(JointState, parent_world_pose_),
    GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(JointState, axis_),
  };
  JointState_reflection_ =
    ::google::protobuf::internal::GeneratedMessageReflection::NewGeneratedMessageReflection(
      JointState_descriptor_,
      JointState::default_instance_,
      JointState_offsets_,
      GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(JointState, _has_bits_[0]),
      -1,
      -1,
      sizeof(JointState),
      GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(JointState, _internal_metadata_),
      -1);
  JointState_Joint_Type_descriptor_ = JointState_descriptor_->enum_type(0);
  SetLinkWorldPose_descriptor_ = file->message_type(39);
  static const int SetLinkWorldPose_offsets_[4] = {
    GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(SetLinkWorldPose, model_name_),
    GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(SetLinkWorldPose, link_name_),
    GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(SetLinkWorldPose, pose_),
    GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(SetLinkWorldPose, duration_),
  };
  SetLinkWorldPose_reflection_ =
    ::google::protobuf::internal::GeneratedMessageReflection::NewGeneratedMessageReflection(
      SetLinkWorldPose_descriptor_,
      SetLinkWorldPose::default_instance_,
      SetLinkWorldPose_offsets_,
      GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(SetLinkWorldPose, _has_bits_[0]),
      -1,
      -1,
      sizeof(SetLinkWorldPose),
      GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(SetLinkWorldPose, _internal_metadata_),
      -1);
  SetLinkLinearVelocity_descriptor_ = file->message_type(40);
  static const int SetLinkLinearVelocity_offsets_[4] = {
    GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(SetLinkLinearVelocity, model_name_),
    GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(SetLinkLinearVelocity, link_name_),
    GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(SetLinkLinearVelocity, velocity_),
    GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(SetLinkLinearVelocity, duration_),
  };
  SetLinkLinearVelocity_reflection_ =
    ::google::protobuf::internal::GeneratedMessageReflection::NewGeneratedMessageReflection(
      SetLinkLinearVelocity_descriptor_,
      SetLinkLinearVelocity::default_instance_,
      SetLinkLinearVelocity_offsets_,
      GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(SetLinkLinearVelocity, _has_bits_[0]),
      -1,
      -1,
      sizeof(SetLinkLinearVelocity),
      GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(SetLinkLinearVelocity, _internal_metadata_),
      -1);
  SetLinkAngularVelocity_descriptor_ = file->message_type(41);
  static const int SetLinkAngularVelocity_offsets_[4] = {
    GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(SetLinkAngularVelocity, model_name_),
    GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(SetLinkAngularVelocity, link_name_),
    GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(SetLinkAngularVelocity, velocity_),
    GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(SetLinkAngularVelocity, duration_),
  };
  SetLinkAngularVelocity_reflection_ =
    ::google::protobuf::internal::GeneratedMessageReflection::NewGeneratedMessageReflection(
      SetLinkAngularVelocity_descriptor_,
      SetLinkAngularVelocity::default_instance_,
      SetLinkAngularVelocity_offsets_,
      GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(SetLinkAngularVelocity, _has_bits_[0]),
      -1,
      -1,
      sizeof(SetLinkAngularVelocity),
      GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(SetLinkAngularVelocity, _internal_metadata_),
      -1);
  GetLinkState_descriptor_ = file->message_type(42);
  static const int GetLinkState_offsets_[2] = {
    GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(GetLinkState, model_name_),
    GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(GetLinkState, link_name_),
  };
  GetLinkState_reflection_ =
    ::google::protobuf::internal::GeneratedMessageReflection::NewGeneratedMessageReflection(
      GetLinkState_descriptor_,
      GetLinkState::default_instance_,
      GetLinkState_offsets_,
      GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(GetLinkState, _has_bits_[0]),
      -1,
      -1,
      sizeof(GetLinkState),
      GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(GetLinkState, _internal_metadata_),
      -1);
  LinkState_descriptor_ = file->message_type(43);
  static const int LinkState_offsets_[14] = {
    GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(LinkState, model_name_),
    GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(LinkState, link_name_),
    GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(LinkState, link_id_),
    GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(LinkState, world_linear_velocity_),
    GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(LinkState, world_angular_velocity_),
    GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(LinkState, relative_linear_velocity_),
    GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(LinkState, relative_angular_velocity_),
    GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(LinkState, world_pose_),
    GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(LinkState, relative_pose_),
    GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(LinkState, self_collide_),
    GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(LinkState, gravity_),
    GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(LinkState, kinematic_),
    GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(LinkState, enable_wind_),
    GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(LinkState, canonical_),
  };
  LinkState_reflection_ =
    ::google::protobuf::internal::GeneratedMessageReflection::NewGeneratedMessageReflection(
      LinkState_descriptor_,
      LinkState::default_instance_,
      LinkState_offsets_,
      GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(LinkState, _has_bits_[0]),
      -1,
      -1,
      sizeof(LinkState),
      GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(LinkState, _internal_metadata_),
      -1);
  ML_Cord_descriptor_ = file->message_type(44);
  static const int ML_Cord_offsets_[2] = {
    GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(ML_Cord, x_),
    GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(ML_Cord, y_),
  };
  ML_Cord_reflection_ =
    ::google::protobuf::internal::GeneratedMessageReflection::NewGeneratedMessageReflection(
      ML_Cord_descriptor_,
      ML_Cord::default_instance_,
      ML_Cord_offsets_,
      GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(ML_Cord, _has_bits_[0]),
      -1,
      -1,
      sizeof(ML_Cord),
      GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(ML_Cord, _internal_metadata_),
      -1);
  ML_Point_descriptor_ = file->message_type(45);
  static const int ML_Point_offsets_[3] = {
    GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(ML_Point, x_),
    GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(ML_Point, y_),
    GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(ML_Point, z_),
  };
  ML_Point_reflection_ =
    ::google::protobuf::internal::GeneratedMessageReflection::NewGeneratedMessageReflection(
      ML_Point_descriptor_,
      ML_Point::default_instance_,
      ML_Point_offsets_,
      GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(ML_Point, _has_bits_[0]),
      -1,
      -1,
      sizeof(ML_Point),
      GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(ML_Point, _internal_metadata_),
      -1);
  ML_Quat_descriptor_ = file->message_type(46);
  static const int ML_Quat_offsets_[4] = {
    GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(ML_Quat, x_),
    GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(ML_Quat, y_),
    GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(ML_Quat, z_),
    GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(ML_Quat, w_),
  };
  ML_Quat_reflection_ =
    ::google::protobuf::internal::GeneratedMessageReflection::NewGeneratedMessageReflection(
      ML_Quat_descriptor_,
      ML_Quat::default_instance_,
      ML_Quat_offsets_,
      GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(ML_Quat, _has_bits_[0]),
      -1,
      -1,
      sizeof(ML_Quat),
      GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(ML_Quat, _internal_metadata_),
      -1);
  ML_Pose_descriptor_ = file->message_type(47);
  static const int ML_Pose_offsets_[2] = {
    GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(ML_Pose, position_),
    GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(ML_Pose, orientation_),
  };
  ML_Pose_reflection_ =
    ::google::protobuf::internal::GeneratedMessageReflection::NewGeneratedMessageReflection(
      ML_Pose_descriptor_,
      ML_Pose::default_instance_,
      ML_Pose_offsets_,
      GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(ML_Pose, _has_bits_[0]),
      -1,
      -1,
      sizeof(ML_Pose),
      GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(ML_Pose, _internal_metadata_),
      -1);
  ML_Inertial_descriptor_ = file->message_type(48);
  static const int ML_Inertial_offsets_[7] = {
    GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(ML_Inertial, mass_),
    GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(ML_Inertial, ixx_),
    GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(ML_Inertial, ixy_),
    GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(ML_Inertial, ixz_),
    GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(ML_Inertial, iyy_),
    GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(ML_Inertial, iyz_),
    GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(ML_Inertial, izz_),
  };
  ML_Inertial_reflection_ =
    ::google::protobuf::internal::GeneratedMessageReflection::NewGeneratedMessageReflection(
      ML_Inertial_descriptor_,
      ML_Inertial::default_instance_,
      ML_Inertial_offsets_,
      GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(ML_Inertial, _has_bits_[0]),
      -1,
      -1,
      sizeof(ML_Inertial),
      GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(ML_Inertial, _internal_metadata_),
      -1);
  ML_Links_descriptor_ = file->message_type(49);
  static const int ML_Links_offsets_[9] = {
    GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(ML_Links, name_),
    GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(ML_Links, pose_),
    GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(ML_Links, inertial_),
    GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(ML_Links, self_collide_),
    GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(ML_Links, gravity_),
    GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(ML_Links, kinematic_),
    GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(ML_Links, enabled_wind_),
    GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(ML_Links, is_static_),
    GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(ML_Links, canonical_),
  };
  ML_Links_reflection_ =
    ::google::protobuf::internal::GeneratedMessageReflection::NewGeneratedMessageReflection(
      ML_Links_descriptor_,
      ML_Links::default_instance_,
      ML_Links_offsets_,
      GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(ML_Links, _has_bits_[0]),
      -1,
      -1,
      sizeof(ML_Links),
      GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(ML_Links, _internal_metadata_),
      -1);
  ML_Axis_descriptor_ = file->message_type(50);
  static const int ML_Axis_offsets_[4] = {
    GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(ML_Axis, xyz_),
    GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(ML_Axis, damping_),
    GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(ML_Axis, friction_),
    GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(ML_Axis, angle_),
  };
  ML_Axis_reflection_ =
    ::google::protobuf::internal::GeneratedMessageReflection::NewGeneratedMessageReflection(
      ML_Axis_descriptor_,
      ML_Axis::default_instance_,
      ML_Axis_offsets_,
      GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(ML_Axis, _has_bits_[0]),
      -1,
      -1,
      sizeof(ML_Axis),
      GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(ML_Axis, _internal_metadata_),
      -1);
  ML_Joints_descriptor_ = file->message_type(51);
  static const int ML_Joints_offsets_[9] = {
    GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(ML_Joints, name_),
    GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(ML_Joints, pose_),
    GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(ML_Joints, axis1_),
    GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(ML_Joints, axis2_),
    GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(ML_Joints, cfm_),
    GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(ML_Joints, fudge_factor_),
    GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(ML_Joints, suspension_cfm_),
    GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(ML_Joints, suspension_erp_),
    GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(ML_Joints, dof_),
  };
  ML_Joints_reflection_ =
    ::google::protobuf::internal::GeneratedMessageReflection::NewGeneratedMessageReflection(
      ML_Joints_descriptor_,
      ML_Joints::default_instance_,
      ML_Joints_offsets_,
      GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(ML_Joints, _has_bits_[0]),
      -1,
      -1,
      sizeof(ML_Joints),
      GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(ML_Joints, _internal_metadata_),
      -1);
  Gazebomodel_descriptor_ = file->message_type(52);
  static const int Gazebomodel_offsets_[7] = {
    GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(Gazebomodel, name_),
    GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(Gazebomodel, links_),
    GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(Gazebomodel, joints_),
    GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(Gazebomodel, pose_),
    GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(Gazebomodel, enable_wind_),
    GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(Gazebomodel, self_collide_),
    GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(Gazebomodel, is_static_),
  };
  Gazebomodel_reflection_ =
    ::google::protobuf::internal::GeneratedMessageReflection::NewGeneratedMessageReflection(
      Gazebomodel_descriptor_,
      Gazebomodel::default_instance_,
      Gazebomodel_offsets_,
      GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(Gazebomodel, _has_bits_[0]),
      -1,
      -1,
      sizeof(Gazebomodel),
      GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(Gazebomodel, _internal_metadata_),
      -1);
  GetGazeboModelParam_descriptor_ = file->message_type(53);
  static const int GetGazeboModelParam_offsets_[3] = {
    GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(GetGazeboModelParam, model_name_),
    GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(GetGazeboModelParam, is_link_),
    GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(GetGazeboModelParam, link_joint_name_),
  };
  GetGazeboModelParam_reflection_ =
    ::google::protobuf::internal::GeneratedMessageReflection::NewGeneratedMessageReflection(
      GetGazeboModelParam_descriptor_,
      GetGazeboModelParam::default_instance_,
      GetGazeboModelParam_offsets_,
      GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(GetGazeboModelParam, _has_bits_[0]),
      -1,
      -1,
      sizeof(GetGazeboModelParam),
      GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(GetGazeboModelParam, _internal_metadata_),
      -1);
  GazeboModelSDF_descriptor_ = file->message_type(54);
  static const int GazeboModelSDF_offsets_[2] = {
    GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(GazeboModelSDF, model_name_),
    GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(GazeboModelSDF, sdf_string_),
  };
  GazeboModelSDF_reflection_ =
    ::google::protobuf::internal::GeneratedMessageReflection::NewGeneratedMessageReflection(
      GazeboModelSDF_descriptor_,
      GazeboModelSDF::default_instance_,
      GazeboModelSDF_offsets_,
      GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(GazeboModelSDF, _has_bits_[0]),
      -1,
      -1,
      sizeof(GazeboModelSDF),
      GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(GazeboModelSDF, _internal_metadata_),
      -1);
  GetGazeboModelSDF_descriptor_ = file->message_type(55);
  static const int GetGazeboModelSDF_offsets_[1] = {
    GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(GetGazeboModelSDF, model_name_),
  };
  GetGazeboModelSDF_reflection_ =
    ::google::protobuf::internal::GeneratedMessageReflection::NewGeneratedMessageReflection(
      GetGazeboModelSDF_descriptor_,
      GetGazeboModelSDF::default_instance_,
      GetGazeboModelSDF_offsets_,
      GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(GetGazeboModelSDF, _has_bits_[0]),
      -1,
      -1,
      sizeof(GetGazeboModelSDF),
      GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(GetGazeboModelSDF, _internal_metadata_),
      -1);
}

namespace {

GOOGLE_PROTOBUF_DECLARE_ONCE(protobuf_AssignDescriptors_once_);
inline void protobuf_AssignDescriptorsOnce() {
  ::google::protobuf::GoogleOnceInit(&protobuf_AssignDescriptors_once_,
                 &protobuf_AssignDesc_mw_2einternal_2erobotics_2egazebotransport_2eCoSimMsgs_2eproto);
}

void protobuf_RegisterTypes(const ::std::string&) GOOGLE_ATTRIBUTE_COLD;
void protobuf_RegisterTypes(const ::std::string&) {
  protobuf_AssignDescriptorsOnce();
  ::google::protobuf::MessageFactory::InternalRegisterGeneratedMessage(
      PluginVersion_descriptor_, &PluginVersion::default_instance());
  ::google::protobuf::MessageFactory::InternalRegisterGeneratedMessage(
      Time_descriptor_, &Time::default_instance());
  ::google::protobuf::MessageFactory::InternalRegisterGeneratedMessage(
      PacketHeader_descriptor_, &PacketHeader::default_instance());
  ::google::protobuf::MessageFactory::InternalRegisterGeneratedMessage(
      Packet_descriptor_, &Packet::default_instance());
  ::google::protobuf::MessageFactory::InternalRegisterGeneratedMessage(
      StepSimulation_descriptor_, &StepSimulation::default_instance());
  ::google::protobuf::MessageFactory::InternalRegisterGeneratedMessage(
      ResetSimulation_descriptor_, &ResetSimulation::default_instance());
  ::google::protobuf::MessageFactory::InternalRegisterGeneratedMessage(
      Image_descriptor_, &Image::default_instance());
  ::google::protobuf::MessageFactory::InternalRegisterGeneratedMessage(
      RequestImage_descriptor_, &RequestImage::default_instance());
  ::google::protobuf::MessageFactory::InternalRegisterGeneratedMessage(
      RequestCoSim_descriptor_, &RequestCoSim::default_instance());
  ::google::protobuf::MessageFactory::InternalRegisterGeneratedMessage(
      StopCoSim_descriptor_, &StopCoSim::default_instance());
  ::google::protobuf::MessageFactory::InternalRegisterGeneratedMessage(
      GetGroundTruthWorldPose_descriptor_, &GetGroundTruthWorldPose::default_instance());
  ::google::protobuf::MessageFactory::InternalRegisterGeneratedMessage(
      Point_descriptor_, &Point::default_instance());
  ::google::protobuf::MessageFactory::InternalRegisterGeneratedMessage(
      Quaternion_descriptor_, &Quaternion::default_instance());
  ::google::protobuf::MessageFactory::InternalRegisterGeneratedMessage(
      Pose_descriptor_, &Pose::default_instance());
  ::google::protobuf::MessageFactory::InternalRegisterGeneratedMessage(
      StopSimulation_descriptor_, &StopSimulation::default_instance());
  ::google::protobuf::MessageFactory::InternalRegisterGeneratedMessage(
      LaserData_descriptor_, &LaserData::default_instance());
  ::google::protobuf::MessageFactory::InternalRegisterGeneratedMessage(
      RequestLaser_descriptor_, &RequestLaser::default_instance());
  ::google::protobuf::MessageFactory::InternalRegisterGeneratedMessage(
      ImuData_descriptor_, &ImuData::default_instance());
  ::google::protobuf::MessageFactory::InternalRegisterGeneratedMessage(
      RequestImu_descriptor_, &RequestImu::default_instance());
  ::google::protobuf::MessageFactory::InternalRegisterGeneratedMessage(
      SubscribeImage_descriptor_, &SubscribeImage::default_instance());
  ::google::protobuf::MessageFactory::InternalRegisterGeneratedMessage(
      SubscribeLaser_descriptor_, &SubscribeLaser::default_instance());
  ::google::protobuf::MessageFactory::InternalRegisterGeneratedMessage(
      SubscribeImu_descriptor_, &SubscribeImu::default_instance());
  ::google::protobuf::MessageFactory::InternalRegisterGeneratedMessage(
      ApplyLinkWrench_descriptor_, &ApplyLinkWrench::default_instance());
  ::google::protobuf::MessageFactory::InternalRegisterGeneratedMessage(
      ApplyJointTorque_descriptor_, &ApplyJointTorque::default_instance());
  ::google::protobuf::MessageFactory::InternalRegisterGeneratedMessage(
      GetPose_descriptor_, &GetPose::default_instance());
  ::google::protobuf::MessageFactory::InternalRegisterGeneratedMessage(
      GetTopicList_descriptor_, &GetTopicList::default_instance());
  ::google::protobuf::MessageFactory::InternalRegisterGeneratedMessage(
      TopicList_descriptor_, &TopicList::default_instance());
  ::google::protobuf::MessageFactory::InternalRegisterGeneratedMessage(
      TopicList_TopicInfo_descriptor_, &TopicList_TopicInfo::default_instance());
  ::google::protobuf::MessageFactory::InternalRegisterGeneratedMessage(
      GetModelInfo_descriptor_, &GetModelInfo::default_instance());
  ::google::protobuf::MessageFactory::InternalRegisterGeneratedMessage(
      ModelInfo_descriptor_, &ModelInfo::default_instance());
  ::google::protobuf::MessageFactory::InternalRegisterGeneratedMessage(
      ModelInfo_LINKS_descriptor_, &ModelInfo_LINKS::default_instance());
  ::google::protobuf::MessageFactory::InternalRegisterGeneratedMessage(
      ModelInfo_JOINTS_descriptor_, &ModelInfo_JOINTS::default_instance());
  ::google::protobuf::MessageFactory::InternalRegisterGeneratedMessage(
      ModelInfo_Model_descriptor_, &ModelInfo_Model::default_instance());
  ::google::protobuf::MessageFactory::InternalRegisterGeneratedMessage(
      MaxStepSize_descriptor_, &MaxStepSize::default_instance());
  ::google::protobuf::MessageFactory::InternalRegisterGeneratedMessage(
      InitCustomPublisher_descriptor_, &InitCustomPublisher::default_instance());
  ::google::protobuf::MessageFactory::InternalRegisterGeneratedMessage(
      InitCustomSubscriber_descriptor_, &InitCustomSubscriber::default_instance());
  ::google::protobuf::MessageFactory::InternalRegisterGeneratedMessage(
      CustomMessageSupport_descriptor_, &CustomMessageSupport::default_instance());
  ::google::protobuf::MessageFactory::InternalRegisterGeneratedMessage(
      RequestCustomMessageSupport_descriptor_, &RequestCustomMessageSupport::default_instance());
  ::google::protobuf::MessageFactory::InternalRegisterGeneratedMessage(
      SetJointPosition_descriptor_, &SetJointPosition::default_instance());
  ::google::protobuf::MessageFactory::InternalRegisterGeneratedMessage(
      SetJointVelocity_descriptor_, &SetJointVelocity::default_instance());
  ::google::protobuf::MessageFactory::InternalRegisterGeneratedMessage(
      GetJointState_descriptor_, &GetJointState::default_instance());
  ::google::protobuf::MessageFactory::InternalRegisterGeneratedMessage(
      Axis_descriptor_, &Axis::default_instance());
  ::google::protobuf::MessageFactory::InternalRegisterGeneratedMessage(
      JointState_descriptor_, &JointState::default_instance());
  ::google::protobuf::MessageFactory::InternalRegisterGeneratedMessage(
      SetLinkWorldPose_descriptor_, &SetLinkWorldPose::default_instance());
  ::google::protobuf::MessageFactory::InternalRegisterGeneratedMessage(
      SetLinkLinearVelocity_descriptor_, &SetLinkLinearVelocity::default_instance());
  ::google::protobuf::MessageFactory::InternalRegisterGeneratedMessage(
      SetLinkAngularVelocity_descriptor_, &SetLinkAngularVelocity::default_instance());
  ::google::protobuf::MessageFactory::InternalRegisterGeneratedMessage(
      GetLinkState_descriptor_, &GetLinkState::default_instance());
  ::google::protobuf::MessageFactory::InternalRegisterGeneratedMessage(
      LinkState_descriptor_, &LinkState::default_instance());
  ::google::protobuf::MessageFactory::InternalRegisterGeneratedMessage(
      ML_Cord_descriptor_, &ML_Cord::default_instance());
  ::google::protobuf::MessageFactory::InternalRegisterGeneratedMessage(
      ML_Point_descriptor_, &ML_Point::default_instance());
  ::google::protobuf::MessageFactory::InternalRegisterGeneratedMessage(
      ML_Quat_descriptor_, &ML_Quat::default_instance());
  ::google::protobuf::MessageFactory::InternalRegisterGeneratedMessage(
      ML_Pose_descriptor_, &ML_Pose::default_instance());
  ::google::protobuf::MessageFactory::InternalRegisterGeneratedMessage(
      ML_Inertial_descriptor_, &ML_Inertial::default_instance());
  ::google::protobuf::MessageFactory::InternalRegisterGeneratedMessage(
      ML_Links_descriptor_, &ML_Links::default_instance());
  ::google::protobuf::MessageFactory::InternalRegisterGeneratedMessage(
      ML_Axis_descriptor_, &ML_Axis::default_instance());
  ::google::protobuf::MessageFactory::InternalRegisterGeneratedMessage(
      ML_Joints_descriptor_, &ML_Joints::default_instance());
  ::google::protobuf::MessageFactory::InternalRegisterGeneratedMessage(
      Gazebomodel_descriptor_, &Gazebomodel::default_instance());
  ::google::protobuf::MessageFactory::InternalRegisterGeneratedMessage(
      GetGazeboModelParam_descriptor_, &GetGazeboModelParam::default_instance());
  ::google::protobuf::MessageFactory::InternalRegisterGeneratedMessage(
      GazeboModelSDF_descriptor_, &GazeboModelSDF::default_instance());
  ::google::protobuf::MessageFactory::InternalRegisterGeneratedMessage(
      GetGazeboModelSDF_descriptor_, &GetGazeboModelSDF::default_instance());
}

}  // namespace

void protobuf_ShutdownFile_mw_2einternal_2erobotics_2egazebotransport_2eCoSimMsgs_2eproto() {
  delete PluginVersion::default_instance_;
  delete PluginVersion_reflection_;
  delete PluginVersion::_default_version_;
  delete Time::default_instance_;
  delete Time_reflection_;
  delete PacketHeader::default_instance_;
  delete PacketHeader_reflection_;
  delete Packet::default_instance_;
  delete Packet_default_oneof_instance_;
  delete Packet_reflection_;
  delete StepSimulation::default_instance_;
  delete StepSimulation_reflection_;
  delete ResetSimulation::default_instance_;
  delete ResetSimulation_reflection_;
  delete Image::default_instance_;
  delete Image_reflection_;
  delete RequestImage::default_instance_;
  delete RequestImage_reflection_;
  delete RequestCoSim::default_instance_;
  delete RequestCoSim_reflection_;
  delete StopCoSim::default_instance_;
  delete StopCoSim_reflection_;
  delete GetGroundTruthWorldPose::default_instance_;
  delete GetGroundTruthWorldPose_reflection_;
  delete Point::default_instance_;
  delete Point_reflection_;
  delete Quaternion::default_instance_;
  delete Quaternion_reflection_;
  delete Pose::default_instance_;
  delete Pose_reflection_;
  delete StopSimulation::default_instance_;
  delete StopSimulation_reflection_;
  delete LaserData::default_instance_;
  delete LaserData_reflection_;
  delete RequestLaser::default_instance_;
  delete RequestLaser_reflection_;
  delete ImuData::default_instance_;
  delete ImuData_reflection_;
  delete RequestImu::default_instance_;
  delete RequestImu_reflection_;
  delete SubscribeImage::default_instance_;
  delete SubscribeImage_reflection_;
  delete SubscribeLaser::default_instance_;
  delete SubscribeLaser_reflection_;
  delete SubscribeImu::default_instance_;
  delete SubscribeImu_reflection_;
  delete ApplyLinkWrench::default_instance_;
  delete ApplyLinkWrench_reflection_;
  delete ApplyJointTorque::default_instance_;
  delete ApplyJointTorque_reflection_;
  delete GetPose::default_instance_;
  delete GetPose_reflection_;
  delete GetTopicList::default_instance_;
  delete GetTopicList_reflection_;
  delete TopicList::default_instance_;
  delete TopicList_reflection_;
  delete TopicList_TopicInfo::default_instance_;
  delete TopicList_TopicInfo_reflection_;
  delete GetModelInfo::default_instance_;
  delete GetModelInfo_reflection_;
  delete ModelInfo::default_instance_;
  delete ModelInfo_reflection_;
  delete ModelInfo_LINKS::default_instance_;
  delete ModelInfo_LINKS_reflection_;
  delete ModelInfo_JOINTS::default_instance_;
  delete ModelInfo_JOINTS_reflection_;
  delete ModelInfo_Model::default_instance_;
  delete ModelInfo_Model_reflection_;
  delete MaxStepSize::default_instance_;
  delete MaxStepSize_reflection_;
  delete InitCustomPublisher::default_instance_;
  delete InitCustomPublisher_reflection_;
  delete InitCustomSubscriber::default_instance_;
  delete InitCustomSubscriber_reflection_;
  delete CustomMessageSupport::default_instance_;
  delete CustomMessageSupport_reflection_;
  delete RequestCustomMessageSupport::default_instance_;
  delete RequestCustomMessageSupport_reflection_;
  delete SetJointPosition::default_instance_;
  delete SetJointPosition_reflection_;
  delete SetJointVelocity::default_instance_;
  delete SetJointVelocity_reflection_;
  delete GetJointState::default_instance_;
  delete GetJointState_reflection_;
  delete Axis::default_instance_;
  delete Axis_reflection_;
  delete JointState::default_instance_;
  delete JointState_reflection_;
  delete SetLinkWorldPose::default_instance_;
  delete SetLinkWorldPose_reflection_;
  delete SetLinkLinearVelocity::default_instance_;
  delete SetLinkLinearVelocity_reflection_;
  delete SetLinkAngularVelocity::default_instance_;
  delete SetLinkAngularVelocity_reflection_;
  delete GetLinkState::default_instance_;
  delete GetLinkState_reflection_;
  delete LinkState::default_instance_;
  delete LinkState_reflection_;
  delete ML_Cord::default_instance_;
  delete ML_Cord_reflection_;
  delete ML_Point::default_instance_;
  delete ML_Point_reflection_;
  delete ML_Quat::default_instance_;
  delete ML_Quat_reflection_;
  delete ML_Pose::default_instance_;
  delete ML_Pose_reflection_;
  delete ML_Inertial::default_instance_;
  delete ML_Inertial_reflection_;
  delete ML_Links::default_instance_;
  delete ML_Links_reflection_;
  delete ML_Axis::default_instance_;
  delete ML_Axis_reflection_;
  delete ML_Joints::default_instance_;
  delete ML_Joints_reflection_;
  delete Gazebomodel::default_instance_;
  delete Gazebomodel_reflection_;
  delete GetGazeboModelParam::default_instance_;
  delete GetGazeboModelParam_reflection_;
  delete GazeboModelSDF::default_instance_;
  delete GazeboModelSDF_reflection_;
  delete GetGazeboModelSDF::default_instance_;
  delete GetGazeboModelSDF_reflection_;
}

void protobuf_AddDesc_mw_2einternal_2erobotics_2egazebotransport_2eCoSimMsgs_2eproto() GOOGLE_ATTRIBUTE_COLD;
void protobuf_AddDesc_mw_2einternal_2erobotics_2egazebotransport_2eCoSimMsgs_2eproto() {
  static bool already_here = false;
  if (already_here) return;
  already_here = true;
  GOOGLE_PROTOBUF_VERIFY_VERSION;

  ::google::protobuf::DescriptorPool::InternalAddGeneratedFile(
    "\n4mw.internal.robotics.gazebotransport.C"
    "oSimMsgs.proto\022$mw.internal.robotics.gaz"
    "ebotransport\"(\n\rPluginVersion\022\027\n\007version"
    "\030\001 \002(\t:\006R2021b\"-\n\004Time\022\017\n\007seconds\030\001 \002(\004\022"
    "\024\n\014nano_seconds\030\002 \002(\004\"\273\010\n\014PacketHeader\022D"
    "\n\002id\030\001 \002(\01628.mw.internal.robotics.gazebo"
    "transport.PacketHeader.MsgID\022>\n\ntime_sta"
    "mp\030\002 \002(\0132*.mw.internal.robotics.gazebotr"
    "ansport.Time\"\244\007\n\005MsgID\022\n\n\006STATUS\020\000\022\023\n\017ST"
    "EP_SIMULATION\020\001\022\024\n\020RESET_SIMULATION\020\002\022\t\n"
    "\005IMAGE\020\003\022\021\n\rREQUEST_IMAGE\020\004\022\021\n\rREQUEST_C"
    "OSIM\020\005\022\016\n\nSTOP_COSIM\020\006\022\037\n\033GET_GROUND_TRU"
    "TH_WORLD_POSE\020\007\022\010\n\004POSE\020\010\022\023\n\017STOP_SIMULA"
    "TION\020\t\022\016\n\nLASER_DATA\020\n\022\021\n\rREQUEST_LASER\020"
    "\013\022\014\n\010IMU_DATA\020\014\022\017\n\013REQUEST_IMU\020\r\022\023\n\017SUBS"
    "CRIBE_IMAGE\020\016\022\023\n\017SUBSCRIBE_LASER\020\017\022\021\n\rSU"
    "BSCRIBE_IMU\020\020\022\026\n\022APPLY_JOINT_TORQUE\020\021\022\014\n"
    "\010GET_POSE\020\022\022\022\n\016GET_TOPIC_LIST\020\023\022\016\n\nTOPIC"
    "_LIST\020\024\022\022\n\016GET_MODEL_INFO\020\025\022\016\n\nMODEL_INF"
    "O\020\026\022\025\n\021APPLY_LINK_WRENCH\020\027\022\021\n\rMAX_STEP_S"
    "IZE\020\030\022\035\n\031CUSTOM_MESSAGE_SUBSCRIBER\020\031\022\034\n\030"
    "CUSTOM_MESSAGE_PUBLISHER\020\032\022!\n\035INIT_CUSTO"
    "M_MESSAGE_PUBLISHER\020\033\022\"\n\036INIT_CUSTOM_MES"
    "SAGE_SUBSCRIBER\020\034\022\026\n\022SET_JOINT_POSITION\020"
    "\035\022\026\n\022SET_JOINT_VELOCITY\020\036\022\023\n\017GET_JOINT_S"
    "TATE\020\037\022\017\n\013JOINT_STATE\020 \022\027\n\023SET_LINK_WORL"
    "D_POSE\020!\022\034\n\030SET_LINK_LINEAR_VELOCITY\020\"\022\035"
    "\n\031SET_LINK_ANGULAR_VELOCITY\020#\022\022\n\016GET_LIN"
    "K_STATE\020$\022\016\n\nLINK_STATE\020%\022\020\n\014GAZEBO_MODE"
    "L\020&\022\032\n\026SET_GAZEBO_MODEL_PARAM\020\'\022\032\n\026GET_G"
    "AZEBO_MODEL_PARAM\020(\022\024\n\020GAZEBO_MODEL_SDF\020"
    ")\022\030\n\024GET_GAZEBO_MODEL_SDF\020*\"\260\037\n\006Packet\022B"
    "\n\006header\030\001 \002(\01322.mw.internal.robotics.ga"
    "zebotransport.PacketHeader\022I\n\006status\030\002 \001"
    "(\01627.mw.internal.robotics.gazebotranspor"
    "t.Packet.CoSimErrorH\000\022O\n\017step_simulation"
    "\030\003 \001(\01324.mw.internal.robotics.gazebotran"
    "sport.StepSimulationH\000\022Q\n\020reset_simulati"
    "on\030\004 \001(\01325.mw.internal.robotics.gazebotr"
    "ansport.ResetSimulationH\000\022<\n\005image\030\005 \001(\013"
    "2+.mw.internal.robotics.gazebotransport."
    "ImageH\000\022K\n\rrequest_image\030\006 \001(\01322.mw.inte"
    "rnal.robotics.gazebotransport.RequestIma"
    "geH\000\022K\n\rrequest_cosim\030\007 \001(\01322.mw.interna"
    "l.robotics.gazebotransport.RequestCoSimH"
    "\000\022E\n\nstop_cosim\030\010 \001(\0132/.mw.internal.robo"
    "tics.gazebotransport.StopCoSimH\000\022d\n\033get_"
    "ground_truth_world_pose\030\t \001(\0132=.mw.inter"
    "nal.robotics.gazebotransport.GetGroundTr"
    "uthWorldPoseH\000\022:\n\004pose\030\n \001(\0132*.mw.intern"
    "al.robotics.gazebotransport.PoseH\000\022O\n\017st"
    "op_simulation\030\013 \001(\01324.mw.internal.roboti"
    "cs.gazebotransport.StopSimulationH\000\022E\n\nl"
    "aser_data\030\014 \001(\0132/.mw.internal.robotics.g"
    "azebotransport.LaserDataH\000\022K\n\rrequest_la"
    "ser\030\r \001(\01322.mw.internal.robotics.gazebot"
    "ransport.RequestLaserH\000\022A\n\010imu_data\030\016 \001("
    "\0132-.mw.internal.robotics.gazebotransport"
    ".ImuDataH\000\022G\n\013request_imu\030\017 \001(\01320.mw.int"
    "ernal.robotics.gazebotransport.RequestIm"
    "uH\000\022O\n\017subscribe_image\030\020 \001(\01324.mw.intern"
    "al.robotics.gazebotransport.SubscribeIma"
    "geH\000\022O\n\017subscribe_laser\030\021 \001(\01324.mw.inter"
    "nal.robotics.gazebotransport.SubscribeLa"
    "serH\000\022K\n\rsubscribe_imu\030\022 \001(\01322.mw.intern"
    "al.robotics.gazebotransport.SubscribeImu"
    "H\000\022T\n\022apply_joint_torque\030\023 \001(\01326.mw.inte"
    "rnal.robotics.gazebotransport.ApplyJoint"
    "TorqueH\000\022A\n\010get_pose\030\024 \001(\0132-.mw.internal"
    ".robotics.gazebotransport.GetPoseH\000\022L\n\016g"
    "et_topic_list\030\025 \001(\01322.mw.internal.roboti"
    "cs.gazebotransport.GetTopicListH\000\022E\n\ntop"
    "ic_list\030\026 \001(\0132/.mw.internal.robotics.gaz"
    "ebotransport.TopicListH\000\022L\n\016get_model_in"
    "fo\030\027 \001(\01322.mw.internal.robotics.gazebotr"
    "ansport.GetModelInfoH\000\022E\n\nmodel_info\030\030 \001"
    "(\0132/.mw.internal.robotics.gazebotranspor"
    "t.ModelInfoH\000\022R\n\021apply_link_wrench\030\031 \001(\013"
    "25.mw.internal.robotics.gazebotransport."
    "ApplyLinkWrenchH\000\022J\n\rmax_step_size\030\032 \001(\013"
    "21.mw.internal.robotics.gazebotransport."
    "MaxStepSizeH\000\022\\\n\026custom_message_support\030"
    "\033 \001(\0132:.mw.internal.robotics.gazebotrans"
    "port.CustomMessageSupportH\000\022Z\n\025init_cust"
    "om_publisher\030\034 \001(\01329.mw.internal.robotic"
    "s.gazebotransport.InitCustomPublisherH\000\022"
    "\\\n\026init_custom_subscriber\030\035 \001(\0132:.mw.int"
    "ernal.robotics.gazebotransport.InitCusto"
    "mSubscriberH\000\022k\n\036request_custom_message_"
    "support\030\036 \001(\0132A.mw.internal.robotics.gaz"
    "ebotransport.RequestCustomMessageSupport"
    "H\000\022T\n\022set_joint_position\030\037 \001(\01326.mw.inte"
    "rnal.robotics.gazebotransport.SetJointPo"
    "sitionH\000\022T\n\022set_joint_velocity\030  \001(\01326.m"
    "w.internal.robotics.gazebotransport.SetJ"
    "ointVelocityH\000\022N\n\017get_joint_state\030! \001(\0132"
    "3.mw.internal.robotics.gazebotransport.G"
    "etJointStateH\000\022G\n\013joint_state\030\" \001(\01320.mw"
    ".internal.robotics.gazebotransport.Joint"
    "StateH\000\022U\n\023set_link_world_pose\030# \001(\01326.m"
    "w.internal.robotics.gazebotransport.SetL"
    "inkWorldPoseH\000\022_\n\030set_link_linear_veloci"
    "ty\030$ \001(\0132;.mw.internal.robotics.gazebotr"
    "ansport.SetLinkLinearVelocityH\000\022a\n\031set_l"
    "ink_angular_velocity\030% \001(\0132<.mw.internal"
    ".robotics.gazebotransport.SetLinkAngular"
    "VelocityH\000\022L\n\016get_link_state\030& \001(\01322.mw."
    "internal.robotics.gazebotransport.GetLin"
    "kStateH\000\022E\n\nlink_state\030\' \001(\0132/.mw.intern"
    "al.robotics.gazebotransport.LinkStateH\000\022"
    "I\n\014gazebo_model\030( \001(\01321.mw.internal.robo"
    "tics.gazebotransport.GazebomodelH\000\022[\n\026ge"
    "t_gazebo_model_param\030) \001(\01329.mw.internal"
    ".robotics.gazebotransport.GetGazeboModel"
    "ParamH\000\022P\n\020gazebo_model_sdf\030* \001(\01324.mw.i"
    "nternal.robotics.gazebotransport.GazeboM"
    "odelSDFH\000\022W\n\024get_gazebo_model_sdf\030+ \001(\0132"
    "7.mw.internal.robotics.gazebotransport.G"
    "etGazeboModelSDFH\000\022\025\n\rerror_message\030, \001("
    "\t\"\377\003\n\nCoSimError\022\010\n\004NONE\020\000\022\017\n\013STEP_FAILE"
    "D\020\001\022\017\n\013MSG_INVALID\020\002\022\021\n\rSOCKET_FAILED\020\003\022"
    "\020\n\014RESET_FAILED\020\004\022\020\n\014COSIM_FAILED\020\005\022\025\n\021S"
    "TOP_COSIM_FAILED\020\006\022&\n\"GET_GROUND_TRUTH_W"
    "ORLD_POSE_FAILED\020\007\022\033\n\027RESET_TIME_SCENE_F"
    "AILED\020\010\022\025\n\021RESET_TIME_FAILED\020\t\022\017\n\013STOP_F"
    "AILED\020\n\022\026\n\022FORCE_TYPE_INVALID\020\013\022\026\n\022MODEL"
    "_NAME_INVALID\020\014\022\025\n\021LINK_NAME_INVALID\020\r\022\026"
    "\n\022JOINT_NAME_INVALID\020\016\022\026\n\022TOPIC_NAME_INV"
    "ALID\020\017\022\027\n\023TORQUE_TYPE_INVALID\020\020\022\027\n\023MAX_S"
    "TEP_SIZE_ERROR\020\021\022\032\n\026CUSTOM_MESSAGE_INVAL"
    "ID\020\022\022\030\n\024MESSAGE_TYPE_INVALID\020\023\022\023\n\017JOINT_"
    "AXIS_NONE\020\024\022\026\n\022INVALID_JOINT_AXIS\020\025B\t\n\007p"
    "ayload\"#\n\016StepSimulation\022\021\n\tnum_steps\030\001 "
    "\002(\r\"\243\001\n\017ResetSimulation\022U\n\010behavior\030\001 \002("
    "\0162C.mw.internal.robotics.gazebotransport"
    ".ResetSimulation.ResetBehavior\"9\n\rResetB"
    "ehavior\022\016\n\nRESET_TIME\020\000\022\030\n\024RESET_TIME_AN"
    "D_SCENE\020\001\"G\n\005Image\022\r\n\005width\030\001 \002(\r\022\016\n\006hei"
    "ght\030\002 \002(\r\022\014\n\004data\030\003 \002(\014\022\021\n\tdata_type\030\004 \002"
    "(\t\"\"\n\014RequestImage\022\022\n\ntopic_name\030\001 \002(\t\"3"
    "\n\014RequestCoSim\022\021\n\tclient_id\030\001 \002(\t\022\020\n\010dur"
    "ation\030\002 \002(\001\"\036\n\tStopCoSim\022\021\n\tclient_id\030\001 "
    "\002(\t\"@\n\027GetGroundTruthWorldPose\022\022\n\nmodel_"
    "name\030\001 \002(\t\022\021\n\tlink_name\030\002 \002(\t\"(\n\005Point\022\t"
    "\n\001x\030\001 \002(\001\022\t\n\001y\030\002 \002(\001\022\t\n\001z\030\003 \002(\001\"8\n\nQuate"
    "rnion\022\t\n\001x\030\001 \002(\001\022\t\n\001y\030\002 \002(\001\022\t\n\001z\030\003 \002(\001\022\t"
    "\n\001w\030\004 \002(\001\"\214\001\n\004Pose\022=\n\010position\030\001 \002(\0132+.m"
    "w.internal.robotics.gazebotransport.Poin"
    "t\022E\n\013orientation\030\002 \002(\01320.mw.internal.rob"
    "otics.gazebotransport.Quaternion\"$\n\016Stop"
    "Simulation\022\022\n\nstop_scene\030\001 \002(\010\"\363\001\n\tLaser"
    "Data\022\021\n\tangle_min\030\001 \002(\001\022\021\n\tangle_max\030\002 \002"
    "(\001\022\022\n\nangle_step\030\003 \002(\001\022\021\n\trange_min\030\004 \002("
    "\001\022\021\n\trange_max\030\005 \002(\001\022\r\n\005count\030\006 \002(\001\022\032\n\022v"
    "ertical_angle_min\030\007 \002(\001\022\032\n\022vertical_angl"
    "e_max\030\010 \002(\001\022\033\n\023vertical_angle_step\030\t \002(\001"
    "\022\r\n\005range\030\n \003(\001\022\023\n\013intensities\030\013 \003(\001\"\"\n\014"
    "RequestLaser\022\022\n\ntopic_name\030\001 \002(\t\"\341\001\n\007Imu"
    "Data\022H\n\023linear_acceleration\030\001 \002(\0132+.mw.i"
    "nternal.robotics.gazebotransport.Point\022E"
    "\n\020angular_velocity\030\002 \002(\0132+.mw.internal.r"
    "obotics.gazebotransport.Point\022E\n\013orienta"
    "tion\030\003 \002(\01320.mw.internal.robotics.gazebo"
    "transport.Quaternion\" \n\nRequestImu\022\022\n\nto"
    "pic_name\030\001 \002(\t\"$\n\016SubscribeImage\022\022\n\ntopi"
    "c_name\030\001 \002(\t\"$\n\016SubscribeLaser\022\022\n\ntopic_"
    "name\030\001 \002(\t\"\"\n\014SubscribeImu\022\022\n\ntopic_name"
    "\030\001 \002(\t\"\347\001\n\017ApplyLinkWrench\022\022\n\nmodel_name"
    "\030\001 \002(\t\022\021\n\tlink_name\030\002 \002(\t\022\022\n\nforce_type\030"
    "\003 \002(\t\022\n\n\002fx\030\004 \002(\001\022\n\n\002fy\030\005 \002(\001\022\n\n\002fz\030\006 \002("
    "\001\022\023\n\013torque_type\030\007 \002(\t\022\n\n\002tx\030\010 \002(\001\022\n\n\002ty"
    "\030\t \002(\001\022\n\n\002tz\030\n \002(\001\022<\n\010duration\030\013 \002(\0132*.m"
    "w.internal.robotics.gazebotransport.Time"
    "\"\227\001\n\020ApplyJointTorque\022\022\n\nmodel_name\030\001 \002("
    "\t\022\022\n\njoint_name\030\002 \002(\t\022\r\n\005index\030\003 \002(\r\022\016\n\006"
    "effort\030\004 \002(\001\022<\n\010duration\030\005 \002(\0132*.mw.inte"
    "rnal.robotics.gazebotransport.Time\"\035\n\007Ge"
    "tPose\022\022\n\nmodel_name\030\001 \002(\t\"\"\n\014GetTopicLis"
    "t\022\022\n\ntopic_name\030\001 \002(\t\"}\n\tTopicList\022G\n\004da"
    "ta\030\001 \003(\01329.mw.internal.robotics.gazebotr"
    "ansport.TopicList.TopicInfo\032\'\n\tTopicInfo"
    "\022\014\n\004name\030\001 \002(\t\022\014\n\004type\030\002 \002(\t\"\"\n\014GetModel"
    "Info\022\022\n\ntopic_name\030\001 \002(\t\"\274\002\n\tModelInfo\022I"
    "\n\nmodel_data\030\001 \003(\01325.mw.internal.robotic"
    "s.gazebotransport.ModelInfo.Model\032\032\n\005LIN"
    "KS\022\021\n\tlink_name\030\001 \003(\t\032\034\n\006JOINTS\022\022\n\njoint"
    "_name\030\001 \003(\t\032\251\001\n\005Model\022\022\n\nmodel_name\030\001 \002("
    "\t\022D\n\005links\030\002 \001(\01325.mw.internal.robotics."
    "gazebotransport.ModelInfo.LINKS\022F\n\006joint"
    "s\030\003 \001(\01326.mw.internal.robotics.gazebotra"
    "nsport.ModelInfo.JOINTS\"\217\001\n\013MaxStepSize\022"
    "D\n\004type\030\001 \002(\01626.mw.internal.robotics.gaz"
    "ebotransport.MaxStepSize.TYPE\022\014\n\004size\030\002 "
    "\002(\001\",\n\004TYPE\022\021\n\rSET_STEP_SIZE\020\000\022\021\n\rGET_ST"
    "EP_SIZE\020\001\"\?\n\023InitCustomPublisher\022\022\n\ntopi"
    "c_name\030\001 \002(\t\022\024\n\014message_type\030\002 \002(\t\"@\n\024In"
    "itCustomSubscriber\022\022\n\ntopic_name\030\001 \002(\t\022\024"
    "\n\014message_type\030\002 \002(\t\"^\n\024CustomMessageSup"
    "port\022\022\n\ntopic_name\030\001 \002(\t\022\024\n\014message_type"
    "\030\002 \002(\t\022\014\n\004data\030\003 \002(\014\022\016\n\006is_new\030\004 \001(\010\"G\n\033"
    "RequestCustomMessageSupport\022\022\n\ntopic_nam"
    "e\030\001 \002(\t\022\024\n\014message_type\030\002 \002(\t\"\231\001\n\020SetJoi"
    "ntPosition\022\022\n\nmodel_name\030\001 \002(\t\022\022\n\njoint_"
    "name\030\002 \002(\t\022\r\n\005index\030\003 \002(\r\022\020\n\010position\030\004 "
    "\002(\001\022<\n\010duration\030\005 \002(\0132*.mw.internal.robo"
    "tics.gazebotransport.Time\"\231\001\n\020SetJointVe"
    "locity\022\022\n\nmodel_name\030\001 \002(\t\022\022\n\njoint_name"
    "\030\002 \002(\t\022\r\n\005index\030\003 \002(\r\022\020\n\010velocity\030\004 \002(\001\022"
    "<\n\010duration\030\005 \002(\0132*.mw.internal.robotics"
    ".gazebotransport.Time\"7\n\rGetJointState\022\022"
    "\n\nmodel_name\030\001 \002(\t\022\022\n\njoint_name\030\002 \002(\t\"\333"
    "\001\n\004Axis\0228\n\003xyz\030\001 \002(\0132+.mw.internal.robot"
    "ics.gazebotransport.Point\022\023\n\013limit_lower"
    "\030\002 \002(\001\022\023\n\013limit_upper\030\003 \002(\001\022\024\n\014limit_eff"
    "ort\030\004 \002(\001\022\026\n\016limit_velocity\030\005 \002(\001\022\017\n\007dam"
    "ping\030\006 \002(\001\022\020\n\010friction\030\007 \002(\001\022\036\n\026use_pare"
    "nt_model_frame\030\010 \002(\010\"\225\005\n\nJointState\022\022\n\nm"
    "odel_name\030\001 \002(\t\022\022\n\njoint_name\030\002 \002(\t\022\020\n\010j"
    "oint_id\030\003 \002(\r\022\026\n\016joint_position\030\004 \003(\001\022\026\n"
    "\016joint_velocity\030\005 \003(\001\022O\n\njoint_type\030\006 \001("
    "\0162;.mw.internal.robotics.gazebotransport"
    ".JointState.Joint_Type\022\023\n\013parent_name\030\007 "
    "\001(\t\022\021\n\tparent_id\030\010 \001(\r\022\022\n\nchild_name\030\t \001"
    "(\t\022\020\n\010child_id\030\n \001(\r\022G\n\023initial_anchor_p"
    "ose\030\013 \001(\0132*.mw.internal.robotics.gazebot"
    "ransport.Pose\022>\n\nworld_pose\030\014 \001(\0132*.mw.i"
    "nternal.robotics.gazebotransport.Pose\022E\n"
    "\021parent_world_pose\030\r \001(\0132*.mw.internal.r"
    "obotics.gazebotransport.Pose\0228\n\004axis\030\016 \003"
    "(\0132*.mw.internal.robotics.gazebotranspor"
    "t.Axis\"t\n\nJoint_Type\022\014\n\010REVOLUTE\020\001\022\r\n\tRE"
    "VOLUTE2\020\002\022\r\n\tPRISMATIC\020\003\022\r\n\tUNIVERSAL\020\004\022"
    "\010\n\004BALL\020\005\022\t\n\005SCREW\020\006\022\013\n\007GEARBOX\020\007\022\t\n\005FIX"
    "ED\020\010\"\261\001\n\020SetLinkWorldPose\022\022\n\nmodel_name\030"
    "\001 \002(\t\022\021\n\tlink_name\030\002 \002(\t\0228\n\004pose\030\003 \002(\0132*"
    ".mw.internal.robotics.gazebotransport.Po"
    "se\022<\n\010duration\030\004 \002(\0132*.mw.internal.robot"
    "ics.gazebotransport.Time\"\273\001\n\025SetLinkLine"
    "arVelocity\022\022\n\nmodel_name\030\001 \002(\t\022\021\n\tlink_n"
    "ame\030\002 \002(\t\022=\n\010velocity\030\003 \002(\0132+.mw.interna"
    "l.robotics.gazebotransport.Point\022<\n\010dura"
    "tion\030\004 \002(\0132*.mw.internal.robotics.gazebo"
    "transport.Time\"\274\001\n\026SetLinkAngularVelocit"
    "y\022\022\n\nmodel_name\030\001 \002(\t\022\021\n\tlink_name\030\002 \002(\t"
    "\022=\n\010velocity\030\003 \002(\0132+.mw.internal.robotic"
    "s.gazebotransport.Point\022<\n\010duration\030\004 \002("
    "\0132*.mw.internal.robotics.gazebotransport"
    ".Time\"5\n\014GetLinkState\022\022\n\nmodel_name\030\001 \002("
    "\t\022\021\n\tlink_name\030\002 \002(\t\"\340\004\n\tLinkState\022\022\n\nmo"
    "del_name\030\001 \002(\t\022\021\n\tlink_name\030\002 \002(\t\022\017\n\007lin"
    "k_id\030\003 \002(\r\022J\n\025world_linear_velocity\030\004 \002("
    "\0132+.mw.internal.robotics.gazebotransport"
    ".Point\022K\n\026world_angular_velocity\030\005 \002(\0132+"
    ".mw.internal.robotics.gazebotransport.Po"
    "int\022M\n\030relative_linear_velocity\030\006 \002(\0132+."
    "mw.internal.robotics.gazebotransport.Poi"
    "nt\022N\n\031relative_angular_velocity\030\007 \002(\0132+."
    "mw.internal.robotics.gazebotransport.Poi"
    "nt\022>\n\nworld_pose\030\010 \001(\0132*.mw.internal.rob"
    "otics.gazebotransport.Pose\022A\n\rrelative_p"
    "ose\030\t \001(\0132*.mw.internal.robotics.gazebot"
    "ransport.Pose\022\024\n\014self_collide\030\n \001(\010\022\017\n\007g"
    "ravity\030\013 \001(\010\022\021\n\tkinematic\030\014 \001(\010\022\023\n\013enabl"
    "e_wind\030\r \001(\010\022\021\n\tcanonical\030\016 \001(\010\"\037\n\007ML_Co"
    "rd\022\t\n\001x\030\001 \001(\001\022\t\n\001y\030\002 \001(\001\"+\n\010ML_Point\022\t\n\001"
    "x\030\001 \001(\001\022\t\n\001y\030\002 \001(\001\022\t\n\001z\030\003 \001(\001\"5\n\007ML_Quat"
    "\022\t\n\001x\030\001 \001(\001\022\t\n\001y\030\002 \001(\001\022\t\n\001z\030\003 \001(\001\022\t\n\001w\030\004"
    " \001(\001\"\217\001\n\007ML_Pose\022@\n\010position\030\001 \001(\0132..mw."
    "internal.robotics.gazebotransport.ML_Poi"
    "nt\022B\n\013orientation\030\002 \001(\0132-.mw.internal.ro"
    "botics.gazebotransport.ML_Quat\"i\n\013ML_Ine"
    "rtial\022\014\n\004mass\030\001 \001(\001\022\013\n\003ixx\030\002 \001(\001\022\013\n\003ixy\030"
    "\003 \001(\001\022\013\n\003ixz\030\004 \001(\001\022\013\n\003iyy\030\005 \001(\001\022\013\n\003iyz\030\006"
    " \001(\001\022\013\n\003izz\030\007 \001(\001\"\220\002\n\010ML_Links\022\014\n\004name\030\001"
    " \001(\t\022;\n\004pose\030\002 \001(\0132-.mw.internal.robotic"
    "s.gazebotransport.ML_Pose\022C\n\010inertial\030\003 "
    "\001(\01321.mw.internal.robotics.gazebotranspo"
    "rt.ML_Inertial\022\024\n\014self_collide\030\004 \001(\010\022\017\n\007"
    "gravity\030\005 \001(\010\022\021\n\tkinematic\030\006 \001(\010\022\024\n\014enab"
    "led_wind\030\007 \001(\010\022\021\n\tis_static\030\010 \001(\010\022\021\n\tcan"
    "onical\030\t \001(\010\"x\n\007ML_Axis\022;\n\003xyz\030\001 \001(\0132..m"
    "w.internal.robotics.gazebotransport.ML_P"
    "oint\022\017\n\007damping\030\002 \001(\001\022\020\n\010friction\030\003 \001(\001\022"
    "\r\n\005angle\030\004 \001(\001\"\262\002\n\tML_Joints\022\014\n\004name\030\001 \001"
    "(\t\022;\n\004pose\030\002 \001(\0132-.mw.internal.robotics."
    "gazebotransport.ML_Pose\022<\n\005axis1\030\003 \001(\0132-"
    ".mw.internal.robotics.gazebotransport.ML"
    "_Axis\022<\n\005axis2\030\004 \001(\0132-.mw.internal.robot"
    "ics.gazebotransport.ML_Axis\022\013\n\003cfm\030\005 \001(\001"
    "\022\024\n\014fudge_factor\030\006 \001(\001\022\026\n\016suspension_cfm"
    "\030\007 \001(\001\022\026\n\016suspension_erp\030\010 \001(\001\022\013\n\003dof\030\t "
    "\001(\r\"\226\002\n\013Gazebomodel\022\014\n\004name\030\001 \002(\t\022=\n\005lin"
    "ks\030\002 \003(\0132..mw.internal.robotics.gazebotr"
    "ansport.ML_Links\022\?\n\006joints\030\003 \003(\0132/.mw.in"
    "ternal.robotics.gazebotransport.ML_Joint"
    "s\022;\n\004pose\030\004 \001(\0132-.mw.internal.robotics.g"
    "azebotransport.ML_Pose\022\023\n\013enable_wind\030\005 "
    "\001(\010\022\024\n\014self_collide\030\006 \001(\010\022\021\n\tis_static\030\007"
    " \001(\010\"S\n\023GetGazeboModelParam\022\022\n\nmodel_nam"
    "e\030\001 \002(\t\022\017\n\007is_link\030\002 \001(\010\022\027\n\017link_joint_n"
    "ame\030\003 \001(\t\"8\n\016GazeboModelSDF\022\022\n\nmodel_nam"
    "e\030\001 \002(\t\022\022\n\nsdf_string\030\002 \002(\t\"\'\n\021GetGazebo"
    "ModelSDF\022\022\n\nmodel_name\030\001 \002(\t", 12108);
  ::google::protobuf::MessageFactory::InternalRegisterGeneratedFile(
    "mw.internal.robotics.gazebotransport.CoSimMsgs.proto", &protobuf_RegisterTypes);
  PluginVersion::_default_version_ =
      new ::std::string("R2021b", 6);
  PluginVersion::default_instance_ = new PluginVersion();
  Time::default_instance_ = new Time();
  PacketHeader::default_instance_ = new PacketHeader();
  Packet::default_instance_ = new Packet();
  Packet_default_oneof_instance_ = new PacketOneofInstance();
  StepSimulation::default_instance_ = new StepSimulation();
  ResetSimulation::default_instance_ = new ResetSimulation();
  Image::default_instance_ = new Image();
  RequestImage::default_instance_ = new RequestImage();
  RequestCoSim::default_instance_ = new RequestCoSim();
  StopCoSim::default_instance_ = new StopCoSim();
  GetGroundTruthWorldPose::default_instance_ = new GetGroundTruthWorldPose();
  Point::default_instance_ = new Point();
  Quaternion::default_instance_ = new Quaternion();
  Pose::default_instance_ = new Pose();
  StopSimulation::default_instance_ = new StopSimulation();
  LaserData::default_instance_ = new LaserData();
  RequestLaser::default_instance_ = new RequestLaser();
  ImuData::default_instance_ = new ImuData();
  RequestImu::default_instance_ = new RequestImu();
  SubscribeImage::default_instance_ = new SubscribeImage();
  SubscribeLaser::default_instance_ = new SubscribeLaser();
  SubscribeImu::default_instance_ = new SubscribeImu();
  ApplyLinkWrench::default_instance_ = new ApplyLinkWrench();
  ApplyJointTorque::default_instance_ = new ApplyJointTorque();
  GetPose::default_instance_ = new GetPose();
  GetTopicList::default_instance_ = new GetTopicList();
  TopicList::default_instance_ = new TopicList();
  TopicList_TopicInfo::default_instance_ = new TopicList_TopicInfo();
  GetModelInfo::default_instance_ = new GetModelInfo();
  ModelInfo::default_instance_ = new ModelInfo();
  ModelInfo_LINKS::default_instance_ = new ModelInfo_LINKS();
  ModelInfo_JOINTS::default_instance_ = new ModelInfo_JOINTS();
  ModelInfo_Model::default_instance_ = new ModelInfo_Model();
  MaxStepSize::default_instance_ = new MaxStepSize();
  InitCustomPublisher::default_instance_ = new InitCustomPublisher();
  InitCustomSubscriber::default_instance_ = new InitCustomSubscriber();
  CustomMessageSupport::default_instance_ = new CustomMessageSupport();
  RequestCustomMessageSupport::default_instance_ = new RequestCustomMessageSupport();
  SetJointPosition::default_instance_ = new SetJointPosition();
  SetJointVelocity::default_instance_ = new SetJointVelocity();
  GetJointState::default_instance_ = new GetJointState();
  Axis::default_instance_ = new Axis();
  JointState::default_instance_ = new JointState();
  SetLinkWorldPose::default_instance_ = new SetLinkWorldPose();
  SetLinkLinearVelocity::default_instance_ = new SetLinkLinearVelocity();
  SetLinkAngularVelocity::default_instance_ = new SetLinkAngularVelocity();
  GetLinkState::default_instance_ = new GetLinkState();
  LinkState::default_instance_ = new LinkState();
  ML_Cord::default_instance_ = new ML_Cord();
  ML_Point::default_instance_ = new ML_Point();
  ML_Quat::default_instance_ = new ML_Quat();
  ML_Pose::default_instance_ = new ML_Pose();
  ML_Inertial::default_instance_ = new ML_Inertial();
  ML_Links::default_instance_ = new ML_Links();
  ML_Axis::default_instance_ = new ML_Axis();
  ML_Joints::default_instance_ = new ML_Joints();
  Gazebomodel::default_instance_ = new Gazebomodel();
  GetGazeboModelParam::default_instance_ = new GetGazeboModelParam();
  GazeboModelSDF::default_instance_ = new GazeboModelSDF();
  GetGazeboModelSDF::default_instance_ = new GetGazeboModelSDF();
  PluginVersion::default_instance_->InitAsDefaultInstance();
  Time::default_instance_->InitAsDefaultInstance();
  PacketHeader::default_instance_->InitAsDefaultInstance();
  Packet::default_instance_->InitAsDefaultInstance();
  StepSimulation::default_instance_->InitAsDefaultInstance();
  ResetSimulation::default_instance_->InitAsDefaultInstance();
  Image::default_instance_->InitAsDefaultInstance();
  RequestImage::default_instance_->InitAsDefaultInstance();
  RequestCoSim::default_instance_->InitAsDefaultInstance();
  StopCoSim::default_instance_->InitAsDefaultInstance();
  GetGroundTruthWorldPose::default_instance_->InitAsDefaultInstance();
  Point::default_instance_->InitAsDefaultInstance();
  Quaternion::default_instance_->InitAsDefaultInstance();
  Pose::default_instance_->InitAsDefaultInstance();
  StopSimulation::default_instance_->InitAsDefaultInstance();
  LaserData::default_instance_->InitAsDefaultInstance();
  RequestLaser::default_instance_->InitAsDefaultInstance();
  ImuData::default_instance_->InitAsDefaultInstance();
  RequestImu::default_instance_->InitAsDefaultInstance();
  SubscribeImage::default_instance_->InitAsDefaultInstance();
  SubscribeLaser::default_instance_->InitAsDefaultInstance();
  SubscribeImu::default_instance_->InitAsDefaultInstance();
  ApplyLinkWrench::default_instance_->InitAsDefaultInstance();
  ApplyJointTorque::default_instance_->InitAsDefaultInstance();
  GetPose::default_instance_->InitAsDefaultInstance();
  GetTopicList::default_instance_->InitAsDefaultInstance();
  TopicList::default_instance_->InitAsDefaultInstance();
  TopicList_TopicInfo::default_instance_->InitAsDefaultInstance();
  GetModelInfo::default_instance_->InitAsDefaultInstance();
  ModelInfo::default_instance_->InitAsDefaultInstance();
  ModelInfo_LINKS::default_instance_->InitAsDefaultInstance();
  ModelInfo_JOINTS::default_instance_->InitAsDefaultInstance();
  ModelInfo_Model::default_instance_->InitAsDefaultInstance();
  MaxStepSize::default_instance_->InitAsDefaultInstance();
  InitCustomPublisher::default_instance_->InitAsDefaultInstance();
  InitCustomSubscriber::default_instance_->InitAsDefaultInstance();
  CustomMessageSupport::default_instance_->InitAsDefaultInstance();
  RequestCustomMessageSupport::default_instance_->InitAsDefaultInstance();
  SetJointPosition::default_instance_->InitAsDefaultInstance();
  SetJointVelocity::default_instance_->InitAsDefaultInstance();
  GetJointState::default_instance_->InitAsDefaultInstance();
  Axis::default_instance_->InitAsDefaultInstance();
  JointState::default_instance_->InitAsDefaultInstance();
  SetLinkWorldPose::default_instance_->InitAsDefaultInstance();
  SetLinkLinearVelocity::default_instance_->InitAsDefaultInstance();
  SetLinkAngularVelocity::default_instance_->InitAsDefaultInstance();
  GetLinkState::default_instance_->InitAsDefaultInstance();
  LinkState::default_instance_->InitAsDefaultInstance();
  ML_Cord::default_instance_->InitAsDefaultInstance();
  ML_Point::default_instance_->InitAsDefaultInstance();
  ML_Quat::default_instance_->InitAsDefaultInstance();
  ML_Pose::default_instance_->InitAsDefaultInstance();
  ML_Inertial::default_instance_->InitAsDefaultInstance();
  ML_Links::default_instance_->InitAsDefaultInstance();
  ML_Axis::default_instance_->InitAsDefaultInstance();
  ML_Joints::default_instance_->InitAsDefaultInstance();
  Gazebomodel::default_instance_->InitAsDefaultInstance();
  GetGazeboModelParam::default_instance_->InitAsDefaultInstance();
  GazeboModelSDF::default_instance_->InitAsDefaultInstance();
  GetGazeboModelSDF::default_instance_->InitAsDefaultInstance();
  ::google::protobuf::internal::OnShutdown(&protobuf_ShutdownFile_mw_2einternal_2erobotics_2egazebotransport_2eCoSimMsgs_2eproto);
}

// Force AddDescriptors() to be called at static initialization time.
struct StaticDescriptorInitializer_mw_2einternal_2erobotics_2egazebotransport_2eCoSimMsgs_2eproto {
  StaticDescriptorInitializer_mw_2einternal_2erobotics_2egazebotransport_2eCoSimMsgs_2eproto() {
    protobuf_AddDesc_mw_2einternal_2erobotics_2egazebotransport_2eCoSimMsgs_2eproto();
  }
} static_descriptor_initializer_mw_2einternal_2erobotics_2egazebotransport_2eCoSimMsgs_2eproto_;

// ===================================================================

::std::string* PluginVersion::_default_version_ = NULL;
#if !defined(_MSC_VER) || _MSC_VER >= 1900
const int PluginVersion::kVersionFieldNumber;
#endif  // !defined(_MSC_VER) || _MSC_VER >= 1900

PluginVersion::PluginVersion()
  : ::google::protobuf::Message(), _internal_metadata_(NULL) {
  SharedCtor();
  // @@protoc_insertion_point(constructor:mw.internal.robotics.gazebotransport.PluginVersion)
}

void PluginVersion::InitAsDefaultInstance() {
}

PluginVersion::PluginVersion(const PluginVersion& from)
  : ::google::protobuf::Message(),
    _internal_metadata_(NULL) {
  SharedCtor();
  MergeFrom(from);
  // @@protoc_insertion_point(copy_constructor:mw.internal.robotics.gazebotransport.PluginVersion)
}

void PluginVersion::SharedCtor() {
  ::google::protobuf::internal::GetEmptyString();
  _cached_size_ = 0;
  version_.UnsafeSetDefault(_default_version_);
  ::memset(_has_bits_, 0, sizeof(_has_bits_));
}

PluginVersion::~PluginVersion() {
  // @@protoc_insertion_point(destructor:mw.internal.robotics.gazebotransport.PluginVersion)
  SharedDtor();
}

void PluginVersion::SharedDtor() {
  version_.DestroyNoArena(_default_version_);
  if (this != default_instance_) {
  }
}

void PluginVersion::SetCachedSize(int size) const {
  GOOGLE_SAFE_CONCURRENT_WRITES_BEGIN();
  _cached_size_ = size;
  GOOGLE_SAFE_CONCURRENT_WRITES_END();
}
const ::google::protobuf::Descriptor* PluginVersion::descriptor() {
  protobuf_AssignDescriptorsOnce();
  return PluginVersion_descriptor_;
}

const PluginVersion& PluginVersion::default_instance() {
  if (default_instance_ == NULL) protobuf_AddDesc_mw_2einternal_2erobotics_2egazebotransport_2eCoSimMsgs_2eproto();
  return *default_instance_;
}

PluginVersion* PluginVersion::default_instance_ = NULL;

PluginVersion* PluginVersion::New(::google::protobuf::Arena* arena) const {
  PluginVersion* n = new PluginVersion;
  if (arena != NULL) {
    arena->Own(n);
  }
  return n;
}

void PluginVersion::Clear() {
// @@protoc_insertion_point(message_clear_start:mw.internal.robotics.gazebotransport.PluginVersion)
  if (has_version()) {
    version_.ClearToDefaultNoArena(_default_version_);
  }
  ::memset(_has_bits_, 0, sizeof(_has_bits_));
  if (_internal_metadata_.have_unknown_fields()) {
    mutable_unknown_fields()->Clear();
  }
}

bool PluginVersion::MergePartialFromCodedStream(
    ::google::protobuf::io::CodedInputStream* input) {
#define DO_(EXPRESSION) if (!GOOGLE_PREDICT_TRUE(EXPRESSION)) goto failure
  ::google::protobuf::uint32 tag;
  // @@protoc_insertion_point(parse_start:mw.internal.robotics.gazebotransport.PluginVersion)
  for (;;) {
    ::std::pair< ::google::protobuf::uint32, bool> p = input->ReadTagWithCutoff(127);
    tag = p.first;
    if (!p.second) goto handle_unusual;
    switch (::google::protobuf::internal::WireFormatLite::GetTagFieldNumber(tag)) {
      // required string version = 1 [default = "R2021b"];
      case 1: {
        if (tag == 10) {
          DO_(::google::protobuf::internal::WireFormatLite::ReadString(
                input, this->mutable_version()));
          ::google::protobuf::internal::WireFormat::VerifyUTF8StringNamedField(
            this->version().data(), this->version().length(),
            ::google::protobuf::internal::WireFormat::PARSE,
            "mw.internal.robotics.gazebotransport.PluginVersion.version");
        } else {
          goto handle_unusual;
        }
        if (input->ExpectAtEnd()) goto success;
        break;
      }

      default: {
      handle_unusual:
        if (tag == 0 ||
            ::google::protobuf::internal::WireFormatLite::GetTagWireType(tag) ==
            ::google::protobuf::internal::WireFormatLite::WIRETYPE_END_GROUP) {
          goto success;
        }
        DO_(::google::protobuf::internal::WireFormat::SkipField(
              input, tag, mutable_unknown_fields()));
        break;
      }
    }
  }
success:
  // @@protoc_insertion_point(parse_success:mw.internal.robotics.gazebotransport.PluginVersion)
  return true;
failure:
  // @@protoc_insertion_point(parse_failure:mw.internal.robotics.gazebotransport.PluginVersion)
  return false;
#undef DO_
}

void PluginVersion::SerializeWithCachedSizes(
    ::google::protobuf::io::CodedOutputStream* output) const {
  // @@protoc_insertion_point(serialize_start:mw.internal.robotics.gazebotransport.PluginVersion)
  // required string version = 1 [default = "R2021b"];
  if (has_version()) {
    ::google::protobuf::internal::WireFormat::VerifyUTF8StringNamedField(
      this->version().data(), this->version().length(),
      ::google::protobuf::internal::WireFormat::SERIALIZE,
      "mw.internal.robotics.gazebotransport.PluginVersion.version");
    ::google::protobuf::internal::WireFormatLite::WriteStringMaybeAliased(
      1, this->version(), output);
  }

  if (_internal_metadata_.have_unknown_fields()) {
    ::google::protobuf::internal::WireFormat::SerializeUnknownFields(
        unknown_fields(), output);
  }
  // @@protoc_insertion_point(serialize_end:mw.internal.robotics.gazebotransport.PluginVersion)
}

::google::protobuf::uint8* PluginVersion::InternalSerializeWithCachedSizesToArray(
    bool deterministic, ::google::protobuf::uint8* target) const {
  // @@protoc_insertion_point(serialize_to_array_start:mw.internal.robotics.gazebotransport.PluginVersion)
  // required string version = 1 [default = "R2021b"];
  if (has_version()) {
    ::google::protobuf::internal::WireFormat::VerifyUTF8StringNamedField(
      this->version().data(), this->version().length(),
      ::google::protobuf::internal::WireFormat::SERIALIZE,
      "mw.internal.robotics.gazebotransport.PluginVersion.version");
    target =
      ::google::protobuf::internal::WireFormatLite::WriteStringToArray(
        1, this->version(), target);
  }

  if (_internal_metadata_.have_unknown_fields()) {
    target = ::google::protobuf::internal::WireFormat::SerializeUnknownFieldsToArray(
        unknown_fields(), target);
  }
  // @@protoc_insertion_point(serialize_to_array_end:mw.internal.robotics.gazebotransport.PluginVersion)
  return target;
}

int PluginVersion::ByteSize() const {
// @@protoc_insertion_point(message_byte_size_start:mw.internal.robotics.gazebotransport.PluginVersion)
  int total_size = 0;

  // required string version = 1 [default = "R2021b"];
  if (has_version()) {
    total_size += 1 +
      ::google::protobuf::internal::WireFormatLite::StringSize(
        this->version());
  }
  if (_internal_metadata_.have_unknown_fields()) {
    total_size +=
      ::google::protobuf::internal::WireFormat::ComputeUnknownFieldsSize(
        unknown_fields());
  }
  GOOGLE_SAFE_CONCURRENT_WRITES_BEGIN();
  _cached_size_ = total_size;
  GOOGLE_SAFE_CONCURRENT_WRITES_END();
  return total_size;
}

void PluginVersion::MergeFrom(const ::google::protobuf::Message& from) {
// @@protoc_insertion_point(generalized_merge_from_start:mw.internal.robotics.gazebotransport.PluginVersion)
  if (GOOGLE_PREDICT_FALSE(&from == this)) {
    ::google::protobuf::internal::MergeFromFail(__FILE__, __LINE__);
  }
  const PluginVersion* source = 
      ::google::protobuf::internal::DynamicCastToGenerated<const PluginVersion>(
          &from);
  if (source == NULL) {
  // @@protoc_insertion_point(generalized_merge_from_cast_fail:mw.internal.robotics.gazebotransport.PluginVersion)
    ::google::protobuf::internal::ReflectionOps::Merge(from, this);
  } else {
  // @@protoc_insertion_point(generalized_merge_from_cast_success:mw.internal.robotics.gazebotransport.PluginVersion)
    MergeFrom(*source);
  }
}

void PluginVersion::MergeFrom(const PluginVersion& from) {
// @@protoc_insertion_point(class_specific_merge_from_start:mw.internal.robotics.gazebotransport.PluginVersion)
  if (GOOGLE_PREDICT_FALSE(&from == this)) {
    ::google::protobuf::internal::MergeFromFail(__FILE__, __LINE__);
  }
  if (from._has_bits_[0 / 32] & (0xffu << (0 % 32))) {
    if (from.has_version()) {
      set_has_version();
      version_.AssignWithDefault(_default_version_, from.version_);
    }
  }
  if (from._internal_metadata_.have_unknown_fields()) {
    mutable_unknown_fields()->MergeFrom(from.unknown_fields());
  }
}

void PluginVersion::CopyFrom(const ::google::protobuf::Message& from) {
// @@protoc_insertion_point(generalized_copy_from_start:mw.internal.robotics.gazebotransport.PluginVersion)
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

void PluginVersion::CopyFrom(const PluginVersion& from) {
// @@protoc_insertion_point(class_specific_copy_from_start:mw.internal.robotics.gazebotransport.PluginVersion)
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

bool PluginVersion::IsInitialized() const {
  if ((_has_bits_[0] & 0x00000001) != 0x00000001) return false;

  return true;
}

void PluginVersion::Swap(PluginVersion* other) {
  if (other == this) return;
  InternalSwap(other);
}
void PluginVersion::InternalSwap(PluginVersion* other) {
  version_.Swap(&other->version_);
  std::swap(_has_bits_[0], other->_has_bits_[0]);
  _internal_metadata_.Swap(&other->_internal_metadata_);
  std::swap(_cached_size_, other->_cached_size_);
}

::google::protobuf::Metadata PluginVersion::GetMetadata() const {
  protobuf_AssignDescriptorsOnce();
  ::google::protobuf::Metadata metadata;
  metadata.descriptor = PluginVersion_descriptor_;
  metadata.reflection = PluginVersion_reflection_;
  return metadata;
}

#if PROTOBUF_INLINE_NOT_IN_HEADERS
// PluginVersion

// required string version = 1 [default = "R2021b"];
bool PluginVersion::has_version() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
void PluginVersion::set_has_version() {
  _has_bits_[0] |= 0x00000001u;
}
void PluginVersion::clear_has_version() {
  _has_bits_[0] &= ~0x00000001u;
}
void PluginVersion::clear_version() {
  version_.ClearToDefaultNoArena(_default_version_);
  clear_has_version();
}
 const ::std::string& PluginVersion::version() const {
  // @@protoc_insertion_point(field_get:mw.internal.robotics.gazebotransport.PluginVersion.version)
  return version_.GetNoArena(_default_version_);
}
 void PluginVersion::set_version(const ::std::string& value) {
  set_has_version();
  version_.SetNoArena(_default_version_, value);
  // @@protoc_insertion_point(field_set:mw.internal.robotics.gazebotransport.PluginVersion.version)
}
 void PluginVersion::set_version(const char* value) {
  set_has_version();
  version_.SetNoArena(_default_version_, ::std::string(value));
  // @@protoc_insertion_point(field_set_char:mw.internal.robotics.gazebotransport.PluginVersion.version)
}
 void PluginVersion::set_version(const char* value, size_t size) {
  set_has_version();
  version_.SetNoArena(_default_version_,
      ::std::string(reinterpret_cast<const char*>(value), size));
  // @@protoc_insertion_point(field_set_pointer:mw.internal.robotics.gazebotransport.PluginVersion.version)
}
 ::std::string* PluginVersion::mutable_version() {
  set_has_version();
  // @@protoc_insertion_point(field_mutable:mw.internal.robotics.gazebotransport.PluginVersion.version)
  return version_.MutableNoArena(_default_version_);
}
 ::std::string* PluginVersion::release_version() {
  // @@protoc_insertion_point(field_release:mw.internal.robotics.gazebotransport.PluginVersion.version)
  clear_has_version();
  return version_.ReleaseNoArena(_default_version_);
}
 void PluginVersion::set_allocated_version(::std::string* version) {
  if (version != NULL) {
    set_has_version();
  } else {
    clear_has_version();
  }
  version_.SetAllocatedNoArena(_default_version_, version);
  // @@protoc_insertion_point(field_set_allocated:mw.internal.robotics.gazebotransport.PluginVersion.version)
}

#endif  // PROTOBUF_INLINE_NOT_IN_HEADERS

// ===================================================================

#if !defined(_MSC_VER) || _MSC_VER >= 1900
const int Time::kSecondsFieldNumber;
const int Time::kNanoSecondsFieldNumber;
#endif  // !defined(_MSC_VER) || _MSC_VER >= 1900

Time::Time()
  : ::google::protobuf::Message(), _internal_metadata_(NULL) {
  SharedCtor();
  // @@protoc_insertion_point(constructor:mw.internal.robotics.gazebotransport.Time)
}

void Time::InitAsDefaultInstance() {
}

Time::Time(const Time& from)
  : ::google::protobuf::Message(),
    _internal_metadata_(NULL) {
  SharedCtor();
  MergeFrom(from);
  // @@protoc_insertion_point(copy_constructor:mw.internal.robotics.gazebotransport.Time)
}

void Time::SharedCtor() {
  _cached_size_ = 0;
  seconds_ = GOOGLE_ULONGLONG(0);
  nano_seconds_ = GOOGLE_ULONGLONG(0);
  ::memset(_has_bits_, 0, sizeof(_has_bits_));
}

Time::~Time() {
  // @@protoc_insertion_point(destructor:mw.internal.robotics.gazebotransport.Time)
  SharedDtor();
}

void Time::SharedDtor() {
  if (this != default_instance_) {
  }
}

void Time::SetCachedSize(int size) const {
  GOOGLE_SAFE_CONCURRENT_WRITES_BEGIN();
  _cached_size_ = size;
  GOOGLE_SAFE_CONCURRENT_WRITES_END();
}
const ::google::protobuf::Descriptor* Time::descriptor() {
  protobuf_AssignDescriptorsOnce();
  return Time_descriptor_;
}

const Time& Time::default_instance() {
  if (default_instance_ == NULL) protobuf_AddDesc_mw_2einternal_2erobotics_2egazebotransport_2eCoSimMsgs_2eproto();
  return *default_instance_;
}

Time* Time::default_instance_ = NULL;

Time* Time::New(::google::protobuf::Arena* arena) const {
  Time* n = new Time;
  if (arena != NULL) {
    arena->Own(n);
  }
  return n;
}

void Time::Clear() {
// @@protoc_insertion_point(message_clear_start:mw.internal.robotics.gazebotransport.Time)
#if defined(__clang__)
#define ZR_HELPER_(f) \
  _Pragma("clang diagnostic push") \
  _Pragma("clang diagnostic ignored \"-Winvalid-offsetof\"") \
  __builtin_offsetof(Time, f) \
  _Pragma("clang diagnostic pop")
#else
#define ZR_HELPER_(f) reinterpret_cast<char*>(\
  &reinterpret_cast<Time*>(16)->f)
#endif

#define ZR_(first, last) do {\
  ::memset(&first, 0,\
           ZR_HELPER_(last) - ZR_HELPER_(first) + sizeof(last));\
} while (0)

  ZR_(seconds_, nano_seconds_);

#undef ZR_HELPER_
#undef ZR_

  ::memset(_has_bits_, 0, sizeof(_has_bits_));
  if (_internal_metadata_.have_unknown_fields()) {
    mutable_unknown_fields()->Clear();
  }
}

bool Time::MergePartialFromCodedStream(
    ::google::protobuf::io::CodedInputStream* input) {
#define DO_(EXPRESSION) if (!GOOGLE_PREDICT_TRUE(EXPRESSION)) goto failure
  ::google::protobuf::uint32 tag;
  // @@protoc_insertion_point(parse_start:mw.internal.robotics.gazebotransport.Time)
  for (;;) {
    ::std::pair< ::google::protobuf::uint32, bool> p = input->ReadTagWithCutoff(127);
    tag = p.first;
    if (!p.second) goto handle_unusual;
    switch (::google::protobuf::internal::WireFormatLite::GetTagFieldNumber(tag)) {
      // required uint64 seconds = 1;
      case 1: {
        if (tag == 8) {
          DO_((::google::protobuf::internal::WireFormatLite::ReadPrimitive<
                   ::google::protobuf::uint64, ::google::protobuf::internal::WireFormatLite::TYPE_UINT64>(
                 input, &seconds_)));
          set_has_seconds();
        } else {
          goto handle_unusual;
        }
        if (input->ExpectTag(16)) goto parse_nano_seconds;
        break;
      }

      // required uint64 nano_seconds = 2;
      case 2: {
        if (tag == 16) {
         parse_nano_seconds:
          DO_((::google::protobuf::internal::WireFormatLite::ReadPrimitive<
                   ::google::protobuf::uint64, ::google::protobuf::internal::WireFormatLite::TYPE_UINT64>(
                 input, &nano_seconds_)));
          set_has_nano_seconds();
        } else {
          goto handle_unusual;
        }
        if (input->ExpectAtEnd()) goto success;
        break;
      }

      default: {
      handle_unusual:
        if (tag == 0 ||
            ::google::protobuf::internal::WireFormatLite::GetTagWireType(tag) ==
            ::google::protobuf::internal::WireFormatLite::WIRETYPE_END_GROUP) {
          goto success;
        }
        DO_(::google::protobuf::internal::WireFormat::SkipField(
              input, tag, mutable_unknown_fields()));
        break;
      }
    }
  }
success:
  // @@protoc_insertion_point(parse_success:mw.internal.robotics.gazebotransport.Time)
  return true;
failure:
  // @@protoc_insertion_point(parse_failure:mw.internal.robotics.gazebotransport.Time)
  return false;
#undef DO_
}

void Time::SerializeWithCachedSizes(
    ::google::protobuf::io::CodedOutputStream* output) const {
  // @@protoc_insertion_point(serialize_start:mw.internal.robotics.gazebotransport.Time)
  // required uint64 seconds = 1;
  if (has_seconds()) {
    ::google::protobuf::internal::WireFormatLite::WriteUInt64(1, this->seconds(), output);
  }

  // required uint64 nano_seconds = 2;
  if (has_nano_seconds()) {
    ::google::protobuf::internal::WireFormatLite::WriteUInt64(2, this->nano_seconds(), output);
  }

  if (_internal_metadata_.have_unknown_fields()) {
    ::google::protobuf::internal::WireFormat::SerializeUnknownFields(
        unknown_fields(), output);
  }
  // @@protoc_insertion_point(serialize_end:mw.internal.robotics.gazebotransport.Time)
}

::google::protobuf::uint8* Time::InternalSerializeWithCachedSizesToArray(
    bool deterministic, ::google::protobuf::uint8* target) const {
  // @@protoc_insertion_point(serialize_to_array_start:mw.internal.robotics.gazebotransport.Time)
  // required uint64 seconds = 1;
  if (has_seconds()) {
    target = ::google::protobuf::internal::WireFormatLite::WriteUInt64ToArray(1, this->seconds(), target);
  }

  // required uint64 nano_seconds = 2;
  if (has_nano_seconds()) {
    target = ::google::protobuf::internal::WireFormatLite::WriteUInt64ToArray(2, this->nano_seconds(), target);
  }

  if (_internal_metadata_.have_unknown_fields()) {
    target = ::google::protobuf::internal::WireFormat::SerializeUnknownFieldsToArray(
        unknown_fields(), target);
  }
  // @@protoc_insertion_point(serialize_to_array_end:mw.internal.robotics.gazebotransport.Time)
  return target;
}

int Time::RequiredFieldsByteSizeFallback() const {
// @@protoc_insertion_point(required_fields_byte_size_fallback_start:mw.internal.robotics.gazebotransport.Time)
  int total_size = 0;

  if (has_seconds()) {
    // required uint64 seconds = 1;
    total_size += 1 +
      ::google::protobuf::internal::WireFormatLite::UInt64Size(
        this->seconds());
  }

  if (has_nano_seconds()) {
    // required uint64 nano_seconds = 2;
    total_size += 1 +
      ::google::protobuf::internal::WireFormatLite::UInt64Size(
        this->nano_seconds());
  }

  return total_size;
}
int Time::ByteSize() const {
// @@protoc_insertion_point(message_byte_size_start:mw.internal.robotics.gazebotransport.Time)
  int total_size = 0;

  if (((_has_bits_[0] & 0x00000003) ^ 0x00000003) == 0) {  // All required fields are present.
    // required uint64 seconds = 1;
    total_size += 1 +
      ::google::protobuf::internal::WireFormatLite::UInt64Size(
        this->seconds());

    // required uint64 nano_seconds = 2;
    total_size += 1 +
      ::google::protobuf::internal::WireFormatLite::UInt64Size(
        this->nano_seconds());

  } else {
    total_size += RequiredFieldsByteSizeFallback();
  }
  if (_internal_metadata_.have_unknown_fields()) {
    total_size +=
      ::google::protobuf::internal::WireFormat::ComputeUnknownFieldsSize(
        unknown_fields());
  }
  GOOGLE_SAFE_CONCURRENT_WRITES_BEGIN();
  _cached_size_ = total_size;
  GOOGLE_SAFE_CONCURRENT_WRITES_END();
  return total_size;
}

void Time::MergeFrom(const ::google::protobuf::Message& from) {
// @@protoc_insertion_point(generalized_merge_from_start:mw.internal.robotics.gazebotransport.Time)
  if (GOOGLE_PREDICT_FALSE(&from == this)) {
    ::google::protobuf::internal::MergeFromFail(__FILE__, __LINE__);
  }
  const Time* source = 
      ::google::protobuf::internal::DynamicCastToGenerated<const Time>(
          &from);
  if (source == NULL) {
  // @@protoc_insertion_point(generalized_merge_from_cast_fail:mw.internal.robotics.gazebotransport.Time)
    ::google::protobuf::internal::ReflectionOps::Merge(from, this);
  } else {
  // @@protoc_insertion_point(generalized_merge_from_cast_success:mw.internal.robotics.gazebotransport.Time)
    MergeFrom(*source);
  }
}

void Time::MergeFrom(const Time& from) {
// @@protoc_insertion_point(class_specific_merge_from_start:mw.internal.robotics.gazebotransport.Time)
  if (GOOGLE_PREDICT_FALSE(&from == this)) {
    ::google::protobuf::internal::MergeFromFail(__FILE__, __LINE__);
  }
  if (from._has_bits_[0 / 32] & (0xffu << (0 % 32))) {
    if (from.has_seconds()) {
      set_seconds(from.seconds());
    }
    if (from.has_nano_seconds()) {
      set_nano_seconds(from.nano_seconds());
    }
  }
  if (from._internal_metadata_.have_unknown_fields()) {
    mutable_unknown_fields()->MergeFrom(from.unknown_fields());
  }
}

void Time::CopyFrom(const ::google::protobuf::Message& from) {
// @@protoc_insertion_point(generalized_copy_from_start:mw.internal.robotics.gazebotransport.Time)
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

void Time::CopyFrom(const Time& from) {
// @@protoc_insertion_point(class_specific_copy_from_start:mw.internal.robotics.gazebotransport.Time)
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

bool Time::IsInitialized() const {
  if ((_has_bits_[0] & 0x00000003) != 0x00000003) return false;

  return true;
}

void Time::Swap(Time* other) {
  if (other == this) return;
  InternalSwap(other);
}
void Time::InternalSwap(Time* other) {
  std::swap(seconds_, other->seconds_);
  std::swap(nano_seconds_, other->nano_seconds_);
  std::swap(_has_bits_[0], other->_has_bits_[0]);
  _internal_metadata_.Swap(&other->_internal_metadata_);
  std::swap(_cached_size_, other->_cached_size_);
}

::google::protobuf::Metadata Time::GetMetadata() const {
  protobuf_AssignDescriptorsOnce();
  ::google::protobuf::Metadata metadata;
  metadata.descriptor = Time_descriptor_;
  metadata.reflection = Time_reflection_;
  return metadata;
}

#if PROTOBUF_INLINE_NOT_IN_HEADERS
// Time

// required uint64 seconds = 1;
bool Time::has_seconds() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
void Time::set_has_seconds() {
  _has_bits_[0] |= 0x00000001u;
}
void Time::clear_has_seconds() {
  _has_bits_[0] &= ~0x00000001u;
}
void Time::clear_seconds() {
  seconds_ = GOOGLE_ULONGLONG(0);
  clear_has_seconds();
}
 ::google::protobuf::uint64 Time::seconds() const {
  // @@protoc_insertion_point(field_get:mw.internal.robotics.gazebotransport.Time.seconds)
  return seconds_;
}
 void Time::set_seconds(::google::protobuf::uint64 value) {
  set_has_seconds();
  seconds_ = value;
  // @@protoc_insertion_point(field_set:mw.internal.robotics.gazebotransport.Time.seconds)
}

// required uint64 nano_seconds = 2;
bool Time::has_nano_seconds() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
void Time::set_has_nano_seconds() {
  _has_bits_[0] |= 0x00000002u;
}
void Time::clear_has_nano_seconds() {
  _has_bits_[0] &= ~0x00000002u;
}
void Time::clear_nano_seconds() {
  nano_seconds_ = GOOGLE_ULONGLONG(0);
  clear_has_nano_seconds();
}
 ::google::protobuf::uint64 Time::nano_seconds() const {
  // @@protoc_insertion_point(field_get:mw.internal.robotics.gazebotransport.Time.nano_seconds)
  return nano_seconds_;
}
 void Time::set_nano_seconds(::google::protobuf::uint64 value) {
  set_has_nano_seconds();
  nano_seconds_ = value;
  // @@protoc_insertion_point(field_set:mw.internal.robotics.gazebotransport.Time.nano_seconds)
}

#endif  // PROTOBUF_INLINE_NOT_IN_HEADERS

// ===================================================================

const ::google::protobuf::EnumDescriptor* PacketHeader_MsgID_descriptor() {
  protobuf_AssignDescriptorsOnce();
  return PacketHeader_MsgID_descriptor_;
}
bool PacketHeader_MsgID_IsValid(int value) {
  switch(value) {
    case 0:
    case 1:
    case 2:
    case 3:
    case 4:
    case 5:
    case 6:
    case 7:
    case 8:
    case 9:
    case 10:
    case 11:
    case 12:
    case 13:
    case 14:
    case 15:
    case 16:
    case 17:
    case 18:
    case 19:
    case 20:
    case 21:
    case 22:
    case 23:
    case 24:
    case 25:
    case 26:
    case 27:
    case 28:
    case 29:
    case 30:
    case 31:
    case 32:
    case 33:
    case 34:
    case 35:
    case 36:
    case 37:
    case 38:
    case 39:
    case 40:
    case 41:
    case 42:
      return true;
    default:
      return false;
  }
}

#if !defined(_MSC_VER) || _MSC_VER >= 1900
const PacketHeader_MsgID PacketHeader::STATUS;
const PacketHeader_MsgID PacketHeader::STEP_SIMULATION;
const PacketHeader_MsgID PacketHeader::RESET_SIMULATION;
const PacketHeader_MsgID PacketHeader::IMAGE;
const PacketHeader_MsgID PacketHeader::REQUEST_IMAGE;
const PacketHeader_MsgID PacketHeader::REQUEST_COSIM;
const PacketHeader_MsgID PacketHeader::STOP_COSIM;
const PacketHeader_MsgID PacketHeader::GET_GROUND_TRUTH_WORLD_POSE;
const PacketHeader_MsgID PacketHeader::POSE;
const PacketHeader_MsgID PacketHeader::STOP_SIMULATION;
const PacketHeader_MsgID PacketHeader::LASER_DATA;
const PacketHeader_MsgID PacketHeader::REQUEST_LASER;
const PacketHeader_MsgID PacketHeader::IMU_DATA;
const PacketHeader_MsgID PacketHeader::REQUEST_IMU;
const PacketHeader_MsgID PacketHeader::SUBSCRIBE_IMAGE;
const PacketHeader_MsgID PacketHeader::SUBSCRIBE_LASER;
const PacketHeader_MsgID PacketHeader::SUBSCRIBE_IMU;
const PacketHeader_MsgID PacketHeader::APPLY_JOINT_TORQUE;
const PacketHeader_MsgID PacketHeader::GET_POSE;
const PacketHeader_MsgID PacketHeader::GET_TOPIC_LIST;
const PacketHeader_MsgID PacketHeader::TOPIC_LIST;
const PacketHeader_MsgID PacketHeader::GET_MODEL_INFO;
const PacketHeader_MsgID PacketHeader::MODEL_INFO;
const PacketHeader_MsgID PacketHeader::APPLY_LINK_WRENCH;
const PacketHeader_MsgID PacketHeader::MAX_STEP_SIZE;
const PacketHeader_MsgID PacketHeader::CUSTOM_MESSAGE_SUBSCRIBER;
const PacketHeader_MsgID PacketHeader::CUSTOM_MESSAGE_PUBLISHER;
const PacketHeader_MsgID PacketHeader::INIT_CUSTOM_MESSAGE_PUBLISHER;
const PacketHeader_MsgID PacketHeader::INIT_CUSTOM_MESSAGE_SUBSCRIBER;
const PacketHeader_MsgID PacketHeader::SET_JOINT_POSITION;
const PacketHeader_MsgID PacketHeader::SET_JOINT_VELOCITY;
const PacketHeader_MsgID PacketHeader::GET_JOINT_STATE;
const PacketHeader_MsgID PacketHeader::JOINT_STATE;
const PacketHeader_MsgID PacketHeader::SET_LINK_WORLD_POSE;
const PacketHeader_MsgID PacketHeader::SET_LINK_LINEAR_VELOCITY;
const PacketHeader_MsgID PacketHeader::SET_LINK_ANGULAR_VELOCITY;
const PacketHeader_MsgID PacketHeader::GET_LINK_STATE;
const PacketHeader_MsgID PacketHeader::LINK_STATE;
const PacketHeader_MsgID PacketHeader::GAZEBO_MODEL;
const PacketHeader_MsgID PacketHeader::SET_GAZEBO_MODEL_PARAM;
const PacketHeader_MsgID PacketHeader::GET_GAZEBO_MODEL_PARAM;
const PacketHeader_MsgID PacketHeader::GAZEBO_MODEL_SDF;
const PacketHeader_MsgID PacketHeader::GET_GAZEBO_MODEL_SDF;
const PacketHeader_MsgID PacketHeader::MsgID_MIN;
const PacketHeader_MsgID PacketHeader::MsgID_MAX;
const int PacketHeader::MsgID_ARRAYSIZE;
#endif  // !defined(_MSC_VER) || _MSC_VER >= 1900
#if !defined(_MSC_VER) || _MSC_VER >= 1900
const int PacketHeader::kIdFieldNumber;
const int PacketHeader::kTimeStampFieldNumber;
#endif  // !defined(_MSC_VER) || _MSC_VER >= 1900

PacketHeader::PacketHeader()
  : ::google::protobuf::Message(), _internal_metadata_(NULL) {
  SharedCtor();
  // @@protoc_insertion_point(constructor:mw.internal.robotics.gazebotransport.PacketHeader)
}

void PacketHeader::InitAsDefaultInstance() {
  time_stamp_ = const_cast< ::mw::internal::robotics::gazebotransport::Time*>(&::mw::internal::robotics::gazebotransport::Time::default_instance());
}

PacketHeader::PacketHeader(const PacketHeader& from)
  : ::google::protobuf::Message(),
    _internal_metadata_(NULL) {
  SharedCtor();
  MergeFrom(from);
  // @@protoc_insertion_point(copy_constructor:mw.internal.robotics.gazebotransport.PacketHeader)
}

void PacketHeader::SharedCtor() {
  _cached_size_ = 0;
  id_ = 0;
  time_stamp_ = NULL;
  ::memset(_has_bits_, 0, sizeof(_has_bits_));
}

PacketHeader::~PacketHeader() {
  // @@protoc_insertion_point(destructor:mw.internal.robotics.gazebotransport.PacketHeader)
  SharedDtor();
}

void PacketHeader::SharedDtor() {
  if (this != default_instance_) {
    delete time_stamp_;
  }
}

void PacketHeader::SetCachedSize(int size) const {
  GOOGLE_SAFE_CONCURRENT_WRITES_BEGIN();
  _cached_size_ = size;
  GOOGLE_SAFE_CONCURRENT_WRITES_END();
}
const ::google::protobuf::Descriptor* PacketHeader::descriptor() {
  protobuf_AssignDescriptorsOnce();
  return PacketHeader_descriptor_;
}

const PacketHeader& PacketHeader::default_instance() {
  if (default_instance_ == NULL) protobuf_AddDesc_mw_2einternal_2erobotics_2egazebotransport_2eCoSimMsgs_2eproto();
  return *default_instance_;
}

PacketHeader* PacketHeader::default_instance_ = NULL;

PacketHeader* PacketHeader::New(::google::protobuf::Arena* arena) const {
  PacketHeader* n = new PacketHeader;
  if (arena != NULL) {
    arena->Own(n);
  }
  return n;
}

void PacketHeader::Clear() {
// @@protoc_insertion_point(message_clear_start:mw.internal.robotics.gazebotransport.PacketHeader)
  if (_has_bits_[0 / 32] & 3u) {
    id_ = 0;
    if (has_time_stamp()) {
      if (time_stamp_ != NULL) time_stamp_->::mw::internal::robotics::gazebotransport::Time::Clear();
    }
  }
  ::memset(_has_bits_, 0, sizeof(_has_bits_));
  if (_internal_metadata_.have_unknown_fields()) {
    mutable_unknown_fields()->Clear();
  }
}

bool PacketHeader::MergePartialFromCodedStream(
    ::google::protobuf::io::CodedInputStream* input) {
#define DO_(EXPRESSION) if (!GOOGLE_PREDICT_TRUE(EXPRESSION)) goto failure
  ::google::protobuf::uint32 tag;
  // @@protoc_insertion_point(parse_start:mw.internal.robotics.gazebotransport.PacketHeader)
  for (;;) {
    ::std::pair< ::google::protobuf::uint32, bool> p = input->ReadTagWithCutoff(127);
    tag = p.first;
    if (!p.second) goto handle_unusual;
    switch (::google::protobuf::internal::WireFormatLite::GetTagFieldNumber(tag)) {
      // required .mw.internal.robotics.gazebotransport.PacketHeader.MsgID id = 1;
      case 1: {
        if (tag == 8) {
          int value;
          DO_((::google::protobuf::internal::WireFormatLite::ReadPrimitive<
                   int, ::google::protobuf::internal::WireFormatLite::TYPE_ENUM>(
                 input, &value)));
          if (::mw::internal::robotics::gazebotransport::PacketHeader_MsgID_IsValid(value)) {
            set_id(static_cast< ::mw::internal::robotics::gazebotransport::PacketHeader_MsgID >(value));
          } else {
            mutable_unknown_fields()->AddVarint(1, value);
          }
        } else {
          goto handle_unusual;
        }
        if (input->ExpectTag(18)) goto parse_time_stamp;
        break;
      }

      // required .mw.internal.robotics.gazebotransport.Time time_stamp = 2;
      case 2: {
        if (tag == 18) {
         parse_time_stamp:
          DO_(::google::protobuf::internal::WireFormatLite::ReadMessageNoVirtual(
               input, mutable_time_stamp()));
        } else {
          goto handle_unusual;
        }
        if (input->ExpectAtEnd()) goto success;
        break;
      }

      default: {
      handle_unusual:
        if (tag == 0 ||
            ::google::protobuf::internal::WireFormatLite::GetTagWireType(tag) ==
            ::google::protobuf::internal::WireFormatLite::WIRETYPE_END_GROUP) {
          goto success;
        }
        DO_(::google::protobuf::internal::WireFormat::SkipField(
              input, tag, mutable_unknown_fields()));
        break;
      }
    }
  }
success:
  // @@protoc_insertion_point(parse_success:mw.internal.robotics.gazebotransport.PacketHeader)
  return true;
failure:
  // @@protoc_insertion_point(parse_failure:mw.internal.robotics.gazebotransport.PacketHeader)
  return false;
#undef DO_
}

void PacketHeader::SerializeWithCachedSizes(
    ::google::protobuf::io::CodedOutputStream* output) const {
  // @@protoc_insertion_point(serialize_start:mw.internal.robotics.gazebotransport.PacketHeader)
  // required .mw.internal.robotics.gazebotransport.PacketHeader.MsgID id = 1;
  if (has_id()) {
    ::google::protobuf::internal::WireFormatLite::WriteEnum(
      1, this->id(), output);
  }

  // required .mw.internal.robotics.gazebotransport.Time time_stamp = 2;
  if (has_time_stamp()) {
    ::google::protobuf::internal::WireFormatLite::WriteMessageMaybeToArray(
      2, *this->time_stamp_, output);
  }

  if (_internal_metadata_.have_unknown_fields()) {
    ::google::protobuf::internal::WireFormat::SerializeUnknownFields(
        unknown_fields(), output);
  }
  // @@protoc_insertion_point(serialize_end:mw.internal.robotics.gazebotransport.PacketHeader)
}

::google::protobuf::uint8* PacketHeader::InternalSerializeWithCachedSizesToArray(
    bool deterministic, ::google::protobuf::uint8* target) const {
  // @@protoc_insertion_point(serialize_to_array_start:mw.internal.robotics.gazebotransport.PacketHeader)
  // required .mw.internal.robotics.gazebotransport.PacketHeader.MsgID id = 1;
  if (has_id()) {
    target = ::google::protobuf::internal::WireFormatLite::WriteEnumToArray(
      1, this->id(), target);
  }

  // required .mw.internal.robotics.gazebotransport.Time time_stamp = 2;
  if (has_time_stamp()) {
    target = ::google::protobuf::internal::WireFormatLite::
      InternalWriteMessageNoVirtualToArray(
        2, *this->time_stamp_, false, target);
  }

  if (_internal_metadata_.have_unknown_fields()) {
    target = ::google::protobuf::internal::WireFormat::SerializeUnknownFieldsToArray(
        unknown_fields(), target);
  }
  // @@protoc_insertion_point(serialize_to_array_end:mw.internal.robotics.gazebotransport.PacketHeader)
  return target;
}

int PacketHeader::RequiredFieldsByteSizeFallback() const {
// @@protoc_insertion_point(required_fields_byte_size_fallback_start:mw.internal.robotics.gazebotransport.PacketHeader)
  int total_size = 0;

  if (has_id()) {
    // required .mw.internal.robotics.gazebotransport.PacketHeader.MsgID id = 1;
    total_size += 1 +
      ::google::protobuf::internal::WireFormatLite::EnumSize(this->id());
  }

  if (has_time_stamp()) {
    // required .mw.internal.robotics.gazebotransport.Time time_stamp = 2;
    total_size += 1 +
      ::google::protobuf::internal::WireFormatLite::MessageSizeNoVirtual(
        *this->time_stamp_);
  }

  return total_size;
}
int PacketHeader::ByteSize() const {
// @@protoc_insertion_point(message_byte_size_start:mw.internal.robotics.gazebotransport.PacketHeader)
  int total_size = 0;

  if (((_has_bits_[0] & 0x00000003) ^ 0x00000003) == 0) {  // All required fields are present.
    // required .mw.internal.robotics.gazebotransport.PacketHeader.MsgID id = 1;
    total_size += 1 +
      ::google::protobuf::internal::WireFormatLite::EnumSize(this->id());

    // required .mw.internal.robotics.gazebotransport.Time time_stamp = 2;
    total_size += 1 +
      ::google::protobuf::internal::WireFormatLite::MessageSizeNoVirtual(
        *this->time_stamp_);

  } else {
    total_size += RequiredFieldsByteSizeFallback();
  }
  if (_internal_metadata_.have_unknown_fields()) {
    total_size +=
      ::google::protobuf::internal::WireFormat::ComputeUnknownFieldsSize(
        unknown_fields());
  }
  GOOGLE_SAFE_CONCURRENT_WRITES_BEGIN();
  _cached_size_ = total_size;
  GOOGLE_SAFE_CONCURRENT_WRITES_END();
  return total_size;
}

void PacketHeader::MergeFrom(const ::google::protobuf::Message& from) {
// @@protoc_insertion_point(generalized_merge_from_start:mw.internal.robotics.gazebotransport.PacketHeader)
  if (GOOGLE_PREDICT_FALSE(&from == this)) {
    ::google::protobuf::internal::MergeFromFail(__FILE__, __LINE__);
  }
  const PacketHeader* source = 
      ::google::protobuf::internal::DynamicCastToGenerated<const PacketHeader>(
          &from);
  if (source == NULL) {
  // @@protoc_insertion_point(generalized_merge_from_cast_fail:mw.internal.robotics.gazebotransport.PacketHeader)
    ::google::protobuf::internal::ReflectionOps::Merge(from, this);
  } else {
  // @@protoc_insertion_point(generalized_merge_from_cast_success:mw.internal.robotics.gazebotransport.PacketHeader)
    MergeFrom(*source);
  }
}

void PacketHeader::MergeFrom(const PacketHeader& from) {
// @@protoc_insertion_point(class_specific_merge_from_start:mw.internal.robotics.gazebotransport.PacketHeader)
  if (GOOGLE_PREDICT_FALSE(&from == this)) {
    ::google::protobuf::internal::MergeFromFail(__FILE__, __LINE__);
  }
  if (from._has_bits_[0 / 32] & (0xffu << (0 % 32))) {
    if (from.has_id()) {
      set_id(from.id());
    }
    if (from.has_time_stamp()) {
      mutable_time_stamp()->::mw::internal::robotics::gazebotransport::Time::MergeFrom(from.time_stamp());
    }
  }
  if (from._internal_metadata_.have_unknown_fields()) {
    mutable_unknown_fields()->MergeFrom(from.unknown_fields());
  }
}

void PacketHeader::CopyFrom(const ::google::protobuf::Message& from) {
// @@protoc_insertion_point(generalized_copy_from_start:mw.internal.robotics.gazebotransport.PacketHeader)
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

void PacketHeader::CopyFrom(const PacketHeader& from) {
// @@protoc_insertion_point(class_specific_copy_from_start:mw.internal.robotics.gazebotransport.PacketHeader)
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

bool PacketHeader::IsInitialized() const {
  if ((_has_bits_[0] & 0x00000003) != 0x00000003) return false;

  if (has_time_stamp()) {
    if (!this->time_stamp_->IsInitialized()) return false;
  }
  return true;
}

void PacketHeader::Swap(PacketHeader* other) {
  if (other == this) return;
  InternalSwap(other);
}
void PacketHeader::InternalSwap(PacketHeader* other) {
  std::swap(id_, other->id_);
  std::swap(time_stamp_, other->time_stamp_);
  std::swap(_has_bits_[0], other->_has_bits_[0]);
  _internal_metadata_.Swap(&other->_internal_metadata_);
  std::swap(_cached_size_, other->_cached_size_);
}

::google::protobuf::Metadata PacketHeader::GetMetadata() const {
  protobuf_AssignDescriptorsOnce();
  ::google::protobuf::Metadata metadata;
  metadata.descriptor = PacketHeader_descriptor_;
  metadata.reflection = PacketHeader_reflection_;
  return metadata;
}

#if PROTOBUF_INLINE_NOT_IN_HEADERS
// PacketHeader

// required .mw.internal.robotics.gazebotransport.PacketHeader.MsgID id = 1;
bool PacketHeader::has_id() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
void PacketHeader::set_has_id() {
  _has_bits_[0] |= 0x00000001u;
}
void PacketHeader::clear_has_id() {
  _has_bits_[0] &= ~0x00000001u;
}
void PacketHeader::clear_id() {
  id_ = 0;
  clear_has_id();
}
 ::mw::internal::robotics::gazebotransport::PacketHeader_MsgID PacketHeader::id() const {
  // @@protoc_insertion_point(field_get:mw.internal.robotics.gazebotransport.PacketHeader.id)
  return static_cast< ::mw::internal::robotics::gazebotransport::PacketHeader_MsgID >(id_);
}
 void PacketHeader::set_id(::mw::internal::robotics::gazebotransport::PacketHeader_MsgID value) {
  assert(::mw::internal::robotics::gazebotransport::PacketHeader_MsgID_IsValid(value));
  set_has_id();
  id_ = value;
  // @@protoc_insertion_point(field_set:mw.internal.robotics.gazebotransport.PacketHeader.id)
}

// required .mw.internal.robotics.gazebotransport.Time time_stamp = 2;
bool PacketHeader::has_time_stamp() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
void PacketHeader::set_has_time_stamp() {
  _has_bits_[0] |= 0x00000002u;
}
void PacketHeader::clear_has_time_stamp() {
  _has_bits_[0] &= ~0x00000002u;
}
void PacketHeader::clear_time_stamp() {
  if (time_stamp_ != NULL) time_stamp_->::mw::internal::robotics::gazebotransport::Time::Clear();
  clear_has_time_stamp();
}
const ::mw::internal::robotics::gazebotransport::Time& PacketHeader::time_stamp() const {
  // @@protoc_insertion_point(field_get:mw.internal.robotics.gazebotransport.PacketHeader.time_stamp)
  return time_stamp_ != NULL ? *time_stamp_ : *default_instance_->time_stamp_;
}
::mw::internal::robotics::gazebotransport::Time* PacketHeader::mutable_time_stamp() {
  set_has_time_stamp();
  if (time_stamp_ == NULL) {
    time_stamp_ = new ::mw::internal::robotics::gazebotransport::Time;
  }
  // @@protoc_insertion_point(field_mutable:mw.internal.robotics.gazebotransport.PacketHeader.time_stamp)
  return time_stamp_;
}
::mw::internal::robotics::gazebotransport::Time* PacketHeader::release_time_stamp() {
  // @@protoc_insertion_point(field_release:mw.internal.robotics.gazebotransport.PacketHeader.time_stamp)
  clear_has_time_stamp();
  ::mw::internal::robotics::gazebotransport::Time* temp = time_stamp_;
  time_stamp_ = NULL;
  return temp;
}
void PacketHeader::set_allocated_time_stamp(::mw::internal::robotics::gazebotransport::Time* time_stamp) {
  delete time_stamp_;
  time_stamp_ = time_stamp;
  if (time_stamp) {
    set_has_time_stamp();
  } else {
    clear_has_time_stamp();
  }
  // @@protoc_insertion_point(field_set_allocated:mw.internal.robotics.gazebotransport.PacketHeader.time_stamp)
}

#endif  // PROTOBUF_INLINE_NOT_IN_HEADERS

// ===================================================================

const ::google::protobuf::EnumDescriptor* Packet_CoSimError_descriptor() {
  protobuf_AssignDescriptorsOnce();
  return Packet_CoSimError_descriptor_;
}
bool Packet_CoSimError_IsValid(int value) {
  switch(value) {
    case 0:
    case 1:
    case 2:
    case 3:
    case 4:
    case 5:
    case 6:
    case 7:
    case 8:
    case 9:
    case 10:
    case 11:
    case 12:
    case 13:
    case 14:
    case 15:
    case 16:
    case 17:
    case 18:
    case 19:
    case 20:
    case 21:
      return true;
    default:
      return false;
  }
}

#if !defined(_MSC_VER) || _MSC_VER >= 1900
const Packet_CoSimError Packet::NONE;
const Packet_CoSimError Packet::STEP_FAILED;
const Packet_CoSimError Packet::MSG_INVALID;
const Packet_CoSimError Packet::SOCKET_FAILED;
const Packet_CoSimError Packet::RESET_FAILED;
const Packet_CoSimError Packet::COSIM_FAILED;
const Packet_CoSimError Packet::STOP_COSIM_FAILED;
const Packet_CoSimError Packet::GET_GROUND_TRUTH_WORLD_POSE_FAILED;
const Packet_CoSimError Packet::RESET_TIME_SCENE_FAILED;
const Packet_CoSimError Packet::RESET_TIME_FAILED;
const Packet_CoSimError Packet::STOP_FAILED;
const Packet_CoSimError Packet::FORCE_TYPE_INVALID;
const Packet_CoSimError Packet::MODEL_NAME_INVALID;
const Packet_CoSimError Packet::LINK_NAME_INVALID;
const Packet_CoSimError Packet::JOINT_NAME_INVALID;
const Packet_CoSimError Packet::TOPIC_NAME_INVALID;
const Packet_CoSimError Packet::TORQUE_TYPE_INVALID;
const Packet_CoSimError Packet::MAX_STEP_SIZE_ERROR;
const Packet_CoSimError Packet::CUSTOM_MESSAGE_INVALID;
const Packet_CoSimError Packet::MESSAGE_TYPE_INVALID;
const Packet_CoSimError Packet::JOINT_AXIS_NONE;
const Packet_CoSimError Packet::INVALID_JOINT_AXIS;
const Packet_CoSimError Packet::CoSimError_MIN;
const Packet_CoSimError Packet::CoSimError_MAX;
const int Packet::CoSimError_ARRAYSIZE;
#endif  // !defined(_MSC_VER) || _MSC_VER >= 1900
#if !defined(_MSC_VER) || _MSC_VER >= 1900
const int Packet::kHeaderFieldNumber;
const int Packet::kStatusFieldNumber;
const int Packet::kStepSimulationFieldNumber;
const int Packet::kResetSimulationFieldNumber;
const int Packet::kImageFieldNumber;
const int Packet::kRequestImageFieldNumber;
const int Packet::kRequestCosimFieldNumber;
const int Packet::kStopCosimFieldNumber;
const int Packet::kGetGroundTruthWorldPoseFieldNumber;
const int Packet::kPoseFieldNumber;
const int Packet::kStopSimulationFieldNumber;
const int Packet::kLaserDataFieldNumber;
const int Packet::kRequestLaserFieldNumber;
const int Packet::kImuDataFieldNumber;
const int Packet::kRequestImuFieldNumber;
const int Packet::kSubscribeImageFieldNumber;
const int Packet::kSubscribeLaserFieldNumber;
const int Packet::kSubscribeImuFieldNumber;
const int Packet::kApplyJointTorqueFieldNumber;
const int Packet::kGetPoseFieldNumber;
const int Packet::kGetTopicListFieldNumber;
const int Packet::kTopicListFieldNumber;
const int Packet::kGetModelInfoFieldNumber;
const int Packet::kModelInfoFieldNumber;
const int Packet::kApplyLinkWrenchFieldNumber;
const int Packet::kMaxStepSizeFieldNumber;
const int Packet::kCustomMessageSupportFieldNumber;
const int Packet::kInitCustomPublisherFieldNumber;
const int Packet::kInitCustomSubscriberFieldNumber;
const int Packet::kRequestCustomMessageSupportFieldNumber;
const int Packet::kSetJointPositionFieldNumber;
const int Packet::kSetJointVelocityFieldNumber;
const int Packet::kGetJointStateFieldNumber;
const int Packet::kJointStateFieldNumber;
const int Packet::kSetLinkWorldPoseFieldNumber;
const int Packet::kSetLinkLinearVelocityFieldNumber;
const int Packet::kSetLinkAngularVelocityFieldNumber;
const int Packet::kGetLinkStateFieldNumber;
const int Packet::kLinkStateFieldNumber;
const int Packet::kGazeboModelFieldNumber;
const int Packet::kGetGazeboModelParamFieldNumber;
const int Packet::kGazeboModelSdfFieldNumber;
const int Packet::kGetGazeboModelSdfFieldNumber;
const int Packet::kErrorMessageFieldNumber;
#endif  // !defined(_MSC_VER) || _MSC_VER >= 1900

Packet::Packet()
  : ::google::protobuf::Message(), _internal_metadata_(NULL) {
  SharedCtor();
  // @@protoc_insertion_point(constructor:mw.internal.robotics.gazebotransport.Packet)
}

void Packet::InitAsDefaultInstance() {
  header_ = const_cast< ::mw::internal::robotics::gazebotransport::PacketHeader*>(&::mw::internal::robotics::gazebotransport::PacketHeader::default_instance());
  Packet_default_oneof_instance_->status_ = 0;
  Packet_default_oneof_instance_->step_simulation_ = const_cast< ::mw::internal::robotics::gazebotransport::StepSimulation*>(&::mw::internal::robotics::gazebotransport::StepSimulation::default_instance());
  Packet_default_oneof_instance_->reset_simulation_ = const_cast< ::mw::internal::robotics::gazebotransport::ResetSimulation*>(&::mw::internal::robotics::gazebotransport::ResetSimulation::default_instance());
  Packet_default_oneof_instance_->image_ = const_cast< ::mw::internal::robotics::gazebotransport::Image*>(&::mw::internal::robotics::gazebotransport::Image::default_instance());
  Packet_default_oneof_instance_->request_image_ = const_cast< ::mw::internal::robotics::gazebotransport::RequestImage*>(&::mw::internal::robotics::gazebotransport::RequestImage::default_instance());
  Packet_default_oneof_instance_->request_cosim_ = const_cast< ::mw::internal::robotics::gazebotransport::RequestCoSim*>(&::mw::internal::robotics::gazebotransport::RequestCoSim::default_instance());
  Packet_default_oneof_instance_->stop_cosim_ = const_cast< ::mw::internal::robotics::gazebotransport::StopCoSim*>(&::mw::internal::robotics::gazebotransport::StopCoSim::default_instance());
  Packet_default_oneof_instance_->get_ground_truth_world_pose_ = const_cast< ::mw::internal::robotics::gazebotransport::GetGroundTruthWorldPose*>(&::mw::internal::robotics::gazebotransport::GetGroundTruthWorldPose::default_instance());
  Packet_default_oneof_instance_->pose_ = const_cast< ::mw::internal::robotics::gazebotransport::Pose*>(&::mw::internal::robotics::gazebotransport::Pose::default_instance());
  Packet_default_oneof_instance_->stop_simulation_ = const_cast< ::mw::internal::robotics::gazebotransport::StopSimulation*>(&::mw::internal::robotics::gazebotransport::StopSimulation::default_instance());
  Packet_default_oneof_instance_->laser_data_ = const_cast< ::mw::internal::robotics::gazebotransport::LaserData*>(&::mw::internal::robotics::gazebotransport::LaserData::default_instance());
  Packet_default_oneof_instance_->request_laser_ = const_cast< ::mw::internal::robotics::gazebotransport::RequestLaser*>(&::mw::internal::robotics::gazebotransport::RequestLaser::default_instance());
  Packet_default_oneof_instance_->imu_data_ = const_cast< ::mw::internal::robotics::gazebotransport::ImuData*>(&::mw::internal::robotics::gazebotransport::ImuData::default_instance());
  Packet_default_oneof_instance_->request_imu_ = const_cast< ::mw::internal::robotics::gazebotransport::RequestImu*>(&::mw::internal::robotics::gazebotransport::RequestImu::default_instance());
  Packet_default_oneof_instance_->subscribe_image_ = const_cast< ::mw::internal::robotics::gazebotransport::SubscribeImage*>(&::mw::internal::robotics::gazebotransport::SubscribeImage::default_instance());
  Packet_default_oneof_instance_->subscribe_laser_ = const_cast< ::mw::internal::robotics::gazebotransport::SubscribeLaser*>(&::mw::internal::robotics::gazebotransport::SubscribeLaser::default_instance());
  Packet_default_oneof_instance_->subscribe_imu_ = const_cast< ::mw::internal::robotics::gazebotransport::SubscribeImu*>(&::mw::internal::robotics::gazebotransport::SubscribeImu::default_instance());
  Packet_default_oneof_instance_->apply_joint_torque_ = const_cast< ::mw::internal::robotics::gazebotransport::ApplyJointTorque*>(&::mw::internal::robotics::gazebotransport::ApplyJointTorque::default_instance());
  Packet_default_oneof_instance_->get_pose_ = const_cast< ::mw::internal::robotics::gazebotransport::GetPose*>(&::mw::internal::robotics::gazebotransport::GetPose::default_instance());
  Packet_default_oneof_instance_->get_topic_list_ = const_cast< ::mw::internal::robotics::gazebotransport::GetTopicList*>(&::mw::internal::robotics::gazebotransport::GetTopicList::default_instance());
  Packet_default_oneof_instance_->topic_list_ = const_cast< ::mw::internal::robotics::gazebotransport::TopicList*>(&::mw::internal::robotics::gazebotransport::TopicList::default_instance());
  Packet_default_oneof_instance_->get_model_info_ = const_cast< ::mw::internal::robotics::gazebotransport::GetModelInfo*>(&::mw::internal::robotics::gazebotransport::GetModelInfo::default_instance());
  Packet_default_oneof_instance_->model_info_ = const_cast< ::mw::internal::robotics::gazebotransport::ModelInfo*>(&::mw::internal::robotics::gazebotransport::ModelInfo::default_instance());
  Packet_default_oneof_instance_->apply_link_wrench_ = const_cast< ::mw::internal::robotics::gazebotransport::ApplyLinkWrench*>(&::mw::internal::robotics::gazebotransport::ApplyLinkWrench::default_instance());
  Packet_default_oneof_instance_->max_step_size_ = const_cast< ::mw::internal::robotics::gazebotransport::MaxStepSize*>(&::mw::internal::robotics::gazebotransport::MaxStepSize::default_instance());
  Packet_default_oneof_instance_->custom_message_support_ = const_cast< ::mw::internal::robotics::gazebotransport::CustomMessageSupport*>(&::mw::internal::robotics::gazebotransport::CustomMessageSupport::default_instance());
  Packet_default_oneof_instance_->init_custom_publisher_ = const_cast< ::mw::internal::robotics::gazebotransport::InitCustomPublisher*>(&::mw::internal::robotics::gazebotransport::InitCustomPublisher::default_instance());
  Packet_default_oneof_instance_->init_custom_subscriber_ = const_cast< ::mw::internal::robotics::gazebotransport::InitCustomSubscriber*>(&::mw::internal::robotics::gazebotransport::InitCustomSubscriber::default_instance());
  Packet_default_oneof_instance_->request_custom_message_support_ = const_cast< ::mw::internal::robotics::gazebotransport::RequestCustomMessageSupport*>(&::mw::internal::robotics::gazebotransport::RequestCustomMessageSupport::default_instance());
  Packet_default_oneof_instance_->set_joint_position_ = const_cast< ::mw::internal::robotics::gazebotransport::SetJointPosition*>(&::mw::internal::robotics::gazebotransport::SetJointPosition::default_instance());
  Packet_default_oneof_instance_->set_joint_velocity_ = const_cast< ::mw::internal::robotics::gazebotransport::SetJointVelocity*>(&::mw::internal::robotics::gazebotransport::SetJointVelocity::default_instance());
  Packet_default_oneof_instance_->get_joint_state_ = const_cast< ::mw::internal::robotics::gazebotransport::GetJointState*>(&::mw::internal::robotics::gazebotransport::GetJointState::default_instance());
  Packet_default_oneof_instance_->joint_state_ = const_cast< ::mw::internal::robotics::gazebotransport::JointState*>(&::mw::internal::robotics::gazebotransport::JointState::default_instance());
  Packet_default_oneof_instance_->set_link_world_pose_ = const_cast< ::mw::internal::robotics::gazebotransport::SetLinkWorldPose*>(&::mw::internal::robotics::gazebotransport::SetLinkWorldPose::default_instance());
  Packet_default_oneof_instance_->set_link_linear_velocity_ = const_cast< ::mw::internal::robotics::gazebotransport::SetLinkLinearVelocity*>(&::mw::internal::robotics::gazebotransport::SetLinkLinearVelocity::default_instance());
  Packet_default_oneof_instance_->set_link_angular_velocity_ = const_cast< ::mw::internal::robotics::gazebotransport::SetLinkAngularVelocity*>(&::mw::internal::robotics::gazebotransport::SetLinkAngularVelocity::default_instance());
  Packet_default_oneof_instance_->get_link_state_ = const_cast< ::mw::internal::robotics::gazebotransport::GetLinkState*>(&::mw::internal::robotics::gazebotransport::GetLinkState::default_instance());
  Packet_default_oneof_instance_->link_state_ = const_cast< ::mw::internal::robotics::gazebotransport::LinkState*>(&::mw::internal::robotics::gazebotransport::LinkState::default_instance());
  Packet_default_oneof_instance_->gazebo_model_ = const_cast< ::mw::internal::robotics::gazebotransport::Gazebomodel*>(&::mw::internal::robotics::gazebotransport::Gazebomodel::default_instance());
  Packet_default_oneof_instance_->get_gazebo_model_param_ = const_cast< ::mw::internal::robotics::gazebotransport::GetGazeboModelParam*>(&::mw::internal::robotics::gazebotransport::GetGazeboModelParam::default_instance());
  Packet_default_oneof_instance_->gazebo_model_sdf_ = const_cast< ::mw::internal::robotics::gazebotransport::GazeboModelSDF*>(&::mw::internal::robotics::gazebotransport::GazeboModelSDF::default_instance());
  Packet_default_oneof_instance_->get_gazebo_model_sdf_ = const_cast< ::mw::internal::robotics::gazebotransport::GetGazeboModelSDF*>(&::mw::internal::robotics::gazebotransport::GetGazeboModelSDF::default_instance());
}

Packet::Packet(const Packet& from)
  : ::google::protobuf::Message(),
    _internal_metadata_(NULL) {
  SharedCtor();
  MergeFrom(from);
  // @@protoc_insertion_point(copy_constructor:mw.internal.robotics.gazebotransport.Packet)
}

void Packet::SharedCtor() {
  ::google::protobuf::internal::GetEmptyString();
  _cached_size_ = 0;
  header_ = NULL;
  error_message_.UnsafeSetDefault(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
  ::memset(_has_bits_, 0, sizeof(_has_bits_));
  clear_has_payload();
}

Packet::~Packet() {
  // @@protoc_insertion_point(destructor:mw.internal.robotics.gazebotransport.Packet)
  SharedDtor();
}

void Packet::SharedDtor() {
  error_message_.DestroyNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
  if (has_payload()) {
    clear_payload();
  }
  if (this != default_instance_) {
    delete header_;
  }
}

void Packet::SetCachedSize(int size) const {
  GOOGLE_SAFE_CONCURRENT_WRITES_BEGIN();
  _cached_size_ = size;
  GOOGLE_SAFE_CONCURRENT_WRITES_END();
}
const ::google::protobuf::Descriptor* Packet::descriptor() {
  protobuf_AssignDescriptorsOnce();
  return Packet_descriptor_;
}

const Packet& Packet::default_instance() {
  if (default_instance_ == NULL) protobuf_AddDesc_mw_2einternal_2erobotics_2egazebotransport_2eCoSimMsgs_2eproto();
  return *default_instance_;
}

Packet* Packet::default_instance_ = NULL;

Packet* Packet::New(::google::protobuf::Arena* arena) const {
  Packet* n = new Packet;
  if (arena != NULL) {
    arena->Own(n);
  }
  return n;
}

void Packet::clear_payload() {
// @@protoc_insertion_point(one_of_clear_start:mw.internal.robotics.gazebotransport.Packet)
  switch(payload_case()) {
    case kStatus: {
      // No need to clear
      break;
    }
    case kStepSimulation: {
      delete payload_.step_simulation_;
      break;
    }
    case kResetSimulation: {
      delete payload_.reset_simulation_;
      break;
    }
    case kImage: {
      delete payload_.image_;
      break;
    }
    case kRequestImage: {
      delete payload_.request_image_;
      break;
    }
    case kRequestCosim: {
      delete payload_.request_cosim_;
      break;
    }
    case kStopCosim: {
      delete payload_.stop_cosim_;
      break;
    }
    case kGetGroundTruthWorldPose: {
      delete payload_.get_ground_truth_world_pose_;
      break;
    }
    case kPose: {
      delete payload_.pose_;
      break;
    }
    case kStopSimulation: {
      delete payload_.stop_simulation_;
      break;
    }
    case kLaserData: {
      delete payload_.laser_data_;
      break;
    }
    case kRequestLaser: {
      delete payload_.request_laser_;
      break;
    }
    case kImuData: {
      delete payload_.imu_data_;
      break;
    }
    case kRequestImu: {
      delete payload_.request_imu_;
      break;
    }
    case kSubscribeImage: {
      delete payload_.subscribe_image_;
      break;
    }
    case kSubscribeLaser: {
      delete payload_.subscribe_laser_;
      break;
    }
    case kSubscribeImu: {
      delete payload_.subscribe_imu_;
      break;
    }
    case kApplyJointTorque: {
      delete payload_.apply_joint_torque_;
      break;
    }
    case kGetPose: {
      delete payload_.get_pose_;
      break;
    }
    case kGetTopicList: {
      delete payload_.get_topic_list_;
      break;
    }
    case kTopicList: {
      delete payload_.topic_list_;
      break;
    }
    case kGetModelInfo: {
      delete payload_.get_model_info_;
      break;
    }
    case kModelInfo: {
      delete payload_.model_info_;
      break;
    }
    case kApplyLinkWrench: {
      delete payload_.apply_link_wrench_;
      break;
    }
    case kMaxStepSize: {
      delete payload_.max_step_size_;
      break;
    }
    case kCustomMessageSupport: {
      delete payload_.custom_message_support_;
      break;
    }
    case kInitCustomPublisher: {
      delete payload_.init_custom_publisher_;
      break;
    }
    case kInitCustomSubscriber: {
      delete payload_.init_custom_subscriber_;
      break;
    }
    case kRequestCustomMessageSupport: {
      delete payload_.request_custom_message_support_;
      break;
    }
    case kSetJointPosition: {
      delete payload_.set_joint_position_;
      break;
    }
    case kSetJointVelocity: {
      delete payload_.set_joint_velocity_;
      break;
    }
    case kGetJointState: {
      delete payload_.get_joint_state_;
      break;
    }
    case kJointState: {
      delete payload_.joint_state_;
      break;
    }
    case kSetLinkWorldPose: {
      delete payload_.set_link_world_pose_;
      break;
    }
    case kSetLinkLinearVelocity: {
      delete payload_.set_link_linear_velocity_;
      break;
    }
    case kSetLinkAngularVelocity: {
      delete payload_.set_link_angular_velocity_;
      break;
    }
    case kGetLinkState: {
      delete payload_.get_link_state_;
      break;
    }
    case kLinkState: {
      delete payload_.link_state_;
      break;
    }
    case kGazeboModel: {
      delete payload_.gazebo_model_;
      break;
    }
    case kGetGazeboModelParam: {
      delete payload_.get_gazebo_model_param_;
      break;
    }
    case kGazeboModelSdf: {
      delete payload_.gazebo_model_sdf_;
      break;
    }
    case kGetGazeboModelSdf: {
      delete payload_.get_gazebo_model_sdf_;
      break;
    }
    case PAYLOAD_NOT_SET: {
      break;
    }
  }
  _oneof_case_[0] = PAYLOAD_NOT_SET;
}


void Packet::Clear() {
// @@protoc_insertion_point(message_clear_start:mw.internal.robotics.gazebotransport.Packet)
  if (has_header()) {
    if (header_ != NULL) header_->::mw::internal::robotics::gazebotransport::PacketHeader::Clear();
  }
  if (has_error_message()) {
    error_message_.ClearToEmptyNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
  }
  clear_payload();
  ::memset(_has_bits_, 0, sizeof(_has_bits_));
  if (_internal_metadata_.have_unknown_fields()) {
    mutable_unknown_fields()->Clear();
  }
}

bool Packet::MergePartialFromCodedStream(
    ::google::protobuf::io::CodedInputStream* input) {
#define DO_(EXPRESSION) if (!GOOGLE_PREDICT_TRUE(EXPRESSION)) goto failure
  ::google::protobuf::uint32 tag;
  // @@protoc_insertion_point(parse_start:mw.internal.robotics.gazebotransport.Packet)
  for (;;) {
    ::std::pair< ::google::protobuf::uint32, bool> p = input->ReadTagWithCutoff(16383);
    tag = p.first;
    if (!p.second) goto handle_unusual;
    switch (::google::protobuf::internal::WireFormatLite::GetTagFieldNumber(tag)) {
      // required .mw.internal.robotics.gazebotransport.PacketHeader header = 1;
      case 1: {
        if (tag == 10) {
          DO_(::google::protobuf::internal::WireFormatLite::ReadMessageNoVirtual(
               input, mutable_header()));
        } else {
          goto handle_unusual;
        }
        if (input->ExpectTag(16)) goto parse_status;
        break;
      }

      // optional .mw.internal.robotics.gazebotransport.Packet.CoSimError status = 2;
      case 2: {
        if (tag == 16) {
         parse_status:
          int value;
          DO_((::google::protobuf::internal::WireFormatLite::ReadPrimitive<
                   int, ::google::protobuf::internal::WireFormatLite::TYPE_ENUM>(
                 input, &value)));
          if (::mw::internal::robotics::gazebotransport::Packet_CoSimError_IsValid(value)) {
            set_status(static_cast< ::mw::internal::robotics::gazebotransport::Packet_CoSimError >(value));
          } else {
            mutable_unknown_fields()->AddVarint(2, value);
          }
        } else {
          goto handle_unusual;
        }
        if (input->ExpectTag(26)) goto parse_step_simulation;
        break;
      }

      // optional .mw.internal.robotics.gazebotransport.StepSimulation step_simulation = 3;
      case 3: {
        if (tag == 26) {
         parse_step_simulation:
          DO_(::google::protobuf::internal::WireFormatLite::ReadMessageNoVirtual(
               input, mutable_step_simulation()));
        } else {
          goto handle_unusual;
        }
        if (input->ExpectTag(34)) goto parse_reset_simulation;
        break;
      }

      // optional .mw.internal.robotics.gazebotransport.ResetSimulation reset_simulation = 4;
      case 4: {
        if (tag == 34) {
         parse_reset_simulation:
          DO_(::google::protobuf::internal::WireFormatLite::ReadMessageNoVirtual(
               input, mutable_reset_simulation()));
        } else {
          goto handle_unusual;
        }
        if (input->ExpectTag(42)) goto parse_image;
        break;
      }

      // optional .mw.internal.robotics.gazebotransport.Image image = 5;
      case 5: {
        if (tag == 42) {
         parse_image:
          DO_(::google::protobuf::internal::WireFormatLite::ReadMessageNoVirtual(
               input, mutable_image()));
        } else {
          goto handle_unusual;
        }
        if (input->ExpectTag(50)) goto parse_request_image;
        break;
      }

      // optional .mw.internal.robotics.gazebotransport.RequestImage request_image = 6;
      case 6: {
        if (tag == 50) {
         parse_request_image:
          DO_(::google::protobuf::internal::WireFormatLite::ReadMessageNoVirtual(
               input, mutable_request_image()));
        } else {
          goto handle_unusual;
        }
        if (input->ExpectTag(58)) goto parse_request_cosim;
        break;
      }

      // optional .mw.internal.robotics.gazebotransport.RequestCoSim request_cosim = 7;
      case 7: {
        if (tag == 58) {
         parse_request_cosim:
          DO_(::google::protobuf::internal::WireFormatLite::ReadMessageNoVirtual(
               input, mutable_request_cosim()));
        } else {
          goto handle_unusual;
        }
        if (input->ExpectTag(66)) goto parse_stop_cosim;
        break;
      }

      // optional .mw.internal.robotics.gazebotransport.StopCoSim stop_cosim = 8;
      case 8: {
        if (tag == 66) {
         parse_stop_cosim:
          DO_(::google::protobuf::internal::WireFormatLite::ReadMessageNoVirtual(
               input, mutable_stop_cosim()));
        } else {
          goto handle_unusual;
        }
        if (input->ExpectTag(74)) goto parse_get_ground_truth_world_pose;
        break;
      }

      // optional .mw.internal.robotics.gazebotransport.GetGroundTruthWorldPose get_ground_truth_world_pose = 9;
      case 9: {
        if (tag == 74) {
         parse_get_ground_truth_world_pose:
          DO_(::google::protobuf::internal::WireFormatLite::ReadMessageNoVirtual(
               input, mutable_get_ground_truth_world_pose()));
        } else {
          goto handle_unusual;
        }
        if (input->ExpectTag(82)) goto parse_pose;
        break;
      }

      // optional .mw.internal.robotics.gazebotransport.Pose pose = 10;
      case 10: {
        if (tag == 82) {
         parse_pose:
          DO_(::google::protobuf::internal::WireFormatLite::ReadMessageNoVirtual(
               input, mutable_pose()));
        } else {
          goto handle_unusual;
        }
        if (input->ExpectTag(90)) goto parse_stop_simulation;
        break;
      }

      // optional .mw.internal.robotics.gazebotransport.StopSimulation stop_simulation = 11;
      case 11: {
        if (tag == 90) {
         parse_stop_simulation:
          DO_(::google::protobuf::internal::WireFormatLite::ReadMessageNoVirtual(
               input, mutable_stop_simulation()));
        } else {
          goto handle_unusual;
        }
        if (input->ExpectTag(98)) goto parse_laser_data;
        break;
      }

      // optional .mw.internal.robotics.gazebotransport.LaserData laser_data = 12;
      case 12: {
        if (tag == 98) {
         parse_laser_data:
          DO_(::google::protobuf::internal::WireFormatLite::ReadMessageNoVirtual(
               input, mutable_laser_data()));
        } else {
          goto handle_unusual;
        }
        if (input->ExpectTag(106)) goto parse_request_laser;
        break;
      }

      // optional .mw.internal.robotics.gazebotransport.RequestLaser request_laser = 13;
      case 13: {
        if (tag == 106) {
         parse_request_laser:
          DO_(::google::protobuf::internal::WireFormatLite::ReadMessageNoVirtual(
               input, mutable_request_laser()));
        } else {
          goto handle_unusual;
        }
        if (input->ExpectTag(114)) goto parse_imu_data;
        break;
      }

      // optional .mw.internal.robotics.gazebotransport.ImuData imu_data = 14;
      case 14: {
        if (tag == 114) {
         parse_imu_data:
          DO_(::google::protobuf::internal::WireFormatLite::ReadMessageNoVirtual(
               input, mutable_imu_data()));
        } else {
          goto handle_unusual;
        }
        if (input->ExpectTag(122)) goto parse_request_imu;
        break;
      }

      // optional .mw.internal.robotics.gazebotransport.RequestImu request_imu = 15;
      case 15: {
        if (tag == 122) {
         parse_request_imu:
          DO_(::google::protobuf::internal::WireFormatLite::ReadMessageNoVirtual(
               input, mutable_request_imu()));
        } else {
          goto handle_unusual;
        }
        if (input->ExpectTag(130)) goto parse_subscribe_image;
        break;
      }

      // optional .mw.internal.robotics.gazebotransport.SubscribeImage subscribe_image = 16;
      case 16: {
        if (tag == 130) {
         parse_subscribe_image:
          DO_(::google::protobuf::internal::WireFormatLite::ReadMessageNoVirtual(
               input, mutable_subscribe_image()));
        } else {
          goto handle_unusual;
        }
        if (input->ExpectTag(138)) goto parse_subscribe_laser;
        break;
      }

      // optional .mw.internal.robotics.gazebotransport.SubscribeLaser subscribe_laser = 17;
      case 17: {
        if (tag == 138) {
         parse_subscribe_laser:
          DO_(::google::protobuf::internal::WireFormatLite::ReadMessageNoVirtual(
               input, mutable_subscribe_laser()));
        } else {
          goto handle_unusual;
        }
        if (input->ExpectTag(146)) goto parse_subscribe_imu;
        break;
      }

      // optional .mw.internal.robotics.gazebotransport.SubscribeImu subscribe_imu = 18;
      case 18: {
        if (tag == 146) {
         parse_subscribe_imu:
          DO_(::google::protobuf::internal::WireFormatLite::ReadMessageNoVirtual(
               input, mutable_subscribe_imu()));
        } else {
          goto handle_unusual;
        }
        if (input->ExpectTag(154)) goto parse_apply_joint_torque;
        break;
      }

      // optional .mw.internal.robotics.gazebotransport.ApplyJointTorque apply_joint_torque = 19;
      case 19: {
        if (tag == 154) {
         parse_apply_joint_torque:
          DO_(::google::protobuf::internal::WireFormatLite::ReadMessageNoVirtual(
               input, mutable_apply_joint_torque()));
        } else {
          goto handle_unusual;
        }
        if (input->ExpectTag(162)) goto parse_get_pose;
        break;
      }

      // optional .mw.internal.robotics.gazebotransport.GetPose get_pose = 20;
      case 20: {
        if (tag == 162) {
         parse_get_pose:
          DO_(::google::protobuf::internal::WireFormatLite::ReadMessageNoVirtual(
               input, mutable_get_pose()));
        } else {
          goto handle_unusual;
        }
        if (input->ExpectTag(170)) goto parse_get_topic_list;
        break;
      }

      // optional .mw.internal.robotics.gazebotransport.GetTopicList get_topic_list = 21;
      case 21: {
        if (tag == 170) {
         parse_get_topic_list:
          DO_(::google::protobuf::internal::WireFormatLite::ReadMessageNoVirtual(
               input, mutable_get_topic_list()));
        } else {
          goto handle_unusual;
        }
        if (input->ExpectTag(178)) goto parse_topic_list;
        break;
      }

      // optional .mw.internal.robotics.gazebotransport.TopicList topic_list = 22;
      case 22: {
        if (tag == 178) {
         parse_topic_list:
          DO_(::google::protobuf::internal::WireFormatLite::ReadMessageNoVirtual(
               input, mutable_topic_list()));
        } else {
          goto handle_unusual;
        }
        if (input->ExpectTag(186)) goto parse_get_model_info;
        break;
      }

      // optional .mw.internal.robotics.gazebotransport.GetModelInfo get_model_info = 23;
      case 23: {
        if (tag == 186) {
         parse_get_model_info:
          DO_(::google::protobuf::internal::WireFormatLite::ReadMessageNoVirtual(
               input, mutable_get_model_info()));
        } else {
          goto handle_unusual;
        }
        if (input->ExpectTag(194)) goto parse_model_info;
        break;
      }

      // optional .mw.internal.robotics.gazebotransport.ModelInfo model_info = 24;
      case 24: {
        if (tag == 194) {
         parse_model_info:
          DO_(::google::protobuf::internal::WireFormatLite::ReadMessageNoVirtual(
               input, mutable_model_info()));
        } else {
          goto handle_unusual;
        }
        if (input->ExpectTag(202)) goto parse_apply_link_wrench;
        break;
      }

      // optional .mw.internal.robotics.gazebotransport.ApplyLinkWrench apply_link_wrench = 25;
      case 25: {
        if (tag == 202) {
         parse_apply_link_wrench:
          DO_(::google::protobuf::internal::WireFormatLite::ReadMessageNoVirtual(
               input, mutable_apply_link_wrench()));
        } else {
          goto handle_unusual;
        }
        if (input->ExpectTag(210)) goto parse_max_step_size;
        break;
      }

      // optional .mw.internal.robotics.gazebotransport.MaxStepSize max_step_size = 26;
      case 26: {
        if (tag == 210) {
         parse_max_step_size:
          DO_(::google::protobuf::internal::WireFormatLite::ReadMessageNoVirtual(
               input, mutable_max_step_size()));
        } else {
          goto handle_unusual;
        }
        if (input->ExpectTag(218)) goto parse_custom_message_support;
        break;
      }

      // optional .mw.internal.robotics.gazebotransport.CustomMessageSupport custom_message_support = 27;
      case 27: {
        if (tag == 218) {
         parse_custom_message_support:
          DO_(::google::protobuf::internal::WireFormatLite::ReadMessageNoVirtual(
               input, mutable_custom_message_support()));
        } else {
          goto handle_unusual;
        }
        if (input->ExpectTag(226)) goto parse_init_custom_publisher;
        break;
      }

      // optional .mw.internal.robotics.gazebotransport.InitCustomPublisher init_custom_publisher = 28;
      case 28: {
        if (tag == 226) {
         parse_init_custom_publisher:
          DO_(::google::protobuf::internal::WireFormatLite::ReadMessageNoVirtual(
               input, mutable_init_custom_publisher()));
        } else {
          goto handle_unusual;
        }
        if (input->ExpectTag(234)) goto parse_init_custom_subscriber;
        break;
      }

      // optional .mw.internal.robotics.gazebotransport.InitCustomSubscriber init_custom_subscriber = 29;
      case 29: {
        if (tag == 234) {
         parse_init_custom_subscriber:
          DO_(::google::protobuf::internal::WireFormatLite::ReadMessageNoVirtual(
               input, mutable_init_custom_subscriber()));
        } else {
          goto handle_unusual;
        }
        if (input->ExpectTag(242)) goto parse_request_custom_message_support;
        break;
      }

      // optional .mw.internal.robotics.gazebotransport.RequestCustomMessageSupport request_custom_message_support = 30;
      case 30: {
        if (tag == 242) {
         parse_request_custom_message_support:
          DO_(::google::protobuf::internal::WireFormatLite::ReadMessageNoVirtual(
               input, mutable_request_custom_message_support()));
        } else {
          goto handle_unusual;
        }
        if (input->ExpectTag(250)) goto parse_set_joint_position;
        break;
      }

      // optional .mw.internal.robotics.gazebotransport.SetJointPosition set_joint_position = 31;
      case 31: {
        if (tag == 250) {
         parse_set_joint_position:
          DO_(::google::protobuf::internal::WireFormatLite::ReadMessageNoVirtual(
               input, mutable_set_joint_position()));
        } else {
          goto handle_unusual;
        }
        if (input->ExpectTag(258)) goto parse_set_joint_velocity;
        break;
      }

      // optional .mw.internal.robotics.gazebotransport.SetJointVelocity set_joint_velocity = 32;
      case 32: {
        if (tag == 258) {
         parse_set_joint_velocity:
          DO_(::google::protobuf::internal::WireFormatLite::ReadMessageNoVirtual(
               input, mutable_set_joint_velocity()));
        } else {
          goto handle_unusual;
        }
        if (input->ExpectTag(266)) goto parse_get_joint_state;
        break;
      }

      // optional .mw.internal.robotics.gazebotransport.GetJointState get_joint_state = 33;
      case 33: {
        if (tag == 266) {
         parse_get_joint_state:
          DO_(::google::protobuf::internal::WireFormatLite::ReadMessageNoVirtual(
               input, mutable_get_joint_state()));
        } else {
          goto handle_unusual;
        }
        if (input->ExpectTag(274)) goto parse_joint_state;
        break;
      }

      // optional .mw.internal.robotics.gazebotransport.JointState joint_state = 34;
      case 34: {
        if (tag == 274) {
         parse_joint_state:
          DO_(::google::protobuf::internal::WireFormatLite::ReadMessageNoVirtual(
               input, mutable_joint_state()));
        } else {
          goto handle_unusual;
        }
        if (input->ExpectTag(282)) goto parse_set_link_world_pose;
        break;
      }

      // optional .mw.internal.robotics.gazebotransport.SetLinkWorldPose set_link_world_pose = 35;
      case 35: {
        if (tag == 282) {
         parse_set_link_world_pose:
          DO_(::google::protobuf::internal::WireFormatLite::ReadMessageNoVirtual(
               input, mutable_set_link_world_pose()));
        } else {
          goto handle_unusual;
        }
        if (input->ExpectTag(290)) goto parse_set_link_linear_velocity;
        break;
      }

      // optional .mw.internal.robotics.gazebotransport.SetLinkLinearVelocity set_link_linear_velocity = 36;
      case 36: {
        if (tag == 290) {
         parse_set_link_linear_velocity:
          DO_(::google::protobuf::internal::WireFormatLite::ReadMessageNoVirtual(
               input, mutable_set_link_linear_velocity()));
        } else {
          goto handle_unusual;
        }
        if (input->ExpectTag(298)) goto parse_set_link_angular_velocity;
        break;
      }

      // optional .mw.internal.robotics.gazebotransport.SetLinkAngularVelocity set_link_angular_velocity = 37;
      case 37: {
        if (tag == 298) {
         parse_set_link_angular_velocity:
          DO_(::google::protobuf::internal::WireFormatLite::ReadMessageNoVirtual(
               input, mutable_set_link_angular_velocity()));
        } else {
          goto handle_unusual;
        }
        if (input->ExpectTag(306)) goto parse_get_link_state;
        break;
      }

      // optional .mw.internal.robotics.gazebotransport.GetLinkState get_link_state = 38;
      case 38: {
        if (tag == 306) {
         parse_get_link_state:
          DO_(::google::protobuf::internal::WireFormatLite::ReadMessageNoVirtual(
               input, mutable_get_link_state()));
        } else {
          goto handle_unusual;
        }
        if (input->ExpectTag(314)) goto parse_link_state;
        break;
      }

      // optional .mw.internal.robotics.gazebotransport.LinkState link_state = 39;
      case 39: {
        if (tag == 314) {
         parse_link_state:
          DO_(::google::protobuf::internal::WireFormatLite::ReadMessageNoVirtual(
               input, mutable_link_state()));
        } else {
          goto handle_unusual;
        }
        if (input->ExpectTag(322)) goto parse_gazebo_model;
        break;
      }

      // optional .mw.internal.robotics.gazebotransport.Gazebomodel gazebo_model = 40;
      case 40: {
        if (tag == 322) {
         parse_gazebo_model:
          DO_(::google::protobuf::internal::WireFormatLite::ReadMessageNoVirtual(
               input, mutable_gazebo_model()));
        } else {
          goto handle_unusual;
        }
        if (input->ExpectTag(330)) goto parse_get_gazebo_model_param;
        break;
      }

      // optional .mw.internal.robotics.gazebotransport.GetGazeboModelParam get_gazebo_model_param = 41;
      case 41: {
        if (tag == 330) {
         parse_get_gazebo_model_param:
          DO_(::google::protobuf::internal::WireFormatLite::ReadMessageNoVirtual(
               input, mutable_get_gazebo_model_param()));
        } else {
          goto handle_unusual;
        }
        if (input->ExpectTag(338)) goto parse_gazebo_model_sdf;
        break;
      }

      // optional .mw.internal.robotics.gazebotransport.GazeboModelSDF gazebo_model_sdf = 42;
      case 42: {
        if (tag == 338) {
         parse_gazebo_model_sdf:
          DO_(::google::protobuf::internal::WireFormatLite::ReadMessageNoVirtual(
               input, mutable_gazebo_model_sdf()));
        } else {
          goto handle_unusual;
        }
        if (input->ExpectTag(346)) goto parse_get_gazebo_model_sdf;
        break;
      }

      // optional .mw.internal.robotics.gazebotransport.GetGazeboModelSDF get_gazebo_model_sdf = 43;
      case 43: {
        if (tag == 346) {
         parse_get_gazebo_model_sdf:
          DO_(::google::protobuf::internal::WireFormatLite::ReadMessageNoVirtual(
               input, mutable_get_gazebo_model_sdf()));
        } else {
          goto handle_unusual;
        }
        if (input->ExpectTag(354)) goto parse_error_message;
        break;
      }

      // optional string error_message = 44;
      case 44: {
        if (tag == 354) {
         parse_error_message:
          DO_(::google::protobuf::internal::WireFormatLite::ReadString(
                input, this->mutable_error_message()));
          ::google::protobuf::internal::WireFormat::VerifyUTF8StringNamedField(
            this->error_message().data(), this->error_message().length(),
            ::google::protobuf::internal::WireFormat::PARSE,
            "mw.internal.robotics.gazebotransport.Packet.error_message");
        } else {
          goto handle_unusual;
        }
        if (input->ExpectAtEnd()) goto success;
        break;
      }

      default: {
      handle_unusual:
        if (tag == 0 ||
            ::google::protobuf::internal::WireFormatLite::GetTagWireType(tag) ==
            ::google::protobuf::internal::WireFormatLite::WIRETYPE_END_GROUP) {
          goto success;
        }
        DO_(::google::protobuf::internal::WireFormat::SkipField(
              input, tag, mutable_unknown_fields()));
        break;
      }
    }
  }
success:
  // @@protoc_insertion_point(parse_success:mw.internal.robotics.gazebotransport.Packet)
  return true;
failure:
  // @@protoc_insertion_point(parse_failure:mw.internal.robotics.gazebotransport.Packet)
  return false;
#undef DO_
}

void Packet::SerializeWithCachedSizes(
    ::google::protobuf::io::CodedOutputStream* output) const {
  // @@protoc_insertion_point(serialize_start:mw.internal.robotics.gazebotransport.Packet)
  // required .mw.internal.robotics.gazebotransport.PacketHeader header = 1;
  if (has_header()) {
    ::google::protobuf::internal::WireFormatLite::WriteMessageMaybeToArray(
      1, *this->header_, output);
  }

  // optional .mw.internal.robotics.gazebotransport.Packet.CoSimError status = 2;
  if (has_status()) {
    ::google::protobuf::internal::WireFormatLite::WriteEnum(
      2, this->status(), output);
  }

  // optional .mw.internal.robotics.gazebotransport.StepSimulation step_simulation = 3;
  if (has_step_simulation()) {
    ::google::protobuf::internal::WireFormatLite::WriteMessageMaybeToArray(
      3, *payload_.step_simulation_, output);
  }

  // optional .mw.internal.robotics.gazebotransport.ResetSimulation reset_simulation = 4;
  if (has_reset_simulation()) {
    ::google::protobuf::internal::WireFormatLite::WriteMessageMaybeToArray(
      4, *payload_.reset_simulation_, output);
  }

  // optional .mw.internal.robotics.gazebotransport.Image image = 5;
  if (has_image()) {
    ::google::protobuf::internal::WireFormatLite::WriteMessageMaybeToArray(
      5, *payload_.image_, output);
  }

  // optional .mw.internal.robotics.gazebotransport.RequestImage request_image = 6;
  if (has_request_image()) {
    ::google::protobuf::internal::WireFormatLite::WriteMessageMaybeToArray(
      6, *payload_.request_image_, output);
  }

  // optional .mw.internal.robotics.gazebotransport.RequestCoSim request_cosim = 7;
  if (has_request_cosim()) {
    ::google::protobuf::internal::WireFormatLite::WriteMessageMaybeToArray(
      7, *payload_.request_cosim_, output);
  }

  // optional .mw.internal.robotics.gazebotransport.StopCoSim stop_cosim = 8;
  if (has_stop_cosim()) {
    ::google::protobuf::internal::WireFormatLite::WriteMessageMaybeToArray(
      8, *payload_.stop_cosim_, output);
  }

  // optional .mw.internal.robotics.gazebotransport.GetGroundTruthWorldPose get_ground_truth_world_pose = 9;
  if (has_get_ground_truth_world_pose()) {
    ::google::protobuf::internal::WireFormatLite::WriteMessageMaybeToArray(
      9, *payload_.get_ground_truth_world_pose_, output);
  }

  // optional .mw.internal.robotics.gazebotransport.Pose pose = 10;
  if (has_pose()) {
    ::google::protobuf::internal::WireFormatLite::WriteMessageMaybeToArray(
      10, *payload_.pose_, output);
  }

  // optional .mw.internal.robotics.gazebotransport.StopSimulation stop_simulation = 11;
  if (has_stop_simulation()) {
    ::google::protobuf::internal::WireFormatLite::WriteMessageMaybeToArray(
      11, *payload_.stop_simulation_, output);
  }

  // optional .mw.internal.robotics.gazebotransport.LaserData laser_data = 12;
  if (has_laser_data()) {
    ::google::protobuf::internal::WireFormatLite::WriteMessageMaybeToArray(
      12, *payload_.laser_data_, output);
  }

  // optional .mw.internal.robotics.gazebotransport.RequestLaser request_laser = 13;
  if (has_request_laser()) {
    ::google::protobuf::internal::WireFormatLite::WriteMessageMaybeToArray(
      13, *payload_.request_laser_, output);
  }

  // optional .mw.internal.robotics.gazebotransport.ImuData imu_data = 14;
  if (has_imu_data()) {
    ::google::protobuf::internal::WireFormatLite::WriteMessageMaybeToArray(
      14, *payload_.imu_data_, output);
  }

  // optional .mw.internal.robotics.gazebotransport.RequestImu request_imu = 15;
  if (has_request_imu()) {
    ::google::protobuf::internal::WireFormatLite::WriteMessageMaybeToArray(
      15, *payload_.request_imu_, output);
  }

  // optional .mw.internal.robotics.gazebotransport.SubscribeImage subscribe_image = 16;
  if (has_subscribe_image()) {
    ::google::protobuf::internal::WireFormatLite::WriteMessageMaybeToArray(
      16, *payload_.subscribe_image_, output);
  }

  // optional .mw.internal.robotics.gazebotransport.SubscribeLaser subscribe_laser = 17;
  if (has_subscribe_laser()) {
    ::google::protobuf::internal::WireFormatLite::WriteMessageMaybeToArray(
      17, *payload_.subscribe_laser_, output);
  }

  // optional .mw.internal.robotics.gazebotransport.SubscribeImu subscribe_imu = 18;
  if (has_subscribe_imu()) {
    ::google::protobuf::internal::WireFormatLite::WriteMessageMaybeToArray(
      18, *payload_.subscribe_imu_, output);
  }

  // optional .mw.internal.robotics.gazebotransport.ApplyJointTorque apply_joint_torque = 19;
  if (has_apply_joint_torque()) {
    ::google::protobuf::internal::WireFormatLite::WriteMessageMaybeToArray(
      19, *payload_.apply_joint_torque_, output);
  }

  // optional .mw.internal.robotics.gazebotransport.GetPose get_pose = 20;
  if (has_get_pose()) {
    ::google::protobuf::internal::WireFormatLite::WriteMessageMaybeToArray(
      20, *payload_.get_pose_, output);
  }

  // optional .mw.internal.robotics.gazebotransport.GetTopicList get_topic_list = 21;
  if (has_get_topic_list()) {
    ::google::protobuf::internal::WireFormatLite::WriteMessageMaybeToArray(
      21, *payload_.get_topic_list_, output);
  }

  // optional .mw.internal.robotics.gazebotransport.TopicList topic_list = 22;
  if (has_topic_list()) {
    ::google::protobuf::internal::WireFormatLite::WriteMessageMaybeToArray(
      22, *payload_.topic_list_, output);
  }

  // optional .mw.internal.robotics.gazebotransport.GetModelInfo get_model_info = 23;
  if (has_get_model_info()) {
    ::google::protobuf::internal::WireFormatLite::WriteMessageMaybeToArray(
      23, *payload_.get_model_info_, output);
  }

  // optional .mw.internal.robotics.gazebotransport.ModelInfo model_info = 24;
  if (has_model_info()) {
    ::google::protobuf::internal::WireFormatLite::WriteMessageMaybeToArray(
      24, *payload_.model_info_, output);
  }

  // optional .mw.internal.robotics.gazebotransport.ApplyLinkWrench apply_link_wrench = 25;
  if (has_apply_link_wrench()) {
    ::google::protobuf::internal::WireFormatLite::WriteMessageMaybeToArray(
      25, *payload_.apply_link_wrench_, output);
  }

  // optional .mw.internal.robotics.gazebotransport.MaxStepSize max_step_size = 26;
  if (has_max_step_size()) {
    ::google::protobuf::internal::WireFormatLite::WriteMessageMaybeToArray(
      26, *payload_.max_step_size_, output);
  }

  // optional .mw.internal.robotics.gazebotransport.CustomMessageSupport custom_message_support = 27;
  if (has_custom_message_support()) {
    ::google::protobuf::internal::WireFormatLite::WriteMessageMaybeToArray(
      27, *payload_.custom_message_support_, output);
  }

  // optional .mw.internal.robotics.gazebotransport.InitCustomPublisher init_custom_publisher = 28;
  if (has_init_custom_publisher()) {
    ::google::protobuf::internal::WireFormatLite::WriteMessageMaybeToArray(
      28, *payload_.init_custom_publisher_, output);
  }

  // optional .mw.internal.robotics.gazebotransport.InitCustomSubscriber init_custom_subscriber = 29;
  if (has_init_custom_subscriber()) {
    ::google::protobuf::internal::WireFormatLite::WriteMessageMaybeToArray(
      29, *payload_.init_custom_subscriber_, output);
  }

  // optional .mw.internal.robotics.gazebotransport.RequestCustomMessageSupport request_custom_message_support = 30;
  if (has_request_custom_message_support()) {
    ::google::protobuf::internal::WireFormatLite::WriteMessageMaybeToArray(
      30, *payload_.request_custom_message_support_, output);
  }

  // optional .mw.internal.robotics.gazebotransport.SetJointPosition set_joint_position = 31;
  if (has_set_joint_position()) {
    ::google::protobuf::internal::WireFormatLite::WriteMessageMaybeToArray(
      31, *payload_.set_joint_position_, output);
  }

  // optional .mw.internal.robotics.gazebotransport.SetJointVelocity set_joint_velocity = 32;
  if (has_set_joint_velocity()) {
    ::google::protobuf::internal::WireFormatLite::WriteMessageMaybeToArray(
      32, *payload_.set_joint_velocity_, output);
  }

  // optional .mw.internal.robotics.gazebotransport.GetJointState get_joint_state = 33;
  if (has_get_joint_state()) {
    ::google::protobuf::internal::WireFormatLite::WriteMessageMaybeToArray(
      33, *payload_.get_joint_state_, output);
  }

  // optional .mw.internal.robotics.gazebotransport.JointState joint_state = 34;
  if (has_joint_state()) {
    ::google::protobuf::internal::WireFormatLite::WriteMessageMaybeToArray(
      34, *payload_.joint_state_, output);
  }

  // optional .mw.internal.robotics.gazebotransport.SetLinkWorldPose set_link_world_pose = 35;
  if (has_set_link_world_pose()) {
    ::google::protobuf::internal::WireFormatLite::WriteMessageMaybeToArray(
      35, *payload_.set_link_world_pose_, output);
  }

  // optional .mw.internal.robotics.gazebotransport.SetLinkLinearVelocity set_link_linear_velocity = 36;
  if (has_set_link_linear_velocity()) {
    ::google::protobuf::internal::WireFormatLite::WriteMessageMaybeToArray(
      36, *payload_.set_link_linear_velocity_, output);
  }

  // optional .mw.internal.robotics.gazebotransport.SetLinkAngularVelocity set_link_angular_velocity = 37;
  if (has_set_link_angular_velocity()) {
    ::google::protobuf::internal::WireFormatLite::WriteMessageMaybeToArray(
      37, *payload_.set_link_angular_velocity_, output);
  }

  // optional .mw.internal.robotics.gazebotransport.GetLinkState get_link_state = 38;
  if (has_get_link_state()) {
    ::google::protobuf::internal::WireFormatLite::WriteMessageMaybeToArray(
      38, *payload_.get_link_state_, output);
  }

  // optional .mw.internal.robotics.gazebotransport.LinkState link_state = 39;
  if (has_link_state()) {
    ::google::protobuf::internal::WireFormatLite::WriteMessageMaybeToArray(
      39, *payload_.link_state_, output);
  }

  // optional .mw.internal.robotics.gazebotransport.Gazebomodel gazebo_model = 40;
  if (has_gazebo_model()) {
    ::google::protobuf::internal::WireFormatLite::WriteMessageMaybeToArray(
      40, *payload_.gazebo_model_, output);
  }

  // optional .mw.internal.robotics.gazebotransport.GetGazeboModelParam get_gazebo_model_param = 41;
  if (has_get_gazebo_model_param()) {
    ::google::protobuf::internal::WireFormatLite::WriteMessageMaybeToArray(
      41, *payload_.get_gazebo_model_param_, output);
  }

  // optional .mw.internal.robotics.gazebotransport.GazeboModelSDF gazebo_model_sdf = 42;
  if (has_gazebo_model_sdf()) {
    ::google::protobuf::internal::WireFormatLite::WriteMessageMaybeToArray(
      42, *payload_.gazebo_model_sdf_, output);
  }

  // optional .mw.internal.robotics.gazebotransport.GetGazeboModelSDF get_gazebo_model_sdf = 43;
  if (has_get_gazebo_model_sdf()) {
    ::google::protobuf::internal::WireFormatLite::WriteMessageMaybeToArray(
      43, *payload_.get_gazebo_model_sdf_, output);
  }

  // optional string error_message = 44;
  if (has_error_message()) {
    ::google::protobuf::internal::WireFormat::VerifyUTF8StringNamedField(
      this->error_message().data(), this->error_message().length(),
      ::google::protobuf::internal::WireFormat::SERIALIZE,
      "mw.internal.robotics.gazebotransport.Packet.error_message");
    ::google::protobuf::internal::WireFormatLite::WriteStringMaybeAliased(
      44, this->error_message(), output);
  }

  if (_internal_metadata_.have_unknown_fields()) {
    ::google::protobuf::internal::WireFormat::SerializeUnknownFields(
        unknown_fields(), output);
  }
  // @@protoc_insertion_point(serialize_end:mw.internal.robotics.gazebotransport.Packet)
}

::google::protobuf::uint8* Packet::InternalSerializeWithCachedSizesToArray(
    bool deterministic, ::google::protobuf::uint8* target) const {
  // @@protoc_insertion_point(serialize_to_array_start:mw.internal.robotics.gazebotransport.Packet)
  // required .mw.internal.robotics.gazebotransport.PacketHeader header = 1;
  if (has_header()) {
    target = ::google::protobuf::internal::WireFormatLite::
      InternalWriteMessageNoVirtualToArray(
        1, *this->header_, false, target);
  }

  // optional .mw.internal.robotics.gazebotransport.Packet.CoSimError status = 2;
  if (has_status()) {
    target = ::google::protobuf::internal::WireFormatLite::WriteEnumToArray(
      2, this->status(), target);
  }

  // optional .mw.internal.robotics.gazebotransport.StepSimulation step_simulation = 3;
  if (has_step_simulation()) {
    target = ::google::protobuf::internal::WireFormatLite::
      InternalWriteMessageNoVirtualToArray(
        3, *payload_.step_simulation_, false, target);
  }

  // optional .mw.internal.robotics.gazebotransport.ResetSimulation reset_simulation = 4;
  if (has_reset_simulation()) {
    target = ::google::protobuf::internal::WireFormatLite::
      InternalWriteMessageNoVirtualToArray(
        4, *payload_.reset_simulation_, false, target);
  }

  // optional .mw.internal.robotics.gazebotransport.Image image = 5;
  if (has_image()) {
    target = ::google::protobuf::internal::WireFormatLite::
      InternalWriteMessageNoVirtualToArray(
        5, *payload_.image_, false, target);
  }

  // optional .mw.internal.robotics.gazebotransport.RequestImage request_image = 6;
  if (has_request_image()) {
    target = ::google::protobuf::internal::WireFormatLite::
      InternalWriteMessageNoVirtualToArray(
        6, *payload_.request_image_, false, target);
  }

  // optional .mw.internal.robotics.gazebotransport.RequestCoSim request_cosim = 7;
  if (has_request_cosim()) {
    target = ::google::protobuf::internal::WireFormatLite::
      InternalWriteMessageNoVirtualToArray(
        7, *payload_.request_cosim_, false, target);
  }

  // optional .mw.internal.robotics.gazebotransport.StopCoSim stop_cosim = 8;
  if (has_stop_cosim()) {
    target = ::google::protobuf::internal::WireFormatLite::
      InternalWriteMessageNoVirtualToArray(
        8, *payload_.stop_cosim_, false, target);
  }

  // optional .mw.internal.robotics.gazebotransport.GetGroundTruthWorldPose get_ground_truth_world_pose = 9;
  if (has_get_ground_truth_world_pose()) {
    target = ::google::protobuf::internal::WireFormatLite::
      InternalWriteMessageNoVirtualToArray(
        9, *payload_.get_ground_truth_world_pose_, false, target);
  }

  // optional .mw.internal.robotics.gazebotransport.Pose pose = 10;
  if (has_pose()) {
    target = ::google::protobuf::internal::WireFormatLite::
      InternalWriteMessageNoVirtualToArray(
        10, *payload_.pose_, false, target);
  }

  // optional .mw.internal.robotics.gazebotransport.StopSimulation stop_simulation = 11;
  if (has_stop_simulation()) {
    target = ::google::protobuf::internal::WireFormatLite::
      InternalWriteMessageNoVirtualToArray(
        11, *payload_.stop_simulation_, false, target);
  }

  // optional .mw.internal.robotics.gazebotransport.LaserData laser_data = 12;
  if (has_laser_data()) {
    target = ::google::protobuf::internal::WireFormatLite::
      InternalWriteMessageNoVirtualToArray(
        12, *payload_.laser_data_, false, target);
  }

  // optional .mw.internal.robotics.gazebotransport.RequestLaser request_laser = 13;
  if (has_request_laser()) {
    target = ::google::protobuf::internal::WireFormatLite::
      InternalWriteMessageNoVirtualToArray(
        13, *payload_.request_laser_, false, target);
  }

  // optional .mw.internal.robotics.gazebotransport.ImuData imu_data = 14;
  if (has_imu_data()) {
    target = ::google::protobuf::internal::WireFormatLite::
      InternalWriteMessageNoVirtualToArray(
        14, *payload_.imu_data_, false, target);
  }

  // optional .mw.internal.robotics.gazebotransport.RequestImu request_imu = 15;
  if (has_request_imu()) {
    target = ::google::protobuf::internal::WireFormatLite::
      InternalWriteMessageNoVirtualToArray(
        15, *payload_.request_imu_, false, target);
  }

  // optional .mw.internal.robotics.gazebotransport.SubscribeImage subscribe_image = 16;
  if (has_subscribe_image()) {
    target = ::google::protobuf::internal::WireFormatLite::
      InternalWriteMessageNoVirtualToArray(
        16, *payload_.subscribe_image_, false, target);
  }

  // optional .mw.internal.robotics.gazebotransport.SubscribeLaser subscribe_laser = 17;
  if (has_subscribe_laser()) {
    target = ::google::protobuf::internal::WireFormatLite::
      InternalWriteMessageNoVirtualToArray(
        17, *payload_.subscribe_laser_, false, target);
  }

  // optional .mw.internal.robotics.gazebotransport.SubscribeImu subscribe_imu = 18;
  if (has_subscribe_imu()) {
    target = ::google::protobuf::internal::WireFormatLite::
      InternalWriteMessageNoVirtualToArray(
        18, *payload_.subscribe_imu_, false, target);
  }

  // optional .mw.internal.robotics.gazebotransport.ApplyJointTorque apply_joint_torque = 19;
  if (has_apply_joint_torque()) {
    target = ::google::protobuf::internal::WireFormatLite::
      InternalWriteMessageNoVirtualToArray(
        19, *payload_.apply_joint_torque_, false, target);
  }

  // optional .mw.internal.robotics.gazebotransport.GetPose get_pose = 20;
  if (has_get_pose()) {
    target = ::google::protobuf::internal::WireFormatLite::
      InternalWriteMessageNoVirtualToArray(
        20, *payload_.get_pose_, false, target);
  }

  // optional .mw.internal.robotics.gazebotransport.GetTopicList get_topic_list = 21;
  if (has_get_topic_list()) {
    target = ::google::protobuf::internal::WireFormatLite::
      InternalWriteMessageNoVirtualToArray(
        21, *payload_.get_topic_list_, false, target);
  }

  // optional .mw.internal.robotics.gazebotransport.TopicList topic_list = 22;
  if (has_topic_list()) {
    target = ::google::protobuf::internal::WireFormatLite::
      InternalWriteMessageNoVirtualToArray(
        22, *payload_.topic_list_, false, target);
  }

  // optional .mw.internal.robotics.gazebotransport.GetModelInfo get_model_info = 23;
  if (has_get_model_info()) {
    target = ::google::protobuf::internal::WireFormatLite::
      InternalWriteMessageNoVirtualToArray(
        23, *payload_.get_model_info_, false, target);
  }

  // optional .mw.internal.robotics.gazebotransport.ModelInfo model_info = 24;
  if (has_model_info()) {
    target = ::google::protobuf::internal::WireFormatLite::
      InternalWriteMessageNoVirtualToArray(
        24, *payload_.model_info_, false, target);
  }

  // optional .mw.internal.robotics.gazebotransport.ApplyLinkWrench apply_link_wrench = 25;
  if (has_apply_link_wrench()) {
    target = ::google::protobuf::internal::WireFormatLite::
      InternalWriteMessageNoVirtualToArray(
        25, *payload_.apply_link_wrench_, false, target);
  }

  // optional .mw.internal.robotics.gazebotransport.MaxStepSize max_step_size = 26;
  if (has_max_step_size()) {
    target = ::google::protobuf::internal::WireFormatLite::
      InternalWriteMessageNoVirtualToArray(
        26, *payload_.max_step_size_, false, target);
  }

  // optional .mw.internal.robotics.gazebotransport.CustomMessageSupport custom_message_support = 27;
  if (has_custom_message_support()) {
    target = ::google::protobuf::internal::WireFormatLite::
      InternalWriteMessageNoVirtualToArray(
        27, *payload_.custom_message_support_, false, target);
  }

  // optional .mw.internal.robotics.gazebotransport.InitCustomPublisher init_custom_publisher = 28;
  if (has_init_custom_publisher()) {
    target = ::google::protobuf::internal::WireFormatLite::
      InternalWriteMessageNoVirtualToArray(
        28, *payload_.init_custom_publisher_, false, target);
  }

  // optional .mw.internal.robotics.gazebotransport.InitCustomSubscriber init_custom_subscriber = 29;
  if (has_init_custom_subscriber()) {
    target = ::google::protobuf::internal::WireFormatLite::
      InternalWriteMessageNoVirtualToArray(
        29, *payload_.init_custom_subscriber_, false, target);
  }

  // optional .mw.internal.robotics.gazebotransport.RequestCustomMessageSupport request_custom_message_support = 30;
  if (has_request_custom_message_support()) {
    target = ::google::protobuf::internal::WireFormatLite::
      InternalWriteMessageNoVirtualToArray(
        30, *payload_.request_custom_message_support_, false, target);
  }

  // optional .mw.internal.robotics.gazebotransport.SetJointPosition set_joint_position = 31;
  if (has_set_joint_position()) {
    target = ::google::protobuf::internal::WireFormatLite::
      InternalWriteMessageNoVirtualToArray(
        31, *payload_.set_joint_position_, false, target);
  }

  // optional .mw.internal.robotics.gazebotransport.SetJointVelocity set_joint_velocity = 32;
  if (has_set_joint_velocity()) {
    target = ::google::protobuf::internal::WireFormatLite::
      InternalWriteMessageNoVirtualToArray(
        32, *payload_.set_joint_velocity_, false, target);
  }

  // optional .mw.internal.robotics.gazebotransport.GetJointState get_joint_state = 33;
  if (has_get_joint_state()) {
    target = ::google::protobuf::internal::WireFormatLite::
      InternalWriteMessageNoVirtualToArray(
        33, *payload_.get_joint_state_, false, target);
  }

  // optional .mw.internal.robotics.gazebotransport.JointState joint_state = 34;
  if (has_joint_state()) {
    target = ::google::protobuf::internal::WireFormatLite::
      InternalWriteMessageNoVirtualToArray(
        34, *payload_.joint_state_, false, target);
  }

  // optional .mw.internal.robotics.gazebotransport.SetLinkWorldPose set_link_world_pose = 35;
  if (has_set_link_world_pose()) {
    target = ::google::protobuf::internal::WireFormatLite::
      InternalWriteMessageNoVirtualToArray(
        35, *payload_.set_link_world_pose_, false, target);
  }

  // optional .mw.internal.robotics.gazebotransport.SetLinkLinearVelocity set_link_linear_velocity = 36;
  if (has_set_link_linear_velocity()) {
    target = ::google::protobuf::internal::WireFormatLite::
      InternalWriteMessageNoVirtualToArray(
        36, *payload_.set_link_linear_velocity_, false, target);
  }

  // optional .mw.internal.robotics.gazebotransport.SetLinkAngularVelocity set_link_angular_velocity = 37;
  if (has_set_link_angular_velocity()) {
    target = ::google::protobuf::internal::WireFormatLite::
      InternalWriteMessageNoVirtualToArray(
        37, *payload_.set_link_angular_velocity_, false, target);
  }

  // optional .mw.internal.robotics.gazebotransport.GetLinkState get_link_state = 38;
  if (has_get_link_state()) {
    target = ::google::protobuf::internal::WireFormatLite::
      InternalWriteMessageNoVirtualToArray(
        38, *payload_.get_link_state_, false, target);
  }

  // optional .mw.internal.robotics.gazebotransport.LinkState link_state = 39;
  if (has_link_state()) {
    target = ::google::protobuf::internal::WireFormatLite::
      InternalWriteMessageNoVirtualToArray(
        39, *payload_.link_state_, false, target);
  }

  // optional .mw.internal.robotics.gazebotransport.Gazebomodel gazebo_model = 40;
  if (has_gazebo_model()) {
    target = ::google::protobuf::internal::WireFormatLite::
      InternalWriteMessageNoVirtualToArray(
        40, *payload_.gazebo_model_, false, target);
  }

  // optional .mw.internal.robotics.gazebotransport.GetGazeboModelParam get_gazebo_model_param = 41;
  if (has_get_gazebo_model_param()) {
    target = ::google::protobuf::internal::WireFormatLite::
      InternalWriteMessageNoVirtualToArray(
        41, *payload_.get_gazebo_model_param_, false, target);
  }

  // optional .mw.internal.robotics.gazebotransport.GazeboModelSDF gazebo_model_sdf = 42;
  if (has_gazebo_model_sdf()) {
    target = ::google::protobuf::internal::WireFormatLite::
      InternalWriteMessageNoVirtualToArray(
        42, *payload_.gazebo_model_sdf_, false, target);
  }

  // optional .mw.internal.robotics.gazebotransport.GetGazeboModelSDF get_gazebo_model_sdf = 43;
  if (has_get_gazebo_model_sdf()) {
    target = ::google::protobuf::internal::WireFormatLite::
      InternalWriteMessageNoVirtualToArray(
        43, *payload_.get_gazebo_model_sdf_, false, target);
  }

  // optional string error_message = 44;
  if (has_error_message()) {
    ::google::protobuf::internal::WireFormat::VerifyUTF8StringNamedField(
      this->error_message().data(), this->error_message().length(),
      ::google::protobuf::internal::WireFormat::SERIALIZE,
      "mw.internal.robotics.gazebotransport.Packet.error_message");
    target =
      ::google::protobuf::internal::WireFormatLite::WriteStringToArray(
        44, this->error_message(), target);
  }

  if (_internal_metadata_.have_unknown_fields()) {
    target = ::google::protobuf::internal::WireFormat::SerializeUnknownFieldsToArray(
        unknown_fields(), target);
  }
  // @@protoc_insertion_point(serialize_to_array_end:mw.internal.robotics.gazebotransport.Packet)
  return target;
}

int Packet::ByteSize() const {
// @@protoc_insertion_point(message_byte_size_start:mw.internal.robotics.gazebotransport.Packet)
  int total_size = 0;

  // required .mw.internal.robotics.gazebotransport.PacketHeader header = 1;
  if (has_header()) {
    total_size += 1 +
      ::google::protobuf::internal::WireFormatLite::MessageSizeNoVirtual(
        *this->header_);
  }
  // optional string error_message = 44;
  if (has_error_message()) {
    total_size += 2 +
      ::google::protobuf::internal::WireFormatLite::StringSize(
        this->error_message());
  }

  switch (payload_case()) {
    // optional .mw.internal.robotics.gazebotransport.Packet.CoSimError status = 2;
    case kStatus: {
      total_size += 1 +
        ::google::protobuf::internal::WireFormatLite::EnumSize(this->status());
      break;
    }
    // optional .mw.internal.robotics.gazebotransport.StepSimulation step_simulation = 3;
    case kStepSimulation: {
      total_size += 1 +
        ::google::protobuf::internal::WireFormatLite::MessageSizeNoVirtual(
          *payload_.step_simulation_);
      break;
    }
    // optional .mw.internal.robotics.gazebotransport.ResetSimulation reset_simulation = 4;
    case kResetSimulation: {
      total_size += 1 +
        ::google::protobuf::internal::WireFormatLite::MessageSizeNoVirtual(
          *payload_.reset_simulation_);
      break;
    }
    // optional .mw.internal.robotics.gazebotransport.Image image = 5;
    case kImage: {
      total_size += 1 +
        ::google::protobuf::internal::WireFormatLite::MessageSizeNoVirtual(
          *payload_.image_);
      break;
    }
    // optional .mw.internal.robotics.gazebotransport.RequestImage request_image = 6;
    case kRequestImage: {
      total_size += 1 +
        ::google::protobuf::internal::WireFormatLite::MessageSizeNoVirtual(
          *payload_.request_image_);
      break;
    }
    // optional .mw.internal.robotics.gazebotransport.RequestCoSim request_cosim = 7;
    case kRequestCosim: {
      total_size += 1 +
        ::google::protobuf::internal::WireFormatLite::MessageSizeNoVirtual(
          *payload_.request_cosim_);
      break;
    }
    // optional .mw.internal.robotics.gazebotransport.StopCoSim stop_cosim = 8;
    case kStopCosim: {
      total_size += 1 +
        ::google::protobuf::internal::WireFormatLite::MessageSizeNoVirtual(
          *payload_.stop_cosim_);
      break;
    }
    // optional .mw.internal.robotics.gazebotransport.GetGroundTruthWorldPose get_ground_truth_world_pose = 9;
    case kGetGroundTruthWorldPose: {
      total_size += 1 +
        ::google::protobuf::internal::WireFormatLite::MessageSizeNoVirtual(
          *payload_.get_ground_truth_world_pose_);
      break;
    }
    // optional .mw.internal.robotics.gazebotransport.Pose pose = 10;
    case kPose: {
      total_size += 1 +
        ::google::protobuf::internal::WireFormatLite::MessageSizeNoVirtual(
          *payload_.pose_);
      break;
    }
    // optional .mw.internal.robotics.gazebotransport.StopSimulation stop_simulation = 11;
    case kStopSimulation: {
      total_size += 1 +
        ::google::protobuf::internal::WireFormatLite::MessageSizeNoVirtual(
          *payload_.stop_simulation_);
      break;
    }
    // optional .mw.internal.robotics.gazebotransport.LaserData laser_data = 12;
    case kLaserData: {
      total_size += 1 +
        ::google::protobuf::internal::WireFormatLite::MessageSizeNoVirtual(
          *payload_.laser_data_);
      break;
    }
    // optional .mw.internal.robotics.gazebotransport.RequestLaser request_laser = 13;
    case kRequestLaser: {
      total_size += 1 +
        ::google::protobuf::internal::WireFormatLite::MessageSizeNoVirtual(
          *payload_.request_laser_);
      break;
    }
    // optional .mw.internal.robotics.gazebotransport.ImuData imu_data = 14;
    case kImuData: {
      total_size += 1 +
        ::google::protobuf::internal::WireFormatLite::MessageSizeNoVirtual(
          *payload_.imu_data_);
      break;
    }
    // optional .mw.internal.robotics.gazebotransport.RequestImu request_imu = 15;
    case kRequestImu: {
      total_size += 1 +
        ::google::protobuf::internal::WireFormatLite::MessageSizeNoVirtual(
          *payload_.request_imu_);
      break;
    }
    // optional .mw.internal.robotics.gazebotransport.SubscribeImage subscribe_image = 16;
    case kSubscribeImage: {
      total_size += 2 +
        ::google::protobuf::internal::WireFormatLite::MessageSizeNoVirtual(
          *payload_.subscribe_image_);
      break;
    }
    // optional .mw.internal.robotics.gazebotransport.SubscribeLaser subscribe_laser = 17;
    case kSubscribeLaser: {
      total_size += 2 +
        ::google::protobuf::internal::WireFormatLite::MessageSizeNoVirtual(
          *payload_.subscribe_laser_);
      break;
    }
    // optional .mw.internal.robotics.gazebotransport.SubscribeImu subscribe_imu = 18;
    case kSubscribeImu: {
      total_size += 2 +
        ::google::protobuf::internal::WireFormatLite::MessageSizeNoVirtual(
          *payload_.subscribe_imu_);
      break;
    }
    // optional .mw.internal.robotics.gazebotransport.ApplyJointTorque apply_joint_torque = 19;
    case kApplyJointTorque: {
      total_size += 2 +
        ::google::protobuf::internal::WireFormatLite::MessageSizeNoVirtual(
          *payload_.apply_joint_torque_);
      break;
    }
    // optional .mw.internal.robotics.gazebotransport.GetPose get_pose = 20;
    case kGetPose: {
      total_size += 2 +
        ::google::protobuf::internal::WireFormatLite::MessageSizeNoVirtual(
          *payload_.get_pose_);
      break;
    }
    // optional .mw.internal.robotics.gazebotransport.GetTopicList get_topic_list = 21;
    case kGetTopicList: {
      total_size += 2 +
        ::google::protobuf::internal::WireFormatLite::MessageSizeNoVirtual(
          *payload_.get_topic_list_);
      break;
    }
    // optional .mw.internal.robotics.gazebotransport.TopicList topic_list = 22;
    case kTopicList: {
      total_size += 2 +
        ::google::protobuf::internal::WireFormatLite::MessageSizeNoVirtual(
          *payload_.topic_list_);
      break;
    }
    // optional .mw.internal.robotics.gazebotransport.GetModelInfo get_model_info = 23;
    case kGetModelInfo: {
      total_size += 2 +
        ::google::protobuf::internal::WireFormatLite::MessageSizeNoVirtual(
          *payload_.get_model_info_);
      break;
    }
    // optional .mw.internal.robotics.gazebotransport.ModelInfo model_info = 24;
    case kModelInfo: {
      total_size += 2 +
        ::google::protobuf::internal::WireFormatLite::MessageSizeNoVirtual(
          *payload_.model_info_);
      break;
    }
    // optional .mw.internal.robotics.gazebotransport.ApplyLinkWrench apply_link_wrench = 25;
    case kApplyLinkWrench: {
      total_size += 2 +
        ::google::protobuf::internal::WireFormatLite::MessageSizeNoVirtual(
          *payload_.apply_link_wrench_);
      break;
    }
    // optional .mw.internal.robotics.gazebotransport.MaxStepSize max_step_size = 26;
    case kMaxStepSize: {
      total_size += 2 +
        ::google::protobuf::internal::WireFormatLite::MessageSizeNoVirtual(
          *payload_.max_step_size_);
      break;
    }
    // optional .mw.internal.robotics.gazebotransport.CustomMessageSupport custom_message_support = 27;
    case kCustomMessageSupport: {
      total_size += 2 +
        ::google::protobuf::internal::WireFormatLite::MessageSizeNoVirtual(
          *payload_.custom_message_support_);
      break;
    }
    // optional .mw.internal.robotics.gazebotransport.InitCustomPublisher init_custom_publisher = 28;
    case kInitCustomPublisher: {
      total_size += 2 +
        ::google::protobuf::internal::WireFormatLite::MessageSizeNoVirtual(
          *payload_.init_custom_publisher_);
      break;
    }
    // optional .mw.internal.robotics.gazebotransport.InitCustomSubscriber init_custom_subscriber = 29;
    case kInitCustomSubscriber: {
      total_size += 2 +
        ::google::protobuf::internal::WireFormatLite::MessageSizeNoVirtual(
          *payload_.init_custom_subscriber_);
      break;
    }
    // optional .mw.internal.robotics.gazebotransport.RequestCustomMessageSupport request_custom_message_support = 30;
    case kRequestCustomMessageSupport: {
      total_size += 2 +
        ::google::protobuf::internal::WireFormatLite::MessageSizeNoVirtual(
          *payload_.request_custom_message_support_);
      break;
    }
    // optional .mw.internal.robotics.gazebotransport.SetJointPosition set_joint_position = 31;
    case kSetJointPosition: {
      total_size += 2 +
        ::google::protobuf::internal::WireFormatLite::MessageSizeNoVirtual(
          *payload_.set_joint_position_);
      break;
    }
    // optional .mw.internal.robotics.gazebotransport.SetJointVelocity set_joint_velocity = 32;
    case kSetJointVelocity: {
      total_size += 2 +
        ::google::protobuf::internal::WireFormatLite::MessageSizeNoVirtual(
          *payload_.set_joint_velocity_);
      break;
    }
    // optional .mw.internal.robotics.gazebotransport.GetJointState get_joint_state = 33;
    case kGetJointState: {
      total_size += 2 +
        ::google::protobuf::internal::WireFormatLite::MessageSizeNoVirtual(
          *payload_.get_joint_state_);
      break;
    }
    // optional .mw.internal.robotics.gazebotransport.JointState joint_state = 34;
    case kJointState: {
      total_size += 2 +
        ::google::protobuf::internal::WireFormatLite::MessageSizeNoVirtual(
          *payload_.joint_state_);
      break;
    }
    // optional .mw.internal.robotics.gazebotransport.SetLinkWorldPose set_link_world_pose = 35;
    case kSetLinkWorldPose: {
      total_size += 2 +
        ::google::protobuf::internal::WireFormatLite::MessageSizeNoVirtual(
          *payload_.set_link_world_pose_);
      break;
    }
    // optional .mw.internal.robotics.gazebotransport.SetLinkLinearVelocity set_link_linear_velocity = 36;
    case kSetLinkLinearVelocity: {
      total_size += 2 +
        ::google::protobuf::internal::WireFormatLite::MessageSizeNoVirtual(
          *payload_.set_link_linear_velocity_);
      break;
    }
    // optional .mw.internal.robotics.gazebotransport.SetLinkAngularVelocity set_link_angular_velocity = 37;
    case kSetLinkAngularVelocity: {
      total_size += 2 +
        ::google::protobuf::internal::WireFormatLite::MessageSizeNoVirtual(
          *payload_.set_link_angular_velocity_);
      break;
    }
    // optional .mw.internal.robotics.gazebotransport.GetLinkState get_link_state = 38;
    case kGetLinkState: {
      total_size += 2 +
        ::google::protobuf::internal::WireFormatLite::MessageSizeNoVirtual(
          *payload_.get_link_state_);
      break;
    }
    // optional .mw.internal.robotics.gazebotransport.LinkState link_state = 39;
    case kLinkState: {
      total_size += 2 +
        ::google::protobuf::internal::WireFormatLite::MessageSizeNoVirtual(
          *payload_.link_state_);
      break;
    }
    // optional .mw.internal.robotics.gazebotransport.Gazebomodel gazebo_model = 40;
    case kGazeboModel: {
      total_size += 2 +
        ::google::protobuf::internal::WireFormatLite::MessageSizeNoVirtual(
          *payload_.gazebo_model_);
      break;
    }
    // optional .mw.internal.robotics.gazebotransport.GetGazeboModelParam get_gazebo_model_param = 41;
    case kGetGazeboModelParam: {
      total_size += 2 +
        ::google::protobuf::internal::WireFormatLite::MessageSizeNoVirtual(
          *payload_.get_gazebo_model_param_);
      break;
    }
    // optional .mw.internal.robotics.gazebotransport.GazeboModelSDF gazebo_model_sdf = 42;
    case kGazeboModelSdf: {
      total_size += 2 +
        ::google::protobuf::internal::WireFormatLite::MessageSizeNoVirtual(
          *payload_.gazebo_model_sdf_);
      break;
    }
    // optional .mw.internal.robotics.gazebotransport.GetGazeboModelSDF get_gazebo_model_sdf = 43;
    case kGetGazeboModelSdf: {
      total_size += 2 +
        ::google::protobuf::internal::WireFormatLite::MessageSizeNoVirtual(
          *payload_.get_gazebo_model_sdf_);
      break;
    }
    case PAYLOAD_NOT_SET: {
      break;
    }
  }
  if (_internal_metadata_.have_unknown_fields()) {
    total_size +=
      ::google::protobuf::internal::WireFormat::ComputeUnknownFieldsSize(
        unknown_fields());
  }
  GOOGLE_SAFE_CONCURRENT_WRITES_BEGIN();
  _cached_size_ = total_size;
  GOOGLE_SAFE_CONCURRENT_WRITES_END();
  return total_size;
}

void Packet::MergeFrom(const ::google::protobuf::Message& from) {
// @@protoc_insertion_point(generalized_merge_from_start:mw.internal.robotics.gazebotransport.Packet)
  if (GOOGLE_PREDICT_FALSE(&from == this)) {
    ::google::protobuf::internal::MergeFromFail(__FILE__, __LINE__);
  }
  const Packet* source = 
      ::google::protobuf::internal::DynamicCastToGenerated<const Packet>(
          &from);
  if (source == NULL) {
  // @@protoc_insertion_point(generalized_merge_from_cast_fail:mw.internal.robotics.gazebotransport.Packet)
    ::google::protobuf::internal::ReflectionOps::Merge(from, this);
  } else {
  // @@protoc_insertion_point(generalized_merge_from_cast_success:mw.internal.robotics.gazebotransport.Packet)
    MergeFrom(*source);
  }
}

void Packet::MergeFrom(const Packet& from) {
// @@protoc_insertion_point(class_specific_merge_from_start:mw.internal.robotics.gazebotransport.Packet)
  if (GOOGLE_PREDICT_FALSE(&from == this)) {
    ::google::protobuf::internal::MergeFromFail(__FILE__, __LINE__);
  }
  switch (from.payload_case()) {
    case kStatus: {
      set_status(from.status());
      break;
    }
    case kStepSimulation: {
      mutable_step_simulation()->::mw::internal::robotics::gazebotransport::StepSimulation::MergeFrom(from.step_simulation());
      break;
    }
    case kResetSimulation: {
      mutable_reset_simulation()->::mw::internal::robotics::gazebotransport::ResetSimulation::MergeFrom(from.reset_simulation());
      break;
    }
    case kImage: {
      mutable_image()->::mw::internal::robotics::gazebotransport::Image::MergeFrom(from.image());
      break;
    }
    case kRequestImage: {
      mutable_request_image()->::mw::internal::robotics::gazebotransport::RequestImage::MergeFrom(from.request_image());
      break;
    }
    case kRequestCosim: {
      mutable_request_cosim()->::mw::internal::robotics::gazebotransport::RequestCoSim::MergeFrom(from.request_cosim());
      break;
    }
    case kStopCosim: {
      mutable_stop_cosim()->::mw::internal::robotics::gazebotransport::StopCoSim::MergeFrom(from.stop_cosim());
      break;
    }
    case kGetGroundTruthWorldPose: {
      mutable_get_ground_truth_world_pose()->::mw::internal::robotics::gazebotransport::GetGroundTruthWorldPose::MergeFrom(from.get_ground_truth_world_pose());
      break;
    }
    case kPose: {
      mutable_pose()->::mw::internal::robotics::gazebotransport::Pose::MergeFrom(from.pose());
      break;
    }
    case kStopSimulation: {
      mutable_stop_simulation()->::mw::internal::robotics::gazebotransport::StopSimulation::MergeFrom(from.stop_simulation());
      break;
    }
    case kLaserData: {
      mutable_laser_data()->::mw::internal::robotics::gazebotransport::LaserData::MergeFrom(from.laser_data());
      break;
    }
    case kRequestLaser: {
      mutable_request_laser()->::mw::internal::robotics::gazebotransport::RequestLaser::MergeFrom(from.request_laser());
      break;
    }
    case kImuData: {
      mutable_imu_data()->::mw::internal::robotics::gazebotransport::ImuData::MergeFrom(from.imu_data());
      break;
    }
    case kRequestImu: {
      mutable_request_imu()->::mw::internal::robotics::gazebotransport::RequestImu::MergeFrom(from.request_imu());
      break;
    }
    case kSubscribeImage: {
      mutable_subscribe_image()->::mw::internal::robotics::gazebotransport::SubscribeImage::MergeFrom(from.subscribe_image());
      break;
    }
    case kSubscribeLaser: {
      mutable_subscribe_laser()->::mw::internal::robotics::gazebotransport::SubscribeLaser::MergeFrom(from.subscribe_laser());
      break;
    }
    case kSubscribeImu: {
      mutable_subscribe_imu()->::mw::internal::robotics::gazebotransport::SubscribeImu::MergeFrom(from.subscribe_imu());
      break;
    }
    case kApplyJointTorque: {
      mutable_apply_joint_torque()->::mw::internal::robotics::gazebotransport::ApplyJointTorque::MergeFrom(from.apply_joint_torque());
      break;
    }
    case kGetPose: {
      mutable_get_pose()->::mw::internal::robotics::gazebotransport::GetPose::MergeFrom(from.get_pose());
      break;
    }
    case kGetTopicList: {
      mutable_get_topic_list()->::mw::internal::robotics::gazebotransport::GetTopicList::MergeFrom(from.get_topic_list());
      break;
    }
    case kTopicList: {
      mutable_topic_list()->::mw::internal::robotics::gazebotransport::TopicList::MergeFrom(from.topic_list());
      break;
    }
    case kGetModelInfo: {
      mutable_get_model_info()->::mw::internal::robotics::gazebotransport::GetModelInfo::MergeFrom(from.get_model_info());
      break;
    }
    case kModelInfo: {
      mutable_model_info()->::mw::internal::robotics::gazebotransport::ModelInfo::MergeFrom(from.model_info());
      break;
    }
    case kApplyLinkWrench: {
      mutable_apply_link_wrench()->::mw::internal::robotics::gazebotransport::ApplyLinkWrench::MergeFrom(from.apply_link_wrench());
      break;
    }
    case kMaxStepSize: {
      mutable_max_step_size()->::mw::internal::robotics::gazebotransport::MaxStepSize::MergeFrom(from.max_step_size());
      break;
    }
    case kCustomMessageSupport: {
      mutable_custom_message_support()->::mw::internal::robotics::gazebotransport::CustomMessageSupport::MergeFrom(from.custom_message_support());
      break;
    }
    case kInitCustomPublisher: {
      mutable_init_custom_publisher()->::mw::internal::robotics::gazebotransport::InitCustomPublisher::MergeFrom(from.init_custom_publisher());
      break;
    }
    case kInitCustomSubscriber: {
      mutable_init_custom_subscriber()->::mw::internal::robotics::gazebotransport::InitCustomSubscriber::MergeFrom(from.init_custom_subscriber());
      break;
    }
    case kRequestCustomMessageSupport: {
      mutable_request_custom_message_support()->::mw::internal::robotics::gazebotransport::RequestCustomMessageSupport::MergeFrom(from.request_custom_message_support());
      break;
    }
    case kSetJointPosition: {
      mutable_set_joint_position()->::mw::internal::robotics::gazebotransport::SetJointPosition::MergeFrom(from.set_joint_position());
      break;
    }
    case kSetJointVelocity: {
      mutable_set_joint_velocity()->::mw::internal::robotics::gazebotransport::SetJointVelocity::MergeFrom(from.set_joint_velocity());
      break;
    }
    case kGetJointState: {
      mutable_get_joint_state()->::mw::internal::robotics::gazebotransport::GetJointState::MergeFrom(from.get_joint_state());
      break;
    }
    case kJointState: {
      mutable_joint_state()->::mw::internal::robotics::gazebotransport::JointState::MergeFrom(from.joint_state());
      break;
    }
    case kSetLinkWorldPose: {
      mutable_set_link_world_pose()->::mw::internal::robotics::gazebotransport::SetLinkWorldPose::MergeFrom(from.set_link_world_pose());
      break;
    }
    case kSetLinkLinearVelocity: {
      mutable_set_link_linear_velocity()->::mw::internal::robotics::gazebotransport::SetLinkLinearVelocity::MergeFrom(from.set_link_linear_velocity());
      break;
    }
    case kSetLinkAngularVelocity: {
      mutable_set_link_angular_velocity()->::mw::internal::robotics::gazebotransport::SetLinkAngularVelocity::MergeFrom(from.set_link_angular_velocity());
      break;
    }
    case kGetLinkState: {
      mutable_get_link_state()->::mw::internal::robotics::gazebotransport::GetLinkState::MergeFrom(from.get_link_state());
      break;
    }
    case kLinkState: {
      mutable_link_state()->::mw::internal::robotics::gazebotransport::LinkState::MergeFrom(from.link_state());
      break;
    }
    case kGazeboModel: {
      mutable_gazebo_model()->::mw::internal::robotics::gazebotransport::Gazebomodel::MergeFrom(from.gazebo_model());
      break;
    }
    case kGetGazeboModelParam: {
      mutable_get_gazebo_model_param()->::mw::internal::robotics::gazebotransport::GetGazeboModelParam::MergeFrom(from.get_gazebo_model_param());
      break;
    }
    case kGazeboModelSdf: {
      mutable_gazebo_model_sdf()->::mw::internal::robotics::gazebotransport::GazeboModelSDF::MergeFrom(from.gazebo_model_sdf());
      break;
    }
    case kGetGazeboModelSdf: {
      mutable_get_gazebo_model_sdf()->::mw::internal::robotics::gazebotransport::GetGazeboModelSDF::MergeFrom(from.get_gazebo_model_sdf());
      break;
    }
    case PAYLOAD_NOT_SET: {
      break;
    }
  }
  if (from._has_bits_[0 / 32] & (0xffu << (0 % 32))) {
    if (from.has_header()) {
      mutable_header()->::mw::internal::robotics::gazebotransport::PacketHeader::MergeFrom(from.header());
    }
  }
  if (from._has_bits_[43 / 32] & (0xffu << (43 % 32))) {
    if (from.has_error_message()) {
      set_has_error_message();
      error_message_.AssignWithDefault(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), from.error_message_);
    }
  }
  if (from._internal_metadata_.have_unknown_fields()) {
    mutable_unknown_fields()->MergeFrom(from.unknown_fields());
  }
}

void Packet::CopyFrom(const ::google::protobuf::Message& from) {
// @@protoc_insertion_point(generalized_copy_from_start:mw.internal.robotics.gazebotransport.Packet)
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

void Packet::CopyFrom(const Packet& from) {
// @@protoc_insertion_point(class_specific_copy_from_start:mw.internal.robotics.gazebotransport.Packet)
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

bool Packet::IsInitialized() const {
  if ((_has_bits_[0] & 0x00000001) != 0x00000001) return false;

  if (has_header()) {
    if (!this->header_->IsInitialized()) return false;
  }
  if (has_step_simulation()) {
    if (!this->step_simulation().IsInitialized()) return false;
  }
  if (has_reset_simulation()) {
    if (!this->reset_simulation().IsInitialized()) return false;
  }
  if (has_image()) {
    if (!this->image().IsInitialized()) return false;
  }
  if (has_request_image()) {
    if (!this->request_image().IsInitialized()) return false;
  }
  if (has_request_cosim()) {
    if (!this->request_cosim().IsInitialized()) return false;
  }
  if (has_stop_cosim()) {
    if (!this->stop_cosim().IsInitialized()) return false;
  }
  if (has_get_ground_truth_world_pose()) {
    if (!this->get_ground_truth_world_pose().IsInitialized()) return false;
  }
  if (has_pose()) {
    if (!this->pose().IsInitialized()) return false;
  }
  if (has_stop_simulation()) {
    if (!this->stop_simulation().IsInitialized()) return false;
  }
  if (has_laser_data()) {
    if (!this->laser_data().IsInitialized()) return false;
  }
  if (has_request_laser()) {
    if (!this->request_laser().IsInitialized()) return false;
  }
  if (has_imu_data()) {
    if (!this->imu_data().IsInitialized()) return false;
  }
  if (has_request_imu()) {
    if (!this->request_imu().IsInitialized()) return false;
  }
  if (has_subscribe_image()) {
    if (!this->subscribe_image().IsInitialized()) return false;
  }
  if (has_subscribe_laser()) {
    if (!this->subscribe_laser().IsInitialized()) return false;
  }
  if (has_subscribe_imu()) {
    if (!this->subscribe_imu().IsInitialized()) return false;
  }
  if (has_apply_joint_torque()) {
    if (!this->apply_joint_torque().IsInitialized()) return false;
  }
  if (has_get_pose()) {
    if (!this->get_pose().IsInitialized()) return false;
  }
  if (has_get_topic_list()) {
    if (!this->get_topic_list().IsInitialized()) return false;
  }
  if (has_topic_list()) {
    if (!this->topic_list().IsInitialized()) return false;
  }
  if (has_get_model_info()) {
    if (!this->get_model_info().IsInitialized()) return false;
  }
  if (has_model_info()) {
    if (!this->model_info().IsInitialized()) return false;
  }
  if (has_apply_link_wrench()) {
    if (!this->apply_link_wrench().IsInitialized()) return false;
  }
  if (has_max_step_size()) {
    if (!this->max_step_size().IsInitialized()) return false;
  }
  if (has_custom_message_support()) {
    if (!this->custom_message_support().IsInitialized()) return false;
  }
  if (has_init_custom_publisher()) {
    if (!this->init_custom_publisher().IsInitialized()) return false;
  }
  if (has_init_custom_subscriber()) {
    if (!this->init_custom_subscriber().IsInitialized()) return false;
  }
  if (has_request_custom_message_support()) {
    if (!this->request_custom_message_support().IsInitialized()) return false;
  }
  if (has_set_joint_position()) {
    if (!this->set_joint_position().IsInitialized()) return false;
  }
  if (has_set_joint_velocity()) {
    if (!this->set_joint_velocity().IsInitialized()) return false;
  }
  if (has_get_joint_state()) {
    if (!this->get_joint_state().IsInitialized()) return false;
  }
  if (has_joint_state()) {
    if (!this->joint_state().IsInitialized()) return false;
  }
  if (has_set_link_world_pose()) {
    if (!this->set_link_world_pose().IsInitialized()) return false;
  }
  if (has_set_link_linear_velocity()) {
    if (!this->set_link_linear_velocity().IsInitialized()) return false;
  }
  if (has_set_link_angular_velocity()) {
    if (!this->set_link_angular_velocity().IsInitialized()) return false;
  }
  if (has_get_link_state()) {
    if (!this->get_link_state().IsInitialized()) return false;
  }
  if (has_link_state()) {
    if (!this->link_state().IsInitialized()) return false;
  }
  if (has_gazebo_model()) {
    if (!this->gazebo_model().IsInitialized()) return false;
  }
  if (has_get_gazebo_model_param()) {
    if (!this->get_gazebo_model_param().IsInitialized()) return false;
  }
  if (has_gazebo_model_sdf()) {
    if (!this->gazebo_model_sdf().IsInitialized()) return false;
  }
  if (has_get_gazebo_model_sdf()) {
    if (!this->get_gazebo_model_sdf().IsInitialized()) return false;
  }
  return true;
}

void Packet::Swap(Packet* other) {
  if (other == this) return;
  InternalSwap(other);
}
void Packet::InternalSwap(Packet* other) {
  std::swap(header_, other->header_);
  error_message_.Swap(&other->error_message_);
  std::swap(payload_, other->payload_);
  std::swap(_oneof_case_[0], other->_oneof_case_[0]);
  std::swap(_has_bits_[0], other->_has_bits_[0]);
  std::swap(_has_bits_[1], other->_has_bits_[1]);
  _internal_metadata_.Swap(&other->_internal_metadata_);
  std::swap(_cached_size_, other->_cached_size_);
}

::google::protobuf::Metadata Packet::GetMetadata() const {
  protobuf_AssignDescriptorsOnce();
  ::google::protobuf::Metadata metadata;
  metadata.descriptor = Packet_descriptor_;
  metadata.reflection = Packet_reflection_;
  return metadata;
}

#if PROTOBUF_INLINE_NOT_IN_HEADERS
// Packet

// required .mw.internal.robotics.gazebotransport.PacketHeader header = 1;
bool Packet::has_header() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
void Packet::set_has_header() {
  _has_bits_[0] |= 0x00000001u;
}
void Packet::clear_has_header() {
  _has_bits_[0] &= ~0x00000001u;
}
void Packet::clear_header() {
  if (header_ != NULL) header_->::mw::internal::robotics::gazebotransport::PacketHeader::Clear();
  clear_has_header();
}
const ::mw::internal::robotics::gazebotransport::PacketHeader& Packet::header() const {
  // @@protoc_insertion_point(field_get:mw.internal.robotics.gazebotransport.Packet.header)
  return header_ != NULL ? *header_ : *default_instance_->header_;
}
::mw::internal::robotics::gazebotransport::PacketHeader* Packet::mutable_header() {
  set_has_header();
  if (header_ == NULL) {
    header_ = new ::mw::internal::robotics::gazebotransport::PacketHeader;
  }
  // @@protoc_insertion_point(field_mutable:mw.internal.robotics.gazebotransport.Packet.header)
  return header_;
}
::mw::internal::robotics::gazebotransport::PacketHeader* Packet::release_header() {
  // @@protoc_insertion_point(field_release:mw.internal.robotics.gazebotransport.Packet.header)
  clear_has_header();
  ::mw::internal::robotics::gazebotransport::PacketHeader* temp = header_;
  header_ = NULL;
  return temp;
}
void Packet::set_allocated_header(::mw::internal::robotics::gazebotransport::PacketHeader* header) {
  delete header_;
  header_ = header;
  if (header) {
    set_has_header();
  } else {
    clear_has_header();
  }
  // @@protoc_insertion_point(field_set_allocated:mw.internal.robotics.gazebotransport.Packet.header)
}

// optional .mw.internal.robotics.gazebotransport.Packet.CoSimError status = 2;
bool Packet::has_status() const {
  return payload_case() == kStatus;
}
void Packet::set_has_status() {
  _oneof_case_[0] = kStatus;
}
void Packet::clear_status() {
  if (has_status()) {
    payload_.status_ = 0;
    clear_has_payload();
  }
}
 ::mw::internal::robotics::gazebotransport::Packet_CoSimError Packet::status() const {
  // @@protoc_insertion_point(field_get:mw.internal.robotics.gazebotransport.Packet.status)
  if (has_status()) {
    return static_cast< ::mw::internal::robotics::gazebotransport::Packet_CoSimError >(payload_.status_);
  }
  return static_cast< ::mw::internal::robotics::gazebotransport::Packet_CoSimError >(0);
}
 void Packet::set_status(::mw::internal::robotics::gazebotransport::Packet_CoSimError value) {
  assert(::mw::internal::robotics::gazebotransport::Packet_CoSimError_IsValid(value));
  if (!has_status()) {
    clear_payload();
    set_has_status();
  }
  payload_.status_ = value;
  // @@protoc_insertion_point(field_set:mw.internal.robotics.gazebotransport.Packet.status)
}

// optional .mw.internal.robotics.gazebotransport.StepSimulation step_simulation = 3;
bool Packet::has_step_simulation() const {
  return payload_case() == kStepSimulation;
}
void Packet::set_has_step_simulation() {
  _oneof_case_[0] = kStepSimulation;
}
void Packet::clear_step_simulation() {
  if (has_step_simulation()) {
    delete payload_.step_simulation_;
    clear_has_payload();
  }
}
 const ::mw::internal::robotics::gazebotransport::StepSimulation& Packet::step_simulation() const {
  // @@protoc_insertion_point(field_get:mw.internal.robotics.gazebotransport.Packet.step_simulation)
  return has_step_simulation()
      ? *payload_.step_simulation_
      : ::mw::internal::robotics::gazebotransport::StepSimulation::default_instance();
}
::mw::internal::robotics::gazebotransport::StepSimulation* Packet::mutable_step_simulation() {
  if (!has_step_simulation()) {
    clear_payload();
    set_has_step_simulation();
    payload_.step_simulation_ = new ::mw::internal::robotics::gazebotransport::StepSimulation;
  }
  // @@protoc_insertion_point(field_mutable:mw.internal.robotics.gazebotransport.Packet.step_simulation)
  return payload_.step_simulation_;
}
::mw::internal::robotics::gazebotransport::StepSimulation* Packet::release_step_simulation() {
  // @@protoc_insertion_point(field_release:mw.internal.robotics.gazebotransport.Packet.step_simulation)
  if (has_step_simulation()) {
    clear_has_payload();
    ::mw::internal::robotics::gazebotransport::StepSimulation* temp = payload_.step_simulation_;
    payload_.step_simulation_ = NULL;
    return temp;
  } else {
    return NULL;
  }
}
void Packet::set_allocated_step_simulation(::mw::internal::robotics::gazebotransport::StepSimulation* step_simulation) {
  clear_payload();
  if (step_simulation) {
    set_has_step_simulation();
    payload_.step_simulation_ = step_simulation;
  }
  // @@protoc_insertion_point(field_set_allocated:mw.internal.robotics.gazebotransport.Packet.step_simulation)
}

// optional .mw.internal.robotics.gazebotransport.ResetSimulation reset_simulation = 4;
bool Packet::has_reset_simulation() const {
  return payload_case() == kResetSimulation;
}
void Packet::set_has_reset_simulation() {
  _oneof_case_[0] = kResetSimulation;
}
void Packet::clear_reset_simulation() {
  if (has_reset_simulation()) {
    delete payload_.reset_simulation_;
    clear_has_payload();
  }
}
 const ::mw::internal::robotics::gazebotransport::ResetSimulation& Packet::reset_simulation() const {
  // @@protoc_insertion_point(field_get:mw.internal.robotics.gazebotransport.Packet.reset_simulation)
  return has_reset_simulation()
      ? *payload_.reset_simulation_
      : ::mw::internal::robotics::gazebotransport::ResetSimulation::default_instance();
}
::mw::internal::robotics::gazebotransport::ResetSimulation* Packet::mutable_reset_simulation() {
  if (!has_reset_simulation()) {
    clear_payload();
    set_has_reset_simulation();
    payload_.reset_simulation_ = new ::mw::internal::robotics::gazebotransport::ResetSimulation;
  }
  // @@protoc_insertion_point(field_mutable:mw.internal.robotics.gazebotransport.Packet.reset_simulation)
  return payload_.reset_simulation_;
}
::mw::internal::robotics::gazebotransport::ResetSimulation* Packet::release_reset_simulation() {
  // @@protoc_insertion_point(field_release:mw.internal.robotics.gazebotransport.Packet.reset_simulation)
  if (has_reset_simulation()) {
    clear_has_payload();
    ::mw::internal::robotics::gazebotransport::ResetSimulation* temp = payload_.reset_simulation_;
    payload_.reset_simulation_ = NULL;
    return temp;
  } else {
    return NULL;
  }
}
void Packet::set_allocated_reset_simulation(::mw::internal::robotics::gazebotransport::ResetSimulation* reset_simulation) {
  clear_payload();
  if (reset_simulation) {
    set_has_reset_simulation();
    payload_.reset_simulation_ = reset_simulation;
  }
  // @@protoc_insertion_point(field_set_allocated:mw.internal.robotics.gazebotransport.Packet.reset_simulation)
}

// optional .mw.internal.robotics.gazebotransport.Image image = 5;
bool Packet::has_image() const {
  return payload_case() == kImage;
}
void Packet::set_has_image() {
  _oneof_case_[0] = kImage;
}
void Packet::clear_image() {
  if (has_image()) {
    delete payload_.image_;
    clear_has_payload();
  }
}
 const ::mw::internal::robotics::gazebotransport::Image& Packet::image() const {
  // @@protoc_insertion_point(field_get:mw.internal.robotics.gazebotransport.Packet.image)
  return has_image()
      ? *payload_.image_
      : ::mw::internal::robotics::gazebotransport::Image::default_instance();
}
::mw::internal::robotics::gazebotransport::Image* Packet::mutable_image() {
  if (!has_image()) {
    clear_payload();
    set_has_image();
    payload_.image_ = new ::mw::internal::robotics::gazebotransport::Image;
  }
  // @@protoc_insertion_point(field_mutable:mw.internal.robotics.gazebotransport.Packet.image)
  return payload_.image_;
}
::mw::internal::robotics::gazebotransport::Image* Packet::release_image() {
  // @@protoc_insertion_point(field_release:mw.internal.robotics.gazebotransport.Packet.image)
  if (has_image()) {
    clear_has_payload();
    ::mw::internal::robotics::gazebotransport::Image* temp = payload_.image_;
    payload_.image_ = NULL;
    return temp;
  } else {
    return NULL;
  }
}
void Packet::set_allocated_image(::mw::internal::robotics::gazebotransport::Image* image) {
  clear_payload();
  if (image) {
    set_has_image();
    payload_.image_ = image;
  }
  // @@protoc_insertion_point(field_set_allocated:mw.internal.robotics.gazebotransport.Packet.image)
}

// optional .mw.internal.robotics.gazebotransport.RequestImage request_image = 6;
bool Packet::has_request_image() const {
  return payload_case() == kRequestImage;
}
void Packet::set_has_request_image() {
  _oneof_case_[0] = kRequestImage;
}
void Packet::clear_request_image() {
  if (has_request_image()) {
    delete payload_.request_image_;
    clear_has_payload();
  }
}
 const ::mw::internal::robotics::gazebotransport::RequestImage& Packet::request_image() const {
  // @@protoc_insertion_point(field_get:mw.internal.robotics.gazebotransport.Packet.request_image)
  return has_request_image()
      ? *payload_.request_image_
      : ::mw::internal::robotics::gazebotransport::RequestImage::default_instance();
}
::mw::internal::robotics::gazebotransport::RequestImage* Packet::mutable_request_image() {
  if (!has_request_image()) {
    clear_payload();
    set_has_request_image();
    payload_.request_image_ = new ::mw::internal::robotics::gazebotransport::RequestImage;
  }
  // @@protoc_insertion_point(field_mutable:mw.internal.robotics.gazebotransport.Packet.request_image)
  return payload_.request_image_;
}
::mw::internal::robotics::gazebotransport::RequestImage* Packet::release_request_image() {
  // @@protoc_insertion_point(field_release:mw.internal.robotics.gazebotransport.Packet.request_image)
  if (has_request_image()) {
    clear_has_payload();
    ::mw::internal::robotics::gazebotransport::RequestImage* temp = payload_.request_image_;
    payload_.request_image_ = NULL;
    return temp;
  } else {
    return NULL;
  }
}
void Packet::set_allocated_request_image(::mw::internal::robotics::gazebotransport::RequestImage* request_image) {
  clear_payload();
  if (request_image) {
    set_has_request_image();
    payload_.request_image_ = request_image;
  }
  // @@protoc_insertion_point(field_set_allocated:mw.internal.robotics.gazebotransport.Packet.request_image)
}

// optional .mw.internal.robotics.gazebotransport.RequestCoSim request_cosim = 7;
bool Packet::has_request_cosim() const {
  return payload_case() == kRequestCosim;
}
void Packet::set_has_request_cosim() {
  _oneof_case_[0] = kRequestCosim;
}
void Packet::clear_request_cosim() {
  if (has_request_cosim()) {
    delete payload_.request_cosim_;
    clear_has_payload();
  }
}
 const ::mw::internal::robotics::gazebotransport::RequestCoSim& Packet::request_cosim() const {
  // @@protoc_insertion_point(field_get:mw.internal.robotics.gazebotransport.Packet.request_cosim)
  return has_request_cosim()
      ? *payload_.request_cosim_
      : ::mw::internal::robotics::gazebotransport::RequestCoSim::default_instance();
}
::mw::internal::robotics::gazebotransport::RequestCoSim* Packet::mutable_request_cosim() {
  if (!has_request_cosim()) {
    clear_payload();
    set_has_request_cosim();
    payload_.request_cosim_ = new ::mw::internal::robotics::gazebotransport::RequestCoSim;
  }
  // @@protoc_insertion_point(field_mutable:mw.internal.robotics.gazebotransport.Packet.request_cosim)
  return payload_.request_cosim_;
}
::mw::internal::robotics::gazebotransport::RequestCoSim* Packet::release_request_cosim() {
  // @@protoc_insertion_point(field_release:mw.internal.robotics.gazebotransport.Packet.request_cosim)
  if (has_request_cosim()) {
    clear_has_payload();
    ::mw::internal::robotics::gazebotransport::RequestCoSim* temp = payload_.request_cosim_;
    payload_.request_cosim_ = NULL;
    return temp;
  } else {
    return NULL;
  }
}
void Packet::set_allocated_request_cosim(::mw::internal::robotics::gazebotransport::RequestCoSim* request_cosim) {
  clear_payload();
  if (request_cosim) {
    set_has_request_cosim();
    payload_.request_cosim_ = request_cosim;
  }
  // @@protoc_insertion_point(field_set_allocated:mw.internal.robotics.gazebotransport.Packet.request_cosim)
}

// optional .mw.internal.robotics.gazebotransport.StopCoSim stop_cosim = 8;
bool Packet::has_stop_cosim() const {
  return payload_case() == kStopCosim;
}
void Packet::set_has_stop_cosim() {
  _oneof_case_[0] = kStopCosim;
}
void Packet::clear_stop_cosim() {
  if (has_stop_cosim()) {
    delete payload_.stop_cosim_;
    clear_has_payload();
  }
}
 const ::mw::internal::robotics::gazebotransport::StopCoSim& Packet::stop_cosim() const {
  // @@protoc_insertion_point(field_get:mw.internal.robotics.gazebotransport.Packet.stop_cosim)
  return has_stop_cosim()
      ? *payload_.stop_cosim_
      : ::mw::internal::robotics::gazebotransport::StopCoSim::default_instance();
}
::mw::internal::robotics::gazebotransport::StopCoSim* Packet::mutable_stop_cosim() {
  if (!has_stop_cosim()) {
    clear_payload();
    set_has_stop_cosim();
    payload_.stop_cosim_ = new ::mw::internal::robotics::gazebotransport::StopCoSim;
  }
  // @@protoc_insertion_point(field_mutable:mw.internal.robotics.gazebotransport.Packet.stop_cosim)
  return payload_.stop_cosim_;
}
::mw::internal::robotics::gazebotransport::StopCoSim* Packet::release_stop_cosim() {
  // @@protoc_insertion_point(field_release:mw.internal.robotics.gazebotransport.Packet.stop_cosim)
  if (has_stop_cosim()) {
    clear_has_payload();
    ::mw::internal::robotics::gazebotransport::StopCoSim* temp = payload_.stop_cosim_;
    payload_.stop_cosim_ = NULL;
    return temp;
  } else {
    return NULL;
  }
}
void Packet::set_allocated_stop_cosim(::mw::internal::robotics::gazebotransport::StopCoSim* stop_cosim) {
  clear_payload();
  if (stop_cosim) {
    set_has_stop_cosim();
    payload_.stop_cosim_ = stop_cosim;
  }
  // @@protoc_insertion_point(field_set_allocated:mw.internal.robotics.gazebotransport.Packet.stop_cosim)
}

// optional .mw.internal.robotics.gazebotransport.GetGroundTruthWorldPose get_ground_truth_world_pose = 9;
bool Packet::has_get_ground_truth_world_pose() const {
  return payload_case() == kGetGroundTruthWorldPose;
}
void Packet::set_has_get_ground_truth_world_pose() {
  _oneof_case_[0] = kGetGroundTruthWorldPose;
}
void Packet::clear_get_ground_truth_world_pose() {
  if (has_get_ground_truth_world_pose()) {
    delete payload_.get_ground_truth_world_pose_;
    clear_has_payload();
  }
}
 const ::mw::internal::robotics::gazebotransport::GetGroundTruthWorldPose& Packet::get_ground_truth_world_pose() const {
  // @@protoc_insertion_point(field_get:mw.internal.robotics.gazebotransport.Packet.get_ground_truth_world_pose)
  return has_get_ground_truth_world_pose()
      ? *payload_.get_ground_truth_world_pose_
      : ::mw::internal::robotics::gazebotransport::GetGroundTruthWorldPose::default_instance();
}
::mw::internal::robotics::gazebotransport::GetGroundTruthWorldPose* Packet::mutable_get_ground_truth_world_pose() {
  if (!has_get_ground_truth_world_pose()) {
    clear_payload();
    set_has_get_ground_truth_world_pose();
    payload_.get_ground_truth_world_pose_ = new ::mw::internal::robotics::gazebotransport::GetGroundTruthWorldPose;
  }
  // @@protoc_insertion_point(field_mutable:mw.internal.robotics.gazebotransport.Packet.get_ground_truth_world_pose)
  return payload_.get_ground_truth_world_pose_;
}
::mw::internal::robotics::gazebotransport::GetGroundTruthWorldPose* Packet::release_get_ground_truth_world_pose() {
  // @@protoc_insertion_point(field_release:mw.internal.robotics.gazebotransport.Packet.get_ground_truth_world_pose)
  if (has_get_ground_truth_world_pose()) {
    clear_has_payload();
    ::mw::internal::robotics::gazebotransport::GetGroundTruthWorldPose* temp = payload_.get_ground_truth_world_pose_;
    payload_.get_ground_truth_world_pose_ = NULL;
    return temp;
  } else {
    return NULL;
  }
}
void Packet::set_allocated_get_ground_truth_world_pose(::mw::internal::robotics::gazebotransport::GetGroundTruthWorldPose* get_ground_truth_world_pose) {
  clear_payload();
  if (get_ground_truth_world_pose) {
    set_has_get_ground_truth_world_pose();
    payload_.get_ground_truth_world_pose_ = get_ground_truth_world_pose;
  }
  // @@protoc_insertion_point(field_set_allocated:mw.internal.robotics.gazebotransport.Packet.get_ground_truth_world_pose)
}

// optional .mw.internal.robotics.gazebotransport.Pose pose = 10;
bool Packet::has_pose() const {
  return payload_case() == kPose;
}
void Packet::set_has_pose() {
  _oneof_case_[0] = kPose;
}
void Packet::clear_pose() {
  if (has_pose()) {
    delete payload_.pose_;
    clear_has_payload();
  }
}
 const ::mw::internal::robotics::gazebotransport::Pose& Packet::pose() const {
  // @@protoc_insertion_point(field_get:mw.internal.robotics.gazebotransport.Packet.pose)
  return has_pose()
      ? *payload_.pose_
      : ::mw::internal::robotics::gazebotransport::Pose::default_instance();
}
::mw::internal::robotics::gazebotransport::Pose* Packet::mutable_pose() {
  if (!has_pose()) {
    clear_payload();
    set_has_pose();
    payload_.pose_ = new ::mw::internal::robotics::gazebotransport::Pose;
  }
  // @@protoc_insertion_point(field_mutable:mw.internal.robotics.gazebotransport.Packet.pose)
  return payload_.pose_;
}
::mw::internal::robotics::gazebotransport::Pose* Packet::release_pose() {
  // @@protoc_insertion_point(field_release:mw.internal.robotics.gazebotransport.Packet.pose)
  if (has_pose()) {
    clear_has_payload();
    ::mw::internal::robotics::gazebotransport::Pose* temp = payload_.pose_;
    payload_.pose_ = NULL;
    return temp;
  } else {
    return NULL;
  }
}
void Packet::set_allocated_pose(::mw::internal::robotics::gazebotransport::Pose* pose) {
  clear_payload();
  if (pose) {
    set_has_pose();
    payload_.pose_ = pose;
  }
  // @@protoc_insertion_point(field_set_allocated:mw.internal.robotics.gazebotransport.Packet.pose)
}

// optional .mw.internal.robotics.gazebotransport.StopSimulation stop_simulation = 11;
bool Packet::has_stop_simulation() const {
  return payload_case() == kStopSimulation;
}
void Packet::set_has_stop_simulation() {
  _oneof_case_[0] = kStopSimulation;
}
void Packet::clear_stop_simulation() {
  if (has_stop_simulation()) {
    delete payload_.stop_simulation_;
    clear_has_payload();
  }
}
 const ::mw::internal::robotics::gazebotransport::StopSimulation& Packet::stop_simulation() const {
  // @@protoc_insertion_point(field_get:mw.internal.robotics.gazebotransport.Packet.stop_simulation)
  return has_stop_simulation()
      ? *payload_.stop_simulation_
      : ::mw::internal::robotics::gazebotransport::StopSimulation::default_instance();
}
::mw::internal::robotics::gazebotransport::StopSimulation* Packet::mutable_stop_simulation() {
  if (!has_stop_simulation()) {
    clear_payload();
    set_has_stop_simulation();
    payload_.stop_simulation_ = new ::mw::internal::robotics::gazebotransport::StopSimulation;
  }
  // @@protoc_insertion_point(field_mutable:mw.internal.robotics.gazebotransport.Packet.stop_simulation)
  return payload_.stop_simulation_;
}
::mw::internal::robotics::gazebotransport::StopSimulation* Packet::release_stop_simulation() {
  // @@protoc_insertion_point(field_release:mw.internal.robotics.gazebotransport.Packet.stop_simulation)
  if (has_stop_simulation()) {
    clear_has_payload();
    ::mw::internal::robotics::gazebotransport::StopSimulation* temp = payload_.stop_simulation_;
    payload_.stop_simulation_ = NULL;
    return temp;
  } else {
    return NULL;
  }
}
void Packet::set_allocated_stop_simulation(::mw::internal::robotics::gazebotransport::StopSimulation* stop_simulation) {
  clear_payload();
  if (stop_simulation) {
    set_has_stop_simulation();
    payload_.stop_simulation_ = stop_simulation;
  }
  // @@protoc_insertion_point(field_set_allocated:mw.internal.robotics.gazebotransport.Packet.stop_simulation)
}

// optional .mw.internal.robotics.gazebotransport.LaserData laser_data = 12;
bool Packet::has_laser_data() const {
  return payload_case() == kLaserData;
}
void Packet::set_has_laser_data() {
  _oneof_case_[0] = kLaserData;
}
void Packet::clear_laser_data() {
  if (has_laser_data()) {
    delete payload_.laser_data_;
    clear_has_payload();
  }
}
 const ::mw::internal::robotics::gazebotransport::LaserData& Packet::laser_data() const {
  // @@protoc_insertion_point(field_get:mw.internal.robotics.gazebotransport.Packet.laser_data)
  return has_laser_data()
      ? *payload_.laser_data_
      : ::mw::internal::robotics::gazebotransport::LaserData::default_instance();
}
::mw::internal::robotics::gazebotransport::LaserData* Packet::mutable_laser_data() {
  if (!has_laser_data()) {
    clear_payload();
    set_has_laser_data();
    payload_.laser_data_ = new ::mw::internal::robotics::gazebotransport::LaserData;
  }
  // @@protoc_insertion_point(field_mutable:mw.internal.robotics.gazebotransport.Packet.laser_data)
  return payload_.laser_data_;
}
::mw::internal::robotics::gazebotransport::LaserData* Packet::release_laser_data() {
  // @@protoc_insertion_point(field_release:mw.internal.robotics.gazebotransport.Packet.laser_data)
  if (has_laser_data()) {
    clear_has_payload();
    ::mw::internal::robotics::gazebotransport::LaserData* temp = payload_.laser_data_;
    payload_.laser_data_ = NULL;
    return temp;
  } else {
    return NULL;
  }
}
void Packet::set_allocated_laser_data(::mw::internal::robotics::gazebotransport::LaserData* laser_data) {
  clear_payload();
  if (laser_data) {
    set_has_laser_data();
    payload_.laser_data_ = laser_data;
  }
  // @@protoc_insertion_point(field_set_allocated:mw.internal.robotics.gazebotransport.Packet.laser_data)
}

// optional .mw.internal.robotics.gazebotransport.RequestLaser request_laser = 13;
bool Packet::has_request_laser() const {
  return payload_case() == kRequestLaser;
}
void Packet::set_has_request_laser() {
  _oneof_case_[0] = kRequestLaser;
}
void Packet::clear_request_laser() {
  if (has_request_laser()) {
    delete payload_.request_laser_;
    clear_has_payload();
  }
}
 const ::mw::internal::robotics::gazebotransport::RequestLaser& Packet::request_laser() const {
  // @@protoc_insertion_point(field_get:mw.internal.robotics.gazebotransport.Packet.request_laser)
  return has_request_laser()
      ? *payload_.request_laser_
      : ::mw::internal::robotics::gazebotransport::RequestLaser::default_instance();
}
::mw::internal::robotics::gazebotransport::RequestLaser* Packet::mutable_request_laser() {
  if (!has_request_laser()) {
    clear_payload();
    set_has_request_laser();
    payload_.request_laser_ = new ::mw::internal::robotics::gazebotransport::RequestLaser;
  }
  // @@protoc_insertion_point(field_mutable:mw.internal.robotics.gazebotransport.Packet.request_laser)
  return payload_.request_laser_;
}
::mw::internal::robotics::gazebotransport::RequestLaser* Packet::release_request_laser() {
  // @@protoc_insertion_point(field_release:mw.internal.robotics.gazebotransport.Packet.request_laser)
  if (has_request_laser()) {
    clear_has_payload();
    ::mw::internal::robotics::gazebotransport::RequestLaser* temp = payload_.request_laser_;
    payload_.request_laser_ = NULL;
    return temp;
  } else {
    return NULL;
  }
}
void Packet::set_allocated_request_laser(::mw::internal::robotics::gazebotransport::RequestLaser* request_laser) {
  clear_payload();
  if (request_laser) {
    set_has_request_laser();
    payload_.request_laser_ = request_laser;
  }
  // @@protoc_insertion_point(field_set_allocated:mw.internal.robotics.gazebotransport.Packet.request_laser)
}

// optional .mw.internal.robotics.gazebotransport.ImuData imu_data = 14;
bool Packet::has_imu_data() const {
  return payload_case() == kImuData;
}
void Packet::set_has_imu_data() {
  _oneof_case_[0] = kImuData;
}
void Packet::clear_imu_data() {
  if (has_imu_data()) {
    delete payload_.imu_data_;
    clear_has_payload();
  }
}
 const ::mw::internal::robotics::gazebotransport::ImuData& Packet::imu_data() const {
  // @@protoc_insertion_point(field_get:mw.internal.robotics.gazebotransport.Packet.imu_data)
  return has_imu_data()
      ? *payload_.imu_data_
      : ::mw::internal::robotics::gazebotransport::ImuData::default_instance();
}
::mw::internal::robotics::gazebotransport::ImuData* Packet::mutable_imu_data() {
  if (!has_imu_data()) {
    clear_payload();
    set_has_imu_data();
    payload_.imu_data_ = new ::mw::internal::robotics::gazebotransport::ImuData;
  }
  // @@protoc_insertion_point(field_mutable:mw.internal.robotics.gazebotransport.Packet.imu_data)
  return payload_.imu_data_;
}
::mw::internal::robotics::gazebotransport::ImuData* Packet::release_imu_data() {
  // @@protoc_insertion_point(field_release:mw.internal.robotics.gazebotransport.Packet.imu_data)
  if (has_imu_data()) {
    clear_has_payload();
    ::mw::internal::robotics::gazebotransport::ImuData* temp = payload_.imu_data_;
    payload_.imu_data_ = NULL;
    return temp;
  } else {
    return NULL;
  }
}
void Packet::set_allocated_imu_data(::mw::internal::robotics::gazebotransport::ImuData* imu_data) {
  clear_payload();
  if (imu_data) {
    set_has_imu_data();
    payload_.imu_data_ = imu_data;
  }
  // @@protoc_insertion_point(field_set_allocated:mw.internal.robotics.gazebotransport.Packet.imu_data)
}

// optional .mw.internal.robotics.gazebotransport.RequestImu request_imu = 15;
bool Packet::has_request_imu() const {
  return payload_case() == kRequestImu;
}
void Packet::set_has_request_imu() {
  _oneof_case_[0] = kRequestImu;
}
void Packet::clear_request_imu() {
  if (has_request_imu()) {
    delete payload_.request_imu_;
    clear_has_payload();
  }
}
 const ::mw::internal::robotics::gazebotransport::RequestImu& Packet::request_imu() const {
  // @@protoc_insertion_point(field_get:mw.internal.robotics.gazebotransport.Packet.request_imu)
  return has_request_imu()
      ? *payload_.request_imu_
      : ::mw::internal::robotics::gazebotransport::RequestImu::default_instance();
}
::mw::internal::robotics::gazebotransport::RequestImu* Packet::mutable_request_imu() {
  if (!has_request_imu()) {
    clear_payload();
    set_has_request_imu();
    payload_.request_imu_ = new ::mw::internal::robotics::gazebotransport::RequestImu;
  }
  // @@protoc_insertion_point(field_mutable:mw.internal.robotics.gazebotransport.Packet.request_imu)
  return payload_.request_imu_;
}
::mw::internal::robotics::gazebotransport::RequestImu* Packet::release_request_imu() {
  // @@protoc_insertion_point(field_release:mw.internal.robotics.gazebotransport.Packet.request_imu)
  if (has_request_imu()) {
    clear_has_payload();
    ::mw::internal::robotics::gazebotransport::RequestImu* temp = payload_.request_imu_;
    payload_.request_imu_ = NULL;
    return temp;
  } else {
    return NULL;
  }
}
void Packet::set_allocated_request_imu(::mw::internal::robotics::gazebotransport::RequestImu* request_imu) {
  clear_payload();
  if (request_imu) {
    set_has_request_imu();
    payload_.request_imu_ = request_imu;
  }
  // @@protoc_insertion_point(field_set_allocated:mw.internal.robotics.gazebotransport.Packet.request_imu)
}

// optional .mw.internal.robotics.gazebotransport.SubscribeImage subscribe_image = 16;
bool Packet::has_subscribe_image() const {
  return payload_case() == kSubscribeImage;
}
void Packet::set_has_subscribe_image() {
  _oneof_case_[0] = kSubscribeImage;
}
void Packet::clear_subscribe_image() {
  if (has_subscribe_image()) {
    delete payload_.subscribe_image_;
    clear_has_payload();
  }
}
 const ::mw::internal::robotics::gazebotransport::SubscribeImage& Packet::subscribe_image() const {
  // @@protoc_insertion_point(field_get:mw.internal.robotics.gazebotransport.Packet.subscribe_image)
  return has_subscribe_image()
      ? *payload_.subscribe_image_
      : ::mw::internal::robotics::gazebotransport::SubscribeImage::default_instance();
}
::mw::internal::robotics::gazebotransport::SubscribeImage* Packet::mutable_subscribe_image() {
  if (!has_subscribe_image()) {
    clear_payload();
    set_has_subscribe_image();
    payload_.subscribe_image_ = new ::mw::internal::robotics::gazebotransport::SubscribeImage;
  }
  // @@protoc_insertion_point(field_mutable:mw.internal.robotics.gazebotransport.Packet.subscribe_image)
  return payload_.subscribe_image_;
}
::mw::internal::robotics::gazebotransport::SubscribeImage* Packet::release_subscribe_image() {
  // @@protoc_insertion_point(field_release:mw.internal.robotics.gazebotransport.Packet.subscribe_image)
  if (has_subscribe_image()) {
    clear_has_payload();
    ::mw::internal::robotics::gazebotransport::SubscribeImage* temp = payload_.subscribe_image_;
    payload_.subscribe_image_ = NULL;
    return temp;
  } else {
    return NULL;
  }
}
void Packet::set_allocated_subscribe_image(::mw::internal::robotics::gazebotransport::SubscribeImage* subscribe_image) {
  clear_payload();
  if (subscribe_image) {
    set_has_subscribe_image();
    payload_.subscribe_image_ = subscribe_image;
  }
  // @@protoc_insertion_point(field_set_allocated:mw.internal.robotics.gazebotransport.Packet.subscribe_image)
}

// optional .mw.internal.robotics.gazebotransport.SubscribeLaser subscribe_laser = 17;
bool Packet::has_subscribe_laser() const {
  return payload_case() == kSubscribeLaser;
}
void Packet::set_has_subscribe_laser() {
  _oneof_case_[0] = kSubscribeLaser;
}
void Packet::clear_subscribe_laser() {
  if (has_subscribe_laser()) {
    delete payload_.subscribe_laser_;
    clear_has_payload();
  }
}
 const ::mw::internal::robotics::gazebotransport::SubscribeLaser& Packet::subscribe_laser() const {
  // @@protoc_insertion_point(field_get:mw.internal.robotics.gazebotransport.Packet.subscribe_laser)
  return has_subscribe_laser()
      ? *payload_.subscribe_laser_
      : ::mw::internal::robotics::gazebotransport::SubscribeLaser::default_instance();
}
::mw::internal::robotics::gazebotransport::SubscribeLaser* Packet::mutable_subscribe_laser() {
  if (!has_subscribe_laser()) {
    clear_payload();
    set_has_subscribe_laser();
    payload_.subscribe_laser_ = new ::mw::internal::robotics::gazebotransport::SubscribeLaser;
  }
  // @@protoc_insertion_point(field_mutable:mw.internal.robotics.gazebotransport.Packet.subscribe_laser)
  return payload_.subscribe_laser_;
}
::mw::internal::robotics::gazebotransport::SubscribeLaser* Packet::release_subscribe_laser() {
  // @@protoc_insertion_point(field_release:mw.internal.robotics.gazebotransport.Packet.subscribe_laser)
  if (has_subscribe_laser()) {
    clear_has_payload();
    ::mw::internal::robotics::gazebotransport::SubscribeLaser* temp = payload_.subscribe_laser_;
    payload_.subscribe_laser_ = NULL;
    return temp;
  } else {
    return NULL;
  }
}
void Packet::set_allocated_subscribe_laser(::mw::internal::robotics::gazebotransport::SubscribeLaser* subscribe_laser) {
  clear_payload();
  if (subscribe_laser) {
    set_has_subscribe_laser();
    payload_.subscribe_laser_ = subscribe_laser;
  }
  // @@protoc_insertion_point(field_set_allocated:mw.internal.robotics.gazebotransport.Packet.subscribe_laser)
}

// optional .mw.internal.robotics.gazebotransport.SubscribeImu subscribe_imu = 18;
bool Packet::has_subscribe_imu() const {
  return payload_case() == kSubscribeImu;
}
void Packet::set_has_subscribe_imu() {
  _oneof_case_[0] = kSubscribeImu;
}
void Packet::clear_subscribe_imu() {
  if (has_subscribe_imu()) {
    delete payload_.subscribe_imu_;
    clear_has_payload();
  }
}
 const ::mw::internal::robotics::gazebotransport::SubscribeImu& Packet::subscribe_imu() const {
  // @@protoc_insertion_point(field_get:mw.internal.robotics.gazebotransport.Packet.subscribe_imu)
  return has_subscribe_imu()
      ? *payload_.subscribe_imu_
      : ::mw::internal::robotics::gazebotransport::SubscribeImu::default_instance();
}
::mw::internal::robotics::gazebotransport::SubscribeImu* Packet::mutable_subscribe_imu() {
  if (!has_subscribe_imu()) {
    clear_payload();
    set_has_subscribe_imu();
    payload_.subscribe_imu_ = new ::mw::internal::robotics::gazebotransport::SubscribeImu;
  }
  // @@protoc_insertion_point(field_mutable:mw.internal.robotics.gazebotransport.Packet.subscribe_imu)
  return payload_.subscribe_imu_;
}
::mw::internal::robotics::gazebotransport::SubscribeImu* Packet::release_subscribe_imu() {
  // @@protoc_insertion_point(field_release:mw.internal.robotics.gazebotransport.Packet.subscribe_imu)
  if (has_subscribe_imu()) {
    clear_has_payload();
    ::mw::internal::robotics::gazebotransport::SubscribeImu* temp = payload_.subscribe_imu_;
    payload_.subscribe_imu_ = NULL;
    return temp;
  } else {
    return NULL;
  }
}
void Packet::set_allocated_subscribe_imu(::mw::internal::robotics::gazebotransport::SubscribeImu* subscribe_imu) {
  clear_payload();
  if (subscribe_imu) {
    set_has_subscribe_imu();
    payload_.subscribe_imu_ = subscribe_imu;
  }
  // @@protoc_insertion_point(field_set_allocated:mw.internal.robotics.gazebotransport.Packet.subscribe_imu)
}

// optional .mw.internal.robotics.gazebotransport.ApplyJointTorque apply_joint_torque = 19;
bool Packet::has_apply_joint_torque() const {
  return payload_case() == kApplyJointTorque;
}
void Packet::set_has_apply_joint_torque() {
  _oneof_case_[0] = kApplyJointTorque;
}
void Packet::clear_apply_joint_torque() {
  if (has_apply_joint_torque()) {
    delete payload_.apply_joint_torque_;
    clear_has_payload();
  }
}
 const ::mw::internal::robotics::gazebotransport::ApplyJointTorque& Packet::apply_joint_torque() const {
  // @@protoc_insertion_point(field_get:mw.internal.robotics.gazebotransport.Packet.apply_joint_torque)
  return has_apply_joint_torque()
      ? *payload_.apply_joint_torque_
      : ::mw::internal::robotics::gazebotransport::ApplyJointTorque::default_instance();
}
::mw::internal::robotics::gazebotransport::ApplyJointTorque* Packet::mutable_apply_joint_torque() {
  if (!has_apply_joint_torque()) {
    clear_payload();
    set_has_apply_joint_torque();
    payload_.apply_joint_torque_ = new ::mw::internal::robotics::gazebotransport::ApplyJointTorque;
  }
  // @@protoc_insertion_point(field_mutable:mw.internal.robotics.gazebotransport.Packet.apply_joint_torque)
  return payload_.apply_joint_torque_;
}
::mw::internal::robotics::gazebotransport::ApplyJointTorque* Packet::release_apply_joint_torque() {
  // @@protoc_insertion_point(field_release:mw.internal.robotics.gazebotransport.Packet.apply_joint_torque)
  if (has_apply_joint_torque()) {
    clear_has_payload();
    ::mw::internal::robotics::gazebotransport::ApplyJointTorque* temp = payload_.apply_joint_torque_;
    payload_.apply_joint_torque_ = NULL;
    return temp;
  } else {
    return NULL;
  }
}
void Packet::set_allocated_apply_joint_torque(::mw::internal::robotics::gazebotransport::ApplyJointTorque* apply_joint_torque) {
  clear_payload();
  if (apply_joint_torque) {
    set_has_apply_joint_torque();
    payload_.apply_joint_torque_ = apply_joint_torque;
  }
  // @@protoc_insertion_point(field_set_allocated:mw.internal.robotics.gazebotransport.Packet.apply_joint_torque)
}

// optional .mw.internal.robotics.gazebotransport.GetPose get_pose = 20;
bool Packet::has_get_pose() const {
  return payload_case() == kGetPose;
}
void Packet::set_has_get_pose() {
  _oneof_case_[0] = kGetPose;
}
void Packet::clear_get_pose() {
  if (has_get_pose()) {
    delete payload_.get_pose_;
    clear_has_payload();
  }
}
 const ::mw::internal::robotics::gazebotransport::GetPose& Packet::get_pose() const {
  // @@protoc_insertion_point(field_get:mw.internal.robotics.gazebotransport.Packet.get_pose)
  return has_get_pose()
      ? *payload_.get_pose_
      : ::mw::internal::robotics::gazebotransport::GetPose::default_instance();
}
::mw::internal::robotics::gazebotransport::GetPose* Packet::mutable_get_pose() {
  if (!has_get_pose()) {
    clear_payload();
    set_has_get_pose();
    payload_.get_pose_ = new ::mw::internal::robotics::gazebotransport::GetPose;
  }
  // @@protoc_insertion_point(field_mutable:mw.internal.robotics.gazebotransport.Packet.get_pose)
  return payload_.get_pose_;
}
::mw::internal::robotics::gazebotransport::GetPose* Packet::release_get_pose() {
  // @@protoc_insertion_point(field_release:mw.internal.robotics.gazebotransport.Packet.get_pose)
  if (has_get_pose()) {
    clear_has_payload();
    ::mw::internal::robotics::gazebotransport::GetPose* temp = payload_.get_pose_;
    payload_.get_pose_ = NULL;
    return temp;
  } else {
    return NULL;
  }
}
void Packet::set_allocated_get_pose(::mw::internal::robotics::gazebotransport::GetPose* get_pose) {
  clear_payload();
  if (get_pose) {
    set_has_get_pose();
    payload_.get_pose_ = get_pose;
  }
  // @@protoc_insertion_point(field_set_allocated:mw.internal.robotics.gazebotransport.Packet.get_pose)
}

// optional .mw.internal.robotics.gazebotransport.GetTopicList get_topic_list = 21;
bool Packet::has_get_topic_list() const {
  return payload_case() == kGetTopicList;
}
void Packet::set_has_get_topic_list() {
  _oneof_case_[0] = kGetTopicList;
}
void Packet::clear_get_topic_list() {
  if (has_get_topic_list()) {
    delete payload_.get_topic_list_;
    clear_has_payload();
  }
}
 const ::mw::internal::robotics::gazebotransport::GetTopicList& Packet::get_topic_list() const {
  // @@protoc_insertion_point(field_get:mw.internal.robotics.gazebotransport.Packet.get_topic_list)
  return has_get_topic_list()
      ? *payload_.get_topic_list_
      : ::mw::internal::robotics::gazebotransport::GetTopicList::default_instance();
}
::mw::internal::robotics::gazebotransport::GetTopicList* Packet::mutable_get_topic_list() {
  if (!has_get_topic_list()) {
    clear_payload();
    set_has_get_topic_list();
    payload_.get_topic_list_ = new ::mw::internal::robotics::gazebotransport::GetTopicList;
  }
  // @@protoc_insertion_point(field_mutable:mw.internal.robotics.gazebotransport.Packet.get_topic_list)
  return payload_.get_topic_list_;
}
::mw::internal::robotics::gazebotransport::GetTopicList* Packet::release_get_topic_list() {
  // @@protoc_insertion_point(field_release:mw.internal.robotics.gazebotransport.Packet.get_topic_list)
  if (has_get_topic_list()) {
    clear_has_payload();
    ::mw::internal::robotics::gazebotransport::GetTopicList* temp = payload_.get_topic_list_;
    payload_.get_topic_list_ = NULL;
    return temp;
  } else {
    return NULL;
  }
}
void Packet::set_allocated_get_topic_list(::mw::internal::robotics::gazebotransport::GetTopicList* get_topic_list) {
  clear_payload();
  if (get_topic_list) {
    set_has_get_topic_list();
    payload_.get_topic_list_ = get_topic_list;
  }
  // @@protoc_insertion_point(field_set_allocated:mw.internal.robotics.gazebotransport.Packet.get_topic_list)
}

// optional .mw.internal.robotics.gazebotransport.TopicList topic_list = 22;
bool Packet::has_topic_list() const {
  return payload_case() == kTopicList;
}
void Packet::set_has_topic_list() {
  _oneof_case_[0] = kTopicList;
}
void Packet::clear_topic_list() {
  if (has_topic_list()) {
    delete payload_.topic_list_;
    clear_has_payload();
  }
}
 const ::mw::internal::robotics::gazebotransport::TopicList& Packet::topic_list() const {
  // @@protoc_insertion_point(field_get:mw.internal.robotics.gazebotransport.Packet.topic_list)
  return has_topic_list()
      ? *payload_.topic_list_
      : ::mw::internal::robotics::gazebotransport::TopicList::default_instance();
}
::mw::internal::robotics::gazebotransport::TopicList* Packet::mutable_topic_list() {
  if (!has_topic_list()) {
    clear_payload();
    set_has_topic_list();
    payload_.topic_list_ = new ::mw::internal::robotics::gazebotransport::TopicList;
  }
  // @@protoc_insertion_point(field_mutable:mw.internal.robotics.gazebotransport.Packet.topic_list)
  return payload_.topic_list_;
}
::mw::internal::robotics::gazebotransport::TopicList* Packet::release_topic_list() {
  // @@protoc_insertion_point(field_release:mw.internal.robotics.gazebotransport.Packet.topic_list)
  if (has_topic_list()) {
    clear_has_payload();
    ::mw::internal::robotics::gazebotransport::TopicList* temp = payload_.topic_list_;
    payload_.topic_list_ = NULL;
    return temp;
  } else {
    return NULL;
  }
}
void Packet::set_allocated_topic_list(::mw::internal::robotics::gazebotransport::TopicList* topic_list) {
  clear_payload();
  if (topic_list) {
    set_has_topic_list();
    payload_.topic_list_ = topic_list;
  }
  // @@protoc_insertion_point(field_set_allocated:mw.internal.robotics.gazebotransport.Packet.topic_list)
}

// optional .mw.internal.robotics.gazebotransport.GetModelInfo get_model_info = 23;
bool Packet::has_get_model_info() const {
  return payload_case() == kGetModelInfo;
}
void Packet::set_has_get_model_info() {
  _oneof_case_[0] = kGetModelInfo;
}
void Packet::clear_get_model_info() {
  if (has_get_model_info()) {
    delete payload_.get_model_info_;
    clear_has_payload();
  }
}
 const ::mw::internal::robotics::gazebotransport::GetModelInfo& Packet::get_model_info() const {
  // @@protoc_insertion_point(field_get:mw.internal.robotics.gazebotransport.Packet.get_model_info)
  return has_get_model_info()
      ? *payload_.get_model_info_
      : ::mw::internal::robotics::gazebotransport::GetModelInfo::default_instance();
}
::mw::internal::robotics::gazebotransport::GetModelInfo* Packet::mutable_get_model_info() {
  if (!has_get_model_info()) {
    clear_payload();
    set_has_get_model_info();
    payload_.get_model_info_ = new ::mw::internal::robotics::gazebotransport::GetModelInfo;
  }
  // @@protoc_insertion_point(field_mutable:mw.internal.robotics.gazebotransport.Packet.get_model_info)
  return payload_.get_model_info_;
}
::mw::internal::robotics::gazebotransport::GetModelInfo* Packet::release_get_model_info() {
  // @@protoc_insertion_point(field_release:mw.internal.robotics.gazebotransport.Packet.get_model_info)
  if (has_get_model_info()) {
    clear_has_payload();
    ::mw::internal::robotics::gazebotransport::GetModelInfo* temp = payload_.get_model_info_;
    payload_.get_model_info_ = NULL;
    return temp;
  } else {
    return NULL;
  }
}
void Packet::set_allocated_get_model_info(::mw::internal::robotics::gazebotransport::GetModelInfo* get_model_info) {
  clear_payload();
  if (get_model_info) {
    set_has_get_model_info();
    payload_.get_model_info_ = get_model_info;
  }
  // @@protoc_insertion_point(field_set_allocated:mw.internal.robotics.gazebotransport.Packet.get_model_info)
}

// optional .mw.internal.robotics.gazebotransport.ModelInfo model_info = 24;
bool Packet::has_model_info() const {
  return payload_case() == kModelInfo;
}
void Packet::set_has_model_info() {
  _oneof_case_[0] = kModelInfo;
}
void Packet::clear_model_info() {
  if (has_model_info()) {
    delete payload_.model_info_;
    clear_has_payload();
  }
}
 const ::mw::internal::robotics::gazebotransport::ModelInfo& Packet::model_info() const {
  // @@protoc_insertion_point(field_get:mw.internal.robotics.gazebotransport.Packet.model_info)
  return has_model_info()
      ? *payload_.model_info_
      : ::mw::internal::robotics::gazebotransport::ModelInfo::default_instance();
}
::mw::internal::robotics::gazebotransport::ModelInfo* Packet::mutable_model_info() {
  if (!has_model_info()) {
    clear_payload();
    set_has_model_info();
    payload_.model_info_ = new ::mw::internal::robotics::gazebotransport::ModelInfo;
  }
  // @@protoc_insertion_point(field_mutable:mw.internal.robotics.gazebotransport.Packet.model_info)
  return payload_.model_info_;
}
::mw::internal::robotics::gazebotransport::ModelInfo* Packet::release_model_info() {
  // @@protoc_insertion_point(field_release:mw.internal.robotics.gazebotransport.Packet.model_info)
  if (has_model_info()) {
    clear_has_payload();
    ::mw::internal::robotics::gazebotransport::ModelInfo* temp = payload_.model_info_;
    payload_.model_info_ = NULL;
    return temp;
  } else {
    return NULL;
  }
}
void Packet::set_allocated_model_info(::mw::internal::robotics::gazebotransport::ModelInfo* model_info) {
  clear_payload();
  if (model_info) {
    set_has_model_info();
    payload_.model_info_ = model_info;
  }
  // @@protoc_insertion_point(field_set_allocated:mw.internal.robotics.gazebotransport.Packet.model_info)
}

// optional .mw.internal.robotics.gazebotransport.ApplyLinkWrench apply_link_wrench = 25;
bool Packet::has_apply_link_wrench() const {
  return payload_case() == kApplyLinkWrench;
}
void Packet::set_has_apply_link_wrench() {
  _oneof_case_[0] = kApplyLinkWrench;
}
void Packet::clear_apply_link_wrench() {
  if (has_apply_link_wrench()) {
    delete payload_.apply_link_wrench_;
    clear_has_payload();
  }
}
 const ::mw::internal::robotics::gazebotransport::ApplyLinkWrench& Packet::apply_link_wrench() const {
  // @@protoc_insertion_point(field_get:mw.internal.robotics.gazebotransport.Packet.apply_link_wrench)
  return has_apply_link_wrench()
      ? *payload_.apply_link_wrench_
      : ::mw::internal::robotics::gazebotransport::ApplyLinkWrench::default_instance();
}
::mw::internal::robotics::gazebotransport::ApplyLinkWrench* Packet::mutable_apply_link_wrench() {
  if (!has_apply_link_wrench()) {
    clear_payload();
    set_has_apply_link_wrench();
    payload_.apply_link_wrench_ = new ::mw::internal::robotics::gazebotransport::ApplyLinkWrench;
  }
  // @@protoc_insertion_point(field_mutable:mw.internal.robotics.gazebotransport.Packet.apply_link_wrench)
  return payload_.apply_link_wrench_;
}
::mw::internal::robotics::gazebotransport::ApplyLinkWrench* Packet::release_apply_link_wrench() {
  // @@protoc_insertion_point(field_release:mw.internal.robotics.gazebotransport.Packet.apply_link_wrench)
  if (has_apply_link_wrench()) {
    clear_has_payload();
    ::mw::internal::robotics::gazebotransport::ApplyLinkWrench* temp = payload_.apply_link_wrench_;
    payload_.apply_link_wrench_ = NULL;
    return temp;
  } else {
    return NULL;
  }
}
void Packet::set_allocated_apply_link_wrench(::mw::internal::robotics::gazebotransport::ApplyLinkWrench* apply_link_wrench) {
  clear_payload();
  if (apply_link_wrench) {
    set_has_apply_link_wrench();
    payload_.apply_link_wrench_ = apply_link_wrench;
  }
  // @@protoc_insertion_point(field_set_allocated:mw.internal.robotics.gazebotransport.Packet.apply_link_wrench)
}

// optional .mw.internal.robotics.gazebotransport.MaxStepSize max_step_size = 26;
bool Packet::has_max_step_size() const {
  return payload_case() == kMaxStepSize;
}
void Packet::set_has_max_step_size() {
  _oneof_case_[0] = kMaxStepSize;
}
void Packet::clear_max_step_size() {
  if (has_max_step_size()) {
    delete payload_.max_step_size_;
    clear_has_payload();
  }
}
 const ::mw::internal::robotics::gazebotransport::MaxStepSize& Packet::max_step_size() const {
  // @@protoc_insertion_point(field_get:mw.internal.robotics.gazebotransport.Packet.max_step_size)
  return has_max_step_size()
      ? *payload_.max_step_size_
      : ::mw::internal::robotics::gazebotransport::MaxStepSize::default_instance();
}
::mw::internal::robotics::gazebotransport::MaxStepSize* Packet::mutable_max_step_size() {
  if (!has_max_step_size()) {
    clear_payload();
    set_has_max_step_size();
    payload_.max_step_size_ = new ::mw::internal::robotics::gazebotransport::MaxStepSize;
  }
  // @@protoc_insertion_point(field_mutable:mw.internal.robotics.gazebotransport.Packet.max_step_size)
  return payload_.max_step_size_;
}
::mw::internal::robotics::gazebotransport::MaxStepSize* Packet::release_max_step_size() {
  // @@protoc_insertion_point(field_release:mw.internal.robotics.gazebotransport.Packet.max_step_size)
  if (has_max_step_size()) {
    clear_has_payload();
    ::mw::internal::robotics::gazebotransport::MaxStepSize* temp = payload_.max_step_size_;
    payload_.max_step_size_ = NULL;
    return temp;
  } else {
    return NULL;
  }
}
void Packet::set_allocated_max_step_size(::mw::internal::robotics::gazebotransport::MaxStepSize* max_step_size) {
  clear_payload();
  if (max_step_size) {
    set_has_max_step_size();
    payload_.max_step_size_ = max_step_size;
  }
  // @@protoc_insertion_point(field_set_allocated:mw.internal.robotics.gazebotransport.Packet.max_step_size)
}

// optional .mw.internal.robotics.gazebotransport.CustomMessageSupport custom_message_support = 27;
bool Packet::has_custom_message_support() const {
  return payload_case() == kCustomMessageSupport;
}
void Packet::set_has_custom_message_support() {
  _oneof_case_[0] = kCustomMessageSupport;
}
void Packet::clear_custom_message_support() {
  if (has_custom_message_support()) {
    delete payload_.custom_message_support_;
    clear_has_payload();
  }
}
 const ::mw::internal::robotics::gazebotransport::CustomMessageSupport& Packet::custom_message_support() const {
  // @@protoc_insertion_point(field_get:mw.internal.robotics.gazebotransport.Packet.custom_message_support)
  return has_custom_message_support()
      ? *payload_.custom_message_support_
      : ::mw::internal::robotics::gazebotransport::CustomMessageSupport::default_instance();
}
::mw::internal::robotics::gazebotransport::CustomMessageSupport* Packet::mutable_custom_message_support() {
  if (!has_custom_message_support()) {
    clear_payload();
    set_has_custom_message_support();
    payload_.custom_message_support_ = new ::mw::internal::robotics::gazebotransport::CustomMessageSupport;
  }
  // @@protoc_insertion_point(field_mutable:mw.internal.robotics.gazebotransport.Packet.custom_message_support)
  return payload_.custom_message_support_;
}
::mw::internal::robotics::gazebotransport::CustomMessageSupport* Packet::release_custom_message_support() {
  // @@protoc_insertion_point(field_release:mw.internal.robotics.gazebotransport.Packet.custom_message_support)
  if (has_custom_message_support()) {
    clear_has_payload();
    ::mw::internal::robotics::gazebotransport::CustomMessageSupport* temp = payload_.custom_message_support_;
    payload_.custom_message_support_ = NULL;
    return temp;
  } else {
    return NULL;
  }
}
void Packet::set_allocated_custom_message_support(::mw::internal::robotics::gazebotransport::CustomMessageSupport* custom_message_support) {
  clear_payload();
  if (custom_message_support) {
    set_has_custom_message_support();
    payload_.custom_message_support_ = custom_message_support;
  }
  // @@protoc_insertion_point(field_set_allocated:mw.internal.robotics.gazebotransport.Packet.custom_message_support)
}

// optional .mw.internal.robotics.gazebotransport.InitCustomPublisher init_custom_publisher = 28;
bool Packet::has_init_custom_publisher() const {
  return payload_case() == kInitCustomPublisher;
}
void Packet::set_has_init_custom_publisher() {
  _oneof_case_[0] = kInitCustomPublisher;
}
void Packet::clear_init_custom_publisher() {
  if (has_init_custom_publisher()) {
    delete payload_.init_custom_publisher_;
    clear_has_payload();
  }
}
 const ::mw::internal::robotics::gazebotransport::InitCustomPublisher& Packet::init_custom_publisher() const {
  // @@protoc_insertion_point(field_get:mw.internal.robotics.gazebotransport.Packet.init_custom_publisher)
  return has_init_custom_publisher()
      ? *payload_.init_custom_publisher_
      : ::mw::internal::robotics::gazebotransport::InitCustomPublisher::default_instance();
}
::mw::internal::robotics::gazebotransport::InitCustomPublisher* Packet::mutable_init_custom_publisher() {
  if (!has_init_custom_publisher()) {
    clear_payload();
    set_has_init_custom_publisher();
    payload_.init_custom_publisher_ = new ::mw::internal::robotics::gazebotransport::InitCustomPublisher;
  }
  // @@protoc_insertion_point(field_mutable:mw.internal.robotics.gazebotransport.Packet.init_custom_publisher)
  return payload_.init_custom_publisher_;
}
::mw::internal::robotics::gazebotransport::InitCustomPublisher* Packet::release_init_custom_publisher() {
  // @@protoc_insertion_point(field_release:mw.internal.robotics.gazebotransport.Packet.init_custom_publisher)
  if (has_init_custom_publisher()) {
    clear_has_payload();
    ::mw::internal::robotics::gazebotransport::InitCustomPublisher* temp = payload_.init_custom_publisher_;
    payload_.init_custom_publisher_ = NULL;
    return temp;
  } else {
    return NULL;
  }
}
void Packet::set_allocated_init_custom_publisher(::mw::internal::robotics::gazebotransport::InitCustomPublisher* init_custom_publisher) {
  clear_payload();
  if (init_custom_publisher) {
    set_has_init_custom_publisher();
    payload_.init_custom_publisher_ = init_custom_publisher;
  }
  // @@protoc_insertion_point(field_set_allocated:mw.internal.robotics.gazebotransport.Packet.init_custom_publisher)
}

// optional .mw.internal.robotics.gazebotransport.InitCustomSubscriber init_custom_subscriber = 29;
bool Packet::has_init_custom_subscriber() const {
  return payload_case() == kInitCustomSubscriber;
}
void Packet::set_has_init_custom_subscriber() {
  _oneof_case_[0] = kInitCustomSubscriber;
}
void Packet::clear_init_custom_subscriber() {
  if (has_init_custom_subscriber()) {
    delete payload_.init_custom_subscriber_;
    clear_has_payload();
  }
}
 const ::mw::internal::robotics::gazebotransport::InitCustomSubscriber& Packet::init_custom_subscriber() const {
  // @@protoc_insertion_point(field_get:mw.internal.robotics.gazebotransport.Packet.init_custom_subscriber)
  return has_init_custom_subscriber()
      ? *payload_.init_custom_subscriber_
      : ::mw::internal::robotics::gazebotransport::InitCustomSubscriber::default_instance();
}
::mw::internal::robotics::gazebotransport::InitCustomSubscriber* Packet::mutable_init_custom_subscriber() {
  if (!has_init_custom_subscriber()) {
    clear_payload();
    set_has_init_custom_subscriber();
    payload_.init_custom_subscriber_ = new ::mw::internal::robotics::gazebotransport::InitCustomSubscriber;
  }
  // @@protoc_insertion_point(field_mutable:mw.internal.robotics.gazebotransport.Packet.init_custom_subscriber)
  return payload_.init_custom_subscriber_;
}
::mw::internal::robotics::gazebotransport::InitCustomSubscriber* Packet::release_init_custom_subscriber() {
  // @@protoc_insertion_point(field_release:mw.internal.robotics.gazebotransport.Packet.init_custom_subscriber)
  if (has_init_custom_subscriber()) {
    clear_has_payload();
    ::mw::internal::robotics::gazebotransport::InitCustomSubscriber* temp = payload_.init_custom_subscriber_;
    payload_.init_custom_subscriber_ = NULL;
    return temp;
  } else {
    return NULL;
  }
}
void Packet::set_allocated_init_custom_subscriber(::mw::internal::robotics::gazebotransport::InitCustomSubscriber* init_custom_subscriber) {
  clear_payload();
  if (init_custom_subscriber) {
    set_has_init_custom_subscriber();
    payload_.init_custom_subscriber_ = init_custom_subscriber;
  }
  // @@protoc_insertion_point(field_set_allocated:mw.internal.robotics.gazebotransport.Packet.init_custom_subscriber)
}

// optional .mw.internal.robotics.gazebotransport.RequestCustomMessageSupport request_custom_message_support = 30;
bool Packet::has_request_custom_message_support() const {
  return payload_case() == kRequestCustomMessageSupport;
}
void Packet::set_has_request_custom_message_support() {
  _oneof_case_[0] = kRequestCustomMessageSupport;
}
void Packet::clear_request_custom_message_support() {
  if (has_request_custom_message_support()) {
    delete payload_.request_custom_message_support_;
    clear_has_payload();
  }
}
 const ::mw::internal::robotics::gazebotransport::RequestCustomMessageSupport& Packet::request_custom_message_support() const {
  // @@protoc_insertion_point(field_get:mw.internal.robotics.gazebotransport.Packet.request_custom_message_support)
  return has_request_custom_message_support()
      ? *payload_.request_custom_message_support_
      : ::mw::internal::robotics::gazebotransport::RequestCustomMessageSupport::default_instance();
}
::mw::internal::robotics::gazebotransport::RequestCustomMessageSupport* Packet::mutable_request_custom_message_support() {
  if (!has_request_custom_message_support()) {
    clear_payload();
    set_has_request_custom_message_support();
    payload_.request_custom_message_support_ = new ::mw::internal::robotics::gazebotransport::RequestCustomMessageSupport;
  }
  // @@protoc_insertion_point(field_mutable:mw.internal.robotics.gazebotransport.Packet.request_custom_message_support)
  return payload_.request_custom_message_support_;
}
::mw::internal::robotics::gazebotransport::RequestCustomMessageSupport* Packet::release_request_custom_message_support() {
  // @@protoc_insertion_point(field_release:mw.internal.robotics.gazebotransport.Packet.request_custom_message_support)
  if (has_request_custom_message_support()) {
    clear_has_payload();
    ::mw::internal::robotics::gazebotransport::RequestCustomMessageSupport* temp = payload_.request_custom_message_support_;
    payload_.request_custom_message_support_ = NULL;
    return temp;
  } else {
    return NULL;
  }
}
void Packet::set_allocated_request_custom_message_support(::mw::internal::robotics::gazebotransport::RequestCustomMessageSupport* request_custom_message_support) {
  clear_payload();
  if (request_custom_message_support) {
    set_has_request_custom_message_support();
    payload_.request_custom_message_support_ = request_custom_message_support;
  }
  // @@protoc_insertion_point(field_set_allocated:mw.internal.robotics.gazebotransport.Packet.request_custom_message_support)
}

// optional .mw.internal.robotics.gazebotransport.SetJointPosition set_joint_position = 31;
bool Packet::has_set_joint_position() const {
  return payload_case() == kSetJointPosition;
}
void Packet::set_has_set_joint_position() {
  _oneof_case_[0] = kSetJointPosition;
}
void Packet::clear_set_joint_position() {
  if (has_set_joint_position()) {
    delete payload_.set_joint_position_;
    clear_has_payload();
  }
}
 const ::mw::internal::robotics::gazebotransport::SetJointPosition& Packet::set_joint_position() const {
  // @@protoc_insertion_point(field_get:mw.internal.robotics.gazebotransport.Packet.set_joint_position)
  return has_set_joint_position()
      ? *payload_.set_joint_position_
      : ::mw::internal::robotics::gazebotransport::SetJointPosition::default_instance();
}
::mw::internal::robotics::gazebotransport::SetJointPosition* Packet::mutable_set_joint_position() {
  if (!has_set_joint_position()) {
    clear_payload();
    set_has_set_joint_position();
    payload_.set_joint_position_ = new ::mw::internal::robotics::gazebotransport::SetJointPosition;
  }
  // @@protoc_insertion_point(field_mutable:mw.internal.robotics.gazebotransport.Packet.set_joint_position)
  return payload_.set_joint_position_;
}
::mw::internal::robotics::gazebotransport::SetJointPosition* Packet::release_set_joint_position() {
  // @@protoc_insertion_point(field_release:mw.internal.robotics.gazebotransport.Packet.set_joint_position)
  if (has_set_joint_position()) {
    clear_has_payload();
    ::mw::internal::robotics::gazebotransport::SetJointPosition* temp = payload_.set_joint_position_;
    payload_.set_joint_position_ = NULL;
    return temp;
  } else {
    return NULL;
  }
}
void Packet::set_allocated_set_joint_position(::mw::internal::robotics::gazebotransport::SetJointPosition* set_joint_position) {
  clear_payload();
  if (set_joint_position) {
    set_has_set_joint_position();
    payload_.set_joint_position_ = set_joint_position;
  }
  // @@protoc_insertion_point(field_set_allocated:mw.internal.robotics.gazebotransport.Packet.set_joint_position)
}

// optional .mw.internal.robotics.gazebotransport.SetJointVelocity set_joint_velocity = 32;
bool Packet::has_set_joint_velocity() const {
  return payload_case() == kSetJointVelocity;
}
void Packet::set_has_set_joint_velocity() {
  _oneof_case_[0] = kSetJointVelocity;
}
void Packet::clear_set_joint_velocity() {
  if (has_set_joint_velocity()) {
    delete payload_.set_joint_velocity_;
    clear_has_payload();
  }
}
 const ::mw::internal::robotics::gazebotransport::SetJointVelocity& Packet::set_joint_velocity() const {
  // @@protoc_insertion_point(field_get:mw.internal.robotics.gazebotransport.Packet.set_joint_velocity)
  return has_set_joint_velocity()
      ? *payload_.set_joint_velocity_
      : ::mw::internal::robotics::gazebotransport::SetJointVelocity::default_instance();
}
::mw::internal::robotics::gazebotransport::SetJointVelocity* Packet::mutable_set_joint_velocity() {
  if (!has_set_joint_velocity()) {
    clear_payload();
    set_has_set_joint_velocity();
    payload_.set_joint_velocity_ = new ::mw::internal::robotics::gazebotransport::SetJointVelocity;
  }
  // @@protoc_insertion_point(field_mutable:mw.internal.robotics.gazebotransport.Packet.set_joint_velocity)
  return payload_.set_joint_velocity_;
}
::mw::internal::robotics::gazebotransport::SetJointVelocity* Packet::release_set_joint_velocity() {
  // @@protoc_insertion_point(field_release:mw.internal.robotics.gazebotransport.Packet.set_joint_velocity)
  if (has_set_joint_velocity()) {
    clear_has_payload();
    ::mw::internal::robotics::gazebotransport::SetJointVelocity* temp = payload_.set_joint_velocity_;
    payload_.set_joint_velocity_ = NULL;
    return temp;
  } else {
    return NULL;
  }
}
void Packet::set_allocated_set_joint_velocity(::mw::internal::robotics::gazebotransport::SetJointVelocity* set_joint_velocity) {
  clear_payload();
  if (set_joint_velocity) {
    set_has_set_joint_velocity();
    payload_.set_joint_velocity_ = set_joint_velocity;
  }
  // @@protoc_insertion_point(field_set_allocated:mw.internal.robotics.gazebotransport.Packet.set_joint_velocity)
}

// optional .mw.internal.robotics.gazebotransport.GetJointState get_joint_state = 33;
bool Packet::has_get_joint_state() const {
  return payload_case() == kGetJointState;
}
void Packet::set_has_get_joint_state() {
  _oneof_case_[0] = kGetJointState;
}
void Packet::clear_get_joint_state() {
  if (has_get_joint_state()) {
    delete payload_.get_joint_state_;
    clear_has_payload();
  }
}
 const ::mw::internal::robotics::gazebotransport::GetJointState& Packet::get_joint_state() const {
  // @@protoc_insertion_point(field_get:mw.internal.robotics.gazebotransport.Packet.get_joint_state)
  return has_get_joint_state()
      ? *payload_.get_joint_state_
      : ::mw::internal::robotics::gazebotransport::GetJointState::default_instance();
}
::mw::internal::robotics::gazebotransport::GetJointState* Packet::mutable_get_joint_state() {
  if (!has_get_joint_state()) {
    clear_payload();
    set_has_get_joint_state();
    payload_.get_joint_state_ = new ::mw::internal::robotics::gazebotransport::GetJointState;
  }
  // @@protoc_insertion_point(field_mutable:mw.internal.robotics.gazebotransport.Packet.get_joint_state)
  return payload_.get_joint_state_;
}
::mw::internal::robotics::gazebotransport::GetJointState* Packet::release_get_joint_state() {
  // @@protoc_insertion_point(field_release:mw.internal.robotics.gazebotransport.Packet.get_joint_state)
  if (has_get_joint_state()) {
    clear_has_payload();
    ::mw::internal::robotics::gazebotransport::GetJointState* temp = payload_.get_joint_state_;
    payload_.get_joint_state_ = NULL;
    return temp;
  } else {
    return NULL;
  }
}
void Packet::set_allocated_get_joint_state(::mw::internal::robotics::gazebotransport::GetJointState* get_joint_state) {
  clear_payload();
  if (get_joint_state) {
    set_has_get_joint_state();
    payload_.get_joint_state_ = get_joint_state;
  }
  // @@protoc_insertion_point(field_set_allocated:mw.internal.robotics.gazebotransport.Packet.get_joint_state)
}

// optional .mw.internal.robotics.gazebotransport.JointState joint_state = 34;
bool Packet::has_joint_state() const {
  return payload_case() == kJointState;
}
void Packet::set_has_joint_state() {
  _oneof_case_[0] = kJointState;
}
void Packet::clear_joint_state() {
  if (has_joint_state()) {
    delete payload_.joint_state_;
    clear_has_payload();
  }
}
 const ::mw::internal::robotics::gazebotransport::JointState& Packet::joint_state() const {
  // @@protoc_insertion_point(field_get:mw.internal.robotics.gazebotransport.Packet.joint_state)
  return has_joint_state()
      ? *payload_.joint_state_
      : ::mw::internal::robotics::gazebotransport::JointState::default_instance();
}
::mw::internal::robotics::gazebotransport::JointState* Packet::mutable_joint_state() {
  if (!has_joint_state()) {
    clear_payload();
    set_has_joint_state();
    payload_.joint_state_ = new ::mw::internal::robotics::gazebotransport::JointState;
  }
  // @@protoc_insertion_point(field_mutable:mw.internal.robotics.gazebotransport.Packet.joint_state)
  return payload_.joint_state_;
}
::mw::internal::robotics::gazebotransport::JointState* Packet::release_joint_state() {
  // @@protoc_insertion_point(field_release:mw.internal.robotics.gazebotransport.Packet.joint_state)
  if (has_joint_state()) {
    clear_has_payload();
    ::mw::internal::robotics::gazebotransport::JointState* temp = payload_.joint_state_;
    payload_.joint_state_ = NULL;
    return temp;
  } else {
    return NULL;
  }
}
void Packet::set_allocated_joint_state(::mw::internal::robotics::gazebotransport::JointState* joint_state) {
  clear_payload();
  if (joint_state) {
    set_has_joint_state();
    payload_.joint_state_ = joint_state;
  }
  // @@protoc_insertion_point(field_set_allocated:mw.internal.robotics.gazebotransport.Packet.joint_state)
}

// optional .mw.internal.robotics.gazebotransport.SetLinkWorldPose set_link_world_pose = 35;
bool Packet::has_set_link_world_pose() const {
  return payload_case() == kSetLinkWorldPose;
}
void Packet::set_has_set_link_world_pose() {
  _oneof_case_[0] = kSetLinkWorldPose;
}
void Packet::clear_set_link_world_pose() {
  if (has_set_link_world_pose()) {
    delete payload_.set_link_world_pose_;
    clear_has_payload();
  }
}
 const ::mw::internal::robotics::gazebotransport::SetLinkWorldPose& Packet::set_link_world_pose() const {
  // @@protoc_insertion_point(field_get:mw.internal.robotics.gazebotransport.Packet.set_link_world_pose)
  return has_set_link_world_pose()
      ? *payload_.set_link_world_pose_
      : ::mw::internal::robotics::gazebotransport::SetLinkWorldPose::default_instance();
}
::mw::internal::robotics::gazebotransport::SetLinkWorldPose* Packet::mutable_set_link_world_pose() {
  if (!has_set_link_world_pose()) {
    clear_payload();
    set_has_set_link_world_pose();
    payload_.set_link_world_pose_ = new ::mw::internal::robotics::gazebotransport::SetLinkWorldPose;
  }
  // @@protoc_insertion_point(field_mutable:mw.internal.robotics.gazebotransport.Packet.set_link_world_pose)
  return payload_.set_link_world_pose_;
}
::mw::internal::robotics::gazebotransport::SetLinkWorldPose* Packet::release_set_link_world_pose() {
  // @@protoc_insertion_point(field_release:mw.internal.robotics.gazebotransport.Packet.set_link_world_pose)
  if (has_set_link_world_pose()) {
    clear_has_payload();
    ::mw::internal::robotics::gazebotransport::SetLinkWorldPose* temp = payload_.set_link_world_pose_;
    payload_.set_link_world_pose_ = NULL;
    return temp;
  } else {
    return NULL;
  }
}
void Packet::set_allocated_set_link_world_pose(::mw::internal::robotics::gazebotransport::SetLinkWorldPose* set_link_world_pose) {
  clear_payload();
  if (set_link_world_pose) {
    set_has_set_link_world_pose();
    payload_.set_link_world_pose_ = set_link_world_pose;
  }
  // @@protoc_insertion_point(field_set_allocated:mw.internal.robotics.gazebotransport.Packet.set_link_world_pose)
}

// optional .mw.internal.robotics.gazebotransport.SetLinkLinearVelocity set_link_linear_velocity = 36;
bool Packet::has_set_link_linear_velocity() const {
  return payload_case() == kSetLinkLinearVelocity;
}
void Packet::set_has_set_link_linear_velocity() {
  _oneof_case_[0] = kSetLinkLinearVelocity;
}
void Packet::clear_set_link_linear_velocity() {
  if (has_set_link_linear_velocity()) {
    delete payload_.set_link_linear_velocity_;
    clear_has_payload();
  }
}
 const ::mw::internal::robotics::gazebotransport::SetLinkLinearVelocity& Packet::set_link_linear_velocity() const {
  // @@protoc_insertion_point(field_get:mw.internal.robotics.gazebotransport.Packet.set_link_linear_velocity)
  return has_set_link_linear_velocity()
      ? *payload_.set_link_linear_velocity_
      : ::mw::internal::robotics::gazebotransport::SetLinkLinearVelocity::default_instance();
}
::mw::internal::robotics::gazebotransport::SetLinkLinearVelocity* Packet::mutable_set_link_linear_velocity() {
  if (!has_set_link_linear_velocity()) {
    clear_payload();
    set_has_set_link_linear_velocity();
    payload_.set_link_linear_velocity_ = new ::mw::internal::robotics::gazebotransport::SetLinkLinearVelocity;
  }
  // @@protoc_insertion_point(field_mutable:mw.internal.robotics.gazebotransport.Packet.set_link_linear_velocity)
  return payload_.set_link_linear_velocity_;
}
::mw::internal::robotics::gazebotransport::SetLinkLinearVelocity* Packet::release_set_link_linear_velocity() {
  // @@protoc_insertion_point(field_release:mw.internal.robotics.gazebotransport.Packet.set_link_linear_velocity)
  if (has_set_link_linear_velocity()) {
    clear_has_payload();
    ::mw::internal::robotics::gazebotransport::SetLinkLinearVelocity* temp = payload_.set_link_linear_velocity_;
    payload_.set_link_linear_velocity_ = NULL;
    return temp;
  } else {
    return NULL;
  }
}
void Packet::set_allocated_set_link_linear_velocity(::mw::internal::robotics::gazebotransport::SetLinkLinearVelocity* set_link_linear_velocity) {
  clear_payload();
  if (set_link_linear_velocity) {
    set_has_set_link_linear_velocity();
    payload_.set_link_linear_velocity_ = set_link_linear_velocity;
  }
  // @@protoc_insertion_point(field_set_allocated:mw.internal.robotics.gazebotransport.Packet.set_link_linear_velocity)
}

// optional .mw.internal.robotics.gazebotransport.SetLinkAngularVelocity set_link_angular_velocity = 37;
bool Packet::has_set_link_angular_velocity() const {
  return payload_case() == kSetLinkAngularVelocity;
}
void Packet::set_has_set_link_angular_velocity() {
  _oneof_case_[0] = kSetLinkAngularVelocity;
}
void Packet::clear_set_link_angular_velocity() {
  if (has_set_link_angular_velocity()) {
    delete payload_.set_link_angular_velocity_;
    clear_has_payload();
  }
}
 const ::mw::internal::robotics::gazebotransport::SetLinkAngularVelocity& Packet::set_link_angular_velocity() const {
  // @@protoc_insertion_point(field_get:mw.internal.robotics.gazebotransport.Packet.set_link_angular_velocity)
  return has_set_link_angular_velocity()
      ? *payload_.set_link_angular_velocity_
      : ::mw::internal::robotics::gazebotransport::SetLinkAngularVelocity::default_instance();
}
::mw::internal::robotics::gazebotransport::SetLinkAngularVelocity* Packet::mutable_set_link_angular_velocity() {
  if (!has_set_link_angular_velocity()) {
    clear_payload();
    set_has_set_link_angular_velocity();
    payload_.set_link_angular_velocity_ = new ::mw::internal::robotics::gazebotransport::SetLinkAngularVelocity;
  }
  // @@protoc_insertion_point(field_mutable:mw.internal.robotics.gazebotransport.Packet.set_link_angular_velocity)
  return payload_.set_link_angular_velocity_;
}
::mw::internal::robotics::gazebotransport::SetLinkAngularVelocity* Packet::release_set_link_angular_velocity() {
  // @@protoc_insertion_point(field_release:mw.internal.robotics.gazebotransport.Packet.set_link_angular_velocity)
  if (has_set_link_angular_velocity()) {
    clear_has_payload();
    ::mw::internal::robotics::gazebotransport::SetLinkAngularVelocity* temp = payload_.set_link_angular_velocity_;
    payload_.set_link_angular_velocity_ = NULL;
    return temp;
  } else {
    return NULL;
  }
}
void Packet::set_allocated_set_link_angular_velocity(::mw::internal::robotics::gazebotransport::SetLinkAngularVelocity* set_link_angular_velocity) {
  clear_payload();
  if (set_link_angular_velocity) {
    set_has_set_link_angular_velocity();
    payload_.set_link_angular_velocity_ = set_link_angular_velocity;
  }
  // @@protoc_insertion_point(field_set_allocated:mw.internal.robotics.gazebotransport.Packet.set_link_angular_velocity)
}

// optional .mw.internal.robotics.gazebotransport.GetLinkState get_link_state = 38;
bool Packet::has_get_link_state() const {
  return payload_case() == kGetLinkState;
}
void Packet::set_has_get_link_state() {
  _oneof_case_[0] = kGetLinkState;
}
void Packet::clear_get_link_state() {
  if (has_get_link_state()) {
    delete payload_.get_link_state_;
    clear_has_payload();
  }
}
 const ::mw::internal::robotics::gazebotransport::GetLinkState& Packet::get_link_state() const {
  // @@protoc_insertion_point(field_get:mw.internal.robotics.gazebotransport.Packet.get_link_state)
  return has_get_link_state()
      ? *payload_.get_link_state_
      : ::mw::internal::robotics::gazebotransport::GetLinkState::default_instance();
}
::mw::internal::robotics::gazebotransport::GetLinkState* Packet::mutable_get_link_state() {
  if (!has_get_link_state()) {
    clear_payload();
    set_has_get_link_state();
    payload_.get_link_state_ = new ::mw::internal::robotics::gazebotransport::GetLinkState;
  }
  // @@protoc_insertion_point(field_mutable:mw.internal.robotics.gazebotransport.Packet.get_link_state)
  return payload_.get_link_state_;
}
::mw::internal::robotics::gazebotransport::GetLinkState* Packet::release_get_link_state() {
  // @@protoc_insertion_point(field_release:mw.internal.robotics.gazebotransport.Packet.get_link_state)
  if (has_get_link_state()) {
    clear_has_payload();
    ::mw::internal::robotics::gazebotransport::GetLinkState* temp = payload_.get_link_state_;
    payload_.get_link_state_ = NULL;
    return temp;
  } else {
    return NULL;
  }
}
void Packet::set_allocated_get_link_state(::mw::internal::robotics::gazebotransport::GetLinkState* get_link_state) {
  clear_payload();
  if (get_link_state) {
    set_has_get_link_state();
    payload_.get_link_state_ = get_link_state;
  }
  // @@protoc_insertion_point(field_set_allocated:mw.internal.robotics.gazebotransport.Packet.get_link_state)
}

// optional .mw.internal.robotics.gazebotransport.LinkState link_state = 39;
bool Packet::has_link_state() const {
  return payload_case() == kLinkState;
}
void Packet::set_has_link_state() {
  _oneof_case_[0] = kLinkState;
}
void Packet::clear_link_state() {
  if (has_link_state()) {
    delete payload_.link_state_;
    clear_has_payload();
  }
}
 const ::mw::internal::robotics::gazebotransport::LinkState& Packet::link_state() const {
  // @@protoc_insertion_point(field_get:mw.internal.robotics.gazebotransport.Packet.link_state)
  return has_link_state()
      ? *payload_.link_state_
      : ::mw::internal::robotics::gazebotransport::LinkState::default_instance();
}
::mw::internal::robotics::gazebotransport::LinkState* Packet::mutable_link_state() {
  if (!has_link_state()) {
    clear_payload();
    set_has_link_state();
    payload_.link_state_ = new ::mw::internal::robotics::gazebotransport::LinkState;
  }
  // @@protoc_insertion_point(field_mutable:mw.internal.robotics.gazebotransport.Packet.link_state)
  return payload_.link_state_;
}
::mw::internal::robotics::gazebotransport::LinkState* Packet::release_link_state() {
  // @@protoc_insertion_point(field_release:mw.internal.robotics.gazebotransport.Packet.link_state)
  if (has_link_state()) {
    clear_has_payload();
    ::mw::internal::robotics::gazebotransport::LinkState* temp = payload_.link_state_;
    payload_.link_state_ = NULL;
    return temp;
  } else {
    return NULL;
  }
}
void Packet::set_allocated_link_state(::mw::internal::robotics::gazebotransport::LinkState* link_state) {
  clear_payload();
  if (link_state) {
    set_has_link_state();
    payload_.link_state_ = link_state;
  }
  // @@protoc_insertion_point(field_set_allocated:mw.internal.robotics.gazebotransport.Packet.link_state)
}

// optional .mw.internal.robotics.gazebotransport.Gazebomodel gazebo_model = 40;
bool Packet::has_gazebo_model() const {
  return payload_case() == kGazeboModel;
}
void Packet::set_has_gazebo_model() {
  _oneof_case_[0] = kGazeboModel;
}
void Packet::clear_gazebo_model() {
  if (has_gazebo_model()) {
    delete payload_.gazebo_model_;
    clear_has_payload();
  }
}
 const ::mw::internal::robotics::gazebotransport::Gazebomodel& Packet::gazebo_model() const {
  // @@protoc_insertion_point(field_get:mw.internal.robotics.gazebotransport.Packet.gazebo_model)
  return has_gazebo_model()
      ? *payload_.gazebo_model_
      : ::mw::internal::robotics::gazebotransport::Gazebomodel::default_instance();
}
::mw::internal::robotics::gazebotransport::Gazebomodel* Packet::mutable_gazebo_model() {
  if (!has_gazebo_model()) {
    clear_payload();
    set_has_gazebo_model();
    payload_.gazebo_model_ = new ::mw::internal::robotics::gazebotransport::Gazebomodel;
  }
  // @@protoc_insertion_point(field_mutable:mw.internal.robotics.gazebotransport.Packet.gazebo_model)
  return payload_.gazebo_model_;
}
::mw::internal::robotics::gazebotransport::Gazebomodel* Packet::release_gazebo_model() {
  // @@protoc_insertion_point(field_release:mw.internal.robotics.gazebotransport.Packet.gazebo_model)
  if (has_gazebo_model()) {
    clear_has_payload();
    ::mw::internal::robotics::gazebotransport::Gazebomodel* temp = payload_.gazebo_model_;
    payload_.gazebo_model_ = NULL;
    return temp;
  } else {
    return NULL;
  }
}
void Packet::set_allocated_gazebo_model(::mw::internal::robotics::gazebotransport::Gazebomodel* gazebo_model) {
  clear_payload();
  if (gazebo_model) {
    set_has_gazebo_model();
    payload_.gazebo_model_ = gazebo_model;
  }
  // @@protoc_insertion_point(field_set_allocated:mw.internal.robotics.gazebotransport.Packet.gazebo_model)
}

// optional .mw.internal.robotics.gazebotransport.GetGazeboModelParam get_gazebo_model_param = 41;
bool Packet::has_get_gazebo_model_param() const {
  return payload_case() == kGetGazeboModelParam;
}
void Packet::set_has_get_gazebo_model_param() {
  _oneof_case_[0] = kGetGazeboModelParam;
}
void Packet::clear_get_gazebo_model_param() {
  if (has_get_gazebo_model_param()) {
    delete payload_.get_gazebo_model_param_;
    clear_has_payload();
  }
}
 const ::mw::internal::robotics::gazebotransport::GetGazeboModelParam& Packet::get_gazebo_model_param() const {
  // @@protoc_insertion_point(field_get:mw.internal.robotics.gazebotransport.Packet.get_gazebo_model_param)
  return has_get_gazebo_model_param()
      ? *payload_.get_gazebo_model_param_
      : ::mw::internal::robotics::gazebotransport::GetGazeboModelParam::default_instance();
}
::mw::internal::robotics::gazebotransport::GetGazeboModelParam* Packet::mutable_get_gazebo_model_param() {
  if (!has_get_gazebo_model_param()) {
    clear_payload();
    set_has_get_gazebo_model_param();
    payload_.get_gazebo_model_param_ = new ::mw::internal::robotics::gazebotransport::GetGazeboModelParam;
  }
  // @@protoc_insertion_point(field_mutable:mw.internal.robotics.gazebotransport.Packet.get_gazebo_model_param)
  return payload_.get_gazebo_model_param_;
}
::mw::internal::robotics::gazebotransport::GetGazeboModelParam* Packet::release_get_gazebo_model_param() {
  // @@protoc_insertion_point(field_release:mw.internal.robotics.gazebotransport.Packet.get_gazebo_model_param)
  if (has_get_gazebo_model_param()) {
    clear_has_payload();
    ::mw::internal::robotics::gazebotransport::GetGazeboModelParam* temp = payload_.get_gazebo_model_param_;
    payload_.get_gazebo_model_param_ = NULL;
    return temp;
  } else {
    return NULL;
  }
}
void Packet::set_allocated_get_gazebo_model_param(::mw::internal::robotics::gazebotransport::GetGazeboModelParam* get_gazebo_model_param) {
  clear_payload();
  if (get_gazebo_model_param) {
    set_has_get_gazebo_model_param();
    payload_.get_gazebo_model_param_ = get_gazebo_model_param;
  }
  // @@protoc_insertion_point(field_set_allocated:mw.internal.robotics.gazebotransport.Packet.get_gazebo_model_param)
}

// optional .mw.internal.robotics.gazebotransport.GazeboModelSDF gazebo_model_sdf = 42;
bool Packet::has_gazebo_model_sdf() const {
  return payload_case() == kGazeboModelSdf;
}
void Packet::set_has_gazebo_model_sdf() {
  _oneof_case_[0] = kGazeboModelSdf;
}
void Packet::clear_gazebo_model_sdf() {
  if (has_gazebo_model_sdf()) {
    delete payload_.gazebo_model_sdf_;
    clear_has_payload();
  }
}
 const ::mw::internal::robotics::gazebotransport::GazeboModelSDF& Packet::gazebo_model_sdf() const {
  // @@protoc_insertion_point(field_get:mw.internal.robotics.gazebotransport.Packet.gazebo_model_sdf)
  return has_gazebo_model_sdf()
      ? *payload_.gazebo_model_sdf_
      : ::mw::internal::robotics::gazebotransport::GazeboModelSDF::default_instance();
}
::mw::internal::robotics::gazebotransport::GazeboModelSDF* Packet::mutable_gazebo_model_sdf() {
  if (!has_gazebo_model_sdf()) {
    clear_payload();
    set_has_gazebo_model_sdf();
    payload_.gazebo_model_sdf_ = new ::mw::internal::robotics::gazebotransport::GazeboModelSDF;
  }
  // @@protoc_insertion_point(field_mutable:mw.internal.robotics.gazebotransport.Packet.gazebo_model_sdf)
  return payload_.gazebo_model_sdf_;
}
::mw::internal::robotics::gazebotransport::GazeboModelSDF* Packet::release_gazebo_model_sdf() {
  // @@protoc_insertion_point(field_release:mw.internal.robotics.gazebotransport.Packet.gazebo_model_sdf)
  if (has_gazebo_model_sdf()) {
    clear_has_payload();
    ::mw::internal::robotics::gazebotransport::GazeboModelSDF* temp = payload_.gazebo_model_sdf_;
    payload_.gazebo_model_sdf_ = NULL;
    return temp;
  } else {
    return NULL;
  }
}
void Packet::set_allocated_gazebo_model_sdf(::mw::internal::robotics::gazebotransport::GazeboModelSDF* gazebo_model_sdf) {
  clear_payload();
  if (gazebo_model_sdf) {
    set_has_gazebo_model_sdf();
    payload_.gazebo_model_sdf_ = gazebo_model_sdf;
  }
  // @@protoc_insertion_point(field_set_allocated:mw.internal.robotics.gazebotransport.Packet.gazebo_model_sdf)
}

// optional .mw.internal.robotics.gazebotransport.GetGazeboModelSDF get_gazebo_model_sdf = 43;
bool Packet::has_get_gazebo_model_sdf() const {
  return payload_case() == kGetGazeboModelSdf;
}
void Packet::set_has_get_gazebo_model_sdf() {
  _oneof_case_[0] = kGetGazeboModelSdf;
}
void Packet::clear_get_gazebo_model_sdf() {
  if (has_get_gazebo_model_sdf()) {
    delete payload_.get_gazebo_model_sdf_;
    clear_has_payload();
  }
}
 const ::mw::internal::robotics::gazebotransport::GetGazeboModelSDF& Packet::get_gazebo_model_sdf() const {
  // @@protoc_insertion_point(field_get:mw.internal.robotics.gazebotransport.Packet.get_gazebo_model_sdf)
  return has_get_gazebo_model_sdf()
      ? *payload_.get_gazebo_model_sdf_
      : ::mw::internal::robotics::gazebotransport::GetGazeboModelSDF::default_instance();
}
::mw::internal::robotics::gazebotransport::GetGazeboModelSDF* Packet::mutable_get_gazebo_model_sdf() {
  if (!has_get_gazebo_model_sdf()) {
    clear_payload();
    set_has_get_gazebo_model_sdf();
    payload_.get_gazebo_model_sdf_ = new ::mw::internal::robotics::gazebotransport::GetGazeboModelSDF;
  }
  // @@protoc_insertion_point(field_mutable:mw.internal.robotics.gazebotransport.Packet.get_gazebo_model_sdf)
  return payload_.get_gazebo_model_sdf_;
}
::mw::internal::robotics::gazebotransport::GetGazeboModelSDF* Packet::release_get_gazebo_model_sdf() {
  // @@protoc_insertion_point(field_release:mw.internal.robotics.gazebotransport.Packet.get_gazebo_model_sdf)
  if (has_get_gazebo_model_sdf()) {
    clear_has_payload();
    ::mw::internal::robotics::gazebotransport::GetGazeboModelSDF* temp = payload_.get_gazebo_model_sdf_;
    payload_.get_gazebo_model_sdf_ = NULL;
    return temp;
  } else {
    return NULL;
  }
}
void Packet::set_allocated_get_gazebo_model_sdf(::mw::internal::robotics::gazebotransport::GetGazeboModelSDF* get_gazebo_model_sdf) {
  clear_payload();
  if (get_gazebo_model_sdf) {
    set_has_get_gazebo_model_sdf();
    payload_.get_gazebo_model_sdf_ = get_gazebo_model_sdf;
  }
  // @@protoc_insertion_point(field_set_allocated:mw.internal.robotics.gazebotransport.Packet.get_gazebo_model_sdf)
}

// optional string error_message = 44;
bool Packet::has_error_message() const {
  return (_has_bits_[1] & 0x00000800u) != 0;
}
void Packet::set_has_error_message() {
  _has_bits_[1] |= 0x00000800u;
}
void Packet::clear_has_error_message() {
  _has_bits_[1] &= ~0x00000800u;
}
void Packet::clear_error_message() {
  error_message_.ClearToEmptyNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
  clear_has_error_message();
}
 const ::std::string& Packet::error_message() const {
  // @@protoc_insertion_point(field_get:mw.internal.robotics.gazebotransport.Packet.error_message)
  return error_message_.GetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
 void Packet::set_error_message(const ::std::string& value) {
  set_has_error_message();
  error_message_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), value);
  // @@protoc_insertion_point(field_set:mw.internal.robotics.gazebotransport.Packet.error_message)
}
 void Packet::set_error_message(const char* value) {
  set_has_error_message();
  error_message_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::string(value));
  // @@protoc_insertion_point(field_set_char:mw.internal.robotics.gazebotransport.Packet.error_message)
}
 void Packet::set_error_message(const char* value, size_t size) {
  set_has_error_message();
  error_message_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(),
      ::std::string(reinterpret_cast<const char*>(value), size));
  // @@protoc_insertion_point(field_set_pointer:mw.internal.robotics.gazebotransport.Packet.error_message)
}
 ::std::string* Packet::mutable_error_message() {
  set_has_error_message();
  // @@protoc_insertion_point(field_mutable:mw.internal.robotics.gazebotransport.Packet.error_message)
  return error_message_.MutableNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
 ::std::string* Packet::release_error_message() {
  // @@protoc_insertion_point(field_release:mw.internal.robotics.gazebotransport.Packet.error_message)
  clear_has_error_message();
  return error_message_.ReleaseNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
 void Packet::set_allocated_error_message(::std::string* error_message) {
  if (error_message != NULL) {
    set_has_error_message();
  } else {
    clear_has_error_message();
  }
  error_message_.SetAllocatedNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), error_message);
  // @@protoc_insertion_point(field_set_allocated:mw.internal.robotics.gazebotransport.Packet.error_message)
}

bool Packet::has_payload() const {
  return payload_case() != PAYLOAD_NOT_SET;
}
void Packet::clear_has_payload() {
  _oneof_case_[0] = PAYLOAD_NOT_SET;
}
Packet::PayloadCase Packet::payload_case() const {
  return Packet::PayloadCase(_oneof_case_[0]);
}
#endif  // PROTOBUF_INLINE_NOT_IN_HEADERS

// ===================================================================

#if !defined(_MSC_VER) || _MSC_VER >= 1900
const int StepSimulation::kNumStepsFieldNumber;
#endif  // !defined(_MSC_VER) || _MSC_VER >= 1900

StepSimulation::StepSimulation()
  : ::google::protobuf::Message(), _internal_metadata_(NULL) {
  SharedCtor();
  // @@protoc_insertion_point(constructor:mw.internal.robotics.gazebotransport.StepSimulation)
}

void StepSimulation::InitAsDefaultInstance() {
}

StepSimulation::StepSimulation(const StepSimulation& from)
  : ::google::protobuf::Message(),
    _internal_metadata_(NULL) {
  SharedCtor();
  MergeFrom(from);
  // @@protoc_insertion_point(copy_constructor:mw.internal.robotics.gazebotransport.StepSimulation)
}

void StepSimulation::SharedCtor() {
  _cached_size_ = 0;
  num_steps_ = 0u;
  ::memset(_has_bits_, 0, sizeof(_has_bits_));
}

StepSimulation::~StepSimulation() {
  // @@protoc_insertion_point(destructor:mw.internal.robotics.gazebotransport.StepSimulation)
  SharedDtor();
}

void StepSimulation::SharedDtor() {
  if (this != default_instance_) {
  }
}

void StepSimulation::SetCachedSize(int size) const {
  GOOGLE_SAFE_CONCURRENT_WRITES_BEGIN();
  _cached_size_ = size;
  GOOGLE_SAFE_CONCURRENT_WRITES_END();
}
const ::google::protobuf::Descriptor* StepSimulation::descriptor() {
  protobuf_AssignDescriptorsOnce();
  return StepSimulation_descriptor_;
}

const StepSimulation& StepSimulation::default_instance() {
  if (default_instance_ == NULL) protobuf_AddDesc_mw_2einternal_2erobotics_2egazebotransport_2eCoSimMsgs_2eproto();
  return *default_instance_;
}

StepSimulation* StepSimulation::default_instance_ = NULL;

StepSimulation* StepSimulation::New(::google::protobuf::Arena* arena) const {
  StepSimulation* n = new StepSimulation;
  if (arena != NULL) {
    arena->Own(n);
  }
  return n;
}

void StepSimulation::Clear() {
// @@protoc_insertion_point(message_clear_start:mw.internal.robotics.gazebotransport.StepSimulation)
  num_steps_ = 0u;
  ::memset(_has_bits_, 0, sizeof(_has_bits_));
  if (_internal_metadata_.have_unknown_fields()) {
    mutable_unknown_fields()->Clear();
  }
}

bool StepSimulation::MergePartialFromCodedStream(
    ::google::protobuf::io::CodedInputStream* input) {
#define DO_(EXPRESSION) if (!GOOGLE_PREDICT_TRUE(EXPRESSION)) goto failure
  ::google::protobuf::uint32 tag;
  // @@protoc_insertion_point(parse_start:mw.internal.robotics.gazebotransport.StepSimulation)
  for (;;) {
    ::std::pair< ::google::protobuf::uint32, bool> p = input->ReadTagWithCutoff(127);
    tag = p.first;
    if (!p.second) goto handle_unusual;
    switch (::google::protobuf::internal::WireFormatLite::GetTagFieldNumber(tag)) {
      // required uint32 num_steps = 1;
      case 1: {
        if (tag == 8) {
          DO_((::google::protobuf::internal::WireFormatLite::ReadPrimitive<
                   ::google::protobuf::uint32, ::google::protobuf::internal::WireFormatLite::TYPE_UINT32>(
                 input, &num_steps_)));
          set_has_num_steps();
        } else {
          goto handle_unusual;
        }
        if (input->ExpectAtEnd()) goto success;
        break;
      }

      default: {
      handle_unusual:
        if (tag == 0 ||
            ::google::protobuf::internal::WireFormatLite::GetTagWireType(tag) ==
            ::google::protobuf::internal::WireFormatLite::WIRETYPE_END_GROUP) {
          goto success;
        }
        DO_(::google::protobuf::internal::WireFormat::SkipField(
              input, tag, mutable_unknown_fields()));
        break;
      }
    }
  }
success:
  // @@protoc_insertion_point(parse_success:mw.internal.robotics.gazebotransport.StepSimulation)
  return true;
failure:
  // @@protoc_insertion_point(parse_failure:mw.internal.robotics.gazebotransport.StepSimulation)
  return false;
#undef DO_
}

void StepSimulation::SerializeWithCachedSizes(
    ::google::protobuf::io::CodedOutputStream* output) const {
  // @@protoc_insertion_point(serialize_start:mw.internal.robotics.gazebotransport.StepSimulation)
  // required uint32 num_steps = 1;
  if (has_num_steps()) {
    ::google::protobuf::internal::WireFormatLite::WriteUInt32(1, this->num_steps(), output);
  }

  if (_internal_metadata_.have_unknown_fields()) {
    ::google::protobuf::internal::WireFormat::SerializeUnknownFields(
        unknown_fields(), output);
  }
  // @@protoc_insertion_point(serialize_end:mw.internal.robotics.gazebotransport.StepSimulation)
}

::google::protobuf::uint8* StepSimulation::InternalSerializeWithCachedSizesToArray(
    bool deterministic, ::google::protobuf::uint8* target) const {
  // @@protoc_insertion_point(serialize_to_array_start:mw.internal.robotics.gazebotransport.StepSimulation)
  // required uint32 num_steps = 1;
  if (has_num_steps()) {
    target = ::google::protobuf::internal::WireFormatLite::WriteUInt32ToArray(1, this->num_steps(), target);
  }

  if (_internal_metadata_.have_unknown_fields()) {
    target = ::google::protobuf::internal::WireFormat::SerializeUnknownFieldsToArray(
        unknown_fields(), target);
  }
  // @@protoc_insertion_point(serialize_to_array_end:mw.internal.robotics.gazebotransport.StepSimulation)
  return target;
}

int StepSimulation::ByteSize() const {
// @@protoc_insertion_point(message_byte_size_start:mw.internal.robotics.gazebotransport.StepSimulation)
  int total_size = 0;

  // required uint32 num_steps = 1;
  if (has_num_steps()) {
    total_size += 1 +
      ::google::protobuf::internal::WireFormatLite::UInt32Size(
        this->num_steps());
  }
  if (_internal_metadata_.have_unknown_fields()) {
    total_size +=
      ::google::protobuf::internal::WireFormat::ComputeUnknownFieldsSize(
        unknown_fields());
  }
  GOOGLE_SAFE_CONCURRENT_WRITES_BEGIN();
  _cached_size_ = total_size;
  GOOGLE_SAFE_CONCURRENT_WRITES_END();
  return total_size;
}

void StepSimulation::MergeFrom(const ::google::protobuf::Message& from) {
// @@protoc_insertion_point(generalized_merge_from_start:mw.internal.robotics.gazebotransport.StepSimulation)
  if (GOOGLE_PREDICT_FALSE(&from == this)) {
    ::google::protobuf::internal::MergeFromFail(__FILE__, __LINE__);
  }
  const StepSimulation* source = 
      ::google::protobuf::internal::DynamicCastToGenerated<const StepSimulation>(
          &from);
  if (source == NULL) {
  // @@protoc_insertion_point(generalized_merge_from_cast_fail:mw.internal.robotics.gazebotransport.StepSimulation)
    ::google::protobuf::internal::ReflectionOps::Merge(from, this);
  } else {
  // @@protoc_insertion_point(generalized_merge_from_cast_success:mw.internal.robotics.gazebotransport.StepSimulation)
    MergeFrom(*source);
  }
}

void StepSimulation::MergeFrom(const StepSimulation& from) {
// @@protoc_insertion_point(class_specific_merge_from_start:mw.internal.robotics.gazebotransport.StepSimulation)
  if (GOOGLE_PREDICT_FALSE(&from == this)) {
    ::google::protobuf::internal::MergeFromFail(__FILE__, __LINE__);
  }
  if (from._has_bits_[0 / 32] & (0xffu << (0 % 32))) {
    if (from.has_num_steps()) {
      set_num_steps(from.num_steps());
    }
  }
  if (from._internal_metadata_.have_unknown_fields()) {
    mutable_unknown_fields()->MergeFrom(from.unknown_fields());
  }
}

void StepSimulation::CopyFrom(const ::google::protobuf::Message& from) {
// @@protoc_insertion_point(generalized_copy_from_start:mw.internal.robotics.gazebotransport.StepSimulation)
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

void StepSimulation::CopyFrom(const StepSimulation& from) {
// @@protoc_insertion_point(class_specific_copy_from_start:mw.internal.robotics.gazebotransport.StepSimulation)
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

bool StepSimulation::IsInitialized() const {
  if ((_has_bits_[0] & 0x00000001) != 0x00000001) return false;

  return true;
}

void StepSimulation::Swap(StepSimulation* other) {
  if (other == this) return;
  InternalSwap(other);
}
void StepSimulation::InternalSwap(StepSimulation* other) {
  std::swap(num_steps_, other->num_steps_);
  std::swap(_has_bits_[0], other->_has_bits_[0]);
  _internal_metadata_.Swap(&other->_internal_metadata_);
  std::swap(_cached_size_, other->_cached_size_);
}

::google::protobuf::Metadata StepSimulation::GetMetadata() const {
  protobuf_AssignDescriptorsOnce();
  ::google::protobuf::Metadata metadata;
  metadata.descriptor = StepSimulation_descriptor_;
  metadata.reflection = StepSimulation_reflection_;
  return metadata;
}

#if PROTOBUF_INLINE_NOT_IN_HEADERS
// StepSimulation

// required uint32 num_steps = 1;
bool StepSimulation::has_num_steps() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
void StepSimulation::set_has_num_steps() {
  _has_bits_[0] |= 0x00000001u;
}
void StepSimulation::clear_has_num_steps() {
  _has_bits_[0] &= ~0x00000001u;
}
void StepSimulation::clear_num_steps() {
  num_steps_ = 0u;
  clear_has_num_steps();
}
 ::google::protobuf::uint32 StepSimulation::num_steps() const {
  // @@protoc_insertion_point(field_get:mw.internal.robotics.gazebotransport.StepSimulation.num_steps)
  return num_steps_;
}
 void StepSimulation::set_num_steps(::google::protobuf::uint32 value) {
  set_has_num_steps();
  num_steps_ = value;
  // @@protoc_insertion_point(field_set:mw.internal.robotics.gazebotransport.StepSimulation.num_steps)
}

#endif  // PROTOBUF_INLINE_NOT_IN_HEADERS

// ===================================================================

const ::google::protobuf::EnumDescriptor* ResetSimulation_ResetBehavior_descriptor() {
  protobuf_AssignDescriptorsOnce();
  return ResetSimulation_ResetBehavior_descriptor_;
}
bool ResetSimulation_ResetBehavior_IsValid(int value) {
  switch(value) {
    case 0:
    case 1:
      return true;
    default:
      return false;
  }
}

#if !defined(_MSC_VER) || _MSC_VER >= 1900
const ResetSimulation_ResetBehavior ResetSimulation::RESET_TIME;
const ResetSimulation_ResetBehavior ResetSimulation::RESET_TIME_AND_SCENE;
const ResetSimulation_ResetBehavior ResetSimulation::ResetBehavior_MIN;
const ResetSimulation_ResetBehavior ResetSimulation::ResetBehavior_MAX;
const int ResetSimulation::ResetBehavior_ARRAYSIZE;
#endif  // !defined(_MSC_VER) || _MSC_VER >= 1900
#if !defined(_MSC_VER) || _MSC_VER >= 1900
const int ResetSimulation::kBehaviorFieldNumber;
#endif  // !defined(_MSC_VER) || _MSC_VER >= 1900

ResetSimulation::ResetSimulation()
  : ::google::protobuf::Message(), _internal_metadata_(NULL) {
  SharedCtor();
  // @@protoc_insertion_point(constructor:mw.internal.robotics.gazebotransport.ResetSimulation)
}

void ResetSimulation::InitAsDefaultInstance() {
}

ResetSimulation::ResetSimulation(const ResetSimulation& from)
  : ::google::protobuf::Message(),
    _internal_metadata_(NULL) {
  SharedCtor();
  MergeFrom(from);
  // @@protoc_insertion_point(copy_constructor:mw.internal.robotics.gazebotransport.ResetSimulation)
}

void ResetSimulation::SharedCtor() {
  _cached_size_ = 0;
  behavior_ = 0;
  ::memset(_has_bits_, 0, sizeof(_has_bits_));
}

ResetSimulation::~ResetSimulation() {
  // @@protoc_insertion_point(destructor:mw.internal.robotics.gazebotransport.ResetSimulation)
  SharedDtor();
}

void ResetSimulation::SharedDtor() {
  if (this != default_instance_) {
  }
}

void ResetSimulation::SetCachedSize(int size) const {
  GOOGLE_SAFE_CONCURRENT_WRITES_BEGIN();
  _cached_size_ = size;
  GOOGLE_SAFE_CONCURRENT_WRITES_END();
}
const ::google::protobuf::Descriptor* ResetSimulation::descriptor() {
  protobuf_AssignDescriptorsOnce();
  return ResetSimulation_descriptor_;
}

const ResetSimulation& ResetSimulation::default_instance() {
  if (default_instance_ == NULL) protobuf_AddDesc_mw_2einternal_2erobotics_2egazebotransport_2eCoSimMsgs_2eproto();
  return *default_instance_;
}

ResetSimulation* ResetSimulation::default_instance_ = NULL;

ResetSimulation* ResetSimulation::New(::google::protobuf::Arena* arena) const {
  ResetSimulation* n = new ResetSimulation;
  if (arena != NULL) {
    arena->Own(n);
  }
  return n;
}

void ResetSimulation::Clear() {
// @@protoc_insertion_point(message_clear_start:mw.internal.robotics.gazebotransport.ResetSimulation)
  behavior_ = 0;
  ::memset(_has_bits_, 0, sizeof(_has_bits_));
  if (_internal_metadata_.have_unknown_fields()) {
    mutable_unknown_fields()->Clear();
  }
}

bool ResetSimulation::MergePartialFromCodedStream(
    ::google::protobuf::io::CodedInputStream* input) {
#define DO_(EXPRESSION) if (!GOOGLE_PREDICT_TRUE(EXPRESSION)) goto failure
  ::google::protobuf::uint32 tag;
  // @@protoc_insertion_point(parse_start:mw.internal.robotics.gazebotransport.ResetSimulation)
  for (;;) {
    ::std::pair< ::google::protobuf::uint32, bool> p = input->ReadTagWithCutoff(127);
    tag = p.first;
    if (!p.second) goto handle_unusual;
    switch (::google::protobuf::internal::WireFormatLite::GetTagFieldNumber(tag)) {
      // required .mw.internal.robotics.gazebotransport.ResetSimulation.ResetBehavior behavior = 1;
      case 1: {
        if (tag == 8) {
          int value;
          DO_((::google::protobuf::internal::WireFormatLite::ReadPrimitive<
                   int, ::google::protobuf::internal::WireFormatLite::TYPE_ENUM>(
                 input, &value)));
          if (::mw::internal::robotics::gazebotransport::ResetSimulation_ResetBehavior_IsValid(value)) {
            set_behavior(static_cast< ::mw::internal::robotics::gazebotransport::ResetSimulation_ResetBehavior >(value));
          } else {
            mutable_unknown_fields()->AddVarint(1, value);
          }
        } else {
          goto handle_unusual;
        }
        if (input->ExpectAtEnd()) goto success;
        break;
      }

      default: {
      handle_unusual:
        if (tag == 0 ||
            ::google::protobuf::internal::WireFormatLite::GetTagWireType(tag) ==
            ::google::protobuf::internal::WireFormatLite::WIRETYPE_END_GROUP) {
          goto success;
        }
        DO_(::google::protobuf::internal::WireFormat::SkipField(
              input, tag, mutable_unknown_fields()));
        break;
      }
    }
  }
success:
  // @@protoc_insertion_point(parse_success:mw.internal.robotics.gazebotransport.ResetSimulation)
  return true;
failure:
  // @@protoc_insertion_point(parse_failure:mw.internal.robotics.gazebotransport.ResetSimulation)
  return false;
#undef DO_
}

void ResetSimulation::SerializeWithCachedSizes(
    ::google::protobuf::io::CodedOutputStream* output) const {
  // @@protoc_insertion_point(serialize_start:mw.internal.robotics.gazebotransport.ResetSimulation)
  // required .mw.internal.robotics.gazebotransport.ResetSimulation.ResetBehavior behavior = 1;
  if (has_behavior()) {
    ::google::protobuf::internal::WireFormatLite::WriteEnum(
      1, this->behavior(), output);
  }

  if (_internal_metadata_.have_unknown_fields()) {
    ::google::protobuf::internal::WireFormat::SerializeUnknownFields(
        unknown_fields(), output);
  }
  // @@protoc_insertion_point(serialize_end:mw.internal.robotics.gazebotransport.ResetSimulation)
}

::google::protobuf::uint8* ResetSimulation::InternalSerializeWithCachedSizesToArray(
    bool deterministic, ::google::protobuf::uint8* target) const {
  // @@protoc_insertion_point(serialize_to_array_start:mw.internal.robotics.gazebotransport.ResetSimulation)
  // required .mw.internal.robotics.gazebotransport.ResetSimulation.ResetBehavior behavior = 1;
  if (has_behavior()) {
    target = ::google::protobuf::internal::WireFormatLite::WriteEnumToArray(
      1, this->behavior(), target);
  }

  if (_internal_metadata_.have_unknown_fields()) {
    target = ::google::protobuf::internal::WireFormat::SerializeUnknownFieldsToArray(
        unknown_fields(), target);
  }
  // @@protoc_insertion_point(serialize_to_array_end:mw.internal.robotics.gazebotransport.ResetSimulation)
  return target;
}

int ResetSimulation::ByteSize() const {
// @@protoc_insertion_point(message_byte_size_start:mw.internal.robotics.gazebotransport.ResetSimulation)
  int total_size = 0;

  // required .mw.internal.robotics.gazebotransport.ResetSimulation.ResetBehavior behavior = 1;
  if (has_behavior()) {
    total_size += 1 +
      ::google::protobuf::internal::WireFormatLite::EnumSize(this->behavior());
  }
  if (_internal_metadata_.have_unknown_fields()) {
    total_size +=
      ::google::protobuf::internal::WireFormat::ComputeUnknownFieldsSize(
        unknown_fields());
  }
  GOOGLE_SAFE_CONCURRENT_WRITES_BEGIN();
  _cached_size_ = total_size;
  GOOGLE_SAFE_CONCURRENT_WRITES_END();
  return total_size;
}

void ResetSimulation::MergeFrom(const ::google::protobuf::Message& from) {
// @@protoc_insertion_point(generalized_merge_from_start:mw.internal.robotics.gazebotransport.ResetSimulation)
  if (GOOGLE_PREDICT_FALSE(&from == this)) {
    ::google::protobuf::internal::MergeFromFail(__FILE__, __LINE__);
  }
  const ResetSimulation* source = 
      ::google::protobuf::internal::DynamicCastToGenerated<const ResetSimulation>(
          &from);
  if (source == NULL) {
  // @@protoc_insertion_point(generalized_merge_from_cast_fail:mw.internal.robotics.gazebotransport.ResetSimulation)
    ::google::protobuf::internal::ReflectionOps::Merge(from, this);
  } else {
  // @@protoc_insertion_point(generalized_merge_from_cast_success:mw.internal.robotics.gazebotransport.ResetSimulation)
    MergeFrom(*source);
  }
}

void ResetSimulation::MergeFrom(const ResetSimulation& from) {
// @@protoc_insertion_point(class_specific_merge_from_start:mw.internal.robotics.gazebotransport.ResetSimulation)
  if (GOOGLE_PREDICT_FALSE(&from == this)) {
    ::google::protobuf::internal::MergeFromFail(__FILE__, __LINE__);
  }
  if (from._has_bits_[0 / 32] & (0xffu << (0 % 32))) {
    if (from.has_behavior()) {
      set_behavior(from.behavior());
    }
  }
  if (from._internal_metadata_.have_unknown_fields()) {
    mutable_unknown_fields()->MergeFrom(from.unknown_fields());
  }
}

void ResetSimulation::CopyFrom(const ::google::protobuf::Message& from) {
// @@protoc_insertion_point(generalized_copy_from_start:mw.internal.robotics.gazebotransport.ResetSimulation)
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

void ResetSimulation::CopyFrom(const ResetSimulation& from) {
// @@protoc_insertion_point(class_specific_copy_from_start:mw.internal.robotics.gazebotransport.ResetSimulation)
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

bool ResetSimulation::IsInitialized() const {
  if ((_has_bits_[0] & 0x00000001) != 0x00000001) return false;

  return true;
}

void ResetSimulation::Swap(ResetSimulation* other) {
  if (other == this) return;
  InternalSwap(other);
}
void ResetSimulation::InternalSwap(ResetSimulation* other) {
  std::swap(behavior_, other->behavior_);
  std::swap(_has_bits_[0], other->_has_bits_[0]);
  _internal_metadata_.Swap(&other->_internal_metadata_);
  std::swap(_cached_size_, other->_cached_size_);
}

::google::protobuf::Metadata ResetSimulation::GetMetadata() const {
  protobuf_AssignDescriptorsOnce();
  ::google::protobuf::Metadata metadata;
  metadata.descriptor = ResetSimulation_descriptor_;
  metadata.reflection = ResetSimulation_reflection_;
  return metadata;
}

#if PROTOBUF_INLINE_NOT_IN_HEADERS
// ResetSimulation

// required .mw.internal.robotics.gazebotransport.ResetSimulation.ResetBehavior behavior = 1;
bool ResetSimulation::has_behavior() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
void ResetSimulation::set_has_behavior() {
  _has_bits_[0] |= 0x00000001u;
}
void ResetSimulation::clear_has_behavior() {
  _has_bits_[0] &= ~0x00000001u;
}
void ResetSimulation::clear_behavior() {
  behavior_ = 0;
  clear_has_behavior();
}
 ::mw::internal::robotics::gazebotransport::ResetSimulation_ResetBehavior ResetSimulation::behavior() const {
  // @@protoc_insertion_point(field_get:mw.internal.robotics.gazebotransport.ResetSimulation.behavior)
  return static_cast< ::mw::internal::robotics::gazebotransport::ResetSimulation_ResetBehavior >(behavior_);
}
 void ResetSimulation::set_behavior(::mw::internal::robotics::gazebotransport::ResetSimulation_ResetBehavior value) {
  assert(::mw::internal::robotics::gazebotransport::ResetSimulation_ResetBehavior_IsValid(value));
  set_has_behavior();
  behavior_ = value;
  // @@protoc_insertion_point(field_set:mw.internal.robotics.gazebotransport.ResetSimulation.behavior)
}

#endif  // PROTOBUF_INLINE_NOT_IN_HEADERS

// ===================================================================

#if !defined(_MSC_VER) || _MSC_VER >= 1900
const int Image::kWidthFieldNumber;
const int Image::kHeightFieldNumber;
const int Image::kDataFieldNumber;
const int Image::kDataTypeFieldNumber;
#endif  // !defined(_MSC_VER) || _MSC_VER >= 1900

Image::Image()
  : ::google::protobuf::Message(), _internal_metadata_(NULL) {
  SharedCtor();
  // @@protoc_insertion_point(constructor:mw.internal.robotics.gazebotransport.Image)
}

void Image::InitAsDefaultInstance() {
}

Image::Image(const Image& from)
  : ::google::protobuf::Message(),
    _internal_metadata_(NULL) {
  SharedCtor();
  MergeFrom(from);
  // @@protoc_insertion_point(copy_constructor:mw.internal.robotics.gazebotransport.Image)
}

void Image::SharedCtor() {
  ::google::protobuf::internal::GetEmptyString();
  _cached_size_ = 0;
  width_ = 0u;
  height_ = 0u;
  data_.UnsafeSetDefault(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
  data_type_.UnsafeSetDefault(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
  ::memset(_has_bits_, 0, sizeof(_has_bits_));
}

Image::~Image() {
  // @@protoc_insertion_point(destructor:mw.internal.robotics.gazebotransport.Image)
  SharedDtor();
}

void Image::SharedDtor() {
  data_.DestroyNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
  data_type_.DestroyNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
  if (this != default_instance_) {
  }
}

void Image::SetCachedSize(int size) const {
  GOOGLE_SAFE_CONCURRENT_WRITES_BEGIN();
  _cached_size_ = size;
  GOOGLE_SAFE_CONCURRENT_WRITES_END();
}
const ::google::protobuf::Descriptor* Image::descriptor() {
  protobuf_AssignDescriptorsOnce();
  return Image_descriptor_;
}

const Image& Image::default_instance() {
  if (default_instance_ == NULL) protobuf_AddDesc_mw_2einternal_2erobotics_2egazebotransport_2eCoSimMsgs_2eproto();
  return *default_instance_;
}

Image* Image::default_instance_ = NULL;

Image* Image::New(::google::protobuf::Arena* arena) const {
  Image* n = new Image;
  if (arena != NULL) {
    arena->Own(n);
  }
  return n;
}

void Image::Clear() {
// @@protoc_insertion_point(message_clear_start:mw.internal.robotics.gazebotransport.Image)
#if defined(__clang__)
#define ZR_HELPER_(f) \
  _Pragma("clang diagnostic push") \
  _Pragma("clang diagnostic ignored \"-Winvalid-offsetof\"") \
  __builtin_offsetof(Image, f) \
  _Pragma("clang diagnostic pop")
#else
#define ZR_HELPER_(f) reinterpret_cast<char*>(\
  &reinterpret_cast<Image*>(16)->f)
#endif

#define ZR_(first, last) do {\
  ::memset(&first, 0,\
           ZR_HELPER_(last) - ZR_HELPER_(first) + sizeof(last));\
} while (0)

  if (_has_bits_[0 / 32] & 15u) {
    ZR_(width_, height_);
    if (has_data()) {
      data_.ClearToEmptyNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
    }
    if (has_data_type()) {
      data_type_.ClearToEmptyNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
    }
  }

#undef ZR_HELPER_
#undef ZR_

  ::memset(_has_bits_, 0, sizeof(_has_bits_));
  if (_internal_metadata_.have_unknown_fields()) {
    mutable_unknown_fields()->Clear();
  }
}

bool Image::MergePartialFromCodedStream(
    ::google::protobuf::io::CodedInputStream* input) {
#define DO_(EXPRESSION) if (!GOOGLE_PREDICT_TRUE(EXPRESSION)) goto failure
  ::google::protobuf::uint32 tag;
  // @@protoc_insertion_point(parse_start:mw.internal.robotics.gazebotransport.Image)
  for (;;) {
    ::std::pair< ::google::protobuf::uint32, bool> p = input->ReadTagWithCutoff(127);
    tag = p.first;
    if (!p.second) goto handle_unusual;
    switch (::google::protobuf::internal::WireFormatLite::GetTagFieldNumber(tag)) {
      // required uint32 width = 1;
      case 1: {
        if (tag == 8) {
          DO_((::google::protobuf::internal::WireFormatLite::ReadPrimitive<
                   ::google::protobuf::uint32, ::google::protobuf::internal::WireFormatLite::TYPE_UINT32>(
                 input, &width_)));
          set_has_width();
        } else {
          goto handle_unusual;
        }
        if (input->ExpectTag(16)) goto parse_height;
        break;
      }

      // required uint32 height = 2;
      case 2: {
        if (tag == 16) {
         parse_height:
          DO_((::google::protobuf::internal::WireFormatLite::ReadPrimitive<
                   ::google::protobuf::uint32, ::google::protobuf::internal::WireFormatLite::TYPE_UINT32>(
                 input, &height_)));
          set_has_height();
        } else {
          goto handle_unusual;
        }
        if (input->ExpectTag(26)) goto parse_data;
        break;
      }

      // required bytes data = 3;
      case 3: {
        if (tag == 26) {
         parse_data:
          DO_(::google::protobuf::internal::WireFormatLite::ReadBytes(
                input, this->mutable_data()));
        } else {
          goto handle_unusual;
        }
        if (input->ExpectTag(34)) goto parse_data_type;
        break;
      }

      // required string data_type = 4;
      case 4: {
        if (tag == 34) {
         parse_data_type:
          DO_(::google::protobuf::internal::WireFormatLite::ReadString(
                input, this->mutable_data_type()));
          ::google::protobuf::internal::WireFormat::VerifyUTF8StringNamedField(
            this->data_type().data(), this->data_type().length(),
            ::google::protobuf::internal::WireFormat::PARSE,
            "mw.internal.robotics.gazebotransport.Image.data_type");
        } else {
          goto handle_unusual;
        }
        if (input->ExpectAtEnd()) goto success;
        break;
      }

      default: {
      handle_unusual:
        if (tag == 0 ||
            ::google::protobuf::internal::WireFormatLite::GetTagWireType(tag) ==
            ::google::protobuf::internal::WireFormatLite::WIRETYPE_END_GROUP) {
          goto success;
        }
        DO_(::google::protobuf::internal::WireFormat::SkipField(
              input, tag, mutable_unknown_fields()));
        break;
      }
    }
  }
success:
  // @@protoc_insertion_point(parse_success:mw.internal.robotics.gazebotransport.Image)
  return true;
failure:
  // @@protoc_insertion_point(parse_failure:mw.internal.robotics.gazebotransport.Image)
  return false;
#undef DO_
}

void Image::SerializeWithCachedSizes(
    ::google::protobuf::io::CodedOutputStream* output) const {
  // @@protoc_insertion_point(serialize_start:mw.internal.robotics.gazebotransport.Image)
  // required uint32 width = 1;
  if (has_width()) {
    ::google::protobuf::internal::WireFormatLite::WriteUInt32(1, this->width(), output);
  }

  // required uint32 height = 2;
  if (has_height()) {
    ::google::protobuf::internal::WireFormatLite::WriteUInt32(2, this->height(), output);
  }

  // required bytes data = 3;
  if (has_data()) {
    ::google::protobuf::internal::WireFormatLite::WriteBytesMaybeAliased(
      3, this->data(), output);
  }

  // required string data_type = 4;
  if (has_data_type()) {
    ::google::protobuf::internal::WireFormat::VerifyUTF8StringNamedField(
      this->data_type().data(), this->data_type().length(),
      ::google::protobuf::internal::WireFormat::SERIALIZE,
      "mw.internal.robotics.gazebotransport.Image.data_type");
    ::google::protobuf::internal::WireFormatLite::WriteStringMaybeAliased(
      4, this->data_type(), output);
  }

  if (_internal_metadata_.have_unknown_fields()) {
    ::google::protobuf::internal::WireFormat::SerializeUnknownFields(
        unknown_fields(), output);
  }
  // @@protoc_insertion_point(serialize_end:mw.internal.robotics.gazebotransport.Image)
}

::google::protobuf::uint8* Image::InternalSerializeWithCachedSizesToArray(
    bool deterministic, ::google::protobuf::uint8* target) const {
  // @@protoc_insertion_point(serialize_to_array_start:mw.internal.robotics.gazebotransport.Image)
  // required uint32 width = 1;
  if (has_width()) {
    target = ::google::protobuf::internal::WireFormatLite::WriteUInt32ToArray(1, this->width(), target);
  }

  // required uint32 height = 2;
  if (has_height()) {
    target = ::google::protobuf::internal::WireFormatLite::WriteUInt32ToArray(2, this->height(), target);
  }

  // required bytes data = 3;
  if (has_data()) {
    target =
      ::google::protobuf::internal::WireFormatLite::WriteBytesToArray(
        3, this->data(), target);
  }

  // required string data_type = 4;
  if (has_data_type()) {
    ::google::protobuf::internal::WireFormat::VerifyUTF8StringNamedField(
      this->data_type().data(), this->data_type().length(),
      ::google::protobuf::internal::WireFormat::SERIALIZE,
      "mw.internal.robotics.gazebotransport.Image.data_type");
    target =
      ::google::protobuf::internal::WireFormatLite::WriteStringToArray(
        4, this->data_type(), target);
  }

  if (_internal_metadata_.have_unknown_fields()) {
    target = ::google::protobuf::internal::WireFormat::SerializeUnknownFieldsToArray(
        unknown_fields(), target);
  }
  // @@protoc_insertion_point(serialize_to_array_end:mw.internal.robotics.gazebotransport.Image)
  return target;
}

int Image::RequiredFieldsByteSizeFallback() const {
// @@protoc_insertion_point(required_fields_byte_size_fallback_start:mw.internal.robotics.gazebotransport.Image)
  int total_size = 0;

  if (has_width()) {
    // required uint32 width = 1;
    total_size += 1 +
      ::google::protobuf::internal::WireFormatLite::UInt32Size(
        this->width());
  }

  if (has_height()) {
    // required uint32 height = 2;
    total_size += 1 +
      ::google::protobuf::internal::WireFormatLite::UInt32Size(
        this->height());
  }

  if (has_data()) {
    // required bytes data = 3;
    total_size += 1 +
      ::google::protobuf::internal::WireFormatLite::BytesSize(
        this->data());
  }

  if (has_data_type()) {
    // required string data_type = 4;
    total_size += 1 +
      ::google::protobuf::internal::WireFormatLite::StringSize(
        this->data_type());
  }

  return total_size;
}
int Image::ByteSize() const {
// @@protoc_insertion_point(message_byte_size_start:mw.internal.robotics.gazebotransport.Image)
  int total_size = 0;

  if (((_has_bits_[0] & 0x0000000f) ^ 0x0000000f) == 0) {  // All required fields are present.
    // required uint32 width = 1;
    total_size += 1 +
      ::google::protobuf::internal::WireFormatLite::UInt32Size(
        this->width());

    // required uint32 height = 2;
    total_size += 1 +
      ::google::protobuf::internal::WireFormatLite::UInt32Size(
        this->height());

    // required bytes data = 3;
    total_size += 1 +
      ::google::protobuf::internal::WireFormatLite::BytesSize(
        this->data());

    // required string data_type = 4;
    total_size += 1 +
      ::google::protobuf::internal::WireFormatLite::StringSize(
        this->data_type());

  } else {
    total_size += RequiredFieldsByteSizeFallback();
  }
  if (_internal_metadata_.have_unknown_fields()) {
    total_size +=
      ::google::protobuf::internal::WireFormat::ComputeUnknownFieldsSize(
        unknown_fields());
  }
  GOOGLE_SAFE_CONCURRENT_WRITES_BEGIN();
  _cached_size_ = total_size;
  GOOGLE_SAFE_CONCURRENT_WRITES_END();
  return total_size;
}

void Image::MergeFrom(const ::google::protobuf::Message& from) {
// @@protoc_insertion_point(generalized_merge_from_start:mw.internal.robotics.gazebotransport.Image)
  if (GOOGLE_PREDICT_FALSE(&from == this)) {
    ::google::protobuf::internal::MergeFromFail(__FILE__, __LINE__);
  }
  const Image* source = 
      ::google::protobuf::internal::DynamicCastToGenerated<const Image>(
          &from);
  if (source == NULL) {
  // @@protoc_insertion_point(generalized_merge_from_cast_fail:mw.internal.robotics.gazebotransport.Image)
    ::google::protobuf::internal::ReflectionOps::Merge(from, this);
  } else {
  // @@protoc_insertion_point(generalized_merge_from_cast_success:mw.internal.robotics.gazebotransport.Image)
    MergeFrom(*source);
  }
}

void Image::MergeFrom(const Image& from) {
// @@protoc_insertion_point(class_specific_merge_from_start:mw.internal.robotics.gazebotransport.Image)
  if (GOOGLE_PREDICT_FALSE(&from == this)) {
    ::google::protobuf::internal::MergeFromFail(__FILE__, __LINE__);
  }
  if (from._has_bits_[0 / 32] & (0xffu << (0 % 32))) {
    if (from.has_width()) {
      set_width(from.width());
    }
    if (from.has_height()) {
      set_height(from.height());
    }
    if (from.has_data()) {
      set_has_data();
      data_.AssignWithDefault(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), from.data_);
    }
    if (from.has_data_type()) {
      set_has_data_type();
      data_type_.AssignWithDefault(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), from.data_type_);
    }
  }
  if (from._internal_metadata_.have_unknown_fields()) {
    mutable_unknown_fields()->MergeFrom(from.unknown_fields());
  }
}

void Image::CopyFrom(const ::google::protobuf::Message& from) {
// @@protoc_insertion_point(generalized_copy_from_start:mw.internal.robotics.gazebotransport.Image)
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

void Image::CopyFrom(const Image& from) {
// @@protoc_insertion_point(class_specific_copy_from_start:mw.internal.robotics.gazebotransport.Image)
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

bool Image::IsInitialized() const {
  if ((_has_bits_[0] & 0x0000000f) != 0x0000000f) return false;

  return true;
}

void Image::Swap(Image* other) {
  if (other == this) return;
  InternalSwap(other);
}
void Image::InternalSwap(Image* other) {
  std::swap(width_, other->width_);
  std::swap(height_, other->height_);
  data_.Swap(&other->data_);
  data_type_.Swap(&other->data_type_);
  std::swap(_has_bits_[0], other->_has_bits_[0]);
  _internal_metadata_.Swap(&other->_internal_metadata_);
  std::swap(_cached_size_, other->_cached_size_);
}

::google::protobuf::Metadata Image::GetMetadata() const {
  protobuf_AssignDescriptorsOnce();
  ::google::protobuf::Metadata metadata;
  metadata.descriptor = Image_descriptor_;
  metadata.reflection = Image_reflection_;
  return metadata;
}

#if PROTOBUF_INLINE_NOT_IN_HEADERS
// Image

// required uint32 width = 1;
bool Image::has_width() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
void Image::set_has_width() {
  _has_bits_[0] |= 0x00000001u;
}
void Image::clear_has_width() {
  _has_bits_[0] &= ~0x00000001u;
}
void Image::clear_width() {
  width_ = 0u;
  clear_has_width();
}
 ::google::protobuf::uint32 Image::width() const {
  // @@protoc_insertion_point(field_get:mw.internal.robotics.gazebotransport.Image.width)
  return width_;
}
 void Image::set_width(::google::protobuf::uint32 value) {
  set_has_width();
  width_ = value;
  // @@protoc_insertion_point(field_set:mw.internal.robotics.gazebotransport.Image.width)
}

// required uint32 height = 2;
bool Image::has_height() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
void Image::set_has_height() {
  _has_bits_[0] |= 0x00000002u;
}
void Image::clear_has_height() {
  _has_bits_[0] &= ~0x00000002u;
}
void Image::clear_height() {
  height_ = 0u;
  clear_has_height();
}
 ::google::protobuf::uint32 Image::height() const {
  // @@protoc_insertion_point(field_get:mw.internal.robotics.gazebotransport.Image.height)
  return height_;
}
 void Image::set_height(::google::protobuf::uint32 value) {
  set_has_height();
  height_ = value;
  // @@protoc_insertion_point(field_set:mw.internal.robotics.gazebotransport.Image.height)
}

// required bytes data = 3;
bool Image::has_data() const {
  return (_has_bits_[0] & 0x00000004u) != 0;
}
void Image::set_has_data() {
  _has_bits_[0] |= 0x00000004u;
}
void Image::clear_has_data() {
  _has_bits_[0] &= ~0x00000004u;
}
void Image::clear_data() {
  data_.ClearToEmptyNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
  clear_has_data();
}
 const ::std::string& Image::data() const {
  // @@protoc_insertion_point(field_get:mw.internal.robotics.gazebotransport.Image.data)
  return data_.GetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
 void Image::set_data(const ::std::string& value) {
  set_has_data();
  data_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), value);
  // @@protoc_insertion_point(field_set:mw.internal.robotics.gazebotransport.Image.data)
}
 void Image::set_data(const char* value) {
  set_has_data();
  data_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::string(value));
  // @@protoc_insertion_point(field_set_char:mw.internal.robotics.gazebotransport.Image.data)
}
 void Image::set_data(const void* value, size_t size) {
  set_has_data();
  data_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(),
      ::std::string(reinterpret_cast<const char*>(value), size));
  // @@protoc_insertion_point(field_set_pointer:mw.internal.robotics.gazebotransport.Image.data)
}
 ::std::string* Image::mutable_data() {
  set_has_data();
  // @@protoc_insertion_point(field_mutable:mw.internal.robotics.gazebotransport.Image.data)
  return data_.MutableNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
 ::std::string* Image::release_data() {
  // @@protoc_insertion_point(field_release:mw.internal.robotics.gazebotransport.Image.data)
  clear_has_data();
  return data_.ReleaseNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
 void Image::set_allocated_data(::std::string* data) {
  if (data != NULL) {
    set_has_data();
  } else {
    clear_has_data();
  }
  data_.SetAllocatedNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), data);
  // @@protoc_insertion_point(field_set_allocated:mw.internal.robotics.gazebotransport.Image.data)
}

// required string data_type = 4;
bool Image::has_data_type() const {
  return (_has_bits_[0] & 0x00000008u) != 0;
}
void Image::set_has_data_type() {
  _has_bits_[0] |= 0x00000008u;
}
void Image::clear_has_data_type() {
  _has_bits_[0] &= ~0x00000008u;
}
void Image::clear_data_type() {
  data_type_.ClearToEmptyNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
  clear_has_data_type();
}
 const ::std::string& Image::data_type() const {
  // @@protoc_insertion_point(field_get:mw.internal.robotics.gazebotransport.Image.data_type)
  return data_type_.GetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
 void Image::set_data_type(const ::std::string& value) {
  set_has_data_type();
  data_type_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), value);
  // @@protoc_insertion_point(field_set:mw.internal.robotics.gazebotransport.Image.data_type)
}
 void Image::set_data_type(const char* value) {
  set_has_data_type();
  data_type_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::string(value));
  // @@protoc_insertion_point(field_set_char:mw.internal.robotics.gazebotransport.Image.data_type)
}
 void Image::set_data_type(const char* value, size_t size) {
  set_has_data_type();
  data_type_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(),
      ::std::string(reinterpret_cast<const char*>(value), size));
  // @@protoc_insertion_point(field_set_pointer:mw.internal.robotics.gazebotransport.Image.data_type)
}
 ::std::string* Image::mutable_data_type() {
  set_has_data_type();
  // @@protoc_insertion_point(field_mutable:mw.internal.robotics.gazebotransport.Image.data_type)
  return data_type_.MutableNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
 ::std::string* Image::release_data_type() {
  // @@protoc_insertion_point(field_release:mw.internal.robotics.gazebotransport.Image.data_type)
  clear_has_data_type();
  return data_type_.ReleaseNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
 void Image::set_allocated_data_type(::std::string* data_type) {
  if (data_type != NULL) {
    set_has_data_type();
  } else {
    clear_has_data_type();
  }
  data_type_.SetAllocatedNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), data_type);
  // @@protoc_insertion_point(field_set_allocated:mw.internal.robotics.gazebotransport.Image.data_type)
}

#endif  // PROTOBUF_INLINE_NOT_IN_HEADERS

// ===================================================================

#if !defined(_MSC_VER) || _MSC_VER >= 1900
const int RequestImage::kTopicNameFieldNumber;
#endif  // !defined(_MSC_VER) || _MSC_VER >= 1900

RequestImage::RequestImage()
  : ::google::protobuf::Message(), _internal_metadata_(NULL) {
  SharedCtor();
  // @@protoc_insertion_point(constructor:mw.internal.robotics.gazebotransport.RequestImage)
}

void RequestImage::InitAsDefaultInstance() {
}

RequestImage::RequestImage(const RequestImage& from)
  : ::google::protobuf::Message(),
    _internal_metadata_(NULL) {
  SharedCtor();
  MergeFrom(from);
  // @@protoc_insertion_point(copy_constructor:mw.internal.robotics.gazebotransport.RequestImage)
}

void RequestImage::SharedCtor() {
  ::google::protobuf::internal::GetEmptyString();
  _cached_size_ = 0;
  topic_name_.UnsafeSetDefault(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
  ::memset(_has_bits_, 0, sizeof(_has_bits_));
}

RequestImage::~RequestImage() {
  // @@protoc_insertion_point(destructor:mw.internal.robotics.gazebotransport.RequestImage)
  SharedDtor();
}

void RequestImage::SharedDtor() {
  topic_name_.DestroyNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
  if (this != default_instance_) {
  }
}

void RequestImage::SetCachedSize(int size) const {
  GOOGLE_SAFE_CONCURRENT_WRITES_BEGIN();
  _cached_size_ = size;
  GOOGLE_SAFE_CONCURRENT_WRITES_END();
}
const ::google::protobuf::Descriptor* RequestImage::descriptor() {
  protobuf_AssignDescriptorsOnce();
  return RequestImage_descriptor_;
}

const RequestImage& RequestImage::default_instance() {
  if (default_instance_ == NULL) protobuf_AddDesc_mw_2einternal_2erobotics_2egazebotransport_2eCoSimMsgs_2eproto();
  return *default_instance_;
}

RequestImage* RequestImage::default_instance_ = NULL;

RequestImage* RequestImage::New(::google::protobuf::Arena* arena) const {
  RequestImage* n = new RequestImage;
  if (arena != NULL) {
    arena->Own(n);
  }
  return n;
}

void RequestImage::Clear() {
// @@protoc_insertion_point(message_clear_start:mw.internal.robotics.gazebotransport.RequestImage)
  if (has_topic_name()) {
    topic_name_.ClearToEmptyNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
  }
  ::memset(_has_bits_, 0, sizeof(_has_bits_));
  if (_internal_metadata_.have_unknown_fields()) {
    mutable_unknown_fields()->Clear();
  }
}

bool RequestImage::MergePartialFromCodedStream(
    ::google::protobuf::io::CodedInputStream* input) {
#define DO_(EXPRESSION) if (!GOOGLE_PREDICT_TRUE(EXPRESSION)) goto failure
  ::google::protobuf::uint32 tag;
  // @@protoc_insertion_point(parse_start:mw.internal.robotics.gazebotransport.RequestImage)
  for (;;) {
    ::std::pair< ::google::protobuf::uint32, bool> p = input->ReadTagWithCutoff(127);
    tag = p.first;
    if (!p.second) goto handle_unusual;
    switch (::google::protobuf::internal::WireFormatLite::GetTagFieldNumber(tag)) {
      // required string topic_name = 1;
      case 1: {
        if (tag == 10) {
          DO_(::google::protobuf::internal::WireFormatLite::ReadString(
                input, this->mutable_topic_name()));
          ::google::protobuf::internal::WireFormat::VerifyUTF8StringNamedField(
            this->topic_name().data(), this->topic_name().length(),
            ::google::protobuf::internal::WireFormat::PARSE,
            "mw.internal.robotics.gazebotransport.RequestImage.topic_name");
        } else {
          goto handle_unusual;
        }
        if (input->ExpectAtEnd()) goto success;
        break;
      }

      default: {
      handle_unusual:
        if (tag == 0 ||
            ::google::protobuf::internal::WireFormatLite::GetTagWireType(tag) ==
            ::google::protobuf::internal::WireFormatLite::WIRETYPE_END_GROUP) {
          goto success;
        }
        DO_(::google::protobuf::internal::WireFormat::SkipField(
              input, tag, mutable_unknown_fields()));
        break;
      }
    }
  }
success:
  // @@protoc_insertion_point(parse_success:mw.internal.robotics.gazebotransport.RequestImage)
  return true;
failure:
  // @@protoc_insertion_point(parse_failure:mw.internal.robotics.gazebotransport.RequestImage)
  return false;
#undef DO_
}

void RequestImage::SerializeWithCachedSizes(
    ::google::protobuf::io::CodedOutputStream* output) const {
  // @@protoc_insertion_point(serialize_start:mw.internal.robotics.gazebotransport.RequestImage)
  // required string topic_name = 1;
  if (has_topic_name()) {
    ::google::protobuf::internal::WireFormat::VerifyUTF8StringNamedField(
      this->topic_name().data(), this->topic_name().length(),
      ::google::protobuf::internal::WireFormat::SERIALIZE,
      "mw.internal.robotics.gazebotransport.RequestImage.topic_name");
    ::google::protobuf::internal::WireFormatLite::WriteStringMaybeAliased(
      1, this->topic_name(), output);
  }

  if (_internal_metadata_.have_unknown_fields()) {
    ::google::protobuf::internal::WireFormat::SerializeUnknownFields(
        unknown_fields(), output);
  }
  // @@protoc_insertion_point(serialize_end:mw.internal.robotics.gazebotransport.RequestImage)
}

::google::protobuf::uint8* RequestImage::InternalSerializeWithCachedSizesToArray(
    bool deterministic, ::google::protobuf::uint8* target) const {
  // @@protoc_insertion_point(serialize_to_array_start:mw.internal.robotics.gazebotransport.RequestImage)
  // required string topic_name = 1;
  if (has_topic_name()) {
    ::google::protobuf::internal::WireFormat::VerifyUTF8StringNamedField(
      this->topic_name().data(), this->topic_name().length(),
      ::google::protobuf::internal::WireFormat::SERIALIZE,
      "mw.internal.robotics.gazebotransport.RequestImage.topic_name");
    target =
      ::google::protobuf::internal::WireFormatLite::WriteStringToArray(
        1, this->topic_name(), target);
  }

  if (_internal_metadata_.have_unknown_fields()) {
    target = ::google::protobuf::internal::WireFormat::SerializeUnknownFieldsToArray(
        unknown_fields(), target);
  }
  // @@protoc_insertion_point(serialize_to_array_end:mw.internal.robotics.gazebotransport.RequestImage)
  return target;
}

int RequestImage::ByteSize() const {
// @@protoc_insertion_point(message_byte_size_start:mw.internal.robotics.gazebotransport.RequestImage)
  int total_size = 0;

  // required string topic_name = 1;
  if (has_topic_name()) {
    total_size += 1 +
      ::google::protobuf::internal::WireFormatLite::StringSize(
        this->topic_name());
  }
  if (_internal_metadata_.have_unknown_fields()) {
    total_size +=
      ::google::protobuf::internal::WireFormat::ComputeUnknownFieldsSize(
        unknown_fields());
  }
  GOOGLE_SAFE_CONCURRENT_WRITES_BEGIN();
  _cached_size_ = total_size;
  GOOGLE_SAFE_CONCURRENT_WRITES_END();
  return total_size;
}

void RequestImage::MergeFrom(const ::google::protobuf::Message& from) {
// @@protoc_insertion_point(generalized_merge_from_start:mw.internal.robotics.gazebotransport.RequestImage)
  if (GOOGLE_PREDICT_FALSE(&from == this)) {
    ::google::protobuf::internal::MergeFromFail(__FILE__, __LINE__);
  }
  const RequestImage* source = 
      ::google::protobuf::internal::DynamicCastToGenerated<const RequestImage>(
          &from);
  if (source == NULL) {
  // @@protoc_insertion_point(generalized_merge_from_cast_fail:mw.internal.robotics.gazebotransport.RequestImage)
    ::google::protobuf::internal::ReflectionOps::Merge(from, this);
  } else {
  // @@protoc_insertion_point(generalized_merge_from_cast_success:mw.internal.robotics.gazebotransport.RequestImage)
    MergeFrom(*source);
  }
}

void RequestImage::MergeFrom(const RequestImage& from) {
// @@protoc_insertion_point(class_specific_merge_from_start:mw.internal.robotics.gazebotransport.RequestImage)
  if (GOOGLE_PREDICT_FALSE(&from == this)) {
    ::google::protobuf::internal::MergeFromFail(__FILE__, __LINE__);
  }
  if (from._has_bits_[0 / 32] & (0xffu << (0 % 32))) {
    if (from.has_topic_name()) {
      set_has_topic_name();
      topic_name_.AssignWithDefault(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), from.topic_name_);
    }
  }
  if (from._internal_metadata_.have_unknown_fields()) {
    mutable_unknown_fields()->MergeFrom(from.unknown_fields());
  }
}

void RequestImage::CopyFrom(const ::google::protobuf::Message& from) {
// @@protoc_insertion_point(generalized_copy_from_start:mw.internal.robotics.gazebotransport.RequestImage)
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

void RequestImage::CopyFrom(const RequestImage& from) {
// @@protoc_insertion_point(class_specific_copy_from_start:mw.internal.robotics.gazebotransport.RequestImage)
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

bool RequestImage::IsInitialized() const {
  if ((_has_bits_[0] & 0x00000001) != 0x00000001) return false;

  return true;
}

void RequestImage::Swap(RequestImage* other) {
  if (other == this) return;
  InternalSwap(other);
}
void RequestImage::InternalSwap(RequestImage* other) {
  topic_name_.Swap(&other->topic_name_);
  std::swap(_has_bits_[0], other->_has_bits_[0]);
  _internal_metadata_.Swap(&other->_internal_metadata_);
  std::swap(_cached_size_, other->_cached_size_);
}

::google::protobuf::Metadata RequestImage::GetMetadata() const {
  protobuf_AssignDescriptorsOnce();
  ::google::protobuf::Metadata metadata;
  metadata.descriptor = RequestImage_descriptor_;
  metadata.reflection = RequestImage_reflection_;
  return metadata;
}

#if PROTOBUF_INLINE_NOT_IN_HEADERS
// RequestImage

// required string topic_name = 1;
bool RequestImage::has_topic_name() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
void RequestImage::set_has_topic_name() {
  _has_bits_[0] |= 0x00000001u;
}
void RequestImage::clear_has_topic_name() {
  _has_bits_[0] &= ~0x00000001u;
}
void RequestImage::clear_topic_name() {
  topic_name_.ClearToEmptyNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
  clear_has_topic_name();
}
 const ::std::string& RequestImage::topic_name() const {
  // @@protoc_insertion_point(field_get:mw.internal.robotics.gazebotransport.RequestImage.topic_name)
  return topic_name_.GetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
 void RequestImage::set_topic_name(const ::std::string& value) {
  set_has_topic_name();
  topic_name_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), value);
  // @@protoc_insertion_point(field_set:mw.internal.robotics.gazebotransport.RequestImage.topic_name)
}
 void RequestImage::set_topic_name(const char* value) {
  set_has_topic_name();
  topic_name_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::string(value));
  // @@protoc_insertion_point(field_set_char:mw.internal.robotics.gazebotransport.RequestImage.topic_name)
}
 void RequestImage::set_topic_name(const char* value, size_t size) {
  set_has_topic_name();
  topic_name_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(),
      ::std::string(reinterpret_cast<const char*>(value), size));
  // @@protoc_insertion_point(field_set_pointer:mw.internal.robotics.gazebotransport.RequestImage.topic_name)
}
 ::std::string* RequestImage::mutable_topic_name() {
  set_has_topic_name();
  // @@protoc_insertion_point(field_mutable:mw.internal.robotics.gazebotransport.RequestImage.topic_name)
  return topic_name_.MutableNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
 ::std::string* RequestImage::release_topic_name() {
  // @@protoc_insertion_point(field_release:mw.internal.robotics.gazebotransport.RequestImage.topic_name)
  clear_has_topic_name();
  return topic_name_.ReleaseNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
 void RequestImage::set_allocated_topic_name(::std::string* topic_name) {
  if (topic_name != NULL) {
    set_has_topic_name();
  } else {
    clear_has_topic_name();
  }
  topic_name_.SetAllocatedNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), topic_name);
  // @@protoc_insertion_point(field_set_allocated:mw.internal.robotics.gazebotransport.RequestImage.topic_name)
}

#endif  // PROTOBUF_INLINE_NOT_IN_HEADERS

// ===================================================================

#if !defined(_MSC_VER) || _MSC_VER >= 1900
const int RequestCoSim::kClientIdFieldNumber;
const int RequestCoSim::kDurationFieldNumber;
#endif  // !defined(_MSC_VER) || _MSC_VER >= 1900

RequestCoSim::RequestCoSim()
  : ::google::protobuf::Message(), _internal_metadata_(NULL) {
  SharedCtor();
  // @@protoc_insertion_point(constructor:mw.internal.robotics.gazebotransport.RequestCoSim)
}

void RequestCoSim::InitAsDefaultInstance() {
}

RequestCoSim::RequestCoSim(const RequestCoSim& from)
  : ::google::protobuf::Message(),
    _internal_metadata_(NULL) {
  SharedCtor();
  MergeFrom(from);
  // @@protoc_insertion_point(copy_constructor:mw.internal.robotics.gazebotransport.RequestCoSim)
}

void RequestCoSim::SharedCtor() {
  ::google::protobuf::internal::GetEmptyString();
  _cached_size_ = 0;
  client_id_.UnsafeSetDefault(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
  duration_ = 0;
  ::memset(_has_bits_, 0, sizeof(_has_bits_));
}

RequestCoSim::~RequestCoSim() {
  // @@protoc_insertion_point(destructor:mw.internal.robotics.gazebotransport.RequestCoSim)
  SharedDtor();
}

void RequestCoSim::SharedDtor() {
  client_id_.DestroyNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
  if (this != default_instance_) {
  }
}

void RequestCoSim::SetCachedSize(int size) const {
  GOOGLE_SAFE_CONCURRENT_WRITES_BEGIN();
  _cached_size_ = size;
  GOOGLE_SAFE_CONCURRENT_WRITES_END();
}
const ::google::protobuf::Descriptor* RequestCoSim::descriptor() {
  protobuf_AssignDescriptorsOnce();
  return RequestCoSim_descriptor_;
}

const RequestCoSim& RequestCoSim::default_instance() {
  if (default_instance_ == NULL) protobuf_AddDesc_mw_2einternal_2erobotics_2egazebotransport_2eCoSimMsgs_2eproto();
  return *default_instance_;
}

RequestCoSim* RequestCoSim::default_instance_ = NULL;

RequestCoSim* RequestCoSim::New(::google::protobuf::Arena* arena) const {
  RequestCoSim* n = new RequestCoSim;
  if (arena != NULL) {
    arena->Own(n);
  }
  return n;
}

void RequestCoSim::Clear() {
// @@protoc_insertion_point(message_clear_start:mw.internal.robotics.gazebotransport.RequestCoSim)
  if (_has_bits_[0 / 32] & 3u) {
    if (has_client_id()) {
      client_id_.ClearToEmptyNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
    }
    duration_ = 0;
  }
  ::memset(_has_bits_, 0, sizeof(_has_bits_));
  if (_internal_metadata_.have_unknown_fields()) {
    mutable_unknown_fields()->Clear();
  }
}

bool RequestCoSim::MergePartialFromCodedStream(
    ::google::protobuf::io::CodedInputStream* input) {
#define DO_(EXPRESSION) if (!GOOGLE_PREDICT_TRUE(EXPRESSION)) goto failure
  ::google::protobuf::uint32 tag;
  // @@protoc_insertion_point(parse_start:mw.internal.robotics.gazebotransport.RequestCoSim)
  for (;;) {
    ::std::pair< ::google::protobuf::uint32, bool> p = input->ReadTagWithCutoff(127);
    tag = p.first;
    if (!p.second) goto handle_unusual;
    switch (::google::protobuf::internal::WireFormatLite::GetTagFieldNumber(tag)) {
      // required string client_id = 1;
      case 1: {
        if (tag == 10) {
          DO_(::google::protobuf::internal::WireFormatLite::ReadString(
                input, this->mutable_client_id()));
          ::google::protobuf::internal::WireFormat::VerifyUTF8StringNamedField(
            this->client_id().data(), this->client_id().length(),
            ::google::protobuf::internal::WireFormat::PARSE,
            "mw.internal.robotics.gazebotransport.RequestCoSim.client_id");
        } else {
          goto handle_unusual;
        }
        if (input->ExpectTag(17)) goto parse_duration;
        break;
      }

      // required double duration = 2;
      case 2: {
        if (tag == 17) {
         parse_duration:
          DO_((::google::protobuf::internal::WireFormatLite::ReadPrimitive<
                   double, ::google::protobuf::internal::WireFormatLite::TYPE_DOUBLE>(
                 input, &duration_)));
          set_has_duration();
        } else {
          goto handle_unusual;
        }
        if (input->ExpectAtEnd()) goto success;
        break;
      }

      default: {
      handle_unusual:
        if (tag == 0 ||
            ::google::protobuf::internal::WireFormatLite::GetTagWireType(tag) ==
            ::google::protobuf::internal::WireFormatLite::WIRETYPE_END_GROUP) {
          goto success;
        }
        DO_(::google::protobuf::internal::WireFormat::SkipField(
              input, tag, mutable_unknown_fields()));
        break;
      }
    }
  }
success:
  // @@protoc_insertion_point(parse_success:mw.internal.robotics.gazebotransport.RequestCoSim)
  return true;
failure:
  // @@protoc_insertion_point(parse_failure:mw.internal.robotics.gazebotransport.RequestCoSim)
  return false;
#undef DO_
}

void RequestCoSim::SerializeWithCachedSizes(
    ::google::protobuf::io::CodedOutputStream* output) const {
  // @@protoc_insertion_point(serialize_start:mw.internal.robotics.gazebotransport.RequestCoSim)
  // required string client_id = 1;
  if (has_client_id()) {
    ::google::protobuf::internal::WireFormat::VerifyUTF8StringNamedField(
      this->client_id().data(), this->client_id().length(),
      ::google::protobuf::internal::WireFormat::SERIALIZE,
      "mw.internal.robotics.gazebotransport.RequestCoSim.client_id");
    ::google::protobuf::internal::WireFormatLite::WriteStringMaybeAliased(
      1, this->client_id(), output);
  }

  // required double duration = 2;
  if (has_duration()) {
    ::google::protobuf::internal::WireFormatLite::WriteDouble(2, this->duration(), output);
  }

  if (_internal_metadata_.have_unknown_fields()) {
    ::google::protobuf::internal::WireFormat::SerializeUnknownFields(
        unknown_fields(), output);
  }
  // @@protoc_insertion_point(serialize_end:mw.internal.robotics.gazebotransport.RequestCoSim)
}

::google::protobuf::uint8* RequestCoSim::InternalSerializeWithCachedSizesToArray(
    bool deterministic, ::google::protobuf::uint8* target) const {
  // @@protoc_insertion_point(serialize_to_array_start:mw.internal.robotics.gazebotransport.RequestCoSim)
  // required string client_id = 1;
  if (has_client_id()) {
    ::google::protobuf::internal::WireFormat::VerifyUTF8StringNamedField(
      this->client_id().data(), this->client_id().length(),
      ::google::protobuf::internal::WireFormat::SERIALIZE,
      "mw.internal.robotics.gazebotransport.RequestCoSim.client_id");
    target =
      ::google::protobuf::internal::WireFormatLite::WriteStringToArray(
        1, this->client_id(), target);
  }

  // required double duration = 2;
  if (has_duration()) {
    target = ::google::protobuf::internal::WireFormatLite::WriteDoubleToArray(2, this->duration(), target);
  }

  if (_internal_metadata_.have_unknown_fields()) {
    target = ::google::protobuf::internal::WireFormat::SerializeUnknownFieldsToArray(
        unknown_fields(), target);
  }
  // @@protoc_insertion_point(serialize_to_array_end:mw.internal.robotics.gazebotransport.RequestCoSim)
  return target;
}

int RequestCoSim::RequiredFieldsByteSizeFallback() const {
// @@protoc_insertion_point(required_fields_byte_size_fallback_start:mw.internal.robotics.gazebotransport.RequestCoSim)
  int total_size = 0;

  if (has_client_id()) {
    // required string client_id = 1;
    total_size += 1 +
      ::google::protobuf::internal::WireFormatLite::StringSize(
        this->client_id());
  }

  if (has_duration()) {
    // required double duration = 2;
    total_size += 1 + 8;
  }

  return total_size;
}
int RequestCoSim::ByteSize() const {
// @@protoc_insertion_point(message_byte_size_start:mw.internal.robotics.gazebotransport.RequestCoSim)
  int total_size = 0;

  if (((_has_bits_[0] & 0x00000003) ^ 0x00000003) == 0) {  // All required fields are present.
    // required string client_id = 1;
    total_size += 1 +
      ::google::protobuf::internal::WireFormatLite::StringSize(
        this->client_id());

    // required double duration = 2;
    total_size += 1 + 8;

  } else {
    total_size += RequiredFieldsByteSizeFallback();
  }
  if (_internal_metadata_.have_unknown_fields()) {
    total_size +=
      ::google::protobuf::internal::WireFormat::ComputeUnknownFieldsSize(
        unknown_fields());
  }
  GOOGLE_SAFE_CONCURRENT_WRITES_BEGIN();
  _cached_size_ = total_size;
  GOOGLE_SAFE_CONCURRENT_WRITES_END();
  return total_size;
}

void RequestCoSim::MergeFrom(const ::google::protobuf::Message& from) {
// @@protoc_insertion_point(generalized_merge_from_start:mw.internal.robotics.gazebotransport.RequestCoSim)
  if (GOOGLE_PREDICT_FALSE(&from == this)) {
    ::google::protobuf::internal::MergeFromFail(__FILE__, __LINE__);
  }
  const RequestCoSim* source = 
      ::google::protobuf::internal::DynamicCastToGenerated<const RequestCoSim>(
          &from);
  if (source == NULL) {
  // @@protoc_insertion_point(generalized_merge_from_cast_fail:mw.internal.robotics.gazebotransport.RequestCoSim)
    ::google::protobuf::internal::ReflectionOps::Merge(from, this);
  } else {
  // @@protoc_insertion_point(generalized_merge_from_cast_success:mw.internal.robotics.gazebotransport.RequestCoSim)
    MergeFrom(*source);
  }
}

void RequestCoSim::MergeFrom(const RequestCoSim& from) {
// @@protoc_insertion_point(class_specific_merge_from_start:mw.internal.robotics.gazebotransport.RequestCoSim)
  if (GOOGLE_PREDICT_FALSE(&from == this)) {
    ::google::protobuf::internal::MergeFromFail(__FILE__, __LINE__);
  }
  if (from._has_bits_[0 / 32] & (0xffu << (0 % 32))) {
    if (from.has_client_id()) {
      set_has_client_id();
      client_id_.AssignWithDefault(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), from.client_id_);
    }
    if (from.has_duration()) {
      set_duration(from.duration());
    }
  }
  if (from._internal_metadata_.have_unknown_fields()) {
    mutable_unknown_fields()->MergeFrom(from.unknown_fields());
  }
}

void RequestCoSim::CopyFrom(const ::google::protobuf::Message& from) {
// @@protoc_insertion_point(generalized_copy_from_start:mw.internal.robotics.gazebotransport.RequestCoSim)
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

void RequestCoSim::CopyFrom(const RequestCoSim& from) {
// @@protoc_insertion_point(class_specific_copy_from_start:mw.internal.robotics.gazebotransport.RequestCoSim)
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

bool RequestCoSim::IsInitialized() const {
  if ((_has_bits_[0] & 0x00000003) != 0x00000003) return false;

  return true;
}

void RequestCoSim::Swap(RequestCoSim* other) {
  if (other == this) return;
  InternalSwap(other);
}
void RequestCoSim::InternalSwap(RequestCoSim* other) {
  client_id_.Swap(&other->client_id_);
  std::swap(duration_, other->duration_);
  std::swap(_has_bits_[0], other->_has_bits_[0]);
  _internal_metadata_.Swap(&other->_internal_metadata_);
  std::swap(_cached_size_, other->_cached_size_);
}

::google::protobuf::Metadata RequestCoSim::GetMetadata() const {
  protobuf_AssignDescriptorsOnce();
  ::google::protobuf::Metadata metadata;
  metadata.descriptor = RequestCoSim_descriptor_;
  metadata.reflection = RequestCoSim_reflection_;
  return metadata;
}

#if PROTOBUF_INLINE_NOT_IN_HEADERS
// RequestCoSim

// required string client_id = 1;
bool RequestCoSim::has_client_id() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
void RequestCoSim::set_has_client_id() {
  _has_bits_[0] |= 0x00000001u;
}
void RequestCoSim::clear_has_client_id() {
  _has_bits_[0] &= ~0x00000001u;
}
void RequestCoSim::clear_client_id() {
  client_id_.ClearToEmptyNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
  clear_has_client_id();
}
 const ::std::string& RequestCoSim::client_id() const {
  // @@protoc_insertion_point(field_get:mw.internal.robotics.gazebotransport.RequestCoSim.client_id)
  return client_id_.GetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
 void RequestCoSim::set_client_id(const ::std::string& value) {
  set_has_client_id();
  client_id_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), value);
  // @@protoc_insertion_point(field_set:mw.internal.robotics.gazebotransport.RequestCoSim.client_id)
}
 void RequestCoSim::set_client_id(const char* value) {
  set_has_client_id();
  client_id_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::string(value));
  // @@protoc_insertion_point(field_set_char:mw.internal.robotics.gazebotransport.RequestCoSim.client_id)
}
 void RequestCoSim::set_client_id(const char* value, size_t size) {
  set_has_client_id();
  client_id_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(),
      ::std::string(reinterpret_cast<const char*>(value), size));
  // @@protoc_insertion_point(field_set_pointer:mw.internal.robotics.gazebotransport.RequestCoSim.client_id)
}
 ::std::string* RequestCoSim::mutable_client_id() {
  set_has_client_id();
  // @@protoc_insertion_point(field_mutable:mw.internal.robotics.gazebotransport.RequestCoSim.client_id)
  return client_id_.MutableNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
 ::std::string* RequestCoSim::release_client_id() {
  // @@protoc_insertion_point(field_release:mw.internal.robotics.gazebotransport.RequestCoSim.client_id)
  clear_has_client_id();
  return client_id_.ReleaseNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
 void RequestCoSim::set_allocated_client_id(::std::string* client_id) {
  if (client_id != NULL) {
    set_has_client_id();
  } else {
    clear_has_client_id();
  }
  client_id_.SetAllocatedNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), client_id);
  // @@protoc_insertion_point(field_set_allocated:mw.internal.robotics.gazebotransport.RequestCoSim.client_id)
}

// required double duration = 2;
bool RequestCoSim::has_duration() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
void RequestCoSim::set_has_duration() {
  _has_bits_[0] |= 0x00000002u;
}
void RequestCoSim::clear_has_duration() {
  _has_bits_[0] &= ~0x00000002u;
}
void RequestCoSim::clear_duration() {
  duration_ = 0;
  clear_has_duration();
}
 double RequestCoSim::duration() const {
  // @@protoc_insertion_point(field_get:mw.internal.robotics.gazebotransport.RequestCoSim.duration)
  return duration_;
}
 void RequestCoSim::set_duration(double value) {
  set_has_duration();
  duration_ = value;
  // @@protoc_insertion_point(field_set:mw.internal.robotics.gazebotransport.RequestCoSim.duration)
}

#endif  // PROTOBUF_INLINE_NOT_IN_HEADERS

// ===================================================================

#if !defined(_MSC_VER) || _MSC_VER >= 1900
const int StopCoSim::kClientIdFieldNumber;
#endif  // !defined(_MSC_VER) || _MSC_VER >= 1900

StopCoSim::StopCoSim()
  : ::google::protobuf::Message(), _internal_metadata_(NULL) {
  SharedCtor();
  // @@protoc_insertion_point(constructor:mw.internal.robotics.gazebotransport.StopCoSim)
}

void StopCoSim::InitAsDefaultInstance() {
}

StopCoSim::StopCoSim(const StopCoSim& from)
  : ::google::protobuf::Message(),
    _internal_metadata_(NULL) {
  SharedCtor();
  MergeFrom(from);
  // @@protoc_insertion_point(copy_constructor:mw.internal.robotics.gazebotransport.StopCoSim)
}

void StopCoSim::SharedCtor() {
  ::google::protobuf::internal::GetEmptyString();
  _cached_size_ = 0;
  client_id_.UnsafeSetDefault(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
  ::memset(_has_bits_, 0, sizeof(_has_bits_));
}

StopCoSim::~StopCoSim() {
  // @@protoc_insertion_point(destructor:mw.internal.robotics.gazebotransport.StopCoSim)
  SharedDtor();
}

void StopCoSim::SharedDtor() {
  client_id_.DestroyNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
  if (this != default_instance_) {
  }
}

void StopCoSim::SetCachedSize(int size) const {
  GOOGLE_SAFE_CONCURRENT_WRITES_BEGIN();
  _cached_size_ = size;
  GOOGLE_SAFE_CONCURRENT_WRITES_END();
}
const ::google::protobuf::Descriptor* StopCoSim::descriptor() {
  protobuf_AssignDescriptorsOnce();
  return StopCoSim_descriptor_;
}

const StopCoSim& StopCoSim::default_instance() {
  if (default_instance_ == NULL) protobuf_AddDesc_mw_2einternal_2erobotics_2egazebotransport_2eCoSimMsgs_2eproto();
  return *default_instance_;
}

StopCoSim* StopCoSim::default_instance_ = NULL;

StopCoSim* StopCoSim::New(::google::protobuf::Arena* arena) const {
  StopCoSim* n = new StopCoSim;
  if (arena != NULL) {
    arena->Own(n);
  }
  return n;
}

void StopCoSim::Clear() {
// @@protoc_insertion_point(message_clear_start:mw.internal.robotics.gazebotransport.StopCoSim)
  if (has_client_id()) {
    client_id_.ClearToEmptyNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
  }
  ::memset(_has_bits_, 0, sizeof(_has_bits_));
  if (_internal_metadata_.have_unknown_fields()) {
    mutable_unknown_fields()->Clear();
  }
}

bool StopCoSim::MergePartialFromCodedStream(
    ::google::protobuf::io::CodedInputStream* input) {
#define DO_(EXPRESSION) if (!GOOGLE_PREDICT_TRUE(EXPRESSION)) goto failure
  ::google::protobuf::uint32 tag;
  // @@protoc_insertion_point(parse_start:mw.internal.robotics.gazebotransport.StopCoSim)
  for (;;) {
    ::std::pair< ::google::protobuf::uint32, bool> p = input->ReadTagWithCutoff(127);
    tag = p.first;
    if (!p.second) goto handle_unusual;
    switch (::google::protobuf::internal::WireFormatLite::GetTagFieldNumber(tag)) {
      // required string client_id = 1;
      case 1: {
        if (tag == 10) {
          DO_(::google::protobuf::internal::WireFormatLite::ReadString(
                input, this->mutable_client_id()));
          ::google::protobuf::internal::WireFormat::VerifyUTF8StringNamedField(
            this->client_id().data(), this->client_id().length(),
            ::google::protobuf::internal::WireFormat::PARSE,
            "mw.internal.robotics.gazebotransport.StopCoSim.client_id");
        } else {
          goto handle_unusual;
        }
        if (input->ExpectAtEnd()) goto success;
        break;
      }

      default: {
      handle_unusual:
        if (tag == 0 ||
            ::google::protobuf::internal::WireFormatLite::GetTagWireType(tag) ==
            ::google::protobuf::internal::WireFormatLite::WIRETYPE_END_GROUP) {
          goto success;
        }
        DO_(::google::protobuf::internal::WireFormat::SkipField(
              input, tag, mutable_unknown_fields()));
        break;
      }
    }
  }
success:
  // @@protoc_insertion_point(parse_success:mw.internal.robotics.gazebotransport.StopCoSim)
  return true;
failure:
  // @@protoc_insertion_point(parse_failure:mw.internal.robotics.gazebotransport.StopCoSim)
  return false;
#undef DO_
}

void StopCoSim::SerializeWithCachedSizes(
    ::google::protobuf::io::CodedOutputStream* output) const {
  // @@protoc_insertion_point(serialize_start:mw.internal.robotics.gazebotransport.StopCoSim)
  // required string client_id = 1;
  if (has_client_id()) {
    ::google::protobuf::internal::WireFormat::VerifyUTF8StringNamedField(
      this->client_id().data(), this->client_id().length(),
      ::google::protobuf::internal::WireFormat::SERIALIZE,
      "mw.internal.robotics.gazebotransport.StopCoSim.client_id");
    ::google::protobuf::internal::WireFormatLite::WriteStringMaybeAliased(
      1, this->client_id(), output);
  }

  if (_internal_metadata_.have_unknown_fields()) {
    ::google::protobuf::internal::WireFormat::SerializeUnknownFields(
        unknown_fields(), output);
  }
  // @@protoc_insertion_point(serialize_end:mw.internal.robotics.gazebotransport.StopCoSim)
}

::google::protobuf::uint8* StopCoSim::InternalSerializeWithCachedSizesToArray(
    bool deterministic, ::google::protobuf::uint8* target) const {
  // @@protoc_insertion_point(serialize_to_array_start:mw.internal.robotics.gazebotransport.StopCoSim)
  // required string client_id = 1;
  if (has_client_id()) {
    ::google::protobuf::internal::WireFormat::VerifyUTF8StringNamedField(
      this->client_id().data(), this->client_id().length(),
      ::google::protobuf::internal::WireFormat::SERIALIZE,
      "mw.internal.robotics.gazebotransport.StopCoSim.client_id");
    target =
      ::google::protobuf::internal::WireFormatLite::WriteStringToArray(
        1, this->client_id(), target);
  }

  if (_internal_metadata_.have_unknown_fields()) {
    target = ::google::protobuf::internal::WireFormat::SerializeUnknownFieldsToArray(
        unknown_fields(), target);
  }
  // @@protoc_insertion_point(serialize_to_array_end:mw.internal.robotics.gazebotransport.StopCoSim)
  return target;
}

int StopCoSim::ByteSize() const {
// @@protoc_insertion_point(message_byte_size_start:mw.internal.robotics.gazebotransport.StopCoSim)
  int total_size = 0;

  // required string client_id = 1;
  if (has_client_id()) {
    total_size += 1 +
      ::google::protobuf::internal::WireFormatLite::StringSize(
        this->client_id());
  }
  if (_internal_metadata_.have_unknown_fields()) {
    total_size +=
      ::google::protobuf::internal::WireFormat::ComputeUnknownFieldsSize(
        unknown_fields());
  }
  GOOGLE_SAFE_CONCURRENT_WRITES_BEGIN();
  _cached_size_ = total_size;
  GOOGLE_SAFE_CONCURRENT_WRITES_END();
  return total_size;
}

void StopCoSim::MergeFrom(const ::google::protobuf::Message& from) {
// @@protoc_insertion_point(generalized_merge_from_start:mw.internal.robotics.gazebotransport.StopCoSim)
  if (GOOGLE_PREDICT_FALSE(&from == this)) {
    ::google::protobuf::internal::MergeFromFail(__FILE__, __LINE__);
  }
  const StopCoSim* source = 
      ::google::protobuf::internal::DynamicCastToGenerated<const StopCoSim>(
          &from);
  if (source == NULL) {
  // @@protoc_insertion_point(generalized_merge_from_cast_fail:mw.internal.robotics.gazebotransport.StopCoSim)
    ::google::protobuf::internal::ReflectionOps::Merge(from, this);
  } else {
  // @@protoc_insertion_point(generalized_merge_from_cast_success:mw.internal.robotics.gazebotransport.StopCoSim)
    MergeFrom(*source);
  }
}

void StopCoSim::MergeFrom(const StopCoSim& from) {
// @@protoc_insertion_point(class_specific_merge_from_start:mw.internal.robotics.gazebotransport.StopCoSim)
  if (GOOGLE_PREDICT_FALSE(&from == this)) {
    ::google::protobuf::internal::MergeFromFail(__FILE__, __LINE__);
  }
  if (from._has_bits_[0 / 32] & (0xffu << (0 % 32))) {
    if (from.has_client_id()) {
      set_has_client_id();
      client_id_.AssignWithDefault(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), from.client_id_);
    }
  }
  if (from._internal_metadata_.have_unknown_fields()) {
    mutable_unknown_fields()->MergeFrom(from.unknown_fields());
  }
}

void StopCoSim::CopyFrom(const ::google::protobuf::Message& from) {
// @@protoc_insertion_point(generalized_copy_from_start:mw.internal.robotics.gazebotransport.StopCoSim)
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

void StopCoSim::CopyFrom(const StopCoSim& from) {
// @@protoc_insertion_point(class_specific_copy_from_start:mw.internal.robotics.gazebotransport.StopCoSim)
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

bool StopCoSim::IsInitialized() const {
  if ((_has_bits_[0] & 0x00000001) != 0x00000001) return false;

  return true;
}

void StopCoSim::Swap(StopCoSim* other) {
  if (other == this) return;
  InternalSwap(other);
}
void StopCoSim::InternalSwap(StopCoSim* other) {
  client_id_.Swap(&other->client_id_);
  std::swap(_has_bits_[0], other->_has_bits_[0]);
  _internal_metadata_.Swap(&other->_internal_metadata_);
  std::swap(_cached_size_, other->_cached_size_);
}

::google::protobuf::Metadata StopCoSim::GetMetadata() const {
  protobuf_AssignDescriptorsOnce();
  ::google::protobuf::Metadata metadata;
  metadata.descriptor = StopCoSim_descriptor_;
  metadata.reflection = StopCoSim_reflection_;
  return metadata;
}

#if PROTOBUF_INLINE_NOT_IN_HEADERS
// StopCoSim

// required string client_id = 1;
bool StopCoSim::has_client_id() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
void StopCoSim::set_has_client_id() {
  _has_bits_[0] |= 0x00000001u;
}
void StopCoSim::clear_has_client_id() {
  _has_bits_[0] &= ~0x00000001u;
}
void StopCoSim::clear_client_id() {
  client_id_.ClearToEmptyNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
  clear_has_client_id();
}
 const ::std::string& StopCoSim::client_id() const {
  // @@protoc_insertion_point(field_get:mw.internal.robotics.gazebotransport.StopCoSim.client_id)
  return client_id_.GetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
 void StopCoSim::set_client_id(const ::std::string& value) {
  set_has_client_id();
  client_id_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), value);
  // @@protoc_insertion_point(field_set:mw.internal.robotics.gazebotransport.StopCoSim.client_id)
}
 void StopCoSim::set_client_id(const char* value) {
  set_has_client_id();
  client_id_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::string(value));
  // @@protoc_insertion_point(field_set_char:mw.internal.robotics.gazebotransport.StopCoSim.client_id)
}
 void StopCoSim::set_client_id(const char* value, size_t size) {
  set_has_client_id();
  client_id_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(),
      ::std::string(reinterpret_cast<const char*>(value), size));
  // @@protoc_insertion_point(field_set_pointer:mw.internal.robotics.gazebotransport.StopCoSim.client_id)
}
 ::std::string* StopCoSim::mutable_client_id() {
  set_has_client_id();
  // @@protoc_insertion_point(field_mutable:mw.internal.robotics.gazebotransport.StopCoSim.client_id)
  return client_id_.MutableNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
 ::std::string* StopCoSim::release_client_id() {
  // @@protoc_insertion_point(field_release:mw.internal.robotics.gazebotransport.StopCoSim.client_id)
  clear_has_client_id();
  return client_id_.ReleaseNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
 void StopCoSim::set_allocated_client_id(::std::string* client_id) {
  if (client_id != NULL) {
    set_has_client_id();
  } else {
    clear_has_client_id();
  }
  client_id_.SetAllocatedNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), client_id);
  // @@protoc_insertion_point(field_set_allocated:mw.internal.robotics.gazebotransport.StopCoSim.client_id)
}

#endif  // PROTOBUF_INLINE_NOT_IN_HEADERS

// ===================================================================

#if !defined(_MSC_VER) || _MSC_VER >= 1900
const int GetGroundTruthWorldPose::kModelNameFieldNumber;
const int GetGroundTruthWorldPose::kLinkNameFieldNumber;
#endif  // !defined(_MSC_VER) || _MSC_VER >= 1900

GetGroundTruthWorldPose::GetGroundTruthWorldPose()
  : ::google::protobuf::Message(), _internal_metadata_(NULL) {
  SharedCtor();
  // @@protoc_insertion_point(constructor:mw.internal.robotics.gazebotransport.GetGroundTruthWorldPose)
}

void GetGroundTruthWorldPose::InitAsDefaultInstance() {
}

GetGroundTruthWorldPose::GetGroundTruthWorldPose(const GetGroundTruthWorldPose& from)
  : ::google::protobuf::Message(),
    _internal_metadata_(NULL) {
  SharedCtor();
  MergeFrom(from);
  // @@protoc_insertion_point(copy_constructor:mw.internal.robotics.gazebotransport.GetGroundTruthWorldPose)
}

void GetGroundTruthWorldPose::SharedCtor() {
  ::google::protobuf::internal::GetEmptyString();
  _cached_size_ = 0;
  model_name_.UnsafeSetDefault(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
  link_name_.UnsafeSetDefault(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
  ::memset(_has_bits_, 0, sizeof(_has_bits_));
}

GetGroundTruthWorldPose::~GetGroundTruthWorldPose() {
  // @@protoc_insertion_point(destructor:mw.internal.robotics.gazebotransport.GetGroundTruthWorldPose)
  SharedDtor();
}

void GetGroundTruthWorldPose::SharedDtor() {
  model_name_.DestroyNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
  link_name_.DestroyNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
  if (this != default_instance_) {
  }
}

void GetGroundTruthWorldPose::SetCachedSize(int size) const {
  GOOGLE_SAFE_CONCURRENT_WRITES_BEGIN();
  _cached_size_ = size;
  GOOGLE_SAFE_CONCURRENT_WRITES_END();
}
const ::google::protobuf::Descriptor* GetGroundTruthWorldPose::descriptor() {
  protobuf_AssignDescriptorsOnce();
  return GetGroundTruthWorldPose_descriptor_;
}

const GetGroundTruthWorldPose& GetGroundTruthWorldPose::default_instance() {
  if (default_instance_ == NULL) protobuf_AddDesc_mw_2einternal_2erobotics_2egazebotransport_2eCoSimMsgs_2eproto();
  return *default_instance_;
}

GetGroundTruthWorldPose* GetGroundTruthWorldPose::default_instance_ = NULL;

GetGroundTruthWorldPose* GetGroundTruthWorldPose::New(::google::protobuf::Arena* arena) const {
  GetGroundTruthWorldPose* n = new GetGroundTruthWorldPose;
  if (arena != NULL) {
    arena->Own(n);
  }
  return n;
}

void GetGroundTruthWorldPose::Clear() {
// @@protoc_insertion_point(message_clear_start:mw.internal.robotics.gazebotransport.GetGroundTruthWorldPose)
  if (_has_bits_[0 / 32] & 3u) {
    if (has_model_name()) {
      model_name_.ClearToEmptyNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
    }
    if (has_link_name()) {
      link_name_.ClearToEmptyNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
    }
  }
  ::memset(_has_bits_, 0, sizeof(_has_bits_));
  if (_internal_metadata_.have_unknown_fields()) {
    mutable_unknown_fields()->Clear();
  }
}

bool GetGroundTruthWorldPose::MergePartialFromCodedStream(
    ::google::protobuf::io::CodedInputStream* input) {
#define DO_(EXPRESSION) if (!GOOGLE_PREDICT_TRUE(EXPRESSION)) goto failure
  ::google::protobuf::uint32 tag;
  // @@protoc_insertion_point(parse_start:mw.internal.robotics.gazebotransport.GetGroundTruthWorldPose)
  for (;;) {
    ::std::pair< ::google::protobuf::uint32, bool> p = input->ReadTagWithCutoff(127);
    tag = p.first;
    if (!p.second) goto handle_unusual;
    switch (::google::protobuf::internal::WireFormatLite::GetTagFieldNumber(tag)) {
      // required string model_name = 1;
      case 1: {
        if (tag == 10) {
          DO_(::google::protobuf::internal::WireFormatLite::ReadString(
                input, this->mutable_model_name()));
          ::google::protobuf::internal::WireFormat::VerifyUTF8StringNamedField(
            this->model_name().data(), this->model_name().length(),
            ::google::protobuf::internal::WireFormat::PARSE,
            "mw.internal.robotics.gazebotransport.GetGroundTruthWorldPose.model_name");
        } else {
          goto handle_unusual;
        }
        if (input->ExpectTag(18)) goto parse_link_name;
        break;
      }

      // required string link_name = 2;
      case 2: {
        if (tag == 18) {
         parse_link_name:
          DO_(::google::protobuf::internal::WireFormatLite::ReadString(
                input, this->mutable_link_name()));
          ::google::protobuf::internal::WireFormat::VerifyUTF8StringNamedField(
            this->link_name().data(), this->link_name().length(),
            ::google::protobuf::internal::WireFormat::PARSE,
            "mw.internal.robotics.gazebotransport.GetGroundTruthWorldPose.link_name");
        } else {
          goto handle_unusual;
        }
        if (input->ExpectAtEnd()) goto success;
        break;
      }

      default: {
      handle_unusual:
        if (tag == 0 ||
            ::google::protobuf::internal::WireFormatLite::GetTagWireType(tag) ==
            ::google::protobuf::internal::WireFormatLite::WIRETYPE_END_GROUP) {
          goto success;
        }
        DO_(::google::protobuf::internal::WireFormat::SkipField(
              input, tag, mutable_unknown_fields()));
        break;
      }
    }
  }
success:
  // @@protoc_insertion_point(parse_success:mw.internal.robotics.gazebotransport.GetGroundTruthWorldPose)
  return true;
failure:
  // @@protoc_insertion_point(parse_failure:mw.internal.robotics.gazebotransport.GetGroundTruthWorldPose)
  return false;
#undef DO_
}

void GetGroundTruthWorldPose::SerializeWithCachedSizes(
    ::google::protobuf::io::CodedOutputStream* output) const {
  // @@protoc_insertion_point(serialize_start:mw.internal.robotics.gazebotransport.GetGroundTruthWorldPose)
  // required string model_name = 1;
  if (has_model_name()) {
    ::google::protobuf::internal::WireFormat::VerifyUTF8StringNamedField(
      this->model_name().data(), this->model_name().length(),
      ::google::protobuf::internal::WireFormat::SERIALIZE,
      "mw.internal.robotics.gazebotransport.GetGroundTruthWorldPose.model_name");
    ::google::protobuf::internal::WireFormatLite::WriteStringMaybeAliased(
      1, this->model_name(), output);
  }

  // required string link_name = 2;
  if (has_link_name()) {
    ::google::protobuf::internal::WireFormat::VerifyUTF8StringNamedField(
      this->link_name().data(), this->link_name().length(),
      ::google::protobuf::internal::WireFormat::SERIALIZE,
      "mw.internal.robotics.gazebotransport.GetGroundTruthWorldPose.link_name");
    ::google::protobuf::internal::WireFormatLite::WriteStringMaybeAliased(
      2, this->link_name(), output);
  }

  if (_internal_metadata_.have_unknown_fields()) {
    ::google::protobuf::internal::WireFormat::SerializeUnknownFields(
        unknown_fields(), output);
  }
  // @@protoc_insertion_point(serialize_end:mw.internal.robotics.gazebotransport.GetGroundTruthWorldPose)
}

::google::protobuf::uint8* GetGroundTruthWorldPose::InternalSerializeWithCachedSizesToArray(
    bool deterministic, ::google::protobuf::uint8* target) const {
  // @@protoc_insertion_point(serialize_to_array_start:mw.internal.robotics.gazebotransport.GetGroundTruthWorldPose)
  // required string model_name = 1;
  if (has_model_name()) {
    ::google::protobuf::internal::WireFormat::VerifyUTF8StringNamedField(
      this->model_name().data(), this->model_name().length(),
      ::google::protobuf::internal::WireFormat::SERIALIZE,
      "mw.internal.robotics.gazebotransport.GetGroundTruthWorldPose.model_name");
    target =
      ::google::protobuf::internal::WireFormatLite::WriteStringToArray(
        1, this->model_name(), target);
  }

  // required string link_name = 2;
  if (has_link_name()) {
    ::google::protobuf::internal::WireFormat::VerifyUTF8StringNamedField(
      this->link_name().data(), this->link_name().length(),
      ::google::protobuf::internal::WireFormat::SERIALIZE,
      "mw.internal.robotics.gazebotransport.GetGroundTruthWorldPose.link_name");
    target =
      ::google::protobuf::internal::WireFormatLite::WriteStringToArray(
        2, this->link_name(), target);
  }

  if (_internal_metadata_.have_unknown_fields()) {
    target = ::google::protobuf::internal::WireFormat::SerializeUnknownFieldsToArray(
        unknown_fields(), target);
  }
  // @@protoc_insertion_point(serialize_to_array_end:mw.internal.robotics.gazebotransport.GetGroundTruthWorldPose)
  return target;
}

int GetGroundTruthWorldPose::RequiredFieldsByteSizeFallback() const {
// @@protoc_insertion_point(required_fields_byte_size_fallback_start:mw.internal.robotics.gazebotransport.GetGroundTruthWorldPose)
  int total_size = 0;

  if (has_model_name()) {
    // required string model_name = 1;
    total_size += 1 +
      ::google::protobuf::internal::WireFormatLite::StringSize(
        this->model_name());
  }

  if (has_link_name()) {
    // required string link_name = 2;
    total_size += 1 +
      ::google::protobuf::internal::WireFormatLite::StringSize(
        this->link_name());
  }

  return total_size;
}
int GetGroundTruthWorldPose::ByteSize() const {
// @@protoc_insertion_point(message_byte_size_start:mw.internal.robotics.gazebotransport.GetGroundTruthWorldPose)
  int total_size = 0;

  if (((_has_bits_[0] & 0x00000003) ^ 0x00000003) == 0) {  // All required fields are present.
    // required string model_name = 1;
    total_size += 1 +
      ::google::protobuf::internal::WireFormatLite::StringSize(
        this->model_name());

    // required string link_name = 2;
    total_size += 1 +
      ::google::protobuf::internal::WireFormatLite::StringSize(
        this->link_name());

  } else {
    total_size += RequiredFieldsByteSizeFallback();
  }
  if (_internal_metadata_.have_unknown_fields()) {
    total_size +=
      ::google::protobuf::internal::WireFormat::ComputeUnknownFieldsSize(
        unknown_fields());
  }
  GOOGLE_SAFE_CONCURRENT_WRITES_BEGIN();
  _cached_size_ = total_size;
  GOOGLE_SAFE_CONCURRENT_WRITES_END();
  return total_size;
}

void GetGroundTruthWorldPose::MergeFrom(const ::google::protobuf::Message& from) {
// @@protoc_insertion_point(generalized_merge_from_start:mw.internal.robotics.gazebotransport.GetGroundTruthWorldPose)
  if (GOOGLE_PREDICT_FALSE(&from == this)) {
    ::google::protobuf::internal::MergeFromFail(__FILE__, __LINE__);
  }
  const GetGroundTruthWorldPose* source = 
      ::google::protobuf::internal::DynamicCastToGenerated<const GetGroundTruthWorldPose>(
          &from);
  if (source == NULL) {
  // @@protoc_insertion_point(generalized_merge_from_cast_fail:mw.internal.robotics.gazebotransport.GetGroundTruthWorldPose)
    ::google::protobuf::internal::ReflectionOps::Merge(from, this);
  } else {
  // @@protoc_insertion_point(generalized_merge_from_cast_success:mw.internal.robotics.gazebotransport.GetGroundTruthWorldPose)
    MergeFrom(*source);
  }
}

void GetGroundTruthWorldPose::MergeFrom(const GetGroundTruthWorldPose& from) {
// @@protoc_insertion_point(class_specific_merge_from_start:mw.internal.robotics.gazebotransport.GetGroundTruthWorldPose)
  if (GOOGLE_PREDICT_FALSE(&from == this)) {
    ::google::protobuf::internal::MergeFromFail(__FILE__, __LINE__);
  }
  if (from._has_bits_[0 / 32] & (0xffu << (0 % 32))) {
    if (from.has_model_name()) {
      set_has_model_name();
      model_name_.AssignWithDefault(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), from.model_name_);
    }
    if (from.has_link_name()) {
      set_has_link_name();
      link_name_.AssignWithDefault(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), from.link_name_);
    }
  }
  if (from._internal_metadata_.have_unknown_fields()) {
    mutable_unknown_fields()->MergeFrom(from.unknown_fields());
  }
}

void GetGroundTruthWorldPose::CopyFrom(const ::google::protobuf::Message& from) {
// @@protoc_insertion_point(generalized_copy_from_start:mw.internal.robotics.gazebotransport.GetGroundTruthWorldPose)
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

void GetGroundTruthWorldPose::CopyFrom(const GetGroundTruthWorldPose& from) {
// @@protoc_insertion_point(class_specific_copy_from_start:mw.internal.robotics.gazebotransport.GetGroundTruthWorldPose)
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

bool GetGroundTruthWorldPose::IsInitialized() const {
  if ((_has_bits_[0] & 0x00000003) != 0x00000003) return false;

  return true;
}

void GetGroundTruthWorldPose::Swap(GetGroundTruthWorldPose* other) {
  if (other == this) return;
  InternalSwap(other);
}
void GetGroundTruthWorldPose::InternalSwap(GetGroundTruthWorldPose* other) {
  model_name_.Swap(&other->model_name_);
  link_name_.Swap(&other->link_name_);
  std::swap(_has_bits_[0], other->_has_bits_[0]);
  _internal_metadata_.Swap(&other->_internal_metadata_);
  std::swap(_cached_size_, other->_cached_size_);
}

::google::protobuf::Metadata GetGroundTruthWorldPose::GetMetadata() const {
  protobuf_AssignDescriptorsOnce();
  ::google::protobuf::Metadata metadata;
  metadata.descriptor = GetGroundTruthWorldPose_descriptor_;
  metadata.reflection = GetGroundTruthWorldPose_reflection_;
  return metadata;
}

#if PROTOBUF_INLINE_NOT_IN_HEADERS
// GetGroundTruthWorldPose

// required string model_name = 1;
bool GetGroundTruthWorldPose::has_model_name() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
void GetGroundTruthWorldPose::set_has_model_name() {
  _has_bits_[0] |= 0x00000001u;
}
void GetGroundTruthWorldPose::clear_has_model_name() {
  _has_bits_[0] &= ~0x00000001u;
}
void GetGroundTruthWorldPose::clear_model_name() {
  model_name_.ClearToEmptyNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
  clear_has_model_name();
}
 const ::std::string& GetGroundTruthWorldPose::model_name() const {
  // @@protoc_insertion_point(field_get:mw.internal.robotics.gazebotransport.GetGroundTruthWorldPose.model_name)
  return model_name_.GetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
 void GetGroundTruthWorldPose::set_model_name(const ::std::string& value) {
  set_has_model_name();
  model_name_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), value);
  // @@protoc_insertion_point(field_set:mw.internal.robotics.gazebotransport.GetGroundTruthWorldPose.model_name)
}
 void GetGroundTruthWorldPose::set_model_name(const char* value) {
  set_has_model_name();
  model_name_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::string(value));
  // @@protoc_insertion_point(field_set_char:mw.internal.robotics.gazebotransport.GetGroundTruthWorldPose.model_name)
}
 void GetGroundTruthWorldPose::set_model_name(const char* value, size_t size) {
  set_has_model_name();
  model_name_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(),
      ::std::string(reinterpret_cast<const char*>(value), size));
  // @@protoc_insertion_point(field_set_pointer:mw.internal.robotics.gazebotransport.GetGroundTruthWorldPose.model_name)
}
 ::std::string* GetGroundTruthWorldPose::mutable_model_name() {
  set_has_model_name();
  // @@protoc_insertion_point(field_mutable:mw.internal.robotics.gazebotransport.GetGroundTruthWorldPose.model_name)
  return model_name_.MutableNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
 ::std::string* GetGroundTruthWorldPose::release_model_name() {
  // @@protoc_insertion_point(field_release:mw.internal.robotics.gazebotransport.GetGroundTruthWorldPose.model_name)
  clear_has_model_name();
  return model_name_.ReleaseNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
 void GetGroundTruthWorldPose::set_allocated_model_name(::std::string* model_name) {
  if (model_name != NULL) {
    set_has_model_name();
  } else {
    clear_has_model_name();
  }
  model_name_.SetAllocatedNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), model_name);
  // @@protoc_insertion_point(field_set_allocated:mw.internal.robotics.gazebotransport.GetGroundTruthWorldPose.model_name)
}

// required string link_name = 2;
bool GetGroundTruthWorldPose::has_link_name() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
void GetGroundTruthWorldPose::set_has_link_name() {
  _has_bits_[0] |= 0x00000002u;
}
void GetGroundTruthWorldPose::clear_has_link_name() {
  _has_bits_[0] &= ~0x00000002u;
}
void GetGroundTruthWorldPose::clear_link_name() {
  link_name_.ClearToEmptyNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
  clear_has_link_name();
}
 const ::std::string& GetGroundTruthWorldPose::link_name() const {
  // @@protoc_insertion_point(field_get:mw.internal.robotics.gazebotransport.GetGroundTruthWorldPose.link_name)
  return link_name_.GetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
 void GetGroundTruthWorldPose::set_link_name(const ::std::string& value) {
  set_has_link_name();
  link_name_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), value);
  // @@protoc_insertion_point(field_set:mw.internal.robotics.gazebotransport.GetGroundTruthWorldPose.link_name)
}
 void GetGroundTruthWorldPose::set_link_name(const char* value) {
  set_has_link_name();
  link_name_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::string(value));
  // @@protoc_insertion_point(field_set_char:mw.internal.robotics.gazebotransport.GetGroundTruthWorldPose.link_name)
}
 void GetGroundTruthWorldPose::set_link_name(const char* value, size_t size) {
  set_has_link_name();
  link_name_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(),
      ::std::string(reinterpret_cast<const char*>(value), size));
  // @@protoc_insertion_point(field_set_pointer:mw.internal.robotics.gazebotransport.GetGroundTruthWorldPose.link_name)
}
 ::std::string* GetGroundTruthWorldPose::mutable_link_name() {
  set_has_link_name();
  // @@protoc_insertion_point(field_mutable:mw.internal.robotics.gazebotransport.GetGroundTruthWorldPose.link_name)
  return link_name_.MutableNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
 ::std::string* GetGroundTruthWorldPose::release_link_name() {
  // @@protoc_insertion_point(field_release:mw.internal.robotics.gazebotransport.GetGroundTruthWorldPose.link_name)
  clear_has_link_name();
  return link_name_.ReleaseNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
 void GetGroundTruthWorldPose::set_allocated_link_name(::std::string* link_name) {
  if (link_name != NULL) {
    set_has_link_name();
  } else {
    clear_has_link_name();
  }
  link_name_.SetAllocatedNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), link_name);
  // @@protoc_insertion_point(field_set_allocated:mw.internal.robotics.gazebotransport.GetGroundTruthWorldPose.link_name)
}

#endif  // PROTOBUF_INLINE_NOT_IN_HEADERS

// ===================================================================

#if !defined(_MSC_VER) || _MSC_VER >= 1900
const int Point::kXFieldNumber;
const int Point::kYFieldNumber;
const int Point::kZFieldNumber;
#endif  // !defined(_MSC_VER) || _MSC_VER >= 1900

Point::Point()
  : ::google::protobuf::Message(), _internal_metadata_(NULL) {
  SharedCtor();
  // @@protoc_insertion_point(constructor:mw.internal.robotics.gazebotransport.Point)
}

void Point::InitAsDefaultInstance() {
}

Point::Point(const Point& from)
  : ::google::protobuf::Message(),
    _internal_metadata_(NULL) {
  SharedCtor();
  MergeFrom(from);
  // @@protoc_insertion_point(copy_constructor:mw.internal.robotics.gazebotransport.Point)
}

void Point::SharedCtor() {
  _cached_size_ = 0;
  x_ = 0;
  y_ = 0;
  z_ = 0;
  ::memset(_has_bits_, 0, sizeof(_has_bits_));
}

Point::~Point() {
  // @@protoc_insertion_point(destructor:mw.internal.robotics.gazebotransport.Point)
  SharedDtor();
}

void Point::SharedDtor() {
  if (this != default_instance_) {
  }
}

void Point::SetCachedSize(int size) const {
  GOOGLE_SAFE_CONCURRENT_WRITES_BEGIN();
  _cached_size_ = size;
  GOOGLE_SAFE_CONCURRENT_WRITES_END();
}
const ::google::protobuf::Descriptor* Point::descriptor() {
  protobuf_AssignDescriptorsOnce();
  return Point_descriptor_;
}

const Point& Point::default_instance() {
  if (default_instance_ == NULL) protobuf_AddDesc_mw_2einternal_2erobotics_2egazebotransport_2eCoSimMsgs_2eproto();
  return *default_instance_;
}

Point* Point::default_instance_ = NULL;

Point* Point::New(::google::protobuf::Arena* arena) const {
  Point* n = new Point;
  if (arena != NULL) {
    arena->Own(n);
  }
  return n;
}

void Point::Clear() {
// @@protoc_insertion_point(message_clear_start:mw.internal.robotics.gazebotransport.Point)
#if defined(__clang__)
#define ZR_HELPER_(f) \
  _Pragma("clang diagnostic push") \
  _Pragma("clang diagnostic ignored \"-Winvalid-offsetof\"") \
  __builtin_offsetof(Point, f) \
  _Pragma("clang diagnostic pop")
#else
#define ZR_HELPER_(f) reinterpret_cast<char*>(\
  &reinterpret_cast<Point*>(16)->f)
#endif

#define ZR_(first, last) do {\
  ::memset(&first, 0,\
           ZR_HELPER_(last) - ZR_HELPER_(first) + sizeof(last));\
} while (0)

  ZR_(x_, z_);

#undef ZR_HELPER_
#undef ZR_

  ::memset(_has_bits_, 0, sizeof(_has_bits_));
  if (_internal_metadata_.have_unknown_fields()) {
    mutable_unknown_fields()->Clear();
  }
}

bool Point::MergePartialFromCodedStream(
    ::google::protobuf::io::CodedInputStream* input) {
#define DO_(EXPRESSION) if (!GOOGLE_PREDICT_TRUE(EXPRESSION)) goto failure
  ::google::protobuf::uint32 tag;
  // @@protoc_insertion_point(parse_start:mw.internal.robotics.gazebotransport.Point)
  for (;;) {
    ::std::pair< ::google::protobuf::uint32, bool> p = input->ReadTagWithCutoff(127);
    tag = p.first;
    if (!p.second) goto handle_unusual;
    switch (::google::protobuf::internal::WireFormatLite::GetTagFieldNumber(tag)) {
      // required double x = 1;
      case 1: {
        if (tag == 9) {
          DO_((::google::protobuf::internal::WireFormatLite::ReadPrimitive<
                   double, ::google::protobuf::internal::WireFormatLite::TYPE_DOUBLE>(
                 input, &x_)));
          set_has_x();
        } else {
          goto handle_unusual;
        }
        if (input->ExpectTag(17)) goto parse_y;
        break;
      }

      // required double y = 2;
      case 2: {
        if (tag == 17) {
         parse_y:
          DO_((::google::protobuf::internal::WireFormatLite::ReadPrimitive<
                   double, ::google::protobuf::internal::WireFormatLite::TYPE_DOUBLE>(
                 input, &y_)));
          set_has_y();
        } else {
          goto handle_unusual;
        }
        if (input->ExpectTag(25)) goto parse_z;
        break;
      }

      // required double z = 3;
      case 3: {
        if (tag == 25) {
         parse_z:
          DO_((::google::protobuf::internal::WireFormatLite::ReadPrimitive<
                   double, ::google::protobuf::internal::WireFormatLite::TYPE_DOUBLE>(
                 input, &z_)));
          set_has_z();
        } else {
          goto handle_unusual;
        }
        if (input->ExpectAtEnd()) goto success;
        break;
      }

      default: {
      handle_unusual:
        if (tag == 0 ||
            ::google::protobuf::internal::WireFormatLite::GetTagWireType(tag) ==
            ::google::protobuf::internal::WireFormatLite::WIRETYPE_END_GROUP) {
          goto success;
        }
        DO_(::google::protobuf::internal::WireFormat::SkipField(
              input, tag, mutable_unknown_fields()));
        break;
      }
    }
  }
success:
  // @@protoc_insertion_point(parse_success:mw.internal.robotics.gazebotransport.Point)
  return true;
failure:
  // @@protoc_insertion_point(parse_failure:mw.internal.robotics.gazebotransport.Point)
  return false;
#undef DO_
}

void Point::SerializeWithCachedSizes(
    ::google::protobuf::io::CodedOutputStream* output) const {
  // @@protoc_insertion_point(serialize_start:mw.internal.robotics.gazebotransport.Point)
  // required double x = 1;
  if (has_x()) {
    ::google::protobuf::internal::WireFormatLite::WriteDouble(1, this->x(), output);
  }

  // required double y = 2;
  if (has_y()) {
    ::google::protobuf::internal::WireFormatLite::WriteDouble(2, this->y(), output);
  }

  // required double z = 3;
  if (has_z()) {
    ::google::protobuf::internal::WireFormatLite::WriteDouble(3, this->z(), output);
  }

  if (_internal_metadata_.have_unknown_fields()) {
    ::google::protobuf::internal::WireFormat::SerializeUnknownFields(
        unknown_fields(), output);
  }
  // @@protoc_insertion_point(serialize_end:mw.internal.robotics.gazebotransport.Point)
}

::google::protobuf::uint8* Point::InternalSerializeWithCachedSizesToArray(
    bool deterministic, ::google::protobuf::uint8* target) const {
  // @@protoc_insertion_point(serialize_to_array_start:mw.internal.robotics.gazebotransport.Point)
  // required double x = 1;
  if (has_x()) {
    target = ::google::protobuf::internal::WireFormatLite::WriteDoubleToArray(1, this->x(), target);
  }

  // required double y = 2;
  if (has_y()) {
    target = ::google::protobuf::internal::WireFormatLite::WriteDoubleToArray(2, this->y(), target);
  }

  // required double z = 3;
  if (has_z()) {
    target = ::google::protobuf::internal::WireFormatLite::WriteDoubleToArray(3, this->z(), target);
  }

  if (_internal_metadata_.have_unknown_fields()) {
    target = ::google::protobuf::internal::WireFormat::SerializeUnknownFieldsToArray(
        unknown_fields(), target);
  }
  // @@protoc_insertion_point(serialize_to_array_end:mw.internal.robotics.gazebotransport.Point)
  return target;
}

int Point::RequiredFieldsByteSizeFallback() const {
// @@protoc_insertion_point(required_fields_byte_size_fallback_start:mw.internal.robotics.gazebotransport.Point)
  int total_size = 0;

  if (has_x()) {
    // required double x = 1;
    total_size += 1 + 8;
  }

  if (has_y()) {
    // required double y = 2;
    total_size += 1 + 8;
  }

  if (has_z()) {
    // required double z = 3;
    total_size += 1 + 8;
  }

  return total_size;
}
int Point::ByteSize() const {
// @@protoc_insertion_point(message_byte_size_start:mw.internal.robotics.gazebotransport.Point)
  int total_size = 0;

  if (((_has_bits_[0] & 0x00000007) ^ 0x00000007) == 0) {  // All required fields are present.
    // required double x = 1;
    total_size += 1 + 8;

    // required double y = 2;
    total_size += 1 + 8;

    // required double z = 3;
    total_size += 1 + 8;

  } else {
    total_size += RequiredFieldsByteSizeFallback();
  }
  if (_internal_metadata_.have_unknown_fields()) {
    total_size +=
      ::google::protobuf::internal::WireFormat::ComputeUnknownFieldsSize(
        unknown_fields());
  }
  GOOGLE_SAFE_CONCURRENT_WRITES_BEGIN();
  _cached_size_ = total_size;
  GOOGLE_SAFE_CONCURRENT_WRITES_END();
  return total_size;
}

void Point::MergeFrom(const ::google::protobuf::Message& from) {
// @@protoc_insertion_point(generalized_merge_from_start:mw.internal.robotics.gazebotransport.Point)
  if (GOOGLE_PREDICT_FALSE(&from == this)) {
    ::google::protobuf::internal::MergeFromFail(__FILE__, __LINE__);
  }
  const Point* source = 
      ::google::protobuf::internal::DynamicCastToGenerated<const Point>(
          &from);
  if (source == NULL) {
  // @@protoc_insertion_point(generalized_merge_from_cast_fail:mw.internal.robotics.gazebotransport.Point)
    ::google::protobuf::internal::ReflectionOps::Merge(from, this);
  } else {
  // @@protoc_insertion_point(generalized_merge_from_cast_success:mw.internal.robotics.gazebotransport.Point)
    MergeFrom(*source);
  }
}

void Point::MergeFrom(const Point& from) {
// @@protoc_insertion_point(class_specific_merge_from_start:mw.internal.robotics.gazebotransport.Point)
  if (GOOGLE_PREDICT_FALSE(&from == this)) {
    ::google::protobuf::internal::MergeFromFail(__FILE__, __LINE__);
  }
  if (from._has_bits_[0 / 32] & (0xffu << (0 % 32))) {
    if (from.has_x()) {
      set_x(from.x());
    }
    if (from.has_y()) {
      set_y(from.y());
    }
    if (from.has_z()) {
      set_z(from.z());
    }
  }
  if (from._internal_metadata_.have_unknown_fields()) {
    mutable_unknown_fields()->MergeFrom(from.unknown_fields());
  }
}

void Point::CopyFrom(const ::google::protobuf::Message& from) {
// @@protoc_insertion_point(generalized_copy_from_start:mw.internal.robotics.gazebotransport.Point)
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

void Point::CopyFrom(const Point& from) {
// @@protoc_insertion_point(class_specific_copy_from_start:mw.internal.robotics.gazebotransport.Point)
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

bool Point::IsInitialized() const {
  if ((_has_bits_[0] & 0x00000007) != 0x00000007) return false;

  return true;
}

void Point::Swap(Point* other) {
  if (other == this) return;
  InternalSwap(other);
}
void Point::InternalSwap(Point* other) {
  std::swap(x_, other->x_);
  std::swap(y_, other->y_);
  std::swap(z_, other->z_);
  std::swap(_has_bits_[0], other->_has_bits_[0]);
  _internal_metadata_.Swap(&other->_internal_metadata_);
  std::swap(_cached_size_, other->_cached_size_);
}

::google::protobuf::Metadata Point::GetMetadata() const {
  protobuf_AssignDescriptorsOnce();
  ::google::protobuf::Metadata metadata;
  metadata.descriptor = Point_descriptor_;
  metadata.reflection = Point_reflection_;
  return metadata;
}

#if PROTOBUF_INLINE_NOT_IN_HEADERS
// Point

// required double x = 1;
bool Point::has_x() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
void Point::set_has_x() {
  _has_bits_[0] |= 0x00000001u;
}
void Point::clear_has_x() {
  _has_bits_[0] &= ~0x00000001u;
}
void Point::clear_x() {
  x_ = 0;
  clear_has_x();
}
 double Point::x() const {
  // @@protoc_insertion_point(field_get:mw.internal.robotics.gazebotransport.Point.x)
  return x_;
}
 void Point::set_x(double value) {
  set_has_x();
  x_ = value;
  // @@protoc_insertion_point(field_set:mw.internal.robotics.gazebotransport.Point.x)
}

// required double y = 2;
bool Point::has_y() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
void Point::set_has_y() {
  _has_bits_[0] |= 0x00000002u;
}
void Point::clear_has_y() {
  _has_bits_[0] &= ~0x00000002u;
}
void Point::clear_y() {
  y_ = 0;
  clear_has_y();
}
 double Point::y() const {
  // @@protoc_insertion_point(field_get:mw.internal.robotics.gazebotransport.Point.y)
  return y_;
}
 void Point::set_y(double value) {
  set_has_y();
  y_ = value;
  // @@protoc_insertion_point(field_set:mw.internal.robotics.gazebotransport.Point.y)
}

// required double z = 3;
bool Point::has_z() const {
  return (_has_bits_[0] & 0x00000004u) != 0;
}
void Point::set_has_z() {
  _has_bits_[0] |= 0x00000004u;
}
void Point::clear_has_z() {
  _has_bits_[0] &= ~0x00000004u;
}
void Point::clear_z() {
  z_ = 0;
  clear_has_z();
}
 double Point::z() const {
  // @@protoc_insertion_point(field_get:mw.internal.robotics.gazebotransport.Point.z)
  return z_;
}
 void Point::set_z(double value) {
  set_has_z();
  z_ = value;
  // @@protoc_insertion_point(field_set:mw.internal.robotics.gazebotransport.Point.z)
}

#endif  // PROTOBUF_INLINE_NOT_IN_HEADERS

// ===================================================================

#if !defined(_MSC_VER) || _MSC_VER >= 1900
const int Quaternion::kXFieldNumber;
const int Quaternion::kYFieldNumber;
const int Quaternion::kZFieldNumber;
const int Quaternion::kWFieldNumber;
#endif  // !defined(_MSC_VER) || _MSC_VER >= 1900

Quaternion::Quaternion()
  : ::google::protobuf::Message(), _internal_metadata_(NULL) {
  SharedCtor();
  // @@protoc_insertion_point(constructor:mw.internal.robotics.gazebotransport.Quaternion)
}

void Quaternion::InitAsDefaultInstance() {
}

Quaternion::Quaternion(const Quaternion& from)
  : ::google::protobuf::Message(),
    _internal_metadata_(NULL) {
  SharedCtor();
  MergeFrom(from);
  // @@protoc_insertion_point(copy_constructor:mw.internal.robotics.gazebotransport.Quaternion)
}

void Quaternion::SharedCtor() {
  _cached_size_ = 0;
  x_ = 0;
  y_ = 0;
  z_ = 0;
  w_ = 0;
  ::memset(_has_bits_, 0, sizeof(_has_bits_));
}

Quaternion::~Quaternion() {
  // @@protoc_insertion_point(destructor:mw.internal.robotics.gazebotransport.Quaternion)
  SharedDtor();
}

void Quaternion::SharedDtor() {
  if (this != default_instance_) {
  }
}

void Quaternion::SetCachedSize(int size) const {
  GOOGLE_SAFE_CONCURRENT_WRITES_BEGIN();
  _cached_size_ = size;
  GOOGLE_SAFE_CONCURRENT_WRITES_END();
}
const ::google::protobuf::Descriptor* Quaternion::descriptor() {
  protobuf_AssignDescriptorsOnce();
  return Quaternion_descriptor_;
}

const Quaternion& Quaternion::default_instance() {
  if (default_instance_ == NULL) protobuf_AddDesc_mw_2einternal_2erobotics_2egazebotransport_2eCoSimMsgs_2eproto();
  return *default_instance_;
}

Quaternion* Quaternion::default_instance_ = NULL;

Quaternion* Quaternion::New(::google::protobuf::Arena* arena) const {
  Quaternion* n = new Quaternion;
  if (arena != NULL) {
    arena->Own(n);
  }
  return n;
}

void Quaternion::Clear() {
// @@protoc_insertion_point(message_clear_start:mw.internal.robotics.gazebotransport.Quaternion)
#if defined(__clang__)
#define ZR_HELPER_(f) \
  _Pragma("clang diagnostic push") \
  _Pragma("clang diagnostic ignored \"-Winvalid-offsetof\"") \
  __builtin_offsetof(Quaternion, f) \
  _Pragma("clang diagnostic pop")
#else
#define ZR_HELPER_(f) reinterpret_cast<char*>(\
  &reinterpret_cast<Quaternion*>(16)->f)
#endif

#define ZR_(first, last) do {\
  ::memset(&first, 0,\
           ZR_HELPER_(last) - ZR_HELPER_(first) + sizeof(last));\
} while (0)

  ZR_(x_, w_);

#undef ZR_HELPER_
#undef ZR_

  ::memset(_has_bits_, 0, sizeof(_has_bits_));
  if (_internal_metadata_.have_unknown_fields()) {
    mutable_unknown_fields()->Clear();
  }
}

bool Quaternion::MergePartialFromCodedStream(
    ::google::protobuf::io::CodedInputStream* input) {
#define DO_(EXPRESSION) if (!GOOGLE_PREDICT_TRUE(EXPRESSION)) goto failure
  ::google::protobuf::uint32 tag;
  // @@protoc_insertion_point(parse_start:mw.internal.robotics.gazebotransport.Quaternion)
  for (;;) {
    ::std::pair< ::google::protobuf::uint32, bool> p = input->ReadTagWithCutoff(127);
    tag = p.first;
    if (!p.second) goto handle_unusual;
    switch (::google::protobuf::internal::WireFormatLite::GetTagFieldNumber(tag)) {
      // required double x = 1;
      case 1: {
        if (tag == 9) {
          DO_((::google::protobuf::internal::WireFormatLite::ReadPrimitive<
                   double, ::google::protobuf::internal::WireFormatLite::TYPE_DOUBLE>(
                 input, &x_)));
          set_has_x();
        } else {
          goto handle_unusual;
        }
        if (input->ExpectTag(17)) goto parse_y;
        break;
      }

      // required double y = 2;
      case 2: {
        if (tag == 17) {
         parse_y:
          DO_((::google::protobuf::internal::WireFormatLite::ReadPrimitive<
                   double, ::google::protobuf::internal::WireFormatLite::TYPE_DOUBLE>(
                 input, &y_)));
          set_has_y();
        } else {
          goto handle_unusual;
        }
        if (input->ExpectTag(25)) goto parse_z;
        break;
      }

      // required double z = 3;
      case 3: {
        if (tag == 25) {
         parse_z:
          DO_((::google::protobuf::internal::WireFormatLite::ReadPrimitive<
                   double, ::google::protobuf::internal::WireFormatLite::TYPE_DOUBLE>(
                 input, &z_)));
          set_has_z();
        } else {
          goto handle_unusual;
        }
        if (input->ExpectTag(33)) goto parse_w;
        break;
      }

      // required double w = 4;
      case 4: {
        if (tag == 33) {
         parse_w:
          DO_((::google::protobuf::internal::WireFormatLite::ReadPrimitive<
                   double, ::google::protobuf::internal::WireFormatLite::TYPE_DOUBLE>(
                 input, &w_)));
          set_has_w();
        } else {
          goto handle_unusual;
        }
        if (input->ExpectAtEnd()) goto success;
        break;
      }

      default: {
      handle_unusual:
        if (tag == 0 ||
            ::google::protobuf::internal::WireFormatLite::GetTagWireType(tag) ==
            ::google::protobuf::internal::WireFormatLite::WIRETYPE_END_GROUP) {
          goto success;
        }
        DO_(::google::protobuf::internal::WireFormat::SkipField(
              input, tag, mutable_unknown_fields()));
        break;
      }
    }
  }
success:
  // @@protoc_insertion_point(parse_success:mw.internal.robotics.gazebotransport.Quaternion)
  return true;
failure:
  // @@protoc_insertion_point(parse_failure:mw.internal.robotics.gazebotransport.Quaternion)
  return false;
#undef DO_
}

void Quaternion::SerializeWithCachedSizes(
    ::google::protobuf::io::CodedOutputStream* output) const {
  // @@protoc_insertion_point(serialize_start:mw.internal.robotics.gazebotransport.Quaternion)
  // required double x = 1;
  if (has_x()) {
    ::google::protobuf::internal::WireFormatLite::WriteDouble(1, this->x(), output);
  }

  // required double y = 2;
  if (has_y()) {
    ::google::protobuf::internal::WireFormatLite::WriteDouble(2, this->y(), output);
  }

  // required double z = 3;
  if (has_z()) {
    ::google::protobuf::internal::WireFormatLite::WriteDouble(3, this->z(), output);
  }

  // required double w = 4;
  if (has_w()) {
    ::google::protobuf::internal::WireFormatLite::WriteDouble(4, this->w(), output);
  }

  if (_internal_metadata_.have_unknown_fields()) {
    ::google::protobuf::internal::WireFormat::SerializeUnknownFields(
        unknown_fields(), output);
  }
  // @@protoc_insertion_point(serialize_end:mw.internal.robotics.gazebotransport.Quaternion)
}

::google::protobuf::uint8* Quaternion::InternalSerializeWithCachedSizesToArray(
    bool deterministic, ::google::protobuf::uint8* target) const {
  // @@protoc_insertion_point(serialize_to_array_start:mw.internal.robotics.gazebotransport.Quaternion)
  // required double x = 1;
  if (has_x()) {
    target = ::google::protobuf::internal::WireFormatLite::WriteDoubleToArray(1, this->x(), target);
  }

  // required double y = 2;
  if (has_y()) {
    target = ::google::protobuf::internal::WireFormatLite::WriteDoubleToArray(2, this->y(), target);
  }

  // required double z = 3;
  if (has_z()) {
    target = ::google::protobuf::internal::WireFormatLite::WriteDoubleToArray(3, this->z(), target);
  }

  // required double w = 4;
  if (has_w()) {
    target = ::google::protobuf::internal::WireFormatLite::WriteDoubleToArray(4, this->w(), target);
  }

  if (_internal_metadata_.have_unknown_fields()) {
    target = ::google::protobuf::internal::WireFormat::SerializeUnknownFieldsToArray(
        unknown_fields(), target);
  }
  // @@protoc_insertion_point(serialize_to_array_end:mw.internal.robotics.gazebotransport.Quaternion)
  return target;
}

int Quaternion::RequiredFieldsByteSizeFallback() const {
// @@protoc_insertion_point(required_fields_byte_size_fallback_start:mw.internal.robotics.gazebotransport.Quaternion)
  int total_size = 0;

  if (has_x()) {
    // required double x = 1;
    total_size += 1 + 8;
  }

  if (has_y()) {
    // required double y = 2;
    total_size += 1 + 8;
  }

  if (has_z()) {
    // required double z = 3;
    total_size += 1 + 8;
  }

  if (has_w()) {
    // required double w = 4;
    total_size += 1 + 8;
  }

  return total_size;
}
int Quaternion::ByteSize() const {
// @@protoc_insertion_point(message_byte_size_start:mw.internal.robotics.gazebotransport.Quaternion)
  int total_size = 0;

  if (((_has_bits_[0] & 0x0000000f) ^ 0x0000000f) == 0) {  // All required fields are present.
    // required double x = 1;
    total_size += 1 + 8;

    // required double y = 2;
    total_size += 1 + 8;

    // required double z = 3;
    total_size += 1 + 8;

    // required double w = 4;
    total_size += 1 + 8;

  } else {
    total_size += RequiredFieldsByteSizeFallback();
  }
  if (_internal_metadata_.have_unknown_fields()) {
    total_size +=
      ::google::protobuf::internal::WireFormat::ComputeUnknownFieldsSize(
        unknown_fields());
  }
  GOOGLE_SAFE_CONCURRENT_WRITES_BEGIN();
  _cached_size_ = total_size;
  GOOGLE_SAFE_CONCURRENT_WRITES_END();
  return total_size;
}

void Quaternion::MergeFrom(const ::google::protobuf::Message& from) {
// @@protoc_insertion_point(generalized_merge_from_start:mw.internal.robotics.gazebotransport.Quaternion)
  if (GOOGLE_PREDICT_FALSE(&from == this)) {
    ::google::protobuf::internal::MergeFromFail(__FILE__, __LINE__);
  }
  const Quaternion* source = 
      ::google::protobuf::internal::DynamicCastToGenerated<const Quaternion>(
          &from);
  if (source == NULL) {
  // @@protoc_insertion_point(generalized_merge_from_cast_fail:mw.internal.robotics.gazebotransport.Quaternion)
    ::google::protobuf::internal::ReflectionOps::Merge(from, this);
  } else {
  // @@protoc_insertion_point(generalized_merge_from_cast_success:mw.internal.robotics.gazebotransport.Quaternion)
    MergeFrom(*source);
  }
}

void Quaternion::MergeFrom(const Quaternion& from) {
// @@protoc_insertion_point(class_specific_merge_from_start:mw.internal.robotics.gazebotransport.Quaternion)
  if (GOOGLE_PREDICT_FALSE(&from == this)) {
    ::google::protobuf::internal::MergeFromFail(__FILE__, __LINE__);
  }
  if (from._has_bits_[0 / 32] & (0xffu << (0 % 32))) {
    if (from.has_x()) {
      set_x(from.x());
    }
    if (from.has_y()) {
      set_y(from.y());
    }
    if (from.has_z()) {
      set_z(from.z());
    }
    if (from.has_w()) {
      set_w(from.w());
    }
  }
  if (from._internal_metadata_.have_unknown_fields()) {
    mutable_unknown_fields()->MergeFrom(from.unknown_fields());
  }
}

void Quaternion::CopyFrom(const ::google::protobuf::Message& from) {
// @@protoc_insertion_point(generalized_copy_from_start:mw.internal.robotics.gazebotransport.Quaternion)
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

void Quaternion::CopyFrom(const Quaternion& from) {
// @@protoc_insertion_point(class_specific_copy_from_start:mw.internal.robotics.gazebotransport.Quaternion)
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

bool Quaternion::IsInitialized() const {
  if ((_has_bits_[0] & 0x0000000f) != 0x0000000f) return false;

  return true;
}

void Quaternion::Swap(Quaternion* other) {
  if (other == this) return;
  InternalSwap(other);
}
void Quaternion::InternalSwap(Quaternion* other) {
  std::swap(x_, other->x_);
  std::swap(y_, other->y_);
  std::swap(z_, other->z_);
  std::swap(w_, other->w_);
  std::swap(_has_bits_[0], other->_has_bits_[0]);
  _internal_metadata_.Swap(&other->_internal_metadata_);
  std::swap(_cached_size_, other->_cached_size_);
}

::google::protobuf::Metadata Quaternion::GetMetadata() const {
  protobuf_AssignDescriptorsOnce();
  ::google::protobuf::Metadata metadata;
  metadata.descriptor = Quaternion_descriptor_;
  metadata.reflection = Quaternion_reflection_;
  return metadata;
}

#if PROTOBUF_INLINE_NOT_IN_HEADERS
// Quaternion

// required double x = 1;
bool Quaternion::has_x() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
void Quaternion::set_has_x() {
  _has_bits_[0] |= 0x00000001u;
}
void Quaternion::clear_has_x() {
  _has_bits_[0] &= ~0x00000001u;
}
void Quaternion::clear_x() {
  x_ = 0;
  clear_has_x();
}
 double Quaternion::x() const {
  // @@protoc_insertion_point(field_get:mw.internal.robotics.gazebotransport.Quaternion.x)
  return x_;
}
 void Quaternion::set_x(double value) {
  set_has_x();
  x_ = value;
  // @@protoc_insertion_point(field_set:mw.internal.robotics.gazebotransport.Quaternion.x)
}

// required double y = 2;
bool Quaternion::has_y() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
void Quaternion::set_has_y() {
  _has_bits_[0] |= 0x00000002u;
}
void Quaternion::clear_has_y() {
  _has_bits_[0] &= ~0x00000002u;
}
void Quaternion::clear_y() {
  y_ = 0;
  clear_has_y();
}
 double Quaternion::y() const {
  // @@protoc_insertion_point(field_get:mw.internal.robotics.gazebotransport.Quaternion.y)
  return y_;
}
 void Quaternion::set_y(double value) {
  set_has_y();
  y_ = value;
  // @@protoc_insertion_point(field_set:mw.internal.robotics.gazebotransport.Quaternion.y)
}

// required double z = 3;
bool Quaternion::has_z() const {
  return (_has_bits_[0] & 0x00000004u) != 0;
}
void Quaternion::set_has_z() {
  _has_bits_[0] |= 0x00000004u;
}
void Quaternion::clear_has_z() {
  _has_bits_[0] &= ~0x00000004u;
}
void Quaternion::clear_z() {
  z_ = 0;
  clear_has_z();
}
 double Quaternion::z() const {
  // @@protoc_insertion_point(field_get:mw.internal.robotics.gazebotransport.Quaternion.z)
  return z_;
}
 void Quaternion::set_z(double value) {
  set_has_z();
  z_ = value;
  // @@protoc_insertion_point(field_set:mw.internal.robotics.gazebotransport.Quaternion.z)
}

// required double w = 4;
bool Quaternion::has_w() const {
  return (_has_bits_[0] & 0x00000008u) != 0;
}
void Quaternion::set_has_w() {
  _has_bits_[0] |= 0x00000008u;
}
void Quaternion::clear_has_w() {
  _has_bits_[0] &= ~0x00000008u;
}
void Quaternion::clear_w() {
  w_ = 0;
  clear_has_w();
}
 double Quaternion::w() const {
  // @@protoc_insertion_point(field_get:mw.internal.robotics.gazebotransport.Quaternion.w)
  return w_;
}
 void Quaternion::set_w(double value) {
  set_has_w();
  w_ = value;
  // @@protoc_insertion_point(field_set:mw.internal.robotics.gazebotransport.Quaternion.w)
}

#endif  // PROTOBUF_INLINE_NOT_IN_HEADERS

// ===================================================================

#if !defined(_MSC_VER) || _MSC_VER >= 1900
const int Pose::kPositionFieldNumber;
const int Pose::kOrientationFieldNumber;
#endif  // !defined(_MSC_VER) || _MSC_VER >= 1900

Pose::Pose()
  : ::google::protobuf::Message(), _internal_metadata_(NULL) {
  SharedCtor();
  // @@protoc_insertion_point(constructor:mw.internal.robotics.gazebotransport.Pose)
}

void Pose::InitAsDefaultInstance() {
  position_ = const_cast< ::mw::internal::robotics::gazebotransport::Point*>(&::mw::internal::robotics::gazebotransport::Point::default_instance());
  orientation_ = const_cast< ::mw::internal::robotics::gazebotransport::Quaternion*>(&::mw::internal::robotics::gazebotransport::Quaternion::default_instance());
}

Pose::Pose(const Pose& from)
  : ::google::protobuf::Message(),
    _internal_metadata_(NULL) {
  SharedCtor();
  MergeFrom(from);
  // @@protoc_insertion_point(copy_constructor:mw.internal.robotics.gazebotransport.Pose)
}

void Pose::SharedCtor() {
  _cached_size_ = 0;
  position_ = NULL;
  orientation_ = NULL;
  ::memset(_has_bits_, 0, sizeof(_has_bits_));
}

Pose::~Pose() {
  // @@protoc_insertion_point(destructor:mw.internal.robotics.gazebotransport.Pose)
  SharedDtor();
}

void Pose::SharedDtor() {
  if (this != default_instance_) {
    delete position_;
    delete orientation_;
  }
}

void Pose::SetCachedSize(int size) const {
  GOOGLE_SAFE_CONCURRENT_WRITES_BEGIN();
  _cached_size_ = size;
  GOOGLE_SAFE_CONCURRENT_WRITES_END();
}
const ::google::protobuf::Descriptor* Pose::descriptor() {
  protobuf_AssignDescriptorsOnce();
  return Pose_descriptor_;
}

const Pose& Pose::default_instance() {
  if (default_instance_ == NULL) protobuf_AddDesc_mw_2einternal_2erobotics_2egazebotransport_2eCoSimMsgs_2eproto();
  return *default_instance_;
}

Pose* Pose::default_instance_ = NULL;

Pose* Pose::New(::google::protobuf::Arena* arena) const {
  Pose* n = new Pose;
  if (arena != NULL) {
    arena->Own(n);
  }
  return n;
}

void Pose::Clear() {
// @@protoc_insertion_point(message_clear_start:mw.internal.robotics.gazebotransport.Pose)
  if (_has_bits_[0 / 32] & 3u) {
    if (has_position()) {
      if (position_ != NULL) position_->::mw::internal::robotics::gazebotransport::Point::Clear();
    }
    if (has_orientation()) {
      if (orientation_ != NULL) orientation_->::mw::internal::robotics::gazebotransport::Quaternion::Clear();
    }
  }
  ::memset(_has_bits_, 0, sizeof(_has_bits_));
  if (_internal_metadata_.have_unknown_fields()) {
    mutable_unknown_fields()->Clear();
  }
}

bool Pose::MergePartialFromCodedStream(
    ::google::protobuf::io::CodedInputStream* input) {
#define DO_(EXPRESSION) if (!GOOGLE_PREDICT_TRUE(EXPRESSION)) goto failure
  ::google::protobuf::uint32 tag;
  // @@protoc_insertion_point(parse_start:mw.internal.robotics.gazebotransport.Pose)
  for (;;) {
    ::std::pair< ::google::protobuf::uint32, bool> p = input->ReadTagWithCutoff(127);
    tag = p.first;
    if (!p.second) goto handle_unusual;
    switch (::google::protobuf::internal::WireFormatLite::GetTagFieldNumber(tag)) {
      // required .mw.internal.robotics.gazebotransport.Point position = 1;
      case 1: {
        if (tag == 10) {
          DO_(::google::protobuf::internal::WireFormatLite::ReadMessageNoVirtual(
               input, mutable_position()));
        } else {
          goto handle_unusual;
        }
        if (input->ExpectTag(18)) goto parse_orientation;
        break;
      }

      // required .mw.internal.robotics.gazebotransport.Quaternion orientation = 2;
      case 2: {
        if (tag == 18) {
         parse_orientation:
          DO_(::google::protobuf::internal::WireFormatLite::ReadMessageNoVirtual(
               input, mutable_orientation()));
        } else {
          goto handle_unusual;
        }
        if (input->ExpectAtEnd()) goto success;
        break;
      }

      default: {
      handle_unusual:
        if (tag == 0 ||
            ::google::protobuf::internal::WireFormatLite::GetTagWireType(tag) ==
            ::google::protobuf::internal::WireFormatLite::WIRETYPE_END_GROUP) {
          goto success;
        }
        DO_(::google::protobuf::internal::WireFormat::SkipField(
              input, tag, mutable_unknown_fields()));
        break;
      }
    }
  }
success:
  // @@protoc_insertion_point(parse_success:mw.internal.robotics.gazebotransport.Pose)
  return true;
failure:
  // @@protoc_insertion_point(parse_failure:mw.internal.robotics.gazebotransport.Pose)
  return false;
#undef DO_
}

void Pose::SerializeWithCachedSizes(
    ::google::protobuf::io::CodedOutputStream* output) const {
  // @@protoc_insertion_point(serialize_start:mw.internal.robotics.gazebotransport.Pose)
  // required .mw.internal.robotics.gazebotransport.Point position = 1;
  if (has_position()) {
    ::google::protobuf::internal::WireFormatLite::WriteMessageMaybeToArray(
      1, *this->position_, output);
  }

  // required .mw.internal.robotics.gazebotransport.Quaternion orientation = 2;
  if (has_orientation()) {
    ::google::protobuf::internal::WireFormatLite::WriteMessageMaybeToArray(
      2, *this->orientation_, output);
  }

  if (_internal_metadata_.have_unknown_fields()) {
    ::google::protobuf::internal::WireFormat::SerializeUnknownFields(
        unknown_fields(), output);
  }
  // @@protoc_insertion_point(serialize_end:mw.internal.robotics.gazebotransport.Pose)
}

::google::protobuf::uint8* Pose::InternalSerializeWithCachedSizesToArray(
    bool deterministic, ::google::protobuf::uint8* target) const {
  // @@protoc_insertion_point(serialize_to_array_start:mw.internal.robotics.gazebotransport.Pose)
  // required .mw.internal.robotics.gazebotransport.Point position = 1;
  if (has_position()) {
    target = ::google::protobuf::internal::WireFormatLite::
      InternalWriteMessageNoVirtualToArray(
        1, *this->position_, false, target);
  }

  // required .mw.internal.robotics.gazebotransport.Quaternion orientation = 2;
  if (has_orientation()) {
    target = ::google::protobuf::internal::WireFormatLite::
      InternalWriteMessageNoVirtualToArray(
        2, *this->orientation_, false, target);
  }

  if (_internal_metadata_.have_unknown_fields()) {
    target = ::google::protobuf::internal::WireFormat::SerializeUnknownFieldsToArray(
        unknown_fields(), target);
  }
  // @@protoc_insertion_point(serialize_to_array_end:mw.internal.robotics.gazebotransport.Pose)
  return target;
}

int Pose::RequiredFieldsByteSizeFallback() const {
// @@protoc_insertion_point(required_fields_byte_size_fallback_start:mw.internal.robotics.gazebotransport.Pose)
  int total_size = 0;

  if (has_position()) {
    // required .mw.internal.robotics.gazebotransport.Point position = 1;
    total_size += 1 +
      ::google::protobuf::internal::WireFormatLite::MessageSizeNoVirtual(
        *this->position_);
  }

  if (has_orientation()) {
    // required .mw.internal.robotics.gazebotransport.Quaternion orientation = 2;
    total_size += 1 +
      ::google::protobuf::internal::WireFormatLite::MessageSizeNoVirtual(
        *this->orientation_);
  }

  return total_size;
}
int Pose::ByteSize() const {
// @@protoc_insertion_point(message_byte_size_start:mw.internal.robotics.gazebotransport.Pose)
  int total_size = 0;

  if (((_has_bits_[0] & 0x00000003) ^ 0x00000003) == 0) {  // All required fields are present.
    // required .mw.internal.robotics.gazebotransport.Point position = 1;
    total_size += 1 +
      ::google::protobuf::internal::WireFormatLite::MessageSizeNoVirtual(
        *this->position_);

    // required .mw.internal.robotics.gazebotransport.Quaternion orientation = 2;
    total_size += 1 +
      ::google::protobuf::internal::WireFormatLite::MessageSizeNoVirtual(
        *this->orientation_);

  } else {
    total_size += RequiredFieldsByteSizeFallback();
  }
  if (_internal_metadata_.have_unknown_fields()) {
    total_size +=
      ::google::protobuf::internal::WireFormat::ComputeUnknownFieldsSize(
        unknown_fields());
  }
  GOOGLE_SAFE_CONCURRENT_WRITES_BEGIN();
  _cached_size_ = total_size;
  GOOGLE_SAFE_CONCURRENT_WRITES_END();
  return total_size;
}

void Pose::MergeFrom(const ::google::protobuf::Message& from) {
// @@protoc_insertion_point(generalized_merge_from_start:mw.internal.robotics.gazebotransport.Pose)
  if (GOOGLE_PREDICT_FALSE(&from == this)) {
    ::google::protobuf::internal::MergeFromFail(__FILE__, __LINE__);
  }
  const Pose* source = 
      ::google::protobuf::internal::DynamicCastToGenerated<const Pose>(
          &from);
  if (source == NULL) {
  // @@protoc_insertion_point(generalized_merge_from_cast_fail:mw.internal.robotics.gazebotransport.Pose)
    ::google::protobuf::internal::ReflectionOps::Merge(from, this);
  } else {
  // @@protoc_insertion_point(generalized_merge_from_cast_success:mw.internal.robotics.gazebotransport.Pose)
    MergeFrom(*source);
  }
}

void Pose::MergeFrom(const Pose& from) {
// @@protoc_insertion_point(class_specific_merge_from_start:mw.internal.robotics.gazebotransport.Pose)
  if (GOOGLE_PREDICT_FALSE(&from == this)) {
    ::google::protobuf::internal::MergeFromFail(__FILE__, __LINE__);
  }
  if (from._has_bits_[0 / 32] & (0xffu << (0 % 32))) {
    if (from.has_position()) {
      mutable_position()->::mw::internal::robotics::gazebotransport::Point::MergeFrom(from.position());
    }
    if (from.has_orientation()) {
      mutable_orientation()->::mw::internal::robotics::gazebotransport::Quaternion::MergeFrom(from.orientation());
    }
  }
  if (from._internal_metadata_.have_unknown_fields()) {
    mutable_unknown_fields()->MergeFrom(from.unknown_fields());
  }
}

void Pose::CopyFrom(const ::google::protobuf::Message& from) {
// @@protoc_insertion_point(generalized_copy_from_start:mw.internal.robotics.gazebotransport.Pose)
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

void Pose::CopyFrom(const Pose& from) {
// @@protoc_insertion_point(class_specific_copy_from_start:mw.internal.robotics.gazebotransport.Pose)
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

bool Pose::IsInitialized() const {
  if ((_has_bits_[0] & 0x00000003) != 0x00000003) return false;

  if (has_position()) {
    if (!this->position_->IsInitialized()) return false;
  }
  if (has_orientation()) {
    if (!this->orientation_->IsInitialized()) return false;
  }
  return true;
}

void Pose::Swap(Pose* other) {
  if (other == this) return;
  InternalSwap(other);
}
void Pose::InternalSwap(Pose* other) {
  std::swap(position_, other->position_);
  std::swap(orientation_, other->orientation_);
  std::swap(_has_bits_[0], other->_has_bits_[0]);
  _internal_metadata_.Swap(&other->_internal_metadata_);
  std::swap(_cached_size_, other->_cached_size_);
}

::google::protobuf::Metadata Pose::GetMetadata() const {
  protobuf_AssignDescriptorsOnce();
  ::google::protobuf::Metadata metadata;
  metadata.descriptor = Pose_descriptor_;
  metadata.reflection = Pose_reflection_;
  return metadata;
}

#if PROTOBUF_INLINE_NOT_IN_HEADERS
// Pose

// required .mw.internal.robotics.gazebotransport.Point position = 1;
bool Pose::has_position() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
void Pose::set_has_position() {
  _has_bits_[0] |= 0x00000001u;
}
void Pose::clear_has_position() {
  _has_bits_[0] &= ~0x00000001u;
}
void Pose::clear_position() {
  if (position_ != NULL) position_->::mw::internal::robotics::gazebotransport::Point::Clear();
  clear_has_position();
}
const ::mw::internal::robotics::gazebotransport::Point& Pose::position() const {
  // @@protoc_insertion_point(field_get:mw.internal.robotics.gazebotransport.Pose.position)
  return position_ != NULL ? *position_ : *default_instance_->position_;
}
::mw::internal::robotics::gazebotransport::Point* Pose::mutable_position() {
  set_has_position();
  if (position_ == NULL) {
    position_ = new ::mw::internal::robotics::gazebotransport::Point;
  }
  // @@protoc_insertion_point(field_mutable:mw.internal.robotics.gazebotransport.Pose.position)
  return position_;
}
::mw::internal::robotics::gazebotransport::Point* Pose::release_position() {
  // @@protoc_insertion_point(field_release:mw.internal.robotics.gazebotransport.Pose.position)
  clear_has_position();
  ::mw::internal::robotics::gazebotransport::Point* temp = position_;
  position_ = NULL;
  return temp;
}
void Pose::set_allocated_position(::mw::internal::robotics::gazebotransport::Point* position) {
  delete position_;
  position_ = position;
  if (position) {
    set_has_position();
  } else {
    clear_has_position();
  }
  // @@protoc_insertion_point(field_set_allocated:mw.internal.robotics.gazebotransport.Pose.position)
}

// required .mw.internal.robotics.gazebotransport.Quaternion orientation = 2;
bool Pose::has_orientation() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
void Pose::set_has_orientation() {
  _has_bits_[0] |= 0x00000002u;
}
void Pose::clear_has_orientation() {
  _has_bits_[0] &= ~0x00000002u;
}
void Pose::clear_orientation() {
  if (orientation_ != NULL) orientation_->::mw::internal::robotics::gazebotransport::Quaternion::Clear();
  clear_has_orientation();
}
const ::mw::internal::robotics::gazebotransport::Quaternion& Pose::orientation() const {
  // @@protoc_insertion_point(field_get:mw.internal.robotics.gazebotransport.Pose.orientation)
  return orientation_ != NULL ? *orientation_ : *default_instance_->orientation_;
}
::mw::internal::robotics::gazebotransport::Quaternion* Pose::mutable_orientation() {
  set_has_orientation();
  if (orientation_ == NULL) {
    orientation_ = new ::mw::internal::robotics::gazebotransport::Quaternion;
  }
  // @@protoc_insertion_point(field_mutable:mw.internal.robotics.gazebotransport.Pose.orientation)
  return orientation_;
}
::mw::internal::robotics::gazebotransport::Quaternion* Pose::release_orientation() {
  // @@protoc_insertion_point(field_release:mw.internal.robotics.gazebotransport.Pose.orientation)
  clear_has_orientation();
  ::mw::internal::robotics::gazebotransport::Quaternion* temp = orientation_;
  orientation_ = NULL;
  return temp;
}
void Pose::set_allocated_orientation(::mw::internal::robotics::gazebotransport::Quaternion* orientation) {
  delete orientation_;
  orientation_ = orientation;
  if (orientation) {
    set_has_orientation();
  } else {
    clear_has_orientation();
  }
  // @@protoc_insertion_point(field_set_allocated:mw.internal.robotics.gazebotransport.Pose.orientation)
}

#endif  // PROTOBUF_INLINE_NOT_IN_HEADERS

// ===================================================================

#if !defined(_MSC_VER) || _MSC_VER >= 1900
const int StopSimulation::kStopSceneFieldNumber;
#endif  // !defined(_MSC_VER) || _MSC_VER >= 1900

StopSimulation::StopSimulation()
  : ::google::protobuf::Message(), _internal_metadata_(NULL) {
  SharedCtor();
  // @@protoc_insertion_point(constructor:mw.internal.robotics.gazebotransport.StopSimulation)
}

void StopSimulation::InitAsDefaultInstance() {
}

StopSimulation::StopSimulation(const StopSimulation& from)
  : ::google::protobuf::Message(),
    _internal_metadata_(NULL) {
  SharedCtor();
  MergeFrom(from);
  // @@protoc_insertion_point(copy_constructor:mw.internal.robotics.gazebotransport.StopSimulation)
}

void StopSimulation::SharedCtor() {
  _cached_size_ = 0;
  stop_scene_ = false;
  ::memset(_has_bits_, 0, sizeof(_has_bits_));
}

StopSimulation::~StopSimulation() {
  // @@protoc_insertion_point(destructor:mw.internal.robotics.gazebotransport.StopSimulation)
  SharedDtor();
}

void StopSimulation::SharedDtor() {
  if (this != default_instance_) {
  }
}

void StopSimulation::SetCachedSize(int size) const {
  GOOGLE_SAFE_CONCURRENT_WRITES_BEGIN();
  _cached_size_ = size;
  GOOGLE_SAFE_CONCURRENT_WRITES_END();
}
const ::google::protobuf::Descriptor* StopSimulation::descriptor() {
  protobuf_AssignDescriptorsOnce();
  return StopSimulation_descriptor_;
}

const StopSimulation& StopSimulation::default_instance() {
  if (default_instance_ == NULL) protobuf_AddDesc_mw_2einternal_2erobotics_2egazebotransport_2eCoSimMsgs_2eproto();
  return *default_instance_;
}

StopSimulation* StopSimulation::default_instance_ = NULL;

StopSimulation* StopSimulation::New(::google::protobuf::Arena* arena) const {
  StopSimulation* n = new StopSimulation;
  if (arena != NULL) {
    arena->Own(n);
  }
  return n;
}

void StopSimulation::Clear() {
// @@protoc_insertion_point(message_clear_start:mw.internal.robotics.gazebotransport.StopSimulation)
  stop_scene_ = false;
  ::memset(_has_bits_, 0, sizeof(_has_bits_));
  if (_internal_metadata_.have_unknown_fields()) {
    mutable_unknown_fields()->Clear();
  }
}

bool StopSimulation::MergePartialFromCodedStream(
    ::google::protobuf::io::CodedInputStream* input) {
#define DO_(EXPRESSION) if (!GOOGLE_PREDICT_TRUE(EXPRESSION)) goto failure
  ::google::protobuf::uint32 tag;
  // @@protoc_insertion_point(parse_start:mw.internal.robotics.gazebotransport.StopSimulation)
  for (;;) {
    ::std::pair< ::google::protobuf::uint32, bool> p = input->ReadTagWithCutoff(127);
    tag = p.first;
    if (!p.second) goto handle_unusual;
    switch (::google::protobuf::internal::WireFormatLite::GetTagFieldNumber(tag)) {
      // required bool stop_scene = 1;
      case 1: {
        if (tag == 8) {
          DO_((::google::protobuf::internal::WireFormatLite::ReadPrimitive<
                   bool, ::google::protobuf::internal::WireFormatLite::TYPE_BOOL>(
                 input, &stop_scene_)));
          set_has_stop_scene();
        } else {
          goto handle_unusual;
        }
        if (input->ExpectAtEnd()) goto success;
        break;
      }

      default: {
      handle_unusual:
        if (tag == 0 ||
            ::google::protobuf::internal::WireFormatLite::GetTagWireType(tag) ==
            ::google::protobuf::internal::WireFormatLite::WIRETYPE_END_GROUP) {
          goto success;
        }
        DO_(::google::protobuf::internal::WireFormat::SkipField(
              input, tag, mutable_unknown_fields()));
        break;
      }
    }
  }
success:
  // @@protoc_insertion_point(parse_success:mw.internal.robotics.gazebotransport.StopSimulation)
  return true;
failure:
  // @@protoc_insertion_point(parse_failure:mw.internal.robotics.gazebotransport.StopSimulation)
  return false;
#undef DO_
}

void StopSimulation::SerializeWithCachedSizes(
    ::google::protobuf::io::CodedOutputStream* output) const {
  // @@protoc_insertion_point(serialize_start:mw.internal.robotics.gazebotransport.StopSimulation)
  // required bool stop_scene = 1;
  if (has_stop_scene()) {
    ::google::protobuf::internal::WireFormatLite::WriteBool(1, this->stop_scene(), output);
  }

  if (_internal_metadata_.have_unknown_fields()) {
    ::google::protobuf::internal::WireFormat::SerializeUnknownFields(
        unknown_fields(), output);
  }
  // @@protoc_insertion_point(serialize_end:mw.internal.robotics.gazebotransport.StopSimulation)
}

::google::protobuf::uint8* StopSimulation::InternalSerializeWithCachedSizesToArray(
    bool deterministic, ::google::protobuf::uint8* target) const {
  // @@protoc_insertion_point(serialize_to_array_start:mw.internal.robotics.gazebotransport.StopSimulation)
  // required bool stop_scene = 1;
  if (has_stop_scene()) {
    target = ::google::protobuf::internal::WireFormatLite::WriteBoolToArray(1, this->stop_scene(), target);
  }

  if (_internal_metadata_.have_unknown_fields()) {
    target = ::google::protobuf::internal::WireFormat::SerializeUnknownFieldsToArray(
        unknown_fields(), target);
  }
  // @@protoc_insertion_point(serialize_to_array_end:mw.internal.robotics.gazebotransport.StopSimulation)
  return target;
}

int StopSimulation::ByteSize() const {
// @@protoc_insertion_point(message_byte_size_start:mw.internal.robotics.gazebotransport.StopSimulation)
  int total_size = 0;

  // required bool stop_scene = 1;
  if (has_stop_scene()) {
    total_size += 1 + 1;
  }
  if (_internal_metadata_.have_unknown_fields()) {
    total_size +=
      ::google::protobuf::internal::WireFormat::ComputeUnknownFieldsSize(
        unknown_fields());
  }
  GOOGLE_SAFE_CONCURRENT_WRITES_BEGIN();
  _cached_size_ = total_size;
  GOOGLE_SAFE_CONCURRENT_WRITES_END();
  return total_size;
}

void StopSimulation::MergeFrom(const ::google::protobuf::Message& from) {
// @@protoc_insertion_point(generalized_merge_from_start:mw.internal.robotics.gazebotransport.StopSimulation)
  if (GOOGLE_PREDICT_FALSE(&from == this)) {
    ::google::protobuf::internal::MergeFromFail(__FILE__, __LINE__);
  }
  const StopSimulation* source = 
      ::google::protobuf::internal::DynamicCastToGenerated<const StopSimulation>(
          &from);
  if (source == NULL) {
  // @@protoc_insertion_point(generalized_merge_from_cast_fail:mw.internal.robotics.gazebotransport.StopSimulation)
    ::google::protobuf::internal::ReflectionOps::Merge(from, this);
  } else {
  // @@protoc_insertion_point(generalized_merge_from_cast_success:mw.internal.robotics.gazebotransport.StopSimulation)
    MergeFrom(*source);
  }
}

void StopSimulation::MergeFrom(const StopSimulation& from) {
// @@protoc_insertion_point(class_specific_merge_from_start:mw.internal.robotics.gazebotransport.StopSimulation)
  if (GOOGLE_PREDICT_FALSE(&from == this)) {
    ::google::protobuf::internal::MergeFromFail(__FILE__, __LINE__);
  }
  if (from._has_bits_[0 / 32] & (0xffu << (0 % 32))) {
    if (from.has_stop_scene()) {
      set_stop_scene(from.stop_scene());
    }
  }
  if (from._internal_metadata_.have_unknown_fields()) {
    mutable_unknown_fields()->MergeFrom(from.unknown_fields());
  }
}

void StopSimulation::CopyFrom(const ::google::protobuf::Message& from) {
// @@protoc_insertion_point(generalized_copy_from_start:mw.internal.robotics.gazebotransport.StopSimulation)
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

void StopSimulation::CopyFrom(const StopSimulation& from) {
// @@protoc_insertion_point(class_specific_copy_from_start:mw.internal.robotics.gazebotransport.StopSimulation)
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

bool StopSimulation::IsInitialized() const {
  if ((_has_bits_[0] & 0x00000001) != 0x00000001) return false;

  return true;
}

void StopSimulation::Swap(StopSimulation* other) {
  if (other == this) return;
  InternalSwap(other);
}
void StopSimulation::InternalSwap(StopSimulation* other) {
  std::swap(stop_scene_, other->stop_scene_);
  std::swap(_has_bits_[0], other->_has_bits_[0]);
  _internal_metadata_.Swap(&other->_internal_metadata_);
  std::swap(_cached_size_, other->_cached_size_);
}

::google::protobuf::Metadata StopSimulation::GetMetadata() const {
  protobuf_AssignDescriptorsOnce();
  ::google::protobuf::Metadata metadata;
  metadata.descriptor = StopSimulation_descriptor_;
  metadata.reflection = StopSimulation_reflection_;
  return metadata;
}

#if PROTOBUF_INLINE_NOT_IN_HEADERS
// StopSimulation

// required bool stop_scene = 1;
bool StopSimulation::has_stop_scene() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
void StopSimulation::set_has_stop_scene() {
  _has_bits_[0] |= 0x00000001u;
}
void StopSimulation::clear_has_stop_scene() {
  _has_bits_[0] &= ~0x00000001u;
}
void StopSimulation::clear_stop_scene() {
  stop_scene_ = false;
  clear_has_stop_scene();
}
 bool StopSimulation::stop_scene() const {
  // @@protoc_insertion_point(field_get:mw.internal.robotics.gazebotransport.StopSimulation.stop_scene)
  return stop_scene_;
}
 void StopSimulation::set_stop_scene(bool value) {
  set_has_stop_scene();
  stop_scene_ = value;
  // @@protoc_insertion_point(field_set:mw.internal.robotics.gazebotransport.StopSimulation.stop_scene)
}

#endif  // PROTOBUF_INLINE_NOT_IN_HEADERS

// ===================================================================

#if !defined(_MSC_VER) || _MSC_VER >= 1900
const int LaserData::kAngleMinFieldNumber;
const int LaserData::kAngleMaxFieldNumber;
const int LaserData::kAngleStepFieldNumber;
const int LaserData::kRangeMinFieldNumber;
const int LaserData::kRangeMaxFieldNumber;
const int LaserData::kCountFieldNumber;
const int LaserData::kVerticalAngleMinFieldNumber;
const int LaserData::kVerticalAngleMaxFieldNumber;
const int LaserData::kVerticalAngleStepFieldNumber;
const int LaserData::kRangeFieldNumber;
const int LaserData::kIntensitiesFieldNumber;
#endif  // !defined(_MSC_VER) || _MSC_VER >= 1900

LaserData::LaserData()
  : ::google::protobuf::Message(), _internal_metadata_(NULL) {
  SharedCtor();
  // @@protoc_insertion_point(constructor:mw.internal.robotics.gazebotransport.LaserData)
}

void LaserData::InitAsDefaultInstance() {
}

LaserData::LaserData(const LaserData& from)
  : ::google::protobuf::Message(),
    _internal_metadata_(NULL) {
  SharedCtor();
  MergeFrom(from);
  // @@protoc_insertion_point(copy_constructor:mw.internal.robotics.gazebotransport.LaserData)
}

void LaserData::SharedCtor() {
  _cached_size_ = 0;
  angle_min_ = 0;
  angle_max_ = 0;
  angle_step_ = 0;
  range_min_ = 0;
  range_max_ = 0;
  count_ = 0;
  vertical_angle_min_ = 0;
  vertical_angle_max_ = 0;
  vertical_angle_step_ = 0;
  ::memset(_has_bits_, 0, sizeof(_has_bits_));
}

LaserData::~LaserData() {
  // @@protoc_insertion_point(destructor:mw.internal.robotics.gazebotransport.LaserData)
  SharedDtor();
}

void LaserData::SharedDtor() {
  if (this != default_instance_) {
  }
}

void LaserData::SetCachedSize(int size) const {
  GOOGLE_SAFE_CONCURRENT_WRITES_BEGIN();
  _cached_size_ = size;
  GOOGLE_SAFE_CONCURRENT_WRITES_END();
}
const ::google::protobuf::Descriptor* LaserData::descriptor() {
  protobuf_AssignDescriptorsOnce();
  return LaserData_descriptor_;
}

const LaserData& LaserData::default_instance() {
  if (default_instance_ == NULL) protobuf_AddDesc_mw_2einternal_2erobotics_2egazebotransport_2eCoSimMsgs_2eproto();
  return *default_instance_;
}

LaserData* LaserData::default_instance_ = NULL;

LaserData* LaserData::New(::google::protobuf::Arena* arena) const {
  LaserData* n = new LaserData;
  if (arena != NULL) {
    arena->Own(n);
  }
  return n;
}

void LaserData::Clear() {
// @@protoc_insertion_point(message_clear_start:mw.internal.robotics.gazebotransport.LaserData)
#if defined(__clang__)
#define ZR_HELPER_(f) \
  _Pragma("clang diagnostic push") \
  _Pragma("clang diagnostic ignored \"-Winvalid-offsetof\"") \
  __builtin_offsetof(LaserData, f) \
  _Pragma("clang diagnostic pop")
#else
#define ZR_HELPER_(f) reinterpret_cast<char*>(\
  &reinterpret_cast<LaserData*>(16)->f)
#endif

#define ZR_(first, last) do {\
  ::memset(&first, 0,\
           ZR_HELPER_(last) - ZR_HELPER_(first) + sizeof(last));\
} while (0)

  if (_has_bits_[0 / 32] & 255u) {
    ZR_(angle_min_, vertical_angle_max_);
  }
  vertical_angle_step_ = 0;

#undef ZR_HELPER_
#undef ZR_

  range_.Clear();
  intensities_.Clear();
  ::memset(_has_bits_, 0, sizeof(_has_bits_));
  if (_internal_metadata_.have_unknown_fields()) {
    mutable_unknown_fields()->Clear();
  }
}

bool LaserData::MergePartialFromCodedStream(
    ::google::protobuf::io::CodedInputStream* input) {
#define DO_(EXPRESSION) if (!GOOGLE_PREDICT_TRUE(EXPRESSION)) goto failure
  ::google::protobuf::uint32 tag;
  // @@protoc_insertion_point(parse_start:mw.internal.robotics.gazebotransport.LaserData)
  for (;;) {
    ::std::pair< ::google::protobuf::uint32, bool> p = input->ReadTagWithCutoff(127);
    tag = p.first;
    if (!p.second) goto handle_unusual;
    switch (::google::protobuf::internal::WireFormatLite::GetTagFieldNumber(tag)) {
      // required double angle_min = 1;
      case 1: {
        if (tag == 9) {
          DO_((::google::protobuf::internal::WireFormatLite::ReadPrimitive<
                   double, ::google::protobuf::internal::WireFormatLite::TYPE_DOUBLE>(
                 input, &angle_min_)));
          set_has_angle_min();
        } else {
          goto handle_unusual;
        }
        if (input->ExpectTag(17)) goto parse_angle_max;
        break;
      }

      // required double angle_max = 2;
      case 2: {
        if (tag == 17) {
         parse_angle_max:
          DO_((::google::protobuf::internal::WireFormatLite::ReadPrimitive<
                   double, ::google::protobuf::internal::WireFormatLite::TYPE_DOUBLE>(
                 input, &angle_max_)));
          set_has_angle_max();
        } else {
          goto handle_unusual;
        }
        if (input->ExpectTag(25)) goto parse_angle_step;
        break;
      }

      // required double angle_step = 3;
      case 3: {
        if (tag == 25) {
         parse_angle_step:
          DO_((::google::protobuf::internal::WireFormatLite::ReadPrimitive<
                   double, ::google::protobuf::internal::WireFormatLite::TYPE_DOUBLE>(
                 input, &angle_step_)));
          set_has_angle_step();
        } else {
          goto handle_unusual;
        }
        if (input->ExpectTag(33)) goto parse_range_min;
        break;
      }

      // required double range_min = 4;
      case 4: {
        if (tag == 33) {
         parse_range_min:
          DO_((::google::protobuf::internal::WireFormatLite::ReadPrimitive<
                   double, ::google::protobuf::internal::WireFormatLite::TYPE_DOUBLE>(
                 input, &range_min_)));
          set_has_range_min();
        } else {
          goto handle_unusual;
        }
        if (input->ExpectTag(41)) goto parse_range_max;
        break;
      }

      // required double range_max = 5;
      case 5: {
        if (tag == 41) {
         parse_range_max:
          DO_((::google::protobuf::internal::WireFormatLite::ReadPrimitive<
                   double, ::google::protobuf::internal::WireFormatLite::TYPE_DOUBLE>(
                 input, &range_max_)));
          set_has_range_max();
        } else {
          goto handle_unusual;
        }
        if (input->ExpectTag(49)) goto parse_count;
        break;
      }

      // required double count = 6;
      case 6: {
        if (tag == 49) {
         parse_count:
          DO_((::google::protobuf::internal::WireFormatLite::ReadPrimitive<
                   double, ::google::protobuf::internal::WireFormatLite::TYPE_DOUBLE>(
                 input, &count_)));
          set_has_count();
        } else {
          goto handle_unusual;
        }
        if (input->ExpectTag(57)) goto parse_vertical_angle_min;
        break;
      }

      // required double vertical_angle_min = 7;
      case 7: {
        if (tag == 57) {
         parse_vertical_angle_min:
          DO_((::google::protobuf::internal::WireFormatLite::ReadPrimitive<
                   double, ::google::protobuf::internal::WireFormatLite::TYPE_DOUBLE>(
                 input, &vertical_angle_min_)));
          set_has_vertical_angle_min();
        } else {
          goto handle_unusual;
        }
        if (input->ExpectTag(65)) goto parse_vertical_angle_max;
        break;
      }

      // required double vertical_angle_max = 8;
      case 8: {
        if (tag == 65) {
         parse_vertical_angle_max:
          DO_((::google::protobuf::internal::WireFormatLite::ReadPrimitive<
                   double, ::google::protobuf::internal::WireFormatLite::TYPE_DOUBLE>(
                 input, &vertical_angle_max_)));
          set_has_vertical_angle_max();
        } else {
          goto handle_unusual;
        }
        if (input->ExpectTag(73)) goto parse_vertical_angle_step;
        break;
      }

      // required double vertical_angle_step = 9;
      case 9: {
        if (tag == 73) {
         parse_vertical_angle_step:
          DO_((::google::protobuf::internal::WireFormatLite::ReadPrimitive<
                   double, ::google::protobuf::internal::WireFormatLite::TYPE_DOUBLE>(
                 input, &vertical_angle_step_)));
          set_has_vertical_angle_step();
        } else {
          goto handle_unusual;
        }
        if (input->ExpectTag(81)) goto parse_range;
        break;
      }

      // repeated double range = 10;
      case 10: {
        if (tag == 81) {
         parse_range:
          DO_((::google::protobuf::internal::WireFormatLite::ReadRepeatedPrimitive<
                   double, ::google::protobuf::internal::WireFormatLite::TYPE_DOUBLE>(
                 1, 81, input, this->mutable_range())));
        } else if (tag == 82) {
          DO_((::google::protobuf::internal::WireFormatLite::ReadPackedPrimitiveNoInline<
                   double, ::google::protobuf::internal::WireFormatLite::TYPE_DOUBLE>(
                 input, this->mutable_range())));
        } else {
          goto handle_unusual;
        }
        if (input->ExpectTag(81)) goto parse_range;
        if (input->ExpectTag(89)) goto parse_intensities;
        break;
      }

      // repeated double intensities = 11;
      case 11: {
        if (tag == 89) {
         parse_intensities:
          DO_((::google::protobuf::internal::WireFormatLite::ReadRepeatedPrimitive<
                   double, ::google::protobuf::internal::WireFormatLite::TYPE_DOUBLE>(
                 1, 89, input, this->mutable_intensities())));
        } else if (tag == 90) {
          DO_((::google::protobuf::internal::WireFormatLite::ReadPackedPrimitiveNoInline<
                   double, ::google::protobuf::internal::WireFormatLite::TYPE_DOUBLE>(
                 input, this->mutable_intensities())));
        } else {
          goto handle_unusual;
        }
        if (input->ExpectTag(89)) goto parse_intensities;
        if (input->ExpectAtEnd()) goto success;
        break;
      }

      default: {
      handle_unusual:
        if (tag == 0 ||
            ::google::protobuf::internal::WireFormatLite::GetTagWireType(tag) ==
            ::google::protobuf::internal::WireFormatLite::WIRETYPE_END_GROUP) {
          goto success;
        }
        DO_(::google::protobuf::internal::WireFormat::SkipField(
              input, tag, mutable_unknown_fields()));
        break;
      }
    }
  }
success:
  // @@protoc_insertion_point(parse_success:mw.internal.robotics.gazebotransport.LaserData)
  return true;
failure:
  // @@protoc_insertion_point(parse_failure:mw.internal.robotics.gazebotransport.LaserData)
  return false;
#undef DO_
}

void LaserData::SerializeWithCachedSizes(
    ::google::protobuf::io::CodedOutputStream* output) const {
  // @@protoc_insertion_point(serialize_start:mw.internal.robotics.gazebotransport.LaserData)
  // required double angle_min = 1;
  if (has_angle_min()) {
    ::google::protobuf::internal::WireFormatLite::WriteDouble(1, this->angle_min(), output);
  }

  // required double angle_max = 2;
  if (has_angle_max()) {
    ::google::protobuf::internal::WireFormatLite::WriteDouble(2, this->angle_max(), output);
  }

  // required double angle_step = 3;
  if (has_angle_step()) {
    ::google::protobuf::internal::WireFormatLite::WriteDouble(3, this->angle_step(), output);
  }

  // required double range_min = 4;
  if (has_range_min()) {
    ::google::protobuf::internal::WireFormatLite::WriteDouble(4, this->range_min(), output);
  }

  // required double range_max = 5;
  if (has_range_max()) {
    ::google::protobuf::internal::WireFormatLite::WriteDouble(5, this->range_max(), output);
  }

  // required double count = 6;
  if (has_count()) {
    ::google::protobuf::internal::WireFormatLite::WriteDouble(6, this->count(), output);
  }

  // required double vertical_angle_min = 7;
  if (has_vertical_angle_min()) {
    ::google::protobuf::internal::WireFormatLite::WriteDouble(7, this->vertical_angle_min(), output);
  }

  // required double vertical_angle_max = 8;
  if (has_vertical_angle_max()) {
    ::google::protobuf::internal::WireFormatLite::WriteDouble(8, this->vertical_angle_max(), output);
  }

  // required double vertical_angle_step = 9;
  if (has_vertical_angle_step()) {
    ::google::protobuf::internal::WireFormatLite::WriteDouble(9, this->vertical_angle_step(), output);
  }

  // repeated double range = 10;
  for (int i = 0; i < this->range_size(); i++) {
    ::google::protobuf::internal::WireFormatLite::WriteDouble(
      10, this->range(i), output);
  }

  // repeated double intensities = 11;
  for (int i = 0; i < this->intensities_size(); i++) {
    ::google::protobuf::internal::WireFormatLite::WriteDouble(
      11, this->intensities(i), output);
  }

  if (_internal_metadata_.have_unknown_fields()) {
    ::google::protobuf::internal::WireFormat::SerializeUnknownFields(
        unknown_fields(), output);
  }
  // @@protoc_insertion_point(serialize_end:mw.internal.robotics.gazebotransport.LaserData)
}

::google::protobuf::uint8* LaserData::InternalSerializeWithCachedSizesToArray(
    bool deterministic, ::google::protobuf::uint8* target) const {
  // @@protoc_insertion_point(serialize_to_array_start:mw.internal.robotics.gazebotransport.LaserData)
  // required double angle_min = 1;
  if (has_angle_min()) {
    target = ::google::protobuf::internal::WireFormatLite::WriteDoubleToArray(1, this->angle_min(), target);
  }

  // required double angle_max = 2;
  if (has_angle_max()) {
    target = ::google::protobuf::internal::WireFormatLite::WriteDoubleToArray(2, this->angle_max(), target);
  }

  // required double angle_step = 3;
  if (has_angle_step()) {
    target = ::google::protobuf::internal::WireFormatLite::WriteDoubleToArray(3, this->angle_step(), target);
  }

  // required double range_min = 4;
  if (has_range_min()) {
    target = ::google::protobuf::internal::WireFormatLite::WriteDoubleToArray(4, this->range_min(), target);
  }

  // required double range_max = 5;
  if (has_range_max()) {
    target = ::google::protobuf::internal::WireFormatLite::WriteDoubleToArray(5, this->range_max(), target);
  }

  // required double count = 6;
  if (has_count()) {
    target = ::google::protobuf::internal::WireFormatLite::WriteDoubleToArray(6, this->count(), target);
  }

  // required double vertical_angle_min = 7;
  if (has_vertical_angle_min()) {
    target = ::google::protobuf::internal::WireFormatLite::WriteDoubleToArray(7, this->vertical_angle_min(), target);
  }

  // required double vertical_angle_max = 8;
  if (has_vertical_angle_max()) {
    target = ::google::protobuf::internal::WireFormatLite::WriteDoubleToArray(8, this->vertical_angle_max(), target);
  }

  // required double vertical_angle_step = 9;
  if (has_vertical_angle_step()) {
    target = ::google::protobuf::internal::WireFormatLite::WriteDoubleToArray(9, this->vertical_angle_step(), target);
  }

  // repeated double range = 10;
  for (int i = 0; i < this->range_size(); i++) {
    target = ::google::protobuf::internal::WireFormatLite::
      WriteDoubleToArray(10, this->range(i), target);
  }

  // repeated double intensities = 11;
  for (int i = 0; i < this->intensities_size(); i++) {
    target = ::google::protobuf::internal::WireFormatLite::
      WriteDoubleToArray(11, this->intensities(i), target);
  }

  if (_internal_metadata_.have_unknown_fields()) {
    target = ::google::protobuf::internal::WireFormat::SerializeUnknownFieldsToArray(
        unknown_fields(), target);
  }
  // @@protoc_insertion_point(serialize_to_array_end:mw.internal.robotics.gazebotransport.LaserData)
  return target;
}

int LaserData::RequiredFieldsByteSizeFallback() const {
// @@protoc_insertion_point(required_fields_byte_size_fallback_start:mw.internal.robotics.gazebotransport.LaserData)
  int total_size = 0;

  if (has_angle_min()) {
    // required double angle_min = 1;
    total_size += 1 + 8;
  }

  if (has_angle_max()) {
    // required double angle_max = 2;
    total_size += 1 + 8;
  }

  if (has_angle_step()) {
    // required double angle_step = 3;
    total_size += 1 + 8;
  }

  if (has_range_min()) {
    // required double range_min = 4;
    total_size += 1 + 8;
  }

  if (has_range_max()) {
    // required double range_max = 5;
    total_size += 1 + 8;
  }

  if (has_count()) {
    // required double count = 6;
    total_size += 1 + 8;
  }

  if (has_vertical_angle_min()) {
    // required double vertical_angle_min = 7;
    total_size += 1 + 8;
  }

  if (has_vertical_angle_max()) {
    // required double vertical_angle_max = 8;
    total_size += 1 + 8;
  }

  if (has_vertical_angle_step()) {
    // required double vertical_angle_step = 9;
    total_size += 1 + 8;
  }

  return total_size;
}
int LaserData::ByteSize() const {
// @@protoc_insertion_point(message_byte_size_start:mw.internal.robotics.gazebotransport.LaserData)
  int total_size = 0;

  if (((_has_bits_[0] & 0x000001ff) ^ 0x000001ff) == 0) {  // All required fields are present.
    // required double angle_min = 1;
    total_size += 1 + 8;

    // required double angle_max = 2;
    total_size += 1 + 8;

    // required double angle_step = 3;
    total_size += 1 + 8;

    // required double range_min = 4;
    total_size += 1 + 8;

    // required double range_max = 5;
    total_size += 1 + 8;

    // required double count = 6;
    total_size += 1 + 8;

    // required double vertical_angle_min = 7;
    total_size += 1 + 8;

    // required double vertical_angle_max = 8;
    total_size += 1 + 8;

    // required double vertical_angle_step = 9;
    total_size += 1 + 8;

  } else {
    total_size += RequiredFieldsByteSizeFallback();
  }
  // repeated double range = 10;
  {
    int data_size = 0;
    data_size = 8 * this->range_size();
    total_size += 1 * this->range_size() + data_size;
  }

  // repeated double intensities = 11;
  {
    int data_size = 0;
    data_size = 8 * this->intensities_size();
    total_size += 1 * this->intensities_size() + data_size;
  }

  if (_internal_metadata_.have_unknown_fields()) {
    total_size +=
      ::google::protobuf::internal::WireFormat::ComputeUnknownFieldsSize(
        unknown_fields());
  }
  GOOGLE_SAFE_CONCURRENT_WRITES_BEGIN();
  _cached_size_ = total_size;
  GOOGLE_SAFE_CONCURRENT_WRITES_END();
  return total_size;
}

void LaserData::MergeFrom(const ::google::protobuf::Message& from) {
// @@protoc_insertion_point(generalized_merge_from_start:mw.internal.robotics.gazebotransport.LaserData)
  if (GOOGLE_PREDICT_FALSE(&from == this)) {
    ::google::protobuf::internal::MergeFromFail(__FILE__, __LINE__);
  }
  const LaserData* source = 
      ::google::protobuf::internal::DynamicCastToGenerated<const LaserData>(
          &from);
  if (source == NULL) {
  // @@protoc_insertion_point(generalized_merge_from_cast_fail:mw.internal.robotics.gazebotransport.LaserData)
    ::google::protobuf::internal::ReflectionOps::Merge(from, this);
  } else {
  // @@protoc_insertion_point(generalized_merge_from_cast_success:mw.internal.robotics.gazebotransport.LaserData)
    MergeFrom(*source);
  }
}

void LaserData::MergeFrom(const LaserData& from) {
// @@protoc_insertion_point(class_specific_merge_from_start:mw.internal.robotics.gazebotransport.LaserData)
  if (GOOGLE_PREDICT_FALSE(&from == this)) {
    ::google::protobuf::internal::MergeFromFail(__FILE__, __LINE__);
  }
  range_.MergeFrom(from.range_);
  intensities_.MergeFrom(from.intensities_);
  if (from._has_bits_[0 / 32] & (0xffu << (0 % 32))) {
    if (from.has_angle_min()) {
      set_angle_min(from.angle_min());
    }
    if (from.has_angle_max()) {
      set_angle_max(from.angle_max());
    }
    if (from.has_angle_step()) {
      set_angle_step(from.angle_step());
    }
    if (from.has_range_min()) {
      set_range_min(from.range_min());
    }
    if (from.has_range_max()) {
      set_range_max(from.range_max());
    }
    if (from.has_count()) {
      set_count(from.count());
    }
    if (from.has_vertical_angle_min()) {
      set_vertical_angle_min(from.vertical_angle_min());
    }
    if (from.has_vertical_angle_max()) {
      set_vertical_angle_max(from.vertical_angle_max());
    }
  }
  if (from._has_bits_[8 / 32] & (0xffu << (8 % 32))) {
    if (from.has_vertical_angle_step()) {
      set_vertical_angle_step(from.vertical_angle_step());
    }
  }
  if (from._internal_metadata_.have_unknown_fields()) {
    mutable_unknown_fields()->MergeFrom(from.unknown_fields());
  }
}

void LaserData::CopyFrom(const ::google::protobuf::Message& from) {
// @@protoc_insertion_point(generalized_copy_from_start:mw.internal.robotics.gazebotransport.LaserData)
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

void LaserData::CopyFrom(const LaserData& from) {
// @@protoc_insertion_point(class_specific_copy_from_start:mw.internal.robotics.gazebotransport.LaserData)
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

bool LaserData::IsInitialized() const {
  if ((_has_bits_[0] & 0x000001ff) != 0x000001ff) return false;

  return true;
}

void LaserData::Swap(LaserData* other) {
  if (other == this) return;
  InternalSwap(other);
}
void LaserData::InternalSwap(LaserData* other) {
  std::swap(angle_min_, other->angle_min_);
  std::swap(angle_max_, other->angle_max_);
  std::swap(angle_step_, other->angle_step_);
  std::swap(range_min_, other->range_min_);
  std::swap(range_max_, other->range_max_);
  std::swap(count_, other->count_);
  std::swap(vertical_angle_min_, other->vertical_angle_min_);
  std::swap(vertical_angle_max_, other->vertical_angle_max_);
  std::swap(vertical_angle_step_, other->vertical_angle_step_);
  range_.UnsafeArenaSwap(&other->range_);
  intensities_.UnsafeArenaSwap(&other->intensities_);
  std::swap(_has_bits_[0], other->_has_bits_[0]);
  _internal_metadata_.Swap(&other->_internal_metadata_);
  std::swap(_cached_size_, other->_cached_size_);
}

::google::protobuf::Metadata LaserData::GetMetadata() const {
  protobuf_AssignDescriptorsOnce();
  ::google::protobuf::Metadata metadata;
  metadata.descriptor = LaserData_descriptor_;
  metadata.reflection = LaserData_reflection_;
  return metadata;
}

#if PROTOBUF_INLINE_NOT_IN_HEADERS
// LaserData

// required double angle_min = 1;
bool LaserData::has_angle_min() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
void LaserData::set_has_angle_min() {
  _has_bits_[0] |= 0x00000001u;
}
void LaserData::clear_has_angle_min() {
  _has_bits_[0] &= ~0x00000001u;
}
void LaserData::clear_angle_min() {
  angle_min_ = 0;
  clear_has_angle_min();
}
 double LaserData::angle_min() const {
  // @@protoc_insertion_point(field_get:mw.internal.robotics.gazebotransport.LaserData.angle_min)
  return angle_min_;
}
 void LaserData::set_angle_min(double value) {
  set_has_angle_min();
  angle_min_ = value;
  // @@protoc_insertion_point(field_set:mw.internal.robotics.gazebotransport.LaserData.angle_min)
}

// required double angle_max = 2;
bool LaserData::has_angle_max() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
void LaserData::set_has_angle_max() {
  _has_bits_[0] |= 0x00000002u;
}
void LaserData::clear_has_angle_max() {
  _has_bits_[0] &= ~0x00000002u;
}
void LaserData::clear_angle_max() {
  angle_max_ = 0;
  clear_has_angle_max();
}
 double LaserData::angle_max() const {
  // @@protoc_insertion_point(field_get:mw.internal.robotics.gazebotransport.LaserData.angle_max)
  return angle_max_;
}
 void LaserData::set_angle_max(double value) {
  set_has_angle_max();
  angle_max_ = value;
  // @@protoc_insertion_point(field_set:mw.internal.robotics.gazebotransport.LaserData.angle_max)
}

// required double angle_step = 3;
bool LaserData::has_angle_step() const {
  return (_has_bits_[0] & 0x00000004u) != 0;
}
void LaserData::set_has_angle_step() {
  _has_bits_[0] |= 0x00000004u;
}
void LaserData::clear_has_angle_step() {
  _has_bits_[0] &= ~0x00000004u;
}
void LaserData::clear_angle_step() {
  angle_step_ = 0;
  clear_has_angle_step();
}
 double LaserData::angle_step() const {
  // @@protoc_insertion_point(field_get:mw.internal.robotics.gazebotransport.LaserData.angle_step)
  return angle_step_;
}
 void LaserData::set_angle_step(double value) {
  set_has_angle_step();
  angle_step_ = value;
  // @@protoc_insertion_point(field_set:mw.internal.robotics.gazebotransport.LaserData.angle_step)
}

// required double range_min = 4;
bool LaserData::has_range_min() const {
  return (_has_bits_[0] & 0x00000008u) != 0;
}
void LaserData::set_has_range_min() {
  _has_bits_[0] |= 0x00000008u;
}
void LaserData::clear_has_range_min() {
  _has_bits_[0] &= ~0x00000008u;
}
void LaserData::clear_range_min() {
  range_min_ = 0;
  clear_has_range_min();
}
 double LaserData::range_min() const {
  // @@protoc_insertion_point(field_get:mw.internal.robotics.gazebotransport.LaserData.range_min)
  return range_min_;
}
 void LaserData::set_range_min(double value) {
  set_has_range_min();
  range_min_ = value;
  // @@protoc_insertion_point(field_set:mw.internal.robotics.gazebotransport.LaserData.range_min)
}

// required double range_max = 5;
bool LaserData::has_range_max() const {
  return (_has_bits_[0] & 0x00000010u) != 0;
}
void LaserData::set_has_range_max() {
  _has_bits_[0] |= 0x00000010u;
}
void LaserData::clear_has_range_max() {
  _has_bits_[0] &= ~0x00000010u;
}
void LaserData::clear_range_max() {
  range_max_ = 0;
  clear_has_range_max();
}
 double LaserData::range_max() const {
  // @@protoc_insertion_point(field_get:mw.internal.robotics.gazebotransport.LaserData.range_max)
  return range_max_;
}
 void LaserData::set_range_max(double value) {
  set_has_range_max();
  range_max_ = value;
  // @@protoc_insertion_point(field_set:mw.internal.robotics.gazebotransport.LaserData.range_max)
}

// required double count = 6;
bool LaserData::has_count() const {
  return (_has_bits_[0] & 0x00000020u) != 0;
}
void LaserData::set_has_count() {
  _has_bits_[0] |= 0x00000020u;
}
void LaserData::clear_has_count() {
  _has_bits_[0] &= ~0x00000020u;
}
void LaserData::clear_count() {
  count_ = 0;
  clear_has_count();
}
 double LaserData::count() const {
  // @@protoc_insertion_point(field_get:mw.internal.robotics.gazebotransport.LaserData.count)
  return count_;
}
 void LaserData::set_count(double value) {
  set_has_count();
  count_ = value;
  // @@protoc_insertion_point(field_set:mw.internal.robotics.gazebotransport.LaserData.count)
}

// required double vertical_angle_min = 7;
bool LaserData::has_vertical_angle_min() const {
  return (_has_bits_[0] & 0x00000040u) != 0;
}
void LaserData::set_has_vertical_angle_min() {
  _has_bits_[0] |= 0x00000040u;
}
void LaserData::clear_has_vertical_angle_min() {
  _has_bits_[0] &= ~0x00000040u;
}
void LaserData::clear_vertical_angle_min() {
  vertical_angle_min_ = 0;
  clear_has_vertical_angle_min();
}
 double LaserData::vertical_angle_min() const {
  // @@protoc_insertion_point(field_get:mw.internal.robotics.gazebotransport.LaserData.vertical_angle_min)
  return vertical_angle_min_;
}
 void LaserData::set_vertical_angle_min(double value) {
  set_has_vertical_angle_min();
  vertical_angle_min_ = value;
  // @@protoc_insertion_point(field_set:mw.internal.robotics.gazebotransport.LaserData.vertical_angle_min)
}

// required double vertical_angle_max = 8;
bool LaserData::has_vertical_angle_max() const {
  return (_has_bits_[0] & 0x00000080u) != 0;
}
void LaserData::set_has_vertical_angle_max() {
  _has_bits_[0] |= 0x00000080u;
}
void LaserData::clear_has_vertical_angle_max() {
  _has_bits_[0] &= ~0x00000080u;
}
void LaserData::clear_vertical_angle_max() {
  vertical_angle_max_ = 0;
  clear_has_vertical_angle_max();
}
 double LaserData::vertical_angle_max() const {
  // @@protoc_insertion_point(field_get:mw.internal.robotics.gazebotransport.LaserData.vertical_angle_max)
  return vertical_angle_max_;
}
 void LaserData::set_vertical_angle_max(double value) {
  set_has_vertical_angle_max();
  vertical_angle_max_ = value;
  // @@protoc_insertion_point(field_set:mw.internal.robotics.gazebotransport.LaserData.vertical_angle_max)
}

// required double vertical_angle_step = 9;
bool LaserData::has_vertical_angle_step() const {
  return (_has_bits_[0] & 0x00000100u) != 0;
}
void LaserData::set_has_vertical_angle_step() {
  _has_bits_[0] |= 0x00000100u;
}
void LaserData::clear_has_vertical_angle_step() {
  _has_bits_[0] &= ~0x00000100u;
}
void LaserData::clear_vertical_angle_step() {
  vertical_angle_step_ = 0;
  clear_has_vertical_angle_step();
}
 double LaserData::vertical_angle_step() const {
  // @@protoc_insertion_point(field_get:mw.internal.robotics.gazebotransport.LaserData.vertical_angle_step)
  return vertical_angle_step_;
}
 void LaserData::set_vertical_angle_step(double value) {
  set_has_vertical_angle_step();
  vertical_angle_step_ = value;
  // @@protoc_insertion_point(field_set:mw.internal.robotics.gazebotransport.LaserData.vertical_angle_step)
}

// repeated double range = 10;
int LaserData::range_size() const {
  return range_.size();
}
void LaserData::clear_range() {
  range_.Clear();
}
 double LaserData::range(int index) const {
  // @@protoc_insertion_point(field_get:mw.internal.robotics.gazebotransport.LaserData.range)
  return range_.Get(index);
}
 void LaserData::set_range(int index, double value) {
  range_.Set(index, value);
  // @@protoc_insertion_point(field_set:mw.internal.robotics.gazebotransport.LaserData.range)
}
 void LaserData::add_range(double value) {
  range_.Add(value);
  // @@protoc_insertion_point(field_add:mw.internal.robotics.gazebotransport.LaserData.range)
}
 const ::google::protobuf::RepeatedField< double >&
LaserData::range() const {
  // @@protoc_insertion_point(field_list:mw.internal.robotics.gazebotransport.LaserData.range)
  return range_;
}
 ::google::protobuf::RepeatedField< double >*
LaserData::mutable_range() {
  // @@protoc_insertion_point(field_mutable_list:mw.internal.robotics.gazebotransport.LaserData.range)
  return &range_;
}

// repeated double intensities = 11;
int LaserData::intensities_size() const {
  return intensities_.size();
}
void LaserData::clear_intensities() {
  intensities_.Clear();
}
 double LaserData::intensities(int index) const {
  // @@protoc_insertion_point(field_get:mw.internal.robotics.gazebotransport.LaserData.intensities)
  return intensities_.Get(index);
}
 void LaserData::set_intensities(int index, double value) {
  intensities_.Set(index, value);
  // @@protoc_insertion_point(field_set:mw.internal.robotics.gazebotransport.LaserData.intensities)
}
 void LaserData::add_intensities(double value) {
  intensities_.Add(value);
  // @@protoc_insertion_point(field_add:mw.internal.robotics.gazebotransport.LaserData.intensities)
}
 const ::google::protobuf::RepeatedField< double >&
LaserData::intensities() const {
  // @@protoc_insertion_point(field_list:mw.internal.robotics.gazebotransport.LaserData.intensities)
  return intensities_;
}
 ::google::protobuf::RepeatedField< double >*
LaserData::mutable_intensities() {
  // @@protoc_insertion_point(field_mutable_list:mw.internal.robotics.gazebotransport.LaserData.intensities)
  return &intensities_;
}

#endif  // PROTOBUF_INLINE_NOT_IN_HEADERS

// ===================================================================

#if !defined(_MSC_VER) || _MSC_VER >= 1900
const int RequestLaser::kTopicNameFieldNumber;
#endif  // !defined(_MSC_VER) || _MSC_VER >= 1900

RequestLaser::RequestLaser()
  : ::google::protobuf::Message(), _internal_metadata_(NULL) {
  SharedCtor();
  // @@protoc_insertion_point(constructor:mw.internal.robotics.gazebotransport.RequestLaser)
}

void RequestLaser::InitAsDefaultInstance() {
}

RequestLaser::RequestLaser(const RequestLaser& from)
  : ::google::protobuf::Message(),
    _internal_metadata_(NULL) {
  SharedCtor();
  MergeFrom(from);
  // @@protoc_insertion_point(copy_constructor:mw.internal.robotics.gazebotransport.RequestLaser)
}

void RequestLaser::SharedCtor() {
  ::google::protobuf::internal::GetEmptyString();
  _cached_size_ = 0;
  topic_name_.UnsafeSetDefault(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
  ::memset(_has_bits_, 0, sizeof(_has_bits_));
}

RequestLaser::~RequestLaser() {
  // @@protoc_insertion_point(destructor:mw.internal.robotics.gazebotransport.RequestLaser)
  SharedDtor();
}

void RequestLaser::SharedDtor() {
  topic_name_.DestroyNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
  if (this != default_instance_) {
  }
}

void RequestLaser::SetCachedSize(int size) const {
  GOOGLE_SAFE_CONCURRENT_WRITES_BEGIN();
  _cached_size_ = size;
  GOOGLE_SAFE_CONCURRENT_WRITES_END();
}
const ::google::protobuf::Descriptor* RequestLaser::descriptor() {
  protobuf_AssignDescriptorsOnce();
  return RequestLaser_descriptor_;
}

const RequestLaser& RequestLaser::default_instance() {
  if (default_instance_ == NULL) protobuf_AddDesc_mw_2einternal_2erobotics_2egazebotransport_2eCoSimMsgs_2eproto();
  return *default_instance_;
}

RequestLaser* RequestLaser::default_instance_ = NULL;

RequestLaser* RequestLaser::New(::google::protobuf::Arena* arena) const {
  RequestLaser* n = new RequestLaser;
  if (arena != NULL) {
    arena->Own(n);
  }
  return n;
}

void RequestLaser::Clear() {
// @@protoc_insertion_point(message_clear_start:mw.internal.robotics.gazebotransport.RequestLaser)
  if (has_topic_name()) {
    topic_name_.ClearToEmptyNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
  }
  ::memset(_has_bits_, 0, sizeof(_has_bits_));
  if (_internal_metadata_.have_unknown_fields()) {
    mutable_unknown_fields()->Clear();
  }
}

bool RequestLaser::MergePartialFromCodedStream(
    ::google::protobuf::io::CodedInputStream* input) {
#define DO_(EXPRESSION) if (!GOOGLE_PREDICT_TRUE(EXPRESSION)) goto failure
  ::google::protobuf::uint32 tag;
  // @@protoc_insertion_point(parse_start:mw.internal.robotics.gazebotransport.RequestLaser)
  for (;;) {
    ::std::pair< ::google::protobuf::uint32, bool> p = input->ReadTagWithCutoff(127);
    tag = p.first;
    if (!p.second) goto handle_unusual;
    switch (::google::protobuf::internal::WireFormatLite::GetTagFieldNumber(tag)) {
      // required string topic_name = 1;
      case 1: {
        if (tag == 10) {
          DO_(::google::protobuf::internal::WireFormatLite::ReadString(
                input, this->mutable_topic_name()));
          ::google::protobuf::internal::WireFormat::VerifyUTF8StringNamedField(
            this->topic_name().data(), this->topic_name().length(),
            ::google::protobuf::internal::WireFormat::PARSE,
            "mw.internal.robotics.gazebotransport.RequestLaser.topic_name");
        } else {
          goto handle_unusual;
        }
        if (input->ExpectAtEnd()) goto success;
        break;
      }

      default: {
      handle_unusual:
        if (tag == 0 ||
            ::google::protobuf::internal::WireFormatLite::GetTagWireType(tag) ==
            ::google::protobuf::internal::WireFormatLite::WIRETYPE_END_GROUP) {
          goto success;
        }
        DO_(::google::protobuf::internal::WireFormat::SkipField(
              input, tag, mutable_unknown_fields()));
        break;
      }
    }
  }
success:
  // @@protoc_insertion_point(parse_success:mw.internal.robotics.gazebotransport.RequestLaser)
  return true;
failure:
  // @@protoc_insertion_point(parse_failure:mw.internal.robotics.gazebotransport.RequestLaser)
  return false;
#undef DO_
}

void RequestLaser::SerializeWithCachedSizes(
    ::google::protobuf::io::CodedOutputStream* output) const {
  // @@protoc_insertion_point(serialize_start:mw.internal.robotics.gazebotransport.RequestLaser)
  // required string topic_name = 1;
  if (has_topic_name()) {
    ::google::protobuf::internal::WireFormat::VerifyUTF8StringNamedField(
      this->topic_name().data(), this->topic_name().length(),
      ::google::protobuf::internal::WireFormat::SERIALIZE,
      "mw.internal.robotics.gazebotransport.RequestLaser.topic_name");
    ::google::protobuf::internal::WireFormatLite::WriteStringMaybeAliased(
      1, this->topic_name(), output);
  }

  if (_internal_metadata_.have_unknown_fields()) {
    ::google::protobuf::internal::WireFormat::SerializeUnknownFields(
        unknown_fields(), output);
  }
  // @@protoc_insertion_point(serialize_end:mw.internal.robotics.gazebotransport.RequestLaser)
}

::google::protobuf::uint8* RequestLaser::InternalSerializeWithCachedSizesToArray(
    bool deterministic, ::google::protobuf::uint8* target) const {
  // @@protoc_insertion_point(serialize_to_array_start:mw.internal.robotics.gazebotransport.RequestLaser)
  // required string topic_name = 1;
  if (has_topic_name()) {
    ::google::protobuf::internal::WireFormat::VerifyUTF8StringNamedField(
      this->topic_name().data(), this->topic_name().length(),
      ::google::protobuf::internal::WireFormat::SERIALIZE,
      "mw.internal.robotics.gazebotransport.RequestLaser.topic_name");
    target =
      ::google::protobuf::internal::WireFormatLite::WriteStringToArray(
        1, this->topic_name(), target);
  }

  if (_internal_metadata_.have_unknown_fields()) {
    target = ::google::protobuf::internal::WireFormat::SerializeUnknownFieldsToArray(
        unknown_fields(), target);
  }
  // @@protoc_insertion_point(serialize_to_array_end:mw.internal.robotics.gazebotransport.RequestLaser)
  return target;
}

int RequestLaser::ByteSize() const {
// @@protoc_insertion_point(message_byte_size_start:mw.internal.robotics.gazebotransport.RequestLaser)
  int total_size = 0;

  // required string topic_name = 1;
  if (has_topic_name()) {
    total_size += 1 +
      ::google::protobuf::internal::WireFormatLite::StringSize(
        this->topic_name());
  }
  if (_internal_metadata_.have_unknown_fields()) {
    total_size +=
      ::google::protobuf::internal::WireFormat::ComputeUnknownFieldsSize(
        unknown_fields());
  }
  GOOGLE_SAFE_CONCURRENT_WRITES_BEGIN();
  _cached_size_ = total_size;
  GOOGLE_SAFE_CONCURRENT_WRITES_END();
  return total_size;
}

void RequestLaser::MergeFrom(const ::google::protobuf::Message& from) {
// @@protoc_insertion_point(generalized_merge_from_start:mw.internal.robotics.gazebotransport.RequestLaser)
  if (GOOGLE_PREDICT_FALSE(&from == this)) {
    ::google::protobuf::internal::MergeFromFail(__FILE__, __LINE__);
  }
  const RequestLaser* source = 
      ::google::protobuf::internal::DynamicCastToGenerated<const RequestLaser>(
          &from);
  if (source == NULL) {
  // @@protoc_insertion_point(generalized_merge_from_cast_fail:mw.internal.robotics.gazebotransport.RequestLaser)
    ::google::protobuf::internal::ReflectionOps::Merge(from, this);
  } else {
  // @@protoc_insertion_point(generalized_merge_from_cast_success:mw.internal.robotics.gazebotransport.RequestLaser)
    MergeFrom(*source);
  }
}

void RequestLaser::MergeFrom(const RequestLaser& from) {
// @@protoc_insertion_point(class_specific_merge_from_start:mw.internal.robotics.gazebotransport.RequestLaser)
  if (GOOGLE_PREDICT_FALSE(&from == this)) {
    ::google::protobuf::internal::MergeFromFail(__FILE__, __LINE__);
  }
  if (from._has_bits_[0 / 32] & (0xffu << (0 % 32))) {
    if (from.has_topic_name()) {
      set_has_topic_name();
      topic_name_.AssignWithDefault(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), from.topic_name_);
    }
  }
  if (from._internal_metadata_.have_unknown_fields()) {
    mutable_unknown_fields()->MergeFrom(from.unknown_fields());
  }
}

void RequestLaser::CopyFrom(const ::google::protobuf::Message& from) {
// @@protoc_insertion_point(generalized_copy_from_start:mw.internal.robotics.gazebotransport.RequestLaser)
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

void RequestLaser::CopyFrom(const RequestLaser& from) {
// @@protoc_insertion_point(class_specific_copy_from_start:mw.internal.robotics.gazebotransport.RequestLaser)
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

bool RequestLaser::IsInitialized() const {
  if ((_has_bits_[0] & 0x00000001) != 0x00000001) return false;

  return true;
}

void RequestLaser::Swap(RequestLaser* other) {
  if (other == this) return;
  InternalSwap(other);
}
void RequestLaser::InternalSwap(RequestLaser* other) {
  topic_name_.Swap(&other->topic_name_);
  std::swap(_has_bits_[0], other->_has_bits_[0]);
  _internal_metadata_.Swap(&other->_internal_metadata_);
  std::swap(_cached_size_, other->_cached_size_);
}

::google::protobuf::Metadata RequestLaser::GetMetadata() const {
  protobuf_AssignDescriptorsOnce();
  ::google::protobuf::Metadata metadata;
  metadata.descriptor = RequestLaser_descriptor_;
  metadata.reflection = RequestLaser_reflection_;
  return metadata;
}

#if PROTOBUF_INLINE_NOT_IN_HEADERS
// RequestLaser

// required string topic_name = 1;
bool RequestLaser::has_topic_name() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
void RequestLaser::set_has_topic_name() {
  _has_bits_[0] |= 0x00000001u;
}
void RequestLaser::clear_has_topic_name() {
  _has_bits_[0] &= ~0x00000001u;
}
void RequestLaser::clear_topic_name() {
  topic_name_.ClearToEmptyNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
  clear_has_topic_name();
}
 const ::std::string& RequestLaser::topic_name() const {
  // @@protoc_insertion_point(field_get:mw.internal.robotics.gazebotransport.RequestLaser.topic_name)
  return topic_name_.GetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
 void RequestLaser::set_topic_name(const ::std::string& value) {
  set_has_topic_name();
  topic_name_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), value);
  // @@protoc_insertion_point(field_set:mw.internal.robotics.gazebotransport.RequestLaser.topic_name)
}
 void RequestLaser::set_topic_name(const char* value) {
  set_has_topic_name();
  topic_name_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::string(value));
  // @@protoc_insertion_point(field_set_char:mw.internal.robotics.gazebotransport.RequestLaser.topic_name)
}
 void RequestLaser::set_topic_name(const char* value, size_t size) {
  set_has_topic_name();
  topic_name_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(),
      ::std::string(reinterpret_cast<const char*>(value), size));
  // @@protoc_insertion_point(field_set_pointer:mw.internal.robotics.gazebotransport.RequestLaser.topic_name)
}
 ::std::string* RequestLaser::mutable_topic_name() {
  set_has_topic_name();
  // @@protoc_insertion_point(field_mutable:mw.internal.robotics.gazebotransport.RequestLaser.topic_name)
  return topic_name_.MutableNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
 ::std::string* RequestLaser::release_topic_name() {
  // @@protoc_insertion_point(field_release:mw.internal.robotics.gazebotransport.RequestLaser.topic_name)
  clear_has_topic_name();
  return topic_name_.ReleaseNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
 void RequestLaser::set_allocated_topic_name(::std::string* topic_name) {
  if (topic_name != NULL) {
    set_has_topic_name();
  } else {
    clear_has_topic_name();
  }
  topic_name_.SetAllocatedNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), topic_name);
  // @@protoc_insertion_point(field_set_allocated:mw.internal.robotics.gazebotransport.RequestLaser.topic_name)
}

#endif  // PROTOBUF_INLINE_NOT_IN_HEADERS

// ===================================================================

#if !defined(_MSC_VER) || _MSC_VER >= 1900
const int ImuData::kLinearAccelerationFieldNumber;
const int ImuData::kAngularVelocityFieldNumber;
const int ImuData::kOrientationFieldNumber;
#endif  // !defined(_MSC_VER) || _MSC_VER >= 1900

ImuData::ImuData()
  : ::google::protobuf::Message(), _internal_metadata_(NULL) {
  SharedCtor();
  // @@protoc_insertion_point(constructor:mw.internal.robotics.gazebotransport.ImuData)
}

void ImuData::InitAsDefaultInstance() {
  linear_acceleration_ = const_cast< ::mw::internal::robotics::gazebotransport::Point*>(&::mw::internal::robotics::gazebotransport::Point::default_instance());
  angular_velocity_ = const_cast< ::mw::internal::robotics::gazebotransport::Point*>(&::mw::internal::robotics::gazebotransport::Point::default_instance());
  orientation_ = const_cast< ::mw::internal::robotics::gazebotransport::Quaternion*>(&::mw::internal::robotics::gazebotransport::Quaternion::default_instance());
}

ImuData::ImuData(const ImuData& from)
  : ::google::protobuf::Message(),
    _internal_metadata_(NULL) {
  SharedCtor();
  MergeFrom(from);
  // @@protoc_insertion_point(copy_constructor:mw.internal.robotics.gazebotransport.ImuData)
}

void ImuData::SharedCtor() {
  _cached_size_ = 0;
  linear_acceleration_ = NULL;
  angular_velocity_ = NULL;
  orientation_ = NULL;
  ::memset(_has_bits_, 0, sizeof(_has_bits_));
}

ImuData::~ImuData() {
  // @@protoc_insertion_point(destructor:mw.internal.robotics.gazebotransport.ImuData)
  SharedDtor();
}

void ImuData::SharedDtor() {
  if (this != default_instance_) {
    delete linear_acceleration_;
    delete angular_velocity_;
    delete orientation_;
  }
}

void ImuData::SetCachedSize(int size) const {
  GOOGLE_SAFE_CONCURRENT_WRITES_BEGIN();
  _cached_size_ = size;
  GOOGLE_SAFE_CONCURRENT_WRITES_END();
}
const ::google::protobuf::Descriptor* ImuData::descriptor() {
  protobuf_AssignDescriptorsOnce();
  return ImuData_descriptor_;
}

const ImuData& ImuData::default_instance() {
  if (default_instance_ == NULL) protobuf_AddDesc_mw_2einternal_2erobotics_2egazebotransport_2eCoSimMsgs_2eproto();
  return *default_instance_;
}

ImuData* ImuData::default_instance_ = NULL;

ImuData* ImuData::New(::google::protobuf::Arena* arena) const {
  ImuData* n = new ImuData;
  if (arena != NULL) {
    arena->Own(n);
  }
  return n;
}

void ImuData::Clear() {
// @@protoc_insertion_point(message_clear_start:mw.internal.robotics.gazebotransport.ImuData)
  if (_has_bits_[0 / 32] & 7u) {
    if (has_linear_acceleration()) {
      if (linear_acceleration_ != NULL) linear_acceleration_->::mw::internal::robotics::gazebotransport::Point::Clear();
    }
    if (has_angular_velocity()) {
      if (angular_velocity_ != NULL) angular_velocity_->::mw::internal::robotics::gazebotransport::Point::Clear();
    }
    if (has_orientation()) {
      if (orientation_ != NULL) orientation_->::mw::internal::robotics::gazebotransport::Quaternion::Clear();
    }
  }
  ::memset(_has_bits_, 0, sizeof(_has_bits_));
  if (_internal_metadata_.have_unknown_fields()) {
    mutable_unknown_fields()->Clear();
  }
}

bool ImuData::MergePartialFromCodedStream(
    ::google::protobuf::io::CodedInputStream* input) {
#define DO_(EXPRESSION) if (!GOOGLE_PREDICT_TRUE(EXPRESSION)) goto failure
  ::google::protobuf::uint32 tag;
  // @@protoc_insertion_point(parse_start:mw.internal.robotics.gazebotransport.ImuData)
  for (;;) {
    ::std::pair< ::google::protobuf::uint32, bool> p = input->ReadTagWithCutoff(127);
    tag = p.first;
    if (!p.second) goto handle_unusual;
    switch (::google::protobuf::internal::WireFormatLite::GetTagFieldNumber(tag)) {
      // required .mw.internal.robotics.gazebotransport.Point linear_acceleration = 1;
      case 1: {
        if (tag == 10) {
          DO_(::google::protobuf::internal::WireFormatLite::ReadMessageNoVirtual(
               input, mutable_linear_acceleration()));
        } else {
          goto handle_unusual;
        }
        if (input->ExpectTag(18)) goto parse_angular_velocity;
        break;
      }

      // required .mw.internal.robotics.gazebotransport.Point angular_velocity = 2;
      case 2: {
        if (tag == 18) {
         parse_angular_velocity:
          DO_(::google::protobuf::internal::WireFormatLite::ReadMessageNoVirtual(
               input, mutable_angular_velocity()));
        } else {
          goto handle_unusual;
        }
        if (input->ExpectTag(26)) goto parse_orientation;
        break;
      }

      // required .mw.internal.robotics.gazebotransport.Quaternion orientation = 3;
      case 3: {
        if (tag == 26) {
         parse_orientation:
          DO_(::google::protobuf::internal::WireFormatLite::ReadMessageNoVirtual(
               input, mutable_orientation()));
        } else {
          goto handle_unusual;
        }
        if (input->ExpectAtEnd()) goto success;
        break;
      }

      default: {
      handle_unusual:
        if (tag == 0 ||
            ::google::protobuf::internal::WireFormatLite::GetTagWireType(tag) ==
            ::google::protobuf::internal::WireFormatLite::WIRETYPE_END_GROUP) {
          goto success;
        }
        DO_(::google::protobuf::internal::WireFormat::SkipField(
              input, tag, mutable_unknown_fields()));
        break;
      }
    }
  }
success:
  // @@protoc_insertion_point(parse_success:mw.internal.robotics.gazebotransport.ImuData)
  return true;
failure:
  // @@protoc_insertion_point(parse_failure:mw.internal.robotics.gazebotransport.ImuData)
  return false;
#undef DO_
}

void ImuData::SerializeWithCachedSizes(
    ::google::protobuf::io::CodedOutputStream* output) const {
  // @@protoc_insertion_point(serialize_start:mw.internal.robotics.gazebotransport.ImuData)
  // required .mw.internal.robotics.gazebotransport.Point linear_acceleration = 1;
  if (has_linear_acceleration()) {
    ::google::protobuf::internal::WireFormatLite::WriteMessageMaybeToArray(
      1, *this->linear_acceleration_, output);
  }

  // required .mw.internal.robotics.gazebotransport.Point angular_velocity = 2;
  if (has_angular_velocity()) {
    ::google::protobuf::internal::WireFormatLite::WriteMessageMaybeToArray(
      2, *this->angular_velocity_, output);
  }

  // required .mw.internal.robotics.gazebotransport.Quaternion orientation = 3;
  if (has_orientation()) {
    ::google::protobuf::internal::WireFormatLite::WriteMessageMaybeToArray(
      3, *this->orientation_, output);
  }

  if (_internal_metadata_.have_unknown_fields()) {
    ::google::protobuf::internal::WireFormat::SerializeUnknownFields(
        unknown_fields(), output);
  }
  // @@protoc_insertion_point(serialize_end:mw.internal.robotics.gazebotransport.ImuData)
}

::google::protobuf::uint8* ImuData::InternalSerializeWithCachedSizesToArray(
    bool deterministic, ::google::protobuf::uint8* target) const {
  // @@protoc_insertion_point(serialize_to_array_start:mw.internal.robotics.gazebotransport.ImuData)
  // required .mw.internal.robotics.gazebotransport.Point linear_acceleration = 1;
  if (has_linear_acceleration()) {
    target = ::google::protobuf::internal::WireFormatLite::
      InternalWriteMessageNoVirtualToArray(
        1, *this->linear_acceleration_, false, target);
  }

  // required .mw.internal.robotics.gazebotransport.Point angular_velocity = 2;
  if (has_angular_velocity()) {
    target = ::google::protobuf::internal::WireFormatLite::
      InternalWriteMessageNoVirtualToArray(
        2, *this->angular_velocity_, false, target);
  }

  // required .mw.internal.robotics.gazebotransport.Quaternion orientation = 3;
  if (has_orientation()) {
    target = ::google::protobuf::internal::WireFormatLite::
      InternalWriteMessageNoVirtualToArray(
        3, *this->orientation_, false, target);
  }

  if (_internal_metadata_.have_unknown_fields()) {
    target = ::google::protobuf::internal::WireFormat::SerializeUnknownFieldsToArray(
        unknown_fields(), target);
  }
  // @@protoc_insertion_point(serialize_to_array_end:mw.internal.robotics.gazebotransport.ImuData)
  return target;
}

int ImuData::RequiredFieldsByteSizeFallback() const {
// @@protoc_insertion_point(required_fields_byte_size_fallback_start:mw.internal.robotics.gazebotransport.ImuData)
  int total_size = 0;

  if (has_linear_acceleration()) {
    // required .mw.internal.robotics.gazebotransport.Point linear_acceleration = 1;
    total_size += 1 +
      ::google::protobuf::internal::WireFormatLite::MessageSizeNoVirtual(
        *this->linear_acceleration_);
  }

  if (has_angular_velocity()) {
    // required .mw.internal.robotics.gazebotransport.Point angular_velocity = 2;
    total_size += 1 +
      ::google::protobuf::internal::WireFormatLite::MessageSizeNoVirtual(
        *this->angular_velocity_);
  }

  if (has_orientation()) {
    // required .mw.internal.robotics.gazebotransport.Quaternion orientation = 3;
    total_size += 1 +
      ::google::protobuf::internal::WireFormatLite::MessageSizeNoVirtual(
        *this->orientation_);
  }

  return total_size;
}
int ImuData::ByteSize() const {
// @@protoc_insertion_point(message_byte_size_start:mw.internal.robotics.gazebotransport.ImuData)
  int total_size = 0;

  if (((_has_bits_[0] & 0x00000007) ^ 0x00000007) == 0) {  // All required fields are present.
    // required .mw.internal.robotics.gazebotransport.Point linear_acceleration = 1;
    total_size += 1 +
      ::google::protobuf::internal::WireFormatLite::MessageSizeNoVirtual(
        *this->linear_acceleration_);

    // required .mw.internal.robotics.gazebotransport.Point angular_velocity = 2;
    total_size += 1 +
      ::google::protobuf::internal::WireFormatLite::MessageSizeNoVirtual(
        *this->angular_velocity_);

    // required .mw.internal.robotics.gazebotransport.Quaternion orientation = 3;
    total_size += 1 +
      ::google::protobuf::internal::WireFormatLite::MessageSizeNoVirtual(
        *this->orientation_);

  } else {
    total_size += RequiredFieldsByteSizeFallback();
  }
  if (_internal_metadata_.have_unknown_fields()) {
    total_size +=
      ::google::protobuf::internal::WireFormat::ComputeUnknownFieldsSize(
        unknown_fields());
  }
  GOOGLE_SAFE_CONCURRENT_WRITES_BEGIN();
  _cached_size_ = total_size;
  GOOGLE_SAFE_CONCURRENT_WRITES_END();
  return total_size;
}

void ImuData::MergeFrom(const ::google::protobuf::Message& from) {
// @@protoc_insertion_point(generalized_merge_from_start:mw.internal.robotics.gazebotransport.ImuData)
  if (GOOGLE_PREDICT_FALSE(&from == this)) {
    ::google::protobuf::internal::MergeFromFail(__FILE__, __LINE__);
  }
  const ImuData* source = 
      ::google::protobuf::internal::DynamicCastToGenerated<const ImuData>(
          &from);
  if (source == NULL) {
  // @@protoc_insertion_point(generalized_merge_from_cast_fail:mw.internal.robotics.gazebotransport.ImuData)
    ::google::protobuf::internal::ReflectionOps::Merge(from, this);
  } else {
  // @@protoc_insertion_point(generalized_merge_from_cast_success:mw.internal.robotics.gazebotransport.ImuData)
    MergeFrom(*source);
  }
}

void ImuData::MergeFrom(const ImuData& from) {
// @@protoc_insertion_point(class_specific_merge_from_start:mw.internal.robotics.gazebotransport.ImuData)
  if (GOOGLE_PREDICT_FALSE(&from == this)) {
    ::google::protobuf::internal::MergeFromFail(__FILE__, __LINE__);
  }
  if (from._has_bits_[0 / 32] & (0xffu << (0 % 32))) {
    if (from.has_linear_acceleration()) {
      mutable_linear_acceleration()->::mw::internal::robotics::gazebotransport::Point::MergeFrom(from.linear_acceleration());
    }
    if (from.has_angular_velocity()) {
      mutable_angular_velocity()->::mw::internal::robotics::gazebotransport::Point::MergeFrom(from.angular_velocity());
    }
    if (from.has_orientation()) {
      mutable_orientation()->::mw::internal::robotics::gazebotransport::Quaternion::MergeFrom(from.orientation());
    }
  }
  if (from._internal_metadata_.have_unknown_fields()) {
    mutable_unknown_fields()->MergeFrom(from.unknown_fields());
  }
}

void ImuData::CopyFrom(const ::google::protobuf::Message& from) {
// @@protoc_insertion_point(generalized_copy_from_start:mw.internal.robotics.gazebotransport.ImuData)
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

void ImuData::CopyFrom(const ImuData& from) {
// @@protoc_insertion_point(class_specific_copy_from_start:mw.internal.robotics.gazebotransport.ImuData)
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

bool ImuData::IsInitialized() const {
  if ((_has_bits_[0] & 0x00000007) != 0x00000007) return false;

  if (has_linear_acceleration()) {
    if (!this->linear_acceleration_->IsInitialized()) return false;
  }
  if (has_angular_velocity()) {
    if (!this->angular_velocity_->IsInitialized()) return false;
  }
  if (has_orientation()) {
    if (!this->orientation_->IsInitialized()) return false;
  }
  return true;
}

void ImuData::Swap(ImuData* other) {
  if (other == this) return;
  InternalSwap(other);
}
void ImuData::InternalSwap(ImuData* other) {
  std::swap(linear_acceleration_, other->linear_acceleration_);
  std::swap(angular_velocity_, other->angular_velocity_);
  std::swap(orientation_, other->orientation_);
  std::swap(_has_bits_[0], other->_has_bits_[0]);
  _internal_metadata_.Swap(&other->_internal_metadata_);
  std::swap(_cached_size_, other->_cached_size_);
}

::google::protobuf::Metadata ImuData::GetMetadata() const {
  protobuf_AssignDescriptorsOnce();
  ::google::protobuf::Metadata metadata;
  metadata.descriptor = ImuData_descriptor_;
  metadata.reflection = ImuData_reflection_;
  return metadata;
}

#if PROTOBUF_INLINE_NOT_IN_HEADERS
// ImuData

// required .mw.internal.robotics.gazebotransport.Point linear_acceleration = 1;
bool ImuData::has_linear_acceleration() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
void ImuData::set_has_linear_acceleration() {
  _has_bits_[0] |= 0x00000001u;
}
void ImuData::clear_has_linear_acceleration() {
  _has_bits_[0] &= ~0x00000001u;
}
void ImuData::clear_linear_acceleration() {
  if (linear_acceleration_ != NULL) linear_acceleration_->::mw::internal::robotics::gazebotransport::Point::Clear();
  clear_has_linear_acceleration();
}
const ::mw::internal::robotics::gazebotransport::Point& ImuData::linear_acceleration() const {
  // @@protoc_insertion_point(field_get:mw.internal.robotics.gazebotransport.ImuData.linear_acceleration)
  return linear_acceleration_ != NULL ? *linear_acceleration_ : *default_instance_->linear_acceleration_;
}
::mw::internal::robotics::gazebotransport::Point* ImuData::mutable_linear_acceleration() {
  set_has_linear_acceleration();
  if (linear_acceleration_ == NULL) {
    linear_acceleration_ = new ::mw::internal::robotics::gazebotransport::Point;
  }
  // @@protoc_insertion_point(field_mutable:mw.internal.robotics.gazebotransport.ImuData.linear_acceleration)
  return linear_acceleration_;
}
::mw::internal::robotics::gazebotransport::Point* ImuData::release_linear_acceleration() {
  // @@protoc_insertion_point(field_release:mw.internal.robotics.gazebotransport.ImuData.linear_acceleration)
  clear_has_linear_acceleration();
  ::mw::internal::robotics::gazebotransport::Point* temp = linear_acceleration_;
  linear_acceleration_ = NULL;
  return temp;
}
void ImuData::set_allocated_linear_acceleration(::mw::internal::robotics::gazebotransport::Point* linear_acceleration) {
  delete linear_acceleration_;
  linear_acceleration_ = linear_acceleration;
  if (linear_acceleration) {
    set_has_linear_acceleration();
  } else {
    clear_has_linear_acceleration();
  }
  // @@protoc_insertion_point(field_set_allocated:mw.internal.robotics.gazebotransport.ImuData.linear_acceleration)
}

// required .mw.internal.robotics.gazebotransport.Point angular_velocity = 2;
bool ImuData::has_angular_velocity() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
void ImuData::set_has_angular_velocity() {
  _has_bits_[0] |= 0x00000002u;
}
void ImuData::clear_has_angular_velocity() {
  _has_bits_[0] &= ~0x00000002u;
}
void ImuData::clear_angular_velocity() {
  if (angular_velocity_ != NULL) angular_velocity_->::mw::internal::robotics::gazebotransport::Point::Clear();
  clear_has_angular_velocity();
}
const ::mw::internal::robotics::gazebotransport::Point& ImuData::angular_velocity() const {
  // @@protoc_insertion_point(field_get:mw.internal.robotics.gazebotransport.ImuData.angular_velocity)
  return angular_velocity_ != NULL ? *angular_velocity_ : *default_instance_->angular_velocity_;
}
::mw::internal::robotics::gazebotransport::Point* ImuData::mutable_angular_velocity() {
  set_has_angular_velocity();
  if (angular_velocity_ == NULL) {
    angular_velocity_ = new ::mw::internal::robotics::gazebotransport::Point;
  }
  // @@protoc_insertion_point(field_mutable:mw.internal.robotics.gazebotransport.ImuData.angular_velocity)
  return angular_velocity_;
}
::mw::internal::robotics::gazebotransport::Point* ImuData::release_angular_velocity() {
  // @@protoc_insertion_point(field_release:mw.internal.robotics.gazebotransport.ImuData.angular_velocity)
  clear_has_angular_velocity();
  ::mw::internal::robotics::gazebotransport::Point* temp = angular_velocity_;
  angular_velocity_ = NULL;
  return temp;
}
void ImuData::set_allocated_angular_velocity(::mw::internal::robotics::gazebotransport::Point* angular_velocity) {
  delete angular_velocity_;
  angular_velocity_ = angular_velocity;
  if (angular_velocity) {
    set_has_angular_velocity();
  } else {
    clear_has_angular_velocity();
  }
  // @@protoc_insertion_point(field_set_allocated:mw.internal.robotics.gazebotransport.ImuData.angular_velocity)
}

// required .mw.internal.robotics.gazebotransport.Quaternion orientation = 3;
bool ImuData::has_orientation() const {
  return (_has_bits_[0] & 0x00000004u) != 0;
}
void ImuData::set_has_orientation() {
  _has_bits_[0] |= 0x00000004u;
}
void ImuData::clear_has_orientation() {
  _has_bits_[0] &= ~0x00000004u;
}
void ImuData::clear_orientation() {
  if (orientation_ != NULL) orientation_->::mw::internal::robotics::gazebotransport::Quaternion::Clear();
  clear_has_orientation();
}
const ::mw::internal::robotics::gazebotransport::Quaternion& ImuData::orientation() const {
  // @@protoc_insertion_point(field_get:mw.internal.robotics.gazebotransport.ImuData.orientation)
  return orientation_ != NULL ? *orientation_ : *default_instance_->orientation_;
}
::mw::internal::robotics::gazebotransport::Quaternion* ImuData::mutable_orientation() {
  set_has_orientation();
  if (orientation_ == NULL) {
    orientation_ = new ::mw::internal::robotics::gazebotransport::Quaternion;
  }
  // @@protoc_insertion_point(field_mutable:mw.internal.robotics.gazebotransport.ImuData.orientation)
  return orientation_;
}
::mw::internal::robotics::gazebotransport::Quaternion* ImuData::release_orientation() {
  // @@protoc_insertion_point(field_release:mw.internal.robotics.gazebotransport.ImuData.orientation)
  clear_has_orientation();
  ::mw::internal::robotics::gazebotransport::Quaternion* temp = orientation_;
  orientation_ = NULL;
  return temp;
}
void ImuData::set_allocated_orientation(::mw::internal::robotics::gazebotransport::Quaternion* orientation) {
  delete orientation_;
  orientation_ = orientation;
  if (orientation) {
    set_has_orientation();
  } else {
    clear_has_orientation();
  }
  // @@protoc_insertion_point(field_set_allocated:mw.internal.robotics.gazebotransport.ImuData.orientation)
}

#endif  // PROTOBUF_INLINE_NOT_IN_HEADERS

// ===================================================================

#if !defined(_MSC_VER) || _MSC_VER >= 1900
const int RequestImu::kTopicNameFieldNumber;
#endif  // !defined(_MSC_VER) || _MSC_VER >= 1900

RequestImu::RequestImu()
  : ::google::protobuf::Message(), _internal_metadata_(NULL) {
  SharedCtor();
  // @@protoc_insertion_point(constructor:mw.internal.robotics.gazebotransport.RequestImu)
}

void RequestImu::InitAsDefaultInstance() {
}

RequestImu::RequestImu(const RequestImu& from)
  : ::google::protobuf::Message(),
    _internal_metadata_(NULL) {
  SharedCtor();
  MergeFrom(from);
  // @@protoc_insertion_point(copy_constructor:mw.internal.robotics.gazebotransport.RequestImu)
}

void RequestImu::SharedCtor() {
  ::google::protobuf::internal::GetEmptyString();
  _cached_size_ = 0;
  topic_name_.UnsafeSetDefault(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
  ::memset(_has_bits_, 0, sizeof(_has_bits_));
}

RequestImu::~RequestImu() {
  // @@protoc_insertion_point(destructor:mw.internal.robotics.gazebotransport.RequestImu)
  SharedDtor();
}

void RequestImu::SharedDtor() {
  topic_name_.DestroyNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
  if (this != default_instance_) {
  }
}

void RequestImu::SetCachedSize(int size) const {
  GOOGLE_SAFE_CONCURRENT_WRITES_BEGIN();
  _cached_size_ = size;
  GOOGLE_SAFE_CONCURRENT_WRITES_END();
}
const ::google::protobuf::Descriptor* RequestImu::descriptor() {
  protobuf_AssignDescriptorsOnce();
  return RequestImu_descriptor_;
}

const RequestImu& RequestImu::default_instance() {
  if (default_instance_ == NULL) protobuf_AddDesc_mw_2einternal_2erobotics_2egazebotransport_2eCoSimMsgs_2eproto();
  return *default_instance_;
}

RequestImu* RequestImu::default_instance_ = NULL;

RequestImu* RequestImu::New(::google::protobuf::Arena* arena) const {
  RequestImu* n = new RequestImu;
  if (arena != NULL) {
    arena->Own(n);
  }
  return n;
}

void RequestImu::Clear() {
// @@protoc_insertion_point(message_clear_start:mw.internal.robotics.gazebotransport.RequestImu)
  if (has_topic_name()) {
    topic_name_.ClearToEmptyNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
  }
  ::memset(_has_bits_, 0, sizeof(_has_bits_));
  if (_internal_metadata_.have_unknown_fields()) {
    mutable_unknown_fields()->Clear();
  }
}

bool RequestImu::MergePartialFromCodedStream(
    ::google::protobuf::io::CodedInputStream* input) {
#define DO_(EXPRESSION) if (!GOOGLE_PREDICT_TRUE(EXPRESSION)) goto failure
  ::google::protobuf::uint32 tag;
  // @@protoc_insertion_point(parse_start:mw.internal.robotics.gazebotransport.RequestImu)
  for (;;) {
    ::std::pair< ::google::protobuf::uint32, bool> p = input->ReadTagWithCutoff(127);
    tag = p.first;
    if (!p.second) goto handle_unusual;
    switch (::google::protobuf::internal::WireFormatLite::GetTagFieldNumber(tag)) {
      // required string topic_name = 1;
      case 1: {
        if (tag == 10) {
          DO_(::google::protobuf::internal::WireFormatLite::ReadString(
                input, this->mutable_topic_name()));
          ::google::protobuf::internal::WireFormat::VerifyUTF8StringNamedField(
            this->topic_name().data(), this->topic_name().length(),
            ::google::protobuf::internal::WireFormat::PARSE,
            "mw.internal.robotics.gazebotransport.RequestImu.topic_name");
        } else {
          goto handle_unusual;
        }
        if (input->ExpectAtEnd()) goto success;
        break;
      }

      default: {
      handle_unusual:
        if (tag == 0 ||
            ::google::protobuf::internal::WireFormatLite::GetTagWireType(tag) ==
            ::google::protobuf::internal::WireFormatLite::WIRETYPE_END_GROUP) {
          goto success;
        }
        DO_(::google::protobuf::internal::WireFormat::SkipField(
              input, tag, mutable_unknown_fields()));
        break;
      }
    }
  }
success:
  // @@protoc_insertion_point(parse_success:mw.internal.robotics.gazebotransport.RequestImu)
  return true;
failure:
  // @@protoc_insertion_point(parse_failure:mw.internal.robotics.gazebotransport.RequestImu)
  return false;
#undef DO_
}

void RequestImu::SerializeWithCachedSizes(
    ::google::protobuf::io::CodedOutputStream* output) const {
  // @@protoc_insertion_point(serialize_start:mw.internal.robotics.gazebotransport.RequestImu)
  // required string topic_name = 1;
  if (has_topic_name()) {
    ::google::protobuf::internal::WireFormat::VerifyUTF8StringNamedField(
      this->topic_name().data(), this->topic_name().length(),
      ::google::protobuf::internal::WireFormat::SERIALIZE,
      "mw.internal.robotics.gazebotransport.RequestImu.topic_name");
    ::google::protobuf::internal::WireFormatLite::WriteStringMaybeAliased(
      1, this->topic_name(), output);
  }

  if (_internal_metadata_.have_unknown_fields()) {
    ::google::protobuf::internal::WireFormat::SerializeUnknownFields(
        unknown_fields(), output);
  }
  // @@protoc_insertion_point(serialize_end:mw.internal.robotics.gazebotransport.RequestImu)
}

::google::protobuf::uint8* RequestImu::InternalSerializeWithCachedSizesToArray(
    bool deterministic, ::google::protobuf::uint8* target) const {
  // @@protoc_insertion_point(serialize_to_array_start:mw.internal.robotics.gazebotransport.RequestImu)
  // required string topic_name = 1;
  if (has_topic_name()) {
    ::google::protobuf::internal::WireFormat::VerifyUTF8StringNamedField(
      this->topic_name().data(), this->topic_name().length(),
      ::google::protobuf::internal::WireFormat::SERIALIZE,
      "mw.internal.robotics.gazebotransport.RequestImu.topic_name");
    target =
      ::google::protobuf::internal::WireFormatLite::WriteStringToArray(
        1, this->topic_name(), target);
  }

  if (_internal_metadata_.have_unknown_fields()) {
    target = ::google::protobuf::internal::WireFormat::SerializeUnknownFieldsToArray(
        unknown_fields(), target);
  }
  // @@protoc_insertion_point(serialize_to_array_end:mw.internal.robotics.gazebotransport.RequestImu)
  return target;
}

int RequestImu::ByteSize() const {
// @@protoc_insertion_point(message_byte_size_start:mw.internal.robotics.gazebotransport.RequestImu)
  int total_size = 0;

  // required string topic_name = 1;
  if (has_topic_name()) {
    total_size += 1 +
      ::google::protobuf::internal::WireFormatLite::StringSize(
        this->topic_name());
  }
  if (_internal_metadata_.have_unknown_fields()) {
    total_size +=
      ::google::protobuf::internal::WireFormat::ComputeUnknownFieldsSize(
        unknown_fields());
  }
  GOOGLE_SAFE_CONCURRENT_WRITES_BEGIN();
  _cached_size_ = total_size;
  GOOGLE_SAFE_CONCURRENT_WRITES_END();
  return total_size;
}

void RequestImu::MergeFrom(const ::google::protobuf::Message& from) {
// @@protoc_insertion_point(generalized_merge_from_start:mw.internal.robotics.gazebotransport.RequestImu)
  if (GOOGLE_PREDICT_FALSE(&from == this)) {
    ::google::protobuf::internal::MergeFromFail(__FILE__, __LINE__);
  }
  const RequestImu* source = 
      ::google::protobuf::internal::DynamicCastToGenerated<const RequestImu>(
          &from);
  if (source == NULL) {
  // @@protoc_insertion_point(generalized_merge_from_cast_fail:mw.internal.robotics.gazebotransport.RequestImu)
    ::google::protobuf::internal::ReflectionOps::Merge(from, this);
  } else {
  // @@protoc_insertion_point(generalized_merge_from_cast_success:mw.internal.robotics.gazebotransport.RequestImu)
    MergeFrom(*source);
  }
}

void RequestImu::MergeFrom(const RequestImu& from) {
// @@protoc_insertion_point(class_specific_merge_from_start:mw.internal.robotics.gazebotransport.RequestImu)
  if (GOOGLE_PREDICT_FALSE(&from == this)) {
    ::google::protobuf::internal::MergeFromFail(__FILE__, __LINE__);
  }
  if (from._has_bits_[0 / 32] & (0xffu << (0 % 32))) {
    if (from.has_topic_name()) {
      set_has_topic_name();
      topic_name_.AssignWithDefault(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), from.topic_name_);
    }
  }
  if (from._internal_metadata_.have_unknown_fields()) {
    mutable_unknown_fields()->MergeFrom(from.unknown_fields());
  }
}

void RequestImu::CopyFrom(const ::google::protobuf::Message& from) {
// @@protoc_insertion_point(generalized_copy_from_start:mw.internal.robotics.gazebotransport.RequestImu)
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

void RequestImu::CopyFrom(const RequestImu& from) {
// @@protoc_insertion_point(class_specific_copy_from_start:mw.internal.robotics.gazebotransport.RequestImu)
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

bool RequestImu::IsInitialized() const {
  if ((_has_bits_[0] & 0x00000001) != 0x00000001) return false;

  return true;
}

void RequestImu::Swap(RequestImu* other) {
  if (other == this) return;
  InternalSwap(other);
}
void RequestImu::InternalSwap(RequestImu* other) {
  topic_name_.Swap(&other->topic_name_);
  std::swap(_has_bits_[0], other->_has_bits_[0]);
  _internal_metadata_.Swap(&other->_internal_metadata_);
  std::swap(_cached_size_, other->_cached_size_);
}

::google::protobuf::Metadata RequestImu::GetMetadata() const {
  protobuf_AssignDescriptorsOnce();
  ::google::protobuf::Metadata metadata;
  metadata.descriptor = RequestImu_descriptor_;
  metadata.reflection = RequestImu_reflection_;
  return metadata;
}

#if PROTOBUF_INLINE_NOT_IN_HEADERS
// RequestImu

// required string topic_name = 1;
bool RequestImu::has_topic_name() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
void RequestImu::set_has_topic_name() {
  _has_bits_[0] |= 0x00000001u;
}
void RequestImu::clear_has_topic_name() {
  _has_bits_[0] &= ~0x00000001u;
}
void RequestImu::clear_topic_name() {
  topic_name_.ClearToEmptyNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
  clear_has_topic_name();
}
 const ::std::string& RequestImu::topic_name() const {
  // @@protoc_insertion_point(field_get:mw.internal.robotics.gazebotransport.RequestImu.topic_name)
  return topic_name_.GetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
 void RequestImu::set_topic_name(const ::std::string& value) {
  set_has_topic_name();
  topic_name_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), value);
  // @@protoc_insertion_point(field_set:mw.internal.robotics.gazebotransport.RequestImu.topic_name)
}
 void RequestImu::set_topic_name(const char* value) {
  set_has_topic_name();
  topic_name_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::string(value));
  // @@protoc_insertion_point(field_set_char:mw.internal.robotics.gazebotransport.RequestImu.topic_name)
}
 void RequestImu::set_topic_name(const char* value, size_t size) {
  set_has_topic_name();
  topic_name_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(),
      ::std::string(reinterpret_cast<const char*>(value), size));
  // @@protoc_insertion_point(field_set_pointer:mw.internal.robotics.gazebotransport.RequestImu.topic_name)
}
 ::std::string* RequestImu::mutable_topic_name() {
  set_has_topic_name();
  // @@protoc_insertion_point(field_mutable:mw.internal.robotics.gazebotransport.RequestImu.topic_name)
  return topic_name_.MutableNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
 ::std::string* RequestImu::release_topic_name() {
  // @@protoc_insertion_point(field_release:mw.internal.robotics.gazebotransport.RequestImu.topic_name)
  clear_has_topic_name();
  return topic_name_.ReleaseNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
 void RequestImu::set_allocated_topic_name(::std::string* topic_name) {
  if (topic_name != NULL) {
    set_has_topic_name();
  } else {
    clear_has_topic_name();
  }
  topic_name_.SetAllocatedNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), topic_name);
  // @@protoc_insertion_point(field_set_allocated:mw.internal.robotics.gazebotransport.RequestImu.topic_name)
}

#endif  // PROTOBUF_INLINE_NOT_IN_HEADERS

// ===================================================================

#if !defined(_MSC_VER) || _MSC_VER >= 1900
const int SubscribeImage::kTopicNameFieldNumber;
#endif  // !defined(_MSC_VER) || _MSC_VER >= 1900

SubscribeImage::SubscribeImage()
  : ::google::protobuf::Message(), _internal_metadata_(NULL) {
  SharedCtor();
  // @@protoc_insertion_point(constructor:mw.internal.robotics.gazebotransport.SubscribeImage)
}

void SubscribeImage::InitAsDefaultInstance() {
}

SubscribeImage::SubscribeImage(const SubscribeImage& from)
  : ::google::protobuf::Message(),
    _internal_metadata_(NULL) {
  SharedCtor();
  MergeFrom(from);
  // @@protoc_insertion_point(copy_constructor:mw.internal.robotics.gazebotransport.SubscribeImage)
}

void SubscribeImage::SharedCtor() {
  ::google::protobuf::internal::GetEmptyString();
  _cached_size_ = 0;
  topic_name_.UnsafeSetDefault(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
  ::memset(_has_bits_, 0, sizeof(_has_bits_));
}

SubscribeImage::~SubscribeImage() {
  // @@protoc_insertion_point(destructor:mw.internal.robotics.gazebotransport.SubscribeImage)
  SharedDtor();
}

void SubscribeImage::SharedDtor() {
  topic_name_.DestroyNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
  if (this != default_instance_) {
  }
}

void SubscribeImage::SetCachedSize(int size) const {
  GOOGLE_SAFE_CONCURRENT_WRITES_BEGIN();
  _cached_size_ = size;
  GOOGLE_SAFE_CONCURRENT_WRITES_END();
}
const ::google::protobuf::Descriptor* SubscribeImage::descriptor() {
  protobuf_AssignDescriptorsOnce();
  return SubscribeImage_descriptor_;
}

const SubscribeImage& SubscribeImage::default_instance() {
  if (default_instance_ == NULL) protobuf_AddDesc_mw_2einternal_2erobotics_2egazebotransport_2eCoSimMsgs_2eproto();
  return *default_instance_;
}

SubscribeImage* SubscribeImage::default_instance_ = NULL;

SubscribeImage* SubscribeImage::New(::google::protobuf::Arena* arena) const {
  SubscribeImage* n = new SubscribeImage;
  if (arena != NULL) {
    arena->Own(n);
  }
  return n;
}

void SubscribeImage::Clear() {
// @@protoc_insertion_point(message_clear_start:mw.internal.robotics.gazebotransport.SubscribeImage)
  if (has_topic_name()) {
    topic_name_.ClearToEmptyNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
  }
  ::memset(_has_bits_, 0, sizeof(_has_bits_));
  if (_internal_metadata_.have_unknown_fields()) {
    mutable_unknown_fields()->Clear();
  }
}

bool SubscribeImage::MergePartialFromCodedStream(
    ::google::protobuf::io::CodedInputStream* input) {
#define DO_(EXPRESSION) if (!GOOGLE_PREDICT_TRUE(EXPRESSION)) goto failure
  ::google::protobuf::uint32 tag;
  // @@protoc_insertion_point(parse_start:mw.internal.robotics.gazebotransport.SubscribeImage)
  for (;;) {
    ::std::pair< ::google::protobuf::uint32, bool> p = input->ReadTagWithCutoff(127);
    tag = p.first;
    if (!p.second) goto handle_unusual;
    switch (::google::protobuf::internal::WireFormatLite::GetTagFieldNumber(tag)) {
      // required string topic_name = 1;
      case 1: {
        if (tag == 10) {
          DO_(::google::protobuf::internal::WireFormatLite::ReadString(
                input, this->mutable_topic_name()));
          ::google::protobuf::internal::WireFormat::VerifyUTF8StringNamedField(
            this->topic_name().data(), this->topic_name().length(),
            ::google::protobuf::internal::WireFormat::PARSE,
            "mw.internal.robotics.gazebotransport.SubscribeImage.topic_name");
        } else {
          goto handle_unusual;
        }
        if (input->ExpectAtEnd()) goto success;
        break;
      }

      default: {
      handle_unusual:
        if (tag == 0 ||
            ::google::protobuf::internal::WireFormatLite::GetTagWireType(tag) ==
            ::google::protobuf::internal::WireFormatLite::WIRETYPE_END_GROUP) {
          goto success;
        }
        DO_(::google::protobuf::internal::WireFormat::SkipField(
              input, tag, mutable_unknown_fields()));
        break;
      }
    }
  }
success:
  // @@protoc_insertion_point(parse_success:mw.internal.robotics.gazebotransport.SubscribeImage)
  return true;
failure:
  // @@protoc_insertion_point(parse_failure:mw.internal.robotics.gazebotransport.SubscribeImage)
  return false;
#undef DO_
}

void SubscribeImage::SerializeWithCachedSizes(
    ::google::protobuf::io::CodedOutputStream* output) const {
  // @@protoc_insertion_point(serialize_start:mw.internal.robotics.gazebotransport.SubscribeImage)
  // required string topic_name = 1;
  if (has_topic_name()) {
    ::google::protobuf::internal::WireFormat::VerifyUTF8StringNamedField(
      this->topic_name().data(), this->topic_name().length(),
      ::google::protobuf::internal::WireFormat::SERIALIZE,
      "mw.internal.robotics.gazebotransport.SubscribeImage.topic_name");
    ::google::protobuf::internal::WireFormatLite::WriteStringMaybeAliased(
      1, this->topic_name(), output);
  }

  if (_internal_metadata_.have_unknown_fields()) {
    ::google::protobuf::internal::WireFormat::SerializeUnknownFields(
        unknown_fields(), output);
  }
  // @@protoc_insertion_point(serialize_end:mw.internal.robotics.gazebotransport.SubscribeImage)
}

::google::protobuf::uint8* SubscribeImage::InternalSerializeWithCachedSizesToArray(
    bool deterministic, ::google::protobuf::uint8* target) const {
  // @@protoc_insertion_point(serialize_to_array_start:mw.internal.robotics.gazebotransport.SubscribeImage)
  // required string topic_name = 1;
  if (has_topic_name()) {
    ::google::protobuf::internal::WireFormat::VerifyUTF8StringNamedField(
      this->topic_name().data(), this->topic_name().length(),
      ::google::protobuf::internal::WireFormat::SERIALIZE,
      "mw.internal.robotics.gazebotransport.SubscribeImage.topic_name");
    target =
      ::google::protobuf::internal::WireFormatLite::WriteStringToArray(
        1, this->topic_name(), target);
  }

  if (_internal_metadata_.have_unknown_fields()) {
    target = ::google::protobuf::internal::WireFormat::SerializeUnknownFieldsToArray(
        unknown_fields(), target);
  }
  // @@protoc_insertion_point(serialize_to_array_end:mw.internal.robotics.gazebotransport.SubscribeImage)
  return target;
}

int SubscribeImage::ByteSize() const {
// @@protoc_insertion_point(message_byte_size_start:mw.internal.robotics.gazebotransport.SubscribeImage)
  int total_size = 0;

  // required string topic_name = 1;
  if (has_topic_name()) {
    total_size += 1 +
      ::google::protobuf::internal::WireFormatLite::StringSize(
        this->topic_name());
  }
  if (_internal_metadata_.have_unknown_fields()) {
    total_size +=
      ::google::protobuf::internal::WireFormat::ComputeUnknownFieldsSize(
        unknown_fields());
  }
  GOOGLE_SAFE_CONCURRENT_WRITES_BEGIN();
  _cached_size_ = total_size;
  GOOGLE_SAFE_CONCURRENT_WRITES_END();
  return total_size;
}

void SubscribeImage::MergeFrom(const ::google::protobuf::Message& from) {
// @@protoc_insertion_point(generalized_merge_from_start:mw.internal.robotics.gazebotransport.SubscribeImage)
  if (GOOGLE_PREDICT_FALSE(&from == this)) {
    ::google::protobuf::internal::MergeFromFail(__FILE__, __LINE__);
  }
  const SubscribeImage* source = 
      ::google::protobuf::internal::DynamicCastToGenerated<const SubscribeImage>(
          &from);
  if (source == NULL) {
  // @@protoc_insertion_point(generalized_merge_from_cast_fail:mw.internal.robotics.gazebotransport.SubscribeImage)
    ::google::protobuf::internal::ReflectionOps::Merge(from, this);
  } else {
  // @@protoc_insertion_point(generalized_merge_from_cast_success:mw.internal.robotics.gazebotransport.SubscribeImage)
    MergeFrom(*source);
  }
}

void SubscribeImage::MergeFrom(const SubscribeImage& from) {
// @@protoc_insertion_point(class_specific_merge_from_start:mw.internal.robotics.gazebotransport.SubscribeImage)
  if (GOOGLE_PREDICT_FALSE(&from == this)) {
    ::google::protobuf::internal::MergeFromFail(__FILE__, __LINE__);
  }
  if (from._has_bits_[0 / 32] & (0xffu << (0 % 32))) {
    if (from.has_topic_name()) {
      set_has_topic_name();
      topic_name_.AssignWithDefault(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), from.topic_name_);
    }
  }
  if (from._internal_metadata_.have_unknown_fields()) {
    mutable_unknown_fields()->MergeFrom(from.unknown_fields());
  }
}

void SubscribeImage::CopyFrom(const ::google::protobuf::Message& from) {
// @@protoc_insertion_point(generalized_copy_from_start:mw.internal.robotics.gazebotransport.SubscribeImage)
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

void SubscribeImage::CopyFrom(const SubscribeImage& from) {
// @@protoc_insertion_point(class_specific_copy_from_start:mw.internal.robotics.gazebotransport.SubscribeImage)
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

bool SubscribeImage::IsInitialized() const {
  if ((_has_bits_[0] & 0x00000001) != 0x00000001) return false;

  return true;
}

void SubscribeImage::Swap(SubscribeImage* other) {
  if (other == this) return;
  InternalSwap(other);
}
void SubscribeImage::InternalSwap(SubscribeImage* other) {
  topic_name_.Swap(&other->topic_name_);
  std::swap(_has_bits_[0], other->_has_bits_[0]);
  _internal_metadata_.Swap(&other->_internal_metadata_);
  std::swap(_cached_size_, other->_cached_size_);
}

::google::protobuf::Metadata SubscribeImage::GetMetadata() const {
  protobuf_AssignDescriptorsOnce();
  ::google::protobuf::Metadata metadata;
  metadata.descriptor = SubscribeImage_descriptor_;
  metadata.reflection = SubscribeImage_reflection_;
  return metadata;
}

#if PROTOBUF_INLINE_NOT_IN_HEADERS
// SubscribeImage

// required string topic_name = 1;
bool SubscribeImage::has_topic_name() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
void SubscribeImage::set_has_topic_name() {
  _has_bits_[0] |= 0x00000001u;
}
void SubscribeImage::clear_has_topic_name() {
  _has_bits_[0] &= ~0x00000001u;
}
void SubscribeImage::clear_topic_name() {
  topic_name_.ClearToEmptyNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
  clear_has_topic_name();
}
 const ::std::string& SubscribeImage::topic_name() const {
  // @@protoc_insertion_point(field_get:mw.internal.robotics.gazebotransport.SubscribeImage.topic_name)
  return topic_name_.GetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
 void SubscribeImage::set_topic_name(const ::std::string& value) {
  set_has_topic_name();
  topic_name_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), value);
  // @@protoc_insertion_point(field_set:mw.internal.robotics.gazebotransport.SubscribeImage.topic_name)
}
 void SubscribeImage::set_topic_name(const char* value) {
  set_has_topic_name();
  topic_name_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::string(value));
  // @@protoc_insertion_point(field_set_char:mw.internal.robotics.gazebotransport.SubscribeImage.topic_name)
}
 void SubscribeImage::set_topic_name(const char* value, size_t size) {
  set_has_topic_name();
  topic_name_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(),
      ::std::string(reinterpret_cast<const char*>(value), size));
  // @@protoc_insertion_point(field_set_pointer:mw.internal.robotics.gazebotransport.SubscribeImage.topic_name)
}
 ::std::string* SubscribeImage::mutable_topic_name() {
  set_has_topic_name();
  // @@protoc_insertion_point(field_mutable:mw.internal.robotics.gazebotransport.SubscribeImage.topic_name)
  return topic_name_.MutableNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
 ::std::string* SubscribeImage::release_topic_name() {
  // @@protoc_insertion_point(field_release:mw.internal.robotics.gazebotransport.SubscribeImage.topic_name)
  clear_has_topic_name();
  return topic_name_.ReleaseNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
 void SubscribeImage::set_allocated_topic_name(::std::string* topic_name) {
  if (topic_name != NULL) {
    set_has_topic_name();
  } else {
    clear_has_topic_name();
  }
  topic_name_.SetAllocatedNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), topic_name);
  // @@protoc_insertion_point(field_set_allocated:mw.internal.robotics.gazebotransport.SubscribeImage.topic_name)
}

#endif  // PROTOBUF_INLINE_NOT_IN_HEADERS

// ===================================================================

#if !defined(_MSC_VER) || _MSC_VER >= 1900
const int SubscribeLaser::kTopicNameFieldNumber;
#endif  // !defined(_MSC_VER) || _MSC_VER >= 1900

SubscribeLaser::SubscribeLaser()
  : ::google::protobuf::Message(), _internal_metadata_(NULL) {
  SharedCtor();
  // @@protoc_insertion_point(constructor:mw.internal.robotics.gazebotransport.SubscribeLaser)
}

void SubscribeLaser::InitAsDefaultInstance() {
}

SubscribeLaser::SubscribeLaser(const SubscribeLaser& from)
  : ::google::protobuf::Message(),
    _internal_metadata_(NULL) {
  SharedCtor();
  MergeFrom(from);
  // @@protoc_insertion_point(copy_constructor:mw.internal.robotics.gazebotransport.SubscribeLaser)
}

void SubscribeLaser::SharedCtor() {
  ::google::protobuf::internal::GetEmptyString();
  _cached_size_ = 0;
  topic_name_.UnsafeSetDefault(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
  ::memset(_has_bits_, 0, sizeof(_has_bits_));
}

SubscribeLaser::~SubscribeLaser() {
  // @@protoc_insertion_point(destructor:mw.internal.robotics.gazebotransport.SubscribeLaser)
  SharedDtor();
}

void SubscribeLaser::SharedDtor() {
  topic_name_.DestroyNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
  if (this != default_instance_) {
  }
}

void SubscribeLaser::SetCachedSize(int size) const {
  GOOGLE_SAFE_CONCURRENT_WRITES_BEGIN();
  _cached_size_ = size;
  GOOGLE_SAFE_CONCURRENT_WRITES_END();
}
const ::google::protobuf::Descriptor* SubscribeLaser::descriptor() {
  protobuf_AssignDescriptorsOnce();
  return SubscribeLaser_descriptor_;
}

const SubscribeLaser& SubscribeLaser::default_instance() {
  if (default_instance_ == NULL) protobuf_AddDesc_mw_2einternal_2erobotics_2egazebotransport_2eCoSimMsgs_2eproto();
  return *default_instance_;
}

SubscribeLaser* SubscribeLaser::default_instance_ = NULL;

SubscribeLaser* SubscribeLaser::New(::google::protobuf::Arena* arena) const {
  SubscribeLaser* n = new SubscribeLaser;
  if (arena != NULL) {
    arena->Own(n);
  }
  return n;
}

void SubscribeLaser::Clear() {
// @@protoc_insertion_point(message_clear_start:mw.internal.robotics.gazebotransport.SubscribeLaser)
  if (has_topic_name()) {
    topic_name_.ClearToEmptyNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
  }
  ::memset(_has_bits_, 0, sizeof(_has_bits_));
  if (_internal_metadata_.have_unknown_fields()) {
    mutable_unknown_fields()->Clear();
  }
}

bool SubscribeLaser::MergePartialFromCodedStream(
    ::google::protobuf::io::CodedInputStream* input) {
#define DO_(EXPRESSION) if (!GOOGLE_PREDICT_TRUE(EXPRESSION)) goto failure
  ::google::protobuf::uint32 tag;
  // @@protoc_insertion_point(parse_start:mw.internal.robotics.gazebotransport.SubscribeLaser)
  for (;;) {
    ::std::pair< ::google::protobuf::uint32, bool> p = input->ReadTagWithCutoff(127);
    tag = p.first;
    if (!p.second) goto handle_unusual;
    switch (::google::protobuf::internal::WireFormatLite::GetTagFieldNumber(tag)) {
      // required string topic_name = 1;
      case 1: {
        if (tag == 10) {
          DO_(::google::protobuf::internal::WireFormatLite::ReadString(
                input, this->mutable_topic_name()));
          ::google::protobuf::internal::WireFormat::VerifyUTF8StringNamedField(
            this->topic_name().data(), this->topic_name().length(),
            ::google::protobuf::internal::WireFormat::PARSE,
            "mw.internal.robotics.gazebotransport.SubscribeLaser.topic_name");
        } else {
          goto handle_unusual;
        }
        if (input->ExpectAtEnd()) goto success;
        break;
      }

      default: {
      handle_unusual:
        if (tag == 0 ||
            ::google::protobuf::internal::WireFormatLite::GetTagWireType(tag) ==
            ::google::protobuf::internal::WireFormatLite::WIRETYPE_END_GROUP) {
          goto success;
        }
        DO_(::google::protobuf::internal::WireFormat::SkipField(
              input, tag, mutable_unknown_fields()));
        break;
      }
    }
  }
success:
  // @@protoc_insertion_point(parse_success:mw.internal.robotics.gazebotransport.SubscribeLaser)
  return true;
failure:
  // @@protoc_insertion_point(parse_failure:mw.internal.robotics.gazebotransport.SubscribeLaser)
  return false;
#undef DO_
}

void SubscribeLaser::SerializeWithCachedSizes(
    ::google::protobuf::io::CodedOutputStream* output) const {
  // @@protoc_insertion_point(serialize_start:mw.internal.robotics.gazebotransport.SubscribeLaser)
  // required string topic_name = 1;
  if (has_topic_name()) {
    ::google::protobuf::internal::WireFormat::VerifyUTF8StringNamedField(
      this->topic_name().data(), this->topic_name().length(),
      ::google::protobuf::internal::WireFormat::SERIALIZE,
      "mw.internal.robotics.gazebotransport.SubscribeLaser.topic_name");
    ::google::protobuf::internal::WireFormatLite::WriteStringMaybeAliased(
      1, this->topic_name(), output);
  }

  if (_internal_metadata_.have_unknown_fields()) {
    ::google::protobuf::internal::WireFormat::SerializeUnknownFields(
        unknown_fields(), output);
  }
  // @@protoc_insertion_point(serialize_end:mw.internal.robotics.gazebotransport.SubscribeLaser)
}

::google::protobuf::uint8* SubscribeLaser::InternalSerializeWithCachedSizesToArray(
    bool deterministic, ::google::protobuf::uint8* target) const {
  // @@protoc_insertion_point(serialize_to_array_start:mw.internal.robotics.gazebotransport.SubscribeLaser)
  // required string topic_name = 1;
  if (has_topic_name()) {
    ::google::protobuf::internal::WireFormat::VerifyUTF8StringNamedField(
      this->topic_name().data(), this->topic_name().length(),
      ::google::protobuf::internal::WireFormat::SERIALIZE,
      "mw.internal.robotics.gazebotransport.SubscribeLaser.topic_name");
    target =
      ::google::protobuf::internal::WireFormatLite::WriteStringToArray(
        1, this->topic_name(), target);
  }

  if (_internal_metadata_.have_unknown_fields()) {
    target = ::google::protobuf::internal::WireFormat::SerializeUnknownFieldsToArray(
        unknown_fields(), target);
  }
  // @@protoc_insertion_point(serialize_to_array_end:mw.internal.robotics.gazebotransport.SubscribeLaser)
  return target;
}

int SubscribeLaser::ByteSize() const {
// @@protoc_insertion_point(message_byte_size_start:mw.internal.robotics.gazebotransport.SubscribeLaser)
  int total_size = 0;

  // required string topic_name = 1;
  if (has_topic_name()) {
    total_size += 1 +
      ::google::protobuf::internal::WireFormatLite::StringSize(
        this->topic_name());
  }
  if (_internal_metadata_.have_unknown_fields()) {
    total_size +=
      ::google::protobuf::internal::WireFormat::ComputeUnknownFieldsSize(
        unknown_fields());
  }
  GOOGLE_SAFE_CONCURRENT_WRITES_BEGIN();
  _cached_size_ = total_size;
  GOOGLE_SAFE_CONCURRENT_WRITES_END();
  return total_size;
}

void SubscribeLaser::MergeFrom(const ::google::protobuf::Message& from) {
// @@protoc_insertion_point(generalized_merge_from_start:mw.internal.robotics.gazebotransport.SubscribeLaser)
  if (GOOGLE_PREDICT_FALSE(&from == this)) {
    ::google::protobuf::internal::MergeFromFail(__FILE__, __LINE__);
  }
  const SubscribeLaser* source = 
      ::google::protobuf::internal::DynamicCastToGenerated<const SubscribeLaser>(
          &from);
  if (source == NULL) {
  // @@protoc_insertion_point(generalized_merge_from_cast_fail:mw.internal.robotics.gazebotransport.SubscribeLaser)
    ::google::protobuf::internal::ReflectionOps::Merge(from, this);
  } else {
  // @@protoc_insertion_point(generalized_merge_from_cast_success:mw.internal.robotics.gazebotransport.SubscribeLaser)
    MergeFrom(*source);
  }
}

void SubscribeLaser::MergeFrom(const SubscribeLaser& from) {
// @@protoc_insertion_point(class_specific_merge_from_start:mw.internal.robotics.gazebotransport.SubscribeLaser)
  if (GOOGLE_PREDICT_FALSE(&from == this)) {
    ::google::protobuf::internal::MergeFromFail(__FILE__, __LINE__);
  }
  if (from._has_bits_[0 / 32] & (0xffu << (0 % 32))) {
    if (from.has_topic_name()) {
      set_has_topic_name();
      topic_name_.AssignWithDefault(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), from.topic_name_);
    }
  }
  if (from._internal_metadata_.have_unknown_fields()) {
    mutable_unknown_fields()->MergeFrom(from.unknown_fields());
  }
}

void SubscribeLaser::CopyFrom(const ::google::protobuf::Message& from) {
// @@protoc_insertion_point(generalized_copy_from_start:mw.internal.robotics.gazebotransport.SubscribeLaser)
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

void SubscribeLaser::CopyFrom(const SubscribeLaser& from) {
// @@protoc_insertion_point(class_specific_copy_from_start:mw.internal.robotics.gazebotransport.SubscribeLaser)
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

bool SubscribeLaser::IsInitialized() const {
  if ((_has_bits_[0] & 0x00000001) != 0x00000001) return false;

  return true;
}

void SubscribeLaser::Swap(SubscribeLaser* other) {
  if (other == this) return;
  InternalSwap(other);
}
void SubscribeLaser::InternalSwap(SubscribeLaser* other) {
  topic_name_.Swap(&other->topic_name_);
  std::swap(_has_bits_[0], other->_has_bits_[0]);
  _internal_metadata_.Swap(&other->_internal_metadata_);
  std::swap(_cached_size_, other->_cached_size_);
}

::google::protobuf::Metadata SubscribeLaser::GetMetadata() const {
  protobuf_AssignDescriptorsOnce();
  ::google::protobuf::Metadata metadata;
  metadata.descriptor = SubscribeLaser_descriptor_;
  metadata.reflection = SubscribeLaser_reflection_;
  return metadata;
}

#if PROTOBUF_INLINE_NOT_IN_HEADERS
// SubscribeLaser

// required string topic_name = 1;
bool SubscribeLaser::has_topic_name() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
void SubscribeLaser::set_has_topic_name() {
  _has_bits_[0] |= 0x00000001u;
}
void SubscribeLaser::clear_has_topic_name() {
  _has_bits_[0] &= ~0x00000001u;
}
void SubscribeLaser::clear_topic_name() {
  topic_name_.ClearToEmptyNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
  clear_has_topic_name();
}
 const ::std::string& SubscribeLaser::topic_name() const {
  // @@protoc_insertion_point(field_get:mw.internal.robotics.gazebotransport.SubscribeLaser.topic_name)
  return topic_name_.GetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
 void SubscribeLaser::set_topic_name(const ::std::string& value) {
  set_has_topic_name();
  topic_name_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), value);
  // @@protoc_insertion_point(field_set:mw.internal.robotics.gazebotransport.SubscribeLaser.topic_name)
}
 void SubscribeLaser::set_topic_name(const char* value) {
  set_has_topic_name();
  topic_name_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::string(value));
  // @@protoc_insertion_point(field_set_char:mw.internal.robotics.gazebotransport.SubscribeLaser.topic_name)
}
 void SubscribeLaser::set_topic_name(const char* value, size_t size) {
  set_has_topic_name();
  topic_name_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(),
      ::std::string(reinterpret_cast<const char*>(value), size));
  // @@protoc_insertion_point(field_set_pointer:mw.internal.robotics.gazebotransport.SubscribeLaser.topic_name)
}
 ::std::string* SubscribeLaser::mutable_topic_name() {
  set_has_topic_name();
  // @@protoc_insertion_point(field_mutable:mw.internal.robotics.gazebotransport.SubscribeLaser.topic_name)
  return topic_name_.MutableNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
 ::std::string* SubscribeLaser::release_topic_name() {
  // @@protoc_insertion_point(field_release:mw.internal.robotics.gazebotransport.SubscribeLaser.topic_name)
  clear_has_topic_name();
  return topic_name_.ReleaseNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
 void SubscribeLaser::set_allocated_topic_name(::std::string* topic_name) {
  if (topic_name != NULL) {
    set_has_topic_name();
  } else {
    clear_has_topic_name();
  }
  topic_name_.SetAllocatedNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), topic_name);
  // @@protoc_insertion_point(field_set_allocated:mw.internal.robotics.gazebotransport.SubscribeLaser.topic_name)
}

#endif  // PROTOBUF_INLINE_NOT_IN_HEADERS

// ===================================================================

#if !defined(_MSC_VER) || _MSC_VER >= 1900
const int SubscribeImu::kTopicNameFieldNumber;
#endif  // !defined(_MSC_VER) || _MSC_VER >= 1900

SubscribeImu::SubscribeImu()
  : ::google::protobuf::Message(), _internal_metadata_(NULL) {
  SharedCtor();
  // @@protoc_insertion_point(constructor:mw.internal.robotics.gazebotransport.SubscribeImu)
}

void SubscribeImu::InitAsDefaultInstance() {
}

SubscribeImu::SubscribeImu(const SubscribeImu& from)
  : ::google::protobuf::Message(),
    _internal_metadata_(NULL) {
  SharedCtor();
  MergeFrom(from);
  // @@protoc_insertion_point(copy_constructor:mw.internal.robotics.gazebotransport.SubscribeImu)
}

void SubscribeImu::SharedCtor() {
  ::google::protobuf::internal::GetEmptyString();
  _cached_size_ = 0;
  topic_name_.UnsafeSetDefault(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
  ::memset(_has_bits_, 0, sizeof(_has_bits_));
}

SubscribeImu::~SubscribeImu() {
  // @@protoc_insertion_point(destructor:mw.internal.robotics.gazebotransport.SubscribeImu)
  SharedDtor();
}

void SubscribeImu::SharedDtor() {
  topic_name_.DestroyNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
  if (this != default_instance_) {
  }
}

void SubscribeImu::SetCachedSize(int size) const {
  GOOGLE_SAFE_CONCURRENT_WRITES_BEGIN();
  _cached_size_ = size;
  GOOGLE_SAFE_CONCURRENT_WRITES_END();
}
const ::google::protobuf::Descriptor* SubscribeImu::descriptor() {
  protobuf_AssignDescriptorsOnce();
  return SubscribeImu_descriptor_;
}

const SubscribeImu& SubscribeImu::default_instance() {
  if (default_instance_ == NULL) protobuf_AddDesc_mw_2einternal_2erobotics_2egazebotransport_2eCoSimMsgs_2eproto();
  return *default_instance_;
}

SubscribeImu* SubscribeImu::default_instance_ = NULL;

SubscribeImu* SubscribeImu::New(::google::protobuf::Arena* arena) const {
  SubscribeImu* n = new SubscribeImu;
  if (arena != NULL) {
    arena->Own(n);
  }
  return n;
}

void SubscribeImu::Clear() {
// @@protoc_insertion_point(message_clear_start:mw.internal.robotics.gazebotransport.SubscribeImu)
  if (has_topic_name()) {
    topic_name_.ClearToEmptyNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
  }
  ::memset(_has_bits_, 0, sizeof(_has_bits_));
  if (_internal_metadata_.have_unknown_fields()) {
    mutable_unknown_fields()->Clear();
  }
}

bool SubscribeImu::MergePartialFromCodedStream(
    ::google::protobuf::io::CodedInputStream* input) {
#define DO_(EXPRESSION) if (!GOOGLE_PREDICT_TRUE(EXPRESSION)) goto failure
  ::google::protobuf::uint32 tag;
  // @@protoc_insertion_point(parse_start:mw.internal.robotics.gazebotransport.SubscribeImu)
  for (;;) {
    ::std::pair< ::google::protobuf::uint32, bool> p = input->ReadTagWithCutoff(127);
    tag = p.first;
    if (!p.second) goto handle_unusual;
    switch (::google::protobuf::internal::WireFormatLite::GetTagFieldNumber(tag)) {
      // required string topic_name = 1;
      case 1: {
        if (tag == 10) {
          DO_(::google::protobuf::internal::WireFormatLite::ReadString(
                input, this->mutable_topic_name()));
          ::google::protobuf::internal::WireFormat::VerifyUTF8StringNamedField(
            this->topic_name().data(), this->topic_name().length(),
            ::google::protobuf::internal::WireFormat::PARSE,
            "mw.internal.robotics.gazebotransport.SubscribeImu.topic_name");
        } else {
          goto handle_unusual;
        }
        if (input->ExpectAtEnd()) goto success;
        break;
      }

      default: {
      handle_unusual:
        if (tag == 0 ||
            ::google::protobuf::internal::WireFormatLite::GetTagWireType(tag) ==
            ::google::protobuf::internal::WireFormatLite::WIRETYPE_END_GROUP) {
          goto success;
        }
        DO_(::google::protobuf::internal::WireFormat::SkipField(
              input, tag, mutable_unknown_fields()));
        break;
      }
    }
  }
success:
  // @@protoc_insertion_point(parse_success:mw.internal.robotics.gazebotransport.SubscribeImu)
  return true;
failure:
  // @@protoc_insertion_point(parse_failure:mw.internal.robotics.gazebotransport.SubscribeImu)
  return false;
#undef DO_
}

void SubscribeImu::SerializeWithCachedSizes(
    ::google::protobuf::io::CodedOutputStream* output) const {
  // @@protoc_insertion_point(serialize_start:mw.internal.robotics.gazebotransport.SubscribeImu)
  // required string topic_name = 1;
  if (has_topic_name()) {
    ::google::protobuf::internal::WireFormat::VerifyUTF8StringNamedField(
      this->topic_name().data(), this->topic_name().length(),
      ::google::protobuf::internal::WireFormat::SERIALIZE,
      "mw.internal.robotics.gazebotransport.SubscribeImu.topic_name");
    ::google::protobuf::internal::WireFormatLite::WriteStringMaybeAliased(
      1, this->topic_name(), output);
  }

  if (_internal_metadata_.have_unknown_fields()) {
    ::google::protobuf::internal::WireFormat::SerializeUnknownFields(
        unknown_fields(), output);
  }
  // @@protoc_insertion_point(serialize_end:mw.internal.robotics.gazebotransport.SubscribeImu)
}

::google::protobuf::uint8* SubscribeImu::InternalSerializeWithCachedSizesToArray(
    bool deterministic, ::google::protobuf::uint8* target) const {
  // @@protoc_insertion_point(serialize_to_array_start:mw.internal.robotics.gazebotransport.SubscribeImu)
  // required string topic_name = 1;
  if (has_topic_name()) {
    ::google::protobuf::internal::WireFormat::VerifyUTF8StringNamedField(
      this->topic_name().data(), this->topic_name().length(),
      ::google::protobuf::internal::WireFormat::SERIALIZE,
      "mw.internal.robotics.gazebotransport.SubscribeImu.topic_name");
    target =
      ::google::protobuf::internal::WireFormatLite::WriteStringToArray(
        1, this->topic_name(), target);
  }

  if (_internal_metadata_.have_unknown_fields()) {
    target = ::google::protobuf::internal::WireFormat::SerializeUnknownFieldsToArray(
        unknown_fields(), target);
  }
  // @@protoc_insertion_point(serialize_to_array_end:mw.internal.robotics.gazebotransport.SubscribeImu)
  return target;
}

int SubscribeImu::ByteSize() const {
// @@protoc_insertion_point(message_byte_size_start:mw.internal.robotics.gazebotransport.SubscribeImu)
  int total_size = 0;

  // required string topic_name = 1;
  if (has_topic_name()) {
    total_size += 1 +
      ::google::protobuf::internal::WireFormatLite::StringSize(
        this->topic_name());
  }
  if (_internal_metadata_.have_unknown_fields()) {
    total_size +=
      ::google::protobuf::internal::WireFormat::ComputeUnknownFieldsSize(
        unknown_fields());
  }
  GOOGLE_SAFE_CONCURRENT_WRITES_BEGIN();
  _cached_size_ = total_size;
  GOOGLE_SAFE_CONCURRENT_WRITES_END();
  return total_size;
}

void SubscribeImu::MergeFrom(const ::google::protobuf::Message& from) {
// @@protoc_insertion_point(generalized_merge_from_start:mw.internal.robotics.gazebotransport.SubscribeImu)
  if (GOOGLE_PREDICT_FALSE(&from == this)) {
    ::google::protobuf::internal::MergeFromFail(__FILE__, __LINE__);
  }
  const SubscribeImu* source = 
      ::google::protobuf::internal::DynamicCastToGenerated<const SubscribeImu>(
          &from);
  if (source == NULL) {
  // @@protoc_insertion_point(generalized_merge_from_cast_fail:mw.internal.robotics.gazebotransport.SubscribeImu)
    ::google::protobuf::internal::ReflectionOps::Merge(from, this);
  } else {
  // @@protoc_insertion_point(generalized_merge_from_cast_success:mw.internal.robotics.gazebotransport.SubscribeImu)
    MergeFrom(*source);
  }
}

void SubscribeImu::MergeFrom(const SubscribeImu& from) {
// @@protoc_insertion_point(class_specific_merge_from_start:mw.internal.robotics.gazebotransport.SubscribeImu)
  if (GOOGLE_PREDICT_FALSE(&from == this)) {
    ::google::protobuf::internal::MergeFromFail(__FILE__, __LINE__);
  }
  if (from._has_bits_[0 / 32] & (0xffu << (0 % 32))) {
    if (from.has_topic_name()) {
      set_has_topic_name();
      topic_name_.AssignWithDefault(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), from.topic_name_);
    }
  }
  if (from._internal_metadata_.have_unknown_fields()) {
    mutable_unknown_fields()->MergeFrom(from.unknown_fields());
  }
}

void SubscribeImu::CopyFrom(const ::google::protobuf::Message& from) {
// @@protoc_insertion_point(generalized_copy_from_start:mw.internal.robotics.gazebotransport.SubscribeImu)
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

void SubscribeImu::CopyFrom(const SubscribeImu& from) {
// @@protoc_insertion_point(class_specific_copy_from_start:mw.internal.robotics.gazebotransport.SubscribeImu)
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

bool SubscribeImu::IsInitialized() const {
  if ((_has_bits_[0] & 0x00000001) != 0x00000001) return false;

  return true;
}

void SubscribeImu::Swap(SubscribeImu* other) {
  if (other == this) return;
  InternalSwap(other);
}
void SubscribeImu::InternalSwap(SubscribeImu* other) {
  topic_name_.Swap(&other->topic_name_);
  std::swap(_has_bits_[0], other->_has_bits_[0]);
  _internal_metadata_.Swap(&other->_internal_metadata_);
  std::swap(_cached_size_, other->_cached_size_);
}

::google::protobuf::Metadata SubscribeImu::GetMetadata() const {
  protobuf_AssignDescriptorsOnce();
  ::google::protobuf::Metadata metadata;
  metadata.descriptor = SubscribeImu_descriptor_;
  metadata.reflection = SubscribeImu_reflection_;
  return metadata;
}

#if PROTOBUF_INLINE_NOT_IN_HEADERS
// SubscribeImu

// required string topic_name = 1;
bool SubscribeImu::has_topic_name() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
void SubscribeImu::set_has_topic_name() {
  _has_bits_[0] |= 0x00000001u;
}
void SubscribeImu::clear_has_topic_name() {
  _has_bits_[0] &= ~0x00000001u;
}
void SubscribeImu::clear_topic_name() {
  topic_name_.ClearToEmptyNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
  clear_has_topic_name();
}
 const ::std::string& SubscribeImu::topic_name() const {
  // @@protoc_insertion_point(field_get:mw.internal.robotics.gazebotransport.SubscribeImu.topic_name)
  return topic_name_.GetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
 void SubscribeImu::set_topic_name(const ::std::string& value) {
  set_has_topic_name();
  topic_name_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), value);
  // @@protoc_insertion_point(field_set:mw.internal.robotics.gazebotransport.SubscribeImu.topic_name)
}
 void SubscribeImu::set_topic_name(const char* value) {
  set_has_topic_name();
  topic_name_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::string(value));
  // @@protoc_insertion_point(field_set_char:mw.internal.robotics.gazebotransport.SubscribeImu.topic_name)
}
 void SubscribeImu::set_topic_name(const char* value, size_t size) {
  set_has_topic_name();
  topic_name_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(),
      ::std::string(reinterpret_cast<const char*>(value), size));
  // @@protoc_insertion_point(field_set_pointer:mw.internal.robotics.gazebotransport.SubscribeImu.topic_name)
}
 ::std::string* SubscribeImu::mutable_topic_name() {
  set_has_topic_name();
  // @@protoc_insertion_point(field_mutable:mw.internal.robotics.gazebotransport.SubscribeImu.topic_name)
  return topic_name_.MutableNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
 ::std::string* SubscribeImu::release_topic_name() {
  // @@protoc_insertion_point(field_release:mw.internal.robotics.gazebotransport.SubscribeImu.topic_name)
  clear_has_topic_name();
  return topic_name_.ReleaseNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
 void SubscribeImu::set_allocated_topic_name(::std::string* topic_name) {
  if (topic_name != NULL) {
    set_has_topic_name();
  } else {
    clear_has_topic_name();
  }
  topic_name_.SetAllocatedNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), topic_name);
  // @@protoc_insertion_point(field_set_allocated:mw.internal.robotics.gazebotransport.SubscribeImu.topic_name)
}

#endif  // PROTOBUF_INLINE_NOT_IN_HEADERS

// ===================================================================

#if !defined(_MSC_VER) || _MSC_VER >= 1900
const int ApplyLinkWrench::kModelNameFieldNumber;
const int ApplyLinkWrench::kLinkNameFieldNumber;
const int ApplyLinkWrench::kForceTypeFieldNumber;
const int ApplyLinkWrench::kFxFieldNumber;
const int ApplyLinkWrench::kFyFieldNumber;
const int ApplyLinkWrench::kFzFieldNumber;
const int ApplyLinkWrench::kTorqueTypeFieldNumber;
const int ApplyLinkWrench::kTxFieldNumber;
const int ApplyLinkWrench::kTyFieldNumber;
const int ApplyLinkWrench::kTzFieldNumber;
const int ApplyLinkWrench::kDurationFieldNumber;
#endif  // !defined(_MSC_VER) || _MSC_VER >= 1900

ApplyLinkWrench::ApplyLinkWrench()
  : ::google::protobuf::Message(), _internal_metadata_(NULL) {
  SharedCtor();
  // @@protoc_insertion_point(constructor:mw.internal.robotics.gazebotransport.ApplyLinkWrench)
}

void ApplyLinkWrench::InitAsDefaultInstance() {
  duration_ = const_cast< ::mw::internal::robotics::gazebotransport::Time*>(&::mw::internal::robotics::gazebotransport::Time::default_instance());
}

ApplyLinkWrench::ApplyLinkWrench(const ApplyLinkWrench& from)
  : ::google::protobuf::Message(),
    _internal_metadata_(NULL) {
  SharedCtor();
  MergeFrom(from);
  // @@protoc_insertion_point(copy_constructor:mw.internal.robotics.gazebotransport.ApplyLinkWrench)
}

void ApplyLinkWrench::SharedCtor() {
  ::google::protobuf::internal::GetEmptyString();
  _cached_size_ = 0;
  model_name_.UnsafeSetDefault(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
  link_name_.UnsafeSetDefault(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
  force_type_.UnsafeSetDefault(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
  fx_ = 0;
  fy_ = 0;
  fz_ = 0;
  torque_type_.UnsafeSetDefault(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
  tx_ = 0;
  ty_ = 0;
  tz_ = 0;
  duration_ = NULL;
  ::memset(_has_bits_, 0, sizeof(_has_bits_));
}

ApplyLinkWrench::~ApplyLinkWrench() {
  // @@protoc_insertion_point(destructor:mw.internal.robotics.gazebotransport.ApplyLinkWrench)
  SharedDtor();
}

void ApplyLinkWrench::SharedDtor() {
  model_name_.DestroyNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
  link_name_.DestroyNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
  force_type_.DestroyNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
  torque_type_.DestroyNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
  if (this != default_instance_) {
    delete duration_;
  }
}

void ApplyLinkWrench::SetCachedSize(int size) const {
  GOOGLE_SAFE_CONCURRENT_WRITES_BEGIN();
  _cached_size_ = size;
  GOOGLE_SAFE_CONCURRENT_WRITES_END();
}
const ::google::protobuf::Descriptor* ApplyLinkWrench::descriptor() {
  protobuf_AssignDescriptorsOnce();
  return ApplyLinkWrench_descriptor_;
}

const ApplyLinkWrench& ApplyLinkWrench::default_instance() {
  if (default_instance_ == NULL) protobuf_AddDesc_mw_2einternal_2erobotics_2egazebotransport_2eCoSimMsgs_2eproto();
  return *default_instance_;
}

ApplyLinkWrench* ApplyLinkWrench::default_instance_ = NULL;

ApplyLinkWrench* ApplyLinkWrench::New(::google::protobuf::Arena* arena) const {
  ApplyLinkWrench* n = new ApplyLinkWrench;
  if (arena != NULL) {
    arena->Own(n);
  }
  return n;
}

void ApplyLinkWrench::Clear() {
// @@protoc_insertion_point(message_clear_start:mw.internal.robotics.gazebotransport.ApplyLinkWrench)
#if defined(__clang__)
#define ZR_HELPER_(f) \
  _Pragma("clang diagnostic push") \
  _Pragma("clang diagnostic ignored \"-Winvalid-offsetof\"") \
  __builtin_offsetof(ApplyLinkWrench, f) \
  _Pragma("clang diagnostic pop")
#else
#define ZR_HELPER_(f) reinterpret_cast<char*>(\
  &reinterpret_cast<ApplyLinkWrench*>(16)->f)
#endif

#define ZR_(first, last) do {\
  ::memset(&first, 0,\
           ZR_HELPER_(last) - ZR_HELPER_(first) + sizeof(last));\
} while (0)

  if (_has_bits_[0 / 32] & 255u) {
    ZR_(fx_, fz_);
    if (has_model_name()) {
      model_name_.ClearToEmptyNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
    }
    if (has_link_name()) {
      link_name_.ClearToEmptyNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
    }
    if (has_force_type()) {
      force_type_.ClearToEmptyNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
    }
    if (has_torque_type()) {
      torque_type_.ClearToEmptyNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
    }
    tx_ = 0;
  }
  if (_has_bits_[8 / 32] & 1792u) {
    ZR_(ty_, tz_);
    if (has_duration()) {
      if (duration_ != NULL) duration_->::mw::internal::robotics::gazebotransport::Time::Clear();
    }
  }

#undef ZR_HELPER_
#undef ZR_

  ::memset(_has_bits_, 0, sizeof(_has_bits_));
  if (_internal_metadata_.have_unknown_fields()) {
    mutable_unknown_fields()->Clear();
  }
}

bool ApplyLinkWrench::MergePartialFromCodedStream(
    ::google::protobuf::io::CodedInputStream* input) {
#define DO_(EXPRESSION) if (!GOOGLE_PREDICT_TRUE(EXPRESSION)) goto failure
  ::google::protobuf::uint32 tag;
  // @@protoc_insertion_point(parse_start:mw.internal.robotics.gazebotransport.ApplyLinkWrench)
  for (;;) {
    ::std::pair< ::google::protobuf::uint32, bool> p = input->ReadTagWithCutoff(127);
    tag = p.first;
    if (!p.second) goto handle_unusual;
    switch (::google::protobuf::internal::WireFormatLite::GetTagFieldNumber(tag)) {
      // required string model_name = 1;
      case 1: {
        if (tag == 10) {
          DO_(::google::protobuf::internal::WireFormatLite::ReadString(
                input, this->mutable_model_name()));
          ::google::protobuf::internal::WireFormat::VerifyUTF8StringNamedField(
            this->model_name().data(), this->model_name().length(),
            ::google::protobuf::internal::WireFormat::PARSE,
            "mw.internal.robotics.gazebotransport.ApplyLinkWrench.model_name");
        } else {
          goto handle_unusual;
        }
        if (input->ExpectTag(18)) goto parse_link_name;
        break;
      }

      // required string link_name = 2;
      case 2: {
        if (tag == 18) {
         parse_link_name:
          DO_(::google::protobuf::internal::WireFormatLite::ReadString(
                input, this->mutable_link_name()));
          ::google::protobuf::internal::WireFormat::VerifyUTF8StringNamedField(
            this->link_name().data(), this->link_name().length(),
            ::google::protobuf::internal::WireFormat::PARSE,
            "mw.internal.robotics.gazebotransport.ApplyLinkWrench.link_name");
        } else {
          goto handle_unusual;
        }
        if (input->ExpectTag(26)) goto parse_force_type;
        break;
      }

      // required string force_type = 3;
      case 3: {
        if (tag == 26) {
         parse_force_type:
          DO_(::google::protobuf::internal::WireFormatLite::ReadString(
                input, this->mutable_force_type()));
          ::google::protobuf::internal::WireFormat::VerifyUTF8StringNamedField(
            this->force_type().data(), this->force_type().length(),
            ::google::protobuf::internal::WireFormat::PARSE,
            "mw.internal.robotics.gazebotransport.ApplyLinkWrench.force_type");
        } else {
          goto handle_unusual;
        }
        if (input->ExpectTag(33)) goto parse_fx;
        break;
      }

      // required double fx = 4;
      case 4: {
        if (tag == 33) {
         parse_fx:
          DO_((::google::protobuf::internal::WireFormatLite::ReadPrimitive<
                   double, ::google::protobuf::internal::WireFormatLite::TYPE_DOUBLE>(
                 input, &fx_)));
          set_has_fx();
        } else {
          goto handle_unusual;
        }
        if (input->ExpectTag(41)) goto parse_fy;
        break;
      }

      // required double fy = 5;
      case 5: {
        if (tag == 41) {
         parse_fy:
          DO_((::google::protobuf::internal::WireFormatLite::ReadPrimitive<
                   double, ::google::protobuf::internal::WireFormatLite::TYPE_DOUBLE>(
                 input, &fy_)));
          set_has_fy();
        } else {
          goto handle_unusual;
        }
        if (input->ExpectTag(49)) goto parse_fz;
        break;
      }

      // required double fz = 6;
      case 6: {
        if (tag == 49) {
         parse_fz:
          DO_((::google::protobuf::internal::WireFormatLite::ReadPrimitive<
                   double, ::google::protobuf::internal::WireFormatLite::TYPE_DOUBLE>(
                 input, &fz_)));
          set_has_fz();
        } else {
          goto handle_unusual;
        }
        if (input->ExpectTag(58)) goto parse_torque_type;
        break;
      }

      // required string torque_type = 7;
      case 7: {
        if (tag == 58) {
         parse_torque_type:
          DO_(::google::protobuf::internal::WireFormatLite::ReadString(
                input, this->mutable_torque_type()));
          ::google::protobuf::internal::WireFormat::VerifyUTF8StringNamedField(
            this->torque_type().data(), this->torque_type().length(),
            ::google::protobuf::internal::WireFormat::PARSE,
            "mw.internal.robotics.gazebotransport.ApplyLinkWrench.torque_type");
        } else {
          goto handle_unusual;
        }
        if (input->ExpectTag(65)) goto parse_tx;
        break;
      }

      // required double tx = 8;
      case 8: {
        if (tag == 65) {
         parse_tx:
          DO_((::google::protobuf::internal::WireFormatLite::ReadPrimitive<
                   double, ::google::protobuf::internal::WireFormatLite::TYPE_DOUBLE>(
                 input, &tx_)));
          set_has_tx();
        } else {
          goto handle_unusual;
        }
        if (input->ExpectTag(73)) goto parse_ty;
        break;
      }

      // required double ty = 9;
      case 9: {
        if (tag == 73) {
         parse_ty:
          DO_((::google::protobuf::internal::WireFormatLite::ReadPrimitive<
                   double, ::google::protobuf::internal::WireFormatLite::TYPE_DOUBLE>(
                 input, &ty_)));
          set_has_ty();
        } else {
          goto handle_unusual;
        }
        if (input->ExpectTag(81)) goto parse_tz;
        break;
      }

      // required double tz = 10;
      case 10: {
        if (tag == 81) {
         parse_tz:
          DO_((::google::protobuf::internal::WireFormatLite::ReadPrimitive<
                   double, ::google::protobuf::internal::WireFormatLite::TYPE_DOUBLE>(
                 input, &tz_)));
          set_has_tz();
        } else {
          goto handle_unusual;
        }
        if (input->ExpectTag(90)) goto parse_duration;
        break;
      }

      // required .mw.internal.robotics.gazebotransport.Time duration = 11;
      case 11: {
        if (tag == 90) {
         parse_duration:
          DO_(::google::protobuf::internal::WireFormatLite::ReadMessageNoVirtual(
               input, mutable_duration()));
        } else {
          goto handle_unusual;
        }
        if (input->ExpectAtEnd()) goto success;
        break;
      }

      default: {
      handle_unusual:
        if (tag == 0 ||
            ::google::protobuf::internal::WireFormatLite::GetTagWireType(tag) ==
            ::google::protobuf::internal::WireFormatLite::WIRETYPE_END_GROUP) {
          goto success;
        }
        DO_(::google::protobuf::internal::WireFormat::SkipField(
              input, tag, mutable_unknown_fields()));
        break;
      }
    }
  }
success:
  // @@protoc_insertion_point(parse_success:mw.internal.robotics.gazebotransport.ApplyLinkWrench)
  return true;
failure:
  // @@protoc_insertion_point(parse_failure:mw.internal.robotics.gazebotransport.ApplyLinkWrench)
  return false;
#undef DO_
}

void ApplyLinkWrench::SerializeWithCachedSizes(
    ::google::protobuf::io::CodedOutputStream* output) const {
  // @@protoc_insertion_point(serialize_start:mw.internal.robotics.gazebotransport.ApplyLinkWrench)
  // required string model_name = 1;
  if (has_model_name()) {
    ::google::protobuf::internal::WireFormat::VerifyUTF8StringNamedField(
      this->model_name().data(), this->model_name().length(),
      ::google::protobuf::internal::WireFormat::SERIALIZE,
      "mw.internal.robotics.gazebotransport.ApplyLinkWrench.model_name");
    ::google::protobuf::internal::WireFormatLite::WriteStringMaybeAliased(
      1, this->model_name(), output);
  }

  // required string link_name = 2;
  if (has_link_name()) {
    ::google::protobuf::internal::WireFormat::VerifyUTF8StringNamedField(
      this->link_name().data(), this->link_name().length(),
      ::google::protobuf::internal::WireFormat::SERIALIZE,
      "mw.internal.robotics.gazebotransport.ApplyLinkWrench.link_name");
    ::google::protobuf::internal::WireFormatLite::WriteStringMaybeAliased(
      2, this->link_name(), output);
  }

  // required string force_type = 3;
  if (has_force_type()) {
    ::google::protobuf::internal::WireFormat::VerifyUTF8StringNamedField(
      this->force_type().data(), this->force_type().length(),
      ::google::protobuf::internal::WireFormat::SERIALIZE,
      "mw.internal.robotics.gazebotransport.ApplyLinkWrench.force_type");
    ::google::protobuf::internal::WireFormatLite::WriteStringMaybeAliased(
      3, this->force_type(), output);
  }

  // required double fx = 4;
  if (has_fx()) {
    ::google::protobuf::internal::WireFormatLite::WriteDouble(4, this->fx(), output);
  }

  // required double fy = 5;
  if (has_fy()) {
    ::google::protobuf::internal::WireFormatLite::WriteDouble(5, this->fy(), output);
  }

  // required double fz = 6;
  if (has_fz()) {
    ::google::protobuf::internal::WireFormatLite::WriteDouble(6, this->fz(), output);
  }

  // required string torque_type = 7;
  if (has_torque_type()) {
    ::google::protobuf::internal::WireFormat::VerifyUTF8StringNamedField(
      this->torque_type().data(), this->torque_type().length(),
      ::google::protobuf::internal::WireFormat::SERIALIZE,
      "mw.internal.robotics.gazebotransport.ApplyLinkWrench.torque_type");
    ::google::protobuf::internal::WireFormatLite::WriteStringMaybeAliased(
      7, this->torque_type(), output);
  }

  // required double tx = 8;
  if (has_tx()) {
    ::google::protobuf::internal::WireFormatLite::WriteDouble(8, this->tx(), output);
  }

  // required double ty = 9;
  if (has_ty()) {
    ::google::protobuf::internal::WireFormatLite::WriteDouble(9, this->ty(), output);
  }

  // required double tz = 10;
  if (has_tz()) {
    ::google::protobuf::internal::WireFormatLite::WriteDouble(10, this->tz(), output);
  }

  // required .mw.internal.robotics.gazebotransport.Time duration = 11;
  if (has_duration()) {
    ::google::protobuf::internal::WireFormatLite::WriteMessageMaybeToArray(
      11, *this->duration_, output);
  }

  if (_internal_metadata_.have_unknown_fields()) {
    ::google::protobuf::internal::WireFormat::SerializeUnknownFields(
        unknown_fields(), output);
  }
  // @@protoc_insertion_point(serialize_end:mw.internal.robotics.gazebotransport.ApplyLinkWrench)
}

::google::protobuf::uint8* ApplyLinkWrench::InternalSerializeWithCachedSizesToArray(
    bool deterministic, ::google::protobuf::uint8* target) const {
  // @@protoc_insertion_point(serialize_to_array_start:mw.internal.robotics.gazebotransport.ApplyLinkWrench)
  // required string model_name = 1;
  if (has_model_name()) {
    ::google::protobuf::internal::WireFormat::VerifyUTF8StringNamedField(
      this->model_name().data(), this->model_name().length(),
      ::google::protobuf::internal::WireFormat::SERIALIZE,
      "mw.internal.robotics.gazebotransport.ApplyLinkWrench.model_name");
    target =
      ::google::protobuf::internal::WireFormatLite::WriteStringToArray(
        1, this->model_name(), target);
  }

  // required string link_name = 2;
  if (has_link_name()) {
    ::google::protobuf::internal::WireFormat::VerifyUTF8StringNamedField(
      this->link_name().data(), this->link_name().length(),
      ::google::protobuf::internal::WireFormat::SERIALIZE,
      "mw.internal.robotics.gazebotransport.ApplyLinkWrench.link_name");
    target =
      ::google::protobuf::internal::WireFormatLite::WriteStringToArray(
        2, this->link_name(), target);
  }

  // required string force_type = 3;
  if (has_force_type()) {
    ::google::protobuf::internal::WireFormat::VerifyUTF8StringNamedField(
      this->force_type().data(), this->force_type().length(),
      ::google::protobuf::internal::WireFormat::SERIALIZE,
      "mw.internal.robotics.gazebotransport.ApplyLinkWrench.force_type");
    target =
      ::google::protobuf::internal::WireFormatLite::WriteStringToArray(
        3, this->force_type(), target);
  }

  // required double fx = 4;
  if (has_fx()) {
    target = ::google::protobuf::internal::WireFormatLite::WriteDoubleToArray(4, this->fx(), target);
  }

  // required double fy = 5;
  if (has_fy()) {
    target = ::google::protobuf::internal::WireFormatLite::WriteDoubleToArray(5, this->fy(), target);
  }

  // required double fz = 6;
  if (has_fz()) {
    target = ::google::protobuf::internal::WireFormatLite::WriteDoubleToArray(6, this->fz(), target);
  }

  // required string torque_type = 7;
  if (has_torque_type()) {
    ::google::protobuf::internal::WireFormat::VerifyUTF8StringNamedField(
      this->torque_type().data(), this->torque_type().length(),
      ::google::protobuf::internal::WireFormat::SERIALIZE,
      "mw.internal.robotics.gazebotransport.ApplyLinkWrench.torque_type");
    target =
      ::google::protobuf::internal::WireFormatLite::WriteStringToArray(
        7, this->torque_type(), target);
  }

  // required double tx = 8;
  if (has_tx()) {
    target = ::google::protobuf::internal::WireFormatLite::WriteDoubleToArray(8, this->tx(), target);
  }

  // required double ty = 9;
  if (has_ty()) {
    target = ::google::protobuf::internal::WireFormatLite::WriteDoubleToArray(9, this->ty(), target);
  }

  // required double tz = 10;
  if (has_tz()) {
    target = ::google::protobuf::internal::WireFormatLite::WriteDoubleToArray(10, this->tz(), target);
  }

  // required .mw.internal.robotics.gazebotransport.Time duration = 11;
  if (has_duration()) {
    target = ::google::protobuf::internal::WireFormatLite::
      InternalWriteMessageNoVirtualToArray(
        11, *this->duration_, false, target);
  }

  if (_internal_metadata_.have_unknown_fields()) {
    target = ::google::protobuf::internal::WireFormat::SerializeUnknownFieldsToArray(
        unknown_fields(), target);
  }
  // @@protoc_insertion_point(serialize_to_array_end:mw.internal.robotics.gazebotransport.ApplyLinkWrench)
  return target;
}

int ApplyLinkWrench::RequiredFieldsByteSizeFallback() const {
// @@protoc_insertion_point(required_fields_byte_size_fallback_start:mw.internal.robotics.gazebotransport.ApplyLinkWrench)
  int total_size = 0;

  if (has_model_name()) {
    // required string model_name = 1;
    total_size += 1 +
      ::google::protobuf::internal::WireFormatLite::StringSize(
        this->model_name());
  }

  if (has_link_name()) {
    // required string link_name = 2;
    total_size += 1 +
      ::google::protobuf::internal::WireFormatLite::StringSize(
        this->link_name());
  }

  if (has_force_type()) {
    // required string force_type = 3;
    total_size += 1 +
      ::google::protobuf::internal::WireFormatLite::StringSize(
        this->force_type());
  }

  if (has_fx()) {
    // required double fx = 4;
    total_size += 1 + 8;
  }

  if (has_fy()) {
    // required double fy = 5;
    total_size += 1 + 8;
  }

  if (has_fz()) {
    // required double fz = 6;
    total_size += 1 + 8;
  }

  if (has_torque_type()) {
    // required string torque_type = 7;
    total_size += 1 +
      ::google::protobuf::internal::WireFormatLite::StringSize(
        this->torque_type());
  }

  if (has_tx()) {
    // required double tx = 8;
    total_size += 1 + 8;
  }

  if (has_ty()) {
    // required double ty = 9;
    total_size += 1 + 8;
  }

  if (has_tz()) {
    // required double tz = 10;
    total_size += 1 + 8;
  }

  if (has_duration()) {
    // required .mw.internal.robotics.gazebotransport.Time duration = 11;
    total_size += 1 +
      ::google::protobuf::internal::WireFormatLite::MessageSizeNoVirtual(
        *this->duration_);
  }

  return total_size;
}
int ApplyLinkWrench::ByteSize() const {
// @@protoc_insertion_point(message_byte_size_start:mw.internal.robotics.gazebotransport.ApplyLinkWrench)
  int total_size = 0;

  if (((_has_bits_[0] & 0x000007ff) ^ 0x000007ff) == 0) {  // All required fields are present.
    // required string model_name = 1;
    total_size += 1 +
      ::google::protobuf::internal::WireFormatLite::StringSize(
        this->model_name());

    // required string link_name = 2;
    total_size += 1 +
      ::google::protobuf::internal::WireFormatLite::StringSize(
        this->link_name());

    // required string force_type = 3;
    total_size += 1 +
      ::google::protobuf::internal::WireFormatLite::StringSize(
        this->force_type());

    // required double fx = 4;
    total_size += 1 + 8;

    // required double fy = 5;
    total_size += 1 + 8;

    // required double fz = 6;
    total_size += 1 + 8;

    // required string torque_type = 7;
    total_size += 1 +
      ::google::protobuf::internal::WireFormatLite::StringSize(
        this->torque_type());

    // required double tx = 8;
    total_size += 1 + 8;

    // required double ty = 9;
    total_size += 1 + 8;

    // required double tz = 10;
    total_size += 1 + 8;

    // required .mw.internal.robotics.gazebotransport.Time duration = 11;
    total_size += 1 +
      ::google::protobuf::internal::WireFormatLite::MessageSizeNoVirtual(
        *this->duration_);

  } else {
    total_size += RequiredFieldsByteSizeFallback();
  }
  if (_internal_metadata_.have_unknown_fields()) {
    total_size +=
      ::google::protobuf::internal::WireFormat::ComputeUnknownFieldsSize(
        unknown_fields());
  }
  GOOGLE_SAFE_CONCURRENT_WRITES_BEGIN();
  _cached_size_ = total_size;
  GOOGLE_SAFE_CONCURRENT_WRITES_END();
  return total_size;
}

void ApplyLinkWrench::MergeFrom(const ::google::protobuf::Message& from) {
// @@protoc_insertion_point(generalized_merge_from_start:mw.internal.robotics.gazebotransport.ApplyLinkWrench)
  if (GOOGLE_PREDICT_FALSE(&from == this)) {
    ::google::protobuf::internal::MergeFromFail(__FILE__, __LINE__);
  }
  const ApplyLinkWrench* source = 
      ::google::protobuf::internal::DynamicCastToGenerated<const ApplyLinkWrench>(
          &from);
  if (source == NULL) {
  // @@protoc_insertion_point(generalized_merge_from_cast_fail:mw.internal.robotics.gazebotransport.ApplyLinkWrench)
    ::google::protobuf::internal::ReflectionOps::Merge(from, this);
  } else {
  // @@protoc_insertion_point(generalized_merge_from_cast_success:mw.internal.robotics.gazebotransport.ApplyLinkWrench)
    MergeFrom(*source);
  }
}

void ApplyLinkWrench::MergeFrom(const ApplyLinkWrench& from) {
// @@protoc_insertion_point(class_specific_merge_from_start:mw.internal.robotics.gazebotransport.ApplyLinkWrench)
  if (GOOGLE_PREDICT_FALSE(&from == this)) {
    ::google::protobuf::internal::MergeFromFail(__FILE__, __LINE__);
  }
  if (from._has_bits_[0 / 32] & (0xffu << (0 % 32))) {
    if (from.has_model_name()) {
      set_has_model_name();
      model_name_.AssignWithDefault(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), from.model_name_);
    }
    if (from.has_link_name()) {
      set_has_link_name();
      link_name_.AssignWithDefault(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), from.link_name_);
    }
    if (from.has_force_type()) {
      set_has_force_type();
      force_type_.AssignWithDefault(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), from.force_type_);
    }
    if (from.has_fx()) {
      set_fx(from.fx());
    }
    if (from.has_fy()) {
      set_fy(from.fy());
    }
    if (from.has_fz()) {
      set_fz(from.fz());
    }
    if (from.has_torque_type()) {
      set_has_torque_type();
      torque_type_.AssignWithDefault(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), from.torque_type_);
    }
    if (from.has_tx()) {
      set_tx(from.tx());
    }
  }
  if (from._has_bits_[8 / 32] & (0xffu << (8 % 32))) {
    if (from.has_ty()) {
      set_ty(from.ty());
    }
    if (from.has_tz()) {
      set_tz(from.tz());
    }
    if (from.has_duration()) {
      mutable_duration()->::mw::internal::robotics::gazebotransport::Time::MergeFrom(from.duration());
    }
  }
  if (from._internal_metadata_.have_unknown_fields()) {
    mutable_unknown_fields()->MergeFrom(from.unknown_fields());
  }
}

void ApplyLinkWrench::CopyFrom(const ::google::protobuf::Message& from) {
// @@protoc_insertion_point(generalized_copy_from_start:mw.internal.robotics.gazebotransport.ApplyLinkWrench)
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

void ApplyLinkWrench::CopyFrom(const ApplyLinkWrench& from) {
// @@protoc_insertion_point(class_specific_copy_from_start:mw.internal.robotics.gazebotransport.ApplyLinkWrench)
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

bool ApplyLinkWrench::IsInitialized() const {
  if ((_has_bits_[0] & 0x000007ff) != 0x000007ff) return false;

  if (has_duration()) {
    if (!this->duration_->IsInitialized()) return false;
  }
  return true;
}

void ApplyLinkWrench::Swap(ApplyLinkWrench* other) {
  if (other == this) return;
  InternalSwap(other);
}
void ApplyLinkWrench::InternalSwap(ApplyLinkWrench* other) {
  model_name_.Swap(&other->model_name_);
  link_name_.Swap(&other->link_name_);
  force_type_.Swap(&other->force_type_);
  std::swap(fx_, other->fx_);
  std::swap(fy_, other->fy_);
  std::swap(fz_, other->fz_);
  torque_type_.Swap(&other->torque_type_);
  std::swap(tx_, other->tx_);
  std::swap(ty_, other->ty_);
  std::swap(tz_, other->tz_);
  std::swap(duration_, other->duration_);
  std::swap(_has_bits_[0], other->_has_bits_[0]);
  _internal_metadata_.Swap(&other->_internal_metadata_);
  std::swap(_cached_size_, other->_cached_size_);
}

::google::protobuf::Metadata ApplyLinkWrench::GetMetadata() const {
  protobuf_AssignDescriptorsOnce();
  ::google::protobuf::Metadata metadata;
  metadata.descriptor = ApplyLinkWrench_descriptor_;
  metadata.reflection = ApplyLinkWrench_reflection_;
  return metadata;
}

#if PROTOBUF_INLINE_NOT_IN_HEADERS
// ApplyLinkWrench

// required string model_name = 1;
bool ApplyLinkWrench::has_model_name() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
void ApplyLinkWrench::set_has_model_name() {
  _has_bits_[0] |= 0x00000001u;
}
void ApplyLinkWrench::clear_has_model_name() {
  _has_bits_[0] &= ~0x00000001u;
}
void ApplyLinkWrench::clear_model_name() {
  model_name_.ClearToEmptyNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
  clear_has_model_name();
}
 const ::std::string& ApplyLinkWrench::model_name() const {
  // @@protoc_insertion_point(field_get:mw.internal.robotics.gazebotransport.ApplyLinkWrench.model_name)
  return model_name_.GetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
 void ApplyLinkWrench::set_model_name(const ::std::string& value) {
  set_has_model_name();
  model_name_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), value);
  // @@protoc_insertion_point(field_set:mw.internal.robotics.gazebotransport.ApplyLinkWrench.model_name)
}
 void ApplyLinkWrench::set_model_name(const char* value) {
  set_has_model_name();
  model_name_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::string(value));
  // @@protoc_insertion_point(field_set_char:mw.internal.robotics.gazebotransport.ApplyLinkWrench.model_name)
}
 void ApplyLinkWrench::set_model_name(const char* value, size_t size) {
  set_has_model_name();
  model_name_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(),
      ::std::string(reinterpret_cast<const char*>(value), size));
  // @@protoc_insertion_point(field_set_pointer:mw.internal.robotics.gazebotransport.ApplyLinkWrench.model_name)
}
 ::std::string* ApplyLinkWrench::mutable_model_name() {
  set_has_model_name();
  // @@protoc_insertion_point(field_mutable:mw.internal.robotics.gazebotransport.ApplyLinkWrench.model_name)
  return model_name_.MutableNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
 ::std::string* ApplyLinkWrench::release_model_name() {
  // @@protoc_insertion_point(field_release:mw.internal.robotics.gazebotransport.ApplyLinkWrench.model_name)
  clear_has_model_name();
  return model_name_.ReleaseNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
 void ApplyLinkWrench::set_allocated_model_name(::std::string* model_name) {
  if (model_name != NULL) {
    set_has_model_name();
  } else {
    clear_has_model_name();
  }
  model_name_.SetAllocatedNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), model_name);
  // @@protoc_insertion_point(field_set_allocated:mw.internal.robotics.gazebotransport.ApplyLinkWrench.model_name)
}

// required string link_name = 2;
bool ApplyLinkWrench::has_link_name() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
void ApplyLinkWrench::set_has_link_name() {
  _has_bits_[0] |= 0x00000002u;
}
void ApplyLinkWrench::clear_has_link_name() {
  _has_bits_[0] &= ~0x00000002u;
}
void ApplyLinkWrench::clear_link_name() {
  link_name_.ClearToEmptyNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
  clear_has_link_name();
}
 const ::std::string& ApplyLinkWrench::link_name() const {
  // @@protoc_insertion_point(field_get:mw.internal.robotics.gazebotransport.ApplyLinkWrench.link_name)
  return link_name_.GetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
 void ApplyLinkWrench::set_link_name(const ::std::string& value) {
  set_has_link_name();
  link_name_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), value);
  // @@protoc_insertion_point(field_set:mw.internal.robotics.gazebotransport.ApplyLinkWrench.link_name)
}
 void ApplyLinkWrench::set_link_name(const char* value) {
  set_has_link_name();
  link_name_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::string(value));
  // @@protoc_insertion_point(field_set_char:mw.internal.robotics.gazebotransport.ApplyLinkWrench.link_name)
}
 void ApplyLinkWrench::set_link_name(const char* value, size_t size) {
  set_has_link_name();
  link_name_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(),
      ::std::string(reinterpret_cast<const char*>(value), size));
  // @@protoc_insertion_point(field_set_pointer:mw.internal.robotics.gazebotransport.ApplyLinkWrench.link_name)
}
 ::std::string* ApplyLinkWrench::mutable_link_name() {
  set_has_link_name();
  // @@protoc_insertion_point(field_mutable:mw.internal.robotics.gazebotransport.ApplyLinkWrench.link_name)
  return link_name_.MutableNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
 ::std::string* ApplyLinkWrench::release_link_name() {
  // @@protoc_insertion_point(field_release:mw.internal.robotics.gazebotransport.ApplyLinkWrench.link_name)
  clear_has_link_name();
  return link_name_.ReleaseNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
 void ApplyLinkWrench::set_allocated_link_name(::std::string* link_name) {
  if (link_name != NULL) {
    set_has_link_name();
  } else {
    clear_has_link_name();
  }
  link_name_.SetAllocatedNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), link_name);
  // @@protoc_insertion_point(field_set_allocated:mw.internal.robotics.gazebotransport.ApplyLinkWrench.link_name)
}

// required string force_type = 3;
bool ApplyLinkWrench::has_force_type() const {
  return (_has_bits_[0] & 0x00000004u) != 0;
}
void ApplyLinkWrench::set_has_force_type() {
  _has_bits_[0] |= 0x00000004u;
}
void ApplyLinkWrench::clear_has_force_type() {
  _has_bits_[0] &= ~0x00000004u;
}
void ApplyLinkWrench::clear_force_type() {
  force_type_.ClearToEmptyNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
  clear_has_force_type();
}
 const ::std::string& ApplyLinkWrench::force_type() const {
  // @@protoc_insertion_point(field_get:mw.internal.robotics.gazebotransport.ApplyLinkWrench.force_type)
  return force_type_.GetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
 void ApplyLinkWrench::set_force_type(const ::std::string& value) {
  set_has_force_type();
  force_type_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), value);
  // @@protoc_insertion_point(field_set:mw.internal.robotics.gazebotransport.ApplyLinkWrench.force_type)
}
 void ApplyLinkWrench::set_force_type(const char* value) {
  set_has_force_type();
  force_type_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::string(value));
  // @@protoc_insertion_point(field_set_char:mw.internal.robotics.gazebotransport.ApplyLinkWrench.force_type)
}
 void ApplyLinkWrench::set_force_type(const char* value, size_t size) {
  set_has_force_type();
  force_type_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(),
      ::std::string(reinterpret_cast<const char*>(value), size));
  // @@protoc_insertion_point(field_set_pointer:mw.internal.robotics.gazebotransport.ApplyLinkWrench.force_type)
}
 ::std::string* ApplyLinkWrench::mutable_force_type() {
  set_has_force_type();
  // @@protoc_insertion_point(field_mutable:mw.internal.robotics.gazebotransport.ApplyLinkWrench.force_type)
  return force_type_.MutableNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
 ::std::string* ApplyLinkWrench::release_force_type() {
  // @@protoc_insertion_point(field_release:mw.internal.robotics.gazebotransport.ApplyLinkWrench.force_type)
  clear_has_force_type();
  return force_type_.ReleaseNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
 void ApplyLinkWrench::set_allocated_force_type(::std::string* force_type) {
  if (force_type != NULL) {
    set_has_force_type();
  } else {
    clear_has_force_type();
  }
  force_type_.SetAllocatedNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), force_type);
  // @@protoc_insertion_point(field_set_allocated:mw.internal.robotics.gazebotransport.ApplyLinkWrench.force_type)
}

// required double fx = 4;
bool ApplyLinkWrench::has_fx() const {
  return (_has_bits_[0] & 0x00000008u) != 0;
}
void ApplyLinkWrench::set_has_fx() {
  _has_bits_[0] |= 0x00000008u;
}
void ApplyLinkWrench::clear_has_fx() {
  _has_bits_[0] &= ~0x00000008u;
}
void ApplyLinkWrench::clear_fx() {
  fx_ = 0;
  clear_has_fx();
}
 double ApplyLinkWrench::fx() const {
  // @@protoc_insertion_point(field_get:mw.internal.robotics.gazebotransport.ApplyLinkWrench.fx)
  return fx_;
}
 void ApplyLinkWrench::set_fx(double value) {
  set_has_fx();
  fx_ = value;
  // @@protoc_insertion_point(field_set:mw.internal.robotics.gazebotransport.ApplyLinkWrench.fx)
}

// required double fy = 5;
bool ApplyLinkWrench::has_fy() const {
  return (_has_bits_[0] & 0x00000010u) != 0;
}
void ApplyLinkWrench::set_has_fy() {
  _has_bits_[0] |= 0x00000010u;
}
void ApplyLinkWrench::clear_has_fy() {
  _has_bits_[0] &= ~0x00000010u;
}
void ApplyLinkWrench::clear_fy() {
  fy_ = 0;
  clear_has_fy();
}
 double ApplyLinkWrench::fy() const {
  // @@protoc_insertion_point(field_get:mw.internal.robotics.gazebotransport.ApplyLinkWrench.fy)
  return fy_;
}
 void ApplyLinkWrench::set_fy(double value) {
  set_has_fy();
  fy_ = value;
  // @@protoc_insertion_point(field_set:mw.internal.robotics.gazebotransport.ApplyLinkWrench.fy)
}

// required double fz = 6;
bool ApplyLinkWrench::has_fz() const {
  return (_has_bits_[0] & 0x00000020u) != 0;
}
void ApplyLinkWrench::set_has_fz() {
  _has_bits_[0] |= 0x00000020u;
}
void ApplyLinkWrench::clear_has_fz() {
  _has_bits_[0] &= ~0x00000020u;
}
void ApplyLinkWrench::clear_fz() {
  fz_ = 0;
  clear_has_fz();
}
 double ApplyLinkWrench::fz() const {
  // @@protoc_insertion_point(field_get:mw.internal.robotics.gazebotransport.ApplyLinkWrench.fz)
  return fz_;
}
 void ApplyLinkWrench::set_fz(double value) {
  set_has_fz();
  fz_ = value;
  // @@protoc_insertion_point(field_set:mw.internal.robotics.gazebotransport.ApplyLinkWrench.fz)
}

// required string torque_type = 7;
bool ApplyLinkWrench::has_torque_type() const {
  return (_has_bits_[0] & 0x00000040u) != 0;
}
void ApplyLinkWrench::set_has_torque_type() {
  _has_bits_[0] |= 0x00000040u;
}
void ApplyLinkWrench::clear_has_torque_type() {
  _has_bits_[0] &= ~0x00000040u;
}
void ApplyLinkWrench::clear_torque_type() {
  torque_type_.ClearToEmptyNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
  clear_has_torque_type();
}
 const ::std::string& ApplyLinkWrench::torque_type() const {
  // @@protoc_insertion_point(field_get:mw.internal.robotics.gazebotransport.ApplyLinkWrench.torque_type)
  return torque_type_.GetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
 void ApplyLinkWrench::set_torque_type(const ::std::string& value) {
  set_has_torque_type();
  torque_type_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), value);
  // @@protoc_insertion_point(field_set:mw.internal.robotics.gazebotransport.ApplyLinkWrench.torque_type)
}
 void ApplyLinkWrench::set_torque_type(const char* value) {
  set_has_torque_type();
  torque_type_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::string(value));
  // @@protoc_insertion_point(field_set_char:mw.internal.robotics.gazebotransport.ApplyLinkWrench.torque_type)
}
 void ApplyLinkWrench::set_torque_type(const char* value, size_t size) {
  set_has_torque_type();
  torque_type_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(),
      ::std::string(reinterpret_cast<const char*>(value), size));
  // @@protoc_insertion_point(field_set_pointer:mw.internal.robotics.gazebotransport.ApplyLinkWrench.torque_type)
}
 ::std::string* ApplyLinkWrench::mutable_torque_type() {
  set_has_torque_type();
  // @@protoc_insertion_point(field_mutable:mw.internal.robotics.gazebotransport.ApplyLinkWrench.torque_type)
  return torque_type_.MutableNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
 ::std::string* ApplyLinkWrench::release_torque_type() {
  // @@protoc_insertion_point(field_release:mw.internal.robotics.gazebotransport.ApplyLinkWrench.torque_type)
  clear_has_torque_type();
  return torque_type_.ReleaseNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
 void ApplyLinkWrench::set_allocated_torque_type(::std::string* torque_type) {
  if (torque_type != NULL) {
    set_has_torque_type();
  } else {
    clear_has_torque_type();
  }
  torque_type_.SetAllocatedNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), torque_type);
  // @@protoc_insertion_point(field_set_allocated:mw.internal.robotics.gazebotransport.ApplyLinkWrench.torque_type)
}

// required double tx = 8;
bool ApplyLinkWrench::has_tx() const {
  return (_has_bits_[0] & 0x00000080u) != 0;
}
void ApplyLinkWrench::set_has_tx() {
  _has_bits_[0] |= 0x00000080u;
}
void ApplyLinkWrench::clear_has_tx() {
  _has_bits_[0] &= ~0x00000080u;
}
void ApplyLinkWrench::clear_tx() {
  tx_ = 0;
  clear_has_tx();
}
 double ApplyLinkWrench::tx() const {
  // @@protoc_insertion_point(field_get:mw.internal.robotics.gazebotransport.ApplyLinkWrench.tx)
  return tx_;
}
 void ApplyLinkWrench::set_tx(double value) {
  set_has_tx();
  tx_ = value;
  // @@protoc_insertion_point(field_set:mw.internal.robotics.gazebotransport.ApplyLinkWrench.tx)
}

// required double ty = 9;
bool ApplyLinkWrench::has_ty() const {
  return (_has_bits_[0] & 0x00000100u) != 0;
}
void ApplyLinkWrench::set_has_ty() {
  _has_bits_[0] |= 0x00000100u;
}
void ApplyLinkWrench::clear_has_ty() {
  _has_bits_[0] &= ~0x00000100u;
}
void ApplyLinkWrench::clear_ty() {
  ty_ = 0;
  clear_has_ty();
}
 double ApplyLinkWrench::ty() const {
  // @@protoc_insertion_point(field_get:mw.internal.robotics.gazebotransport.ApplyLinkWrench.ty)
  return ty_;
}
 void ApplyLinkWrench::set_ty(double value) {
  set_has_ty();
  ty_ = value;
  // @@protoc_insertion_point(field_set:mw.internal.robotics.gazebotransport.ApplyLinkWrench.ty)
}

// required double tz = 10;
bool ApplyLinkWrench::has_tz() const {
  return (_has_bits_[0] & 0x00000200u) != 0;
}
void ApplyLinkWrench::set_has_tz() {
  _has_bits_[0] |= 0x00000200u;
}
void ApplyLinkWrench::clear_has_tz() {
  _has_bits_[0] &= ~0x00000200u;
}
void ApplyLinkWrench::clear_tz() {
  tz_ = 0;
  clear_has_tz();
}
 double ApplyLinkWrench::tz() const {
  // @@protoc_insertion_point(field_get:mw.internal.robotics.gazebotransport.ApplyLinkWrench.tz)
  return tz_;
}
 void ApplyLinkWrench::set_tz(double value) {
  set_has_tz();
  tz_ = value;
  // @@protoc_insertion_point(field_set:mw.internal.robotics.gazebotransport.ApplyLinkWrench.tz)
}

// required .mw.internal.robotics.gazebotransport.Time duration = 11;
bool ApplyLinkWrench::has_duration() const {
  return (_has_bits_[0] & 0x00000400u) != 0;
}
void ApplyLinkWrench::set_has_duration() {
  _has_bits_[0] |= 0x00000400u;
}
void ApplyLinkWrench::clear_has_duration() {
  _has_bits_[0] &= ~0x00000400u;
}
void ApplyLinkWrench::clear_duration() {
  if (duration_ != NULL) duration_->::mw::internal::robotics::gazebotransport::Time::Clear();
  clear_has_duration();
}
const ::mw::internal::robotics::gazebotransport::Time& ApplyLinkWrench::duration() const {
  // @@protoc_insertion_point(field_get:mw.internal.robotics.gazebotransport.ApplyLinkWrench.duration)
  return duration_ != NULL ? *duration_ : *default_instance_->duration_;
}
::mw::internal::robotics::gazebotransport::Time* ApplyLinkWrench::mutable_duration() {
  set_has_duration();
  if (duration_ == NULL) {
    duration_ = new ::mw::internal::robotics::gazebotransport::Time;
  }
  // @@protoc_insertion_point(field_mutable:mw.internal.robotics.gazebotransport.ApplyLinkWrench.duration)
  return duration_;
}
::mw::internal::robotics::gazebotransport::Time* ApplyLinkWrench::release_duration() {
  // @@protoc_insertion_point(field_release:mw.internal.robotics.gazebotransport.ApplyLinkWrench.duration)
  clear_has_duration();
  ::mw::internal::robotics::gazebotransport::Time* temp = duration_;
  duration_ = NULL;
  return temp;
}
void ApplyLinkWrench::set_allocated_duration(::mw::internal::robotics::gazebotransport::Time* duration) {
  delete duration_;
  duration_ = duration;
  if (duration) {
    set_has_duration();
  } else {
    clear_has_duration();
  }
  // @@protoc_insertion_point(field_set_allocated:mw.internal.robotics.gazebotransport.ApplyLinkWrench.duration)
}

#endif  // PROTOBUF_INLINE_NOT_IN_HEADERS

// ===================================================================

#if !defined(_MSC_VER) || _MSC_VER >= 1900
const int ApplyJointTorque::kModelNameFieldNumber;
const int ApplyJointTorque::kJointNameFieldNumber;
const int ApplyJointTorque::kIndexFieldNumber;
const int ApplyJointTorque::kEffortFieldNumber;
const int ApplyJointTorque::kDurationFieldNumber;
#endif  // !defined(_MSC_VER) || _MSC_VER >= 1900

ApplyJointTorque::ApplyJointTorque()
  : ::google::protobuf::Message(), _internal_metadata_(NULL) {
  SharedCtor();
  // @@protoc_insertion_point(constructor:mw.internal.robotics.gazebotransport.ApplyJointTorque)
}

void ApplyJointTorque::InitAsDefaultInstance() {
  duration_ = const_cast< ::mw::internal::robotics::gazebotransport::Time*>(&::mw::internal::robotics::gazebotransport::Time::default_instance());
}

ApplyJointTorque::ApplyJointTorque(const ApplyJointTorque& from)
  : ::google::protobuf::Message(),
    _internal_metadata_(NULL) {
  SharedCtor();
  MergeFrom(from);
  // @@protoc_insertion_point(copy_constructor:mw.internal.robotics.gazebotransport.ApplyJointTorque)
}

void ApplyJointTorque::SharedCtor() {
  ::google::protobuf::internal::GetEmptyString();
  _cached_size_ = 0;
  model_name_.UnsafeSetDefault(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
  joint_name_.UnsafeSetDefault(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
  index_ = 0u;
  effort_ = 0;
  duration_ = NULL;
  ::memset(_has_bits_, 0, sizeof(_has_bits_));
}

ApplyJointTorque::~ApplyJointTorque() {
  // @@protoc_insertion_point(destructor:mw.internal.robotics.gazebotransport.ApplyJointTorque)
  SharedDtor();
}

void ApplyJointTorque::SharedDtor() {
  model_name_.DestroyNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
  joint_name_.DestroyNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
  if (this != default_instance_) {
    delete duration_;
  }
}

void ApplyJointTorque::SetCachedSize(int size) const {
  GOOGLE_SAFE_CONCURRENT_WRITES_BEGIN();
  _cached_size_ = size;
  GOOGLE_SAFE_CONCURRENT_WRITES_END();
}
const ::google::protobuf::Descriptor* ApplyJointTorque::descriptor() {
  protobuf_AssignDescriptorsOnce();
  return ApplyJointTorque_descriptor_;
}

const ApplyJointTorque& ApplyJointTorque::default_instance() {
  if (default_instance_ == NULL) protobuf_AddDesc_mw_2einternal_2erobotics_2egazebotransport_2eCoSimMsgs_2eproto();
  return *default_instance_;
}

ApplyJointTorque* ApplyJointTorque::default_instance_ = NULL;

ApplyJointTorque* ApplyJointTorque::New(::google::protobuf::Arena* arena) const {
  ApplyJointTorque* n = new ApplyJointTorque;
  if (arena != NULL) {
    arena->Own(n);
  }
  return n;
}

void ApplyJointTorque::Clear() {
// @@protoc_insertion_point(message_clear_start:mw.internal.robotics.gazebotransport.ApplyJointTorque)
  if (_has_bits_[0 / 32] & 31u) {
    if (has_model_name()) {
      model_name_.ClearToEmptyNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
    }
    if (has_joint_name()) {
      joint_name_.ClearToEmptyNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
    }
    index_ = 0u;
    effort_ = 0;
    if (has_duration()) {
      if (duration_ != NULL) duration_->::mw::internal::robotics::gazebotransport::Time::Clear();
    }
  }
  ::memset(_has_bits_, 0, sizeof(_has_bits_));
  if (_internal_metadata_.have_unknown_fields()) {
    mutable_unknown_fields()->Clear();
  }
}

bool ApplyJointTorque::MergePartialFromCodedStream(
    ::google::protobuf::io::CodedInputStream* input) {
#define DO_(EXPRESSION) if (!GOOGLE_PREDICT_TRUE(EXPRESSION)) goto failure
  ::google::protobuf::uint32 tag;
  // @@protoc_insertion_point(parse_start:mw.internal.robotics.gazebotransport.ApplyJointTorque)
  for (;;) {
    ::std::pair< ::google::protobuf::uint32, bool> p = input->ReadTagWithCutoff(127);
    tag = p.first;
    if (!p.second) goto handle_unusual;
    switch (::google::protobuf::internal::WireFormatLite::GetTagFieldNumber(tag)) {
      // required string model_name = 1;
      case 1: {
        if (tag == 10) {
          DO_(::google::protobuf::internal::WireFormatLite::ReadString(
                input, this->mutable_model_name()));
          ::google::protobuf::internal::WireFormat::VerifyUTF8StringNamedField(
            this->model_name().data(), this->model_name().length(),
            ::google::protobuf::internal::WireFormat::PARSE,
            "mw.internal.robotics.gazebotransport.ApplyJointTorque.model_name");
        } else {
          goto handle_unusual;
        }
        if (input->ExpectTag(18)) goto parse_joint_name;
        break;
      }

      // required string joint_name = 2;
      case 2: {
        if (tag == 18) {
         parse_joint_name:
          DO_(::google::protobuf::internal::WireFormatLite::ReadString(
                input, this->mutable_joint_name()));
          ::google::protobuf::internal::WireFormat::VerifyUTF8StringNamedField(
            this->joint_name().data(), this->joint_name().length(),
            ::google::protobuf::internal::WireFormat::PARSE,
            "mw.internal.robotics.gazebotransport.ApplyJointTorque.joint_name");
        } else {
          goto handle_unusual;
        }
        if (input->ExpectTag(24)) goto parse_index;
        break;
      }

      // required uint32 index = 3;
      case 3: {
        if (tag == 24) {
         parse_index:
          DO_((::google::protobuf::internal::WireFormatLite::ReadPrimitive<
                   ::google::protobuf::uint32, ::google::protobuf::internal::WireFormatLite::TYPE_UINT32>(
                 input, &index_)));
          set_has_index();
        } else {
          goto handle_unusual;
        }
        if (input->ExpectTag(33)) goto parse_effort;
        break;
      }

      // required double effort = 4;
      case 4: {
        if (tag == 33) {
         parse_effort:
          DO_((::google::protobuf::internal::WireFormatLite::ReadPrimitive<
                   double, ::google::protobuf::internal::WireFormatLite::TYPE_DOUBLE>(
                 input, &effort_)));
          set_has_effort();
        } else {
          goto handle_unusual;
        }
        if (input->ExpectTag(42)) goto parse_duration;
        break;
      }

      // required .mw.internal.robotics.gazebotransport.Time duration = 5;
      case 5: {
        if (tag == 42) {
         parse_duration:
          DO_(::google::protobuf::internal::WireFormatLite::ReadMessageNoVirtual(
               input, mutable_duration()));
        } else {
          goto handle_unusual;
        }
        if (input->ExpectAtEnd()) goto success;
        break;
      }

      default: {
      handle_unusual:
        if (tag == 0 ||
            ::google::protobuf::internal::WireFormatLite::GetTagWireType(tag) ==
            ::google::protobuf::internal::WireFormatLite::WIRETYPE_END_GROUP) {
          goto success;
        }
        DO_(::google::protobuf::internal::WireFormat::SkipField(
              input, tag, mutable_unknown_fields()));
        break;
      }
    }
  }
success:
  // @@protoc_insertion_point(parse_success:mw.internal.robotics.gazebotransport.ApplyJointTorque)
  return true;
failure:
  // @@protoc_insertion_point(parse_failure:mw.internal.robotics.gazebotransport.ApplyJointTorque)
  return false;
#undef DO_
}

void ApplyJointTorque::SerializeWithCachedSizes(
    ::google::protobuf::io::CodedOutputStream* output) const {
  // @@protoc_insertion_point(serialize_start:mw.internal.robotics.gazebotransport.ApplyJointTorque)
  // required string model_name = 1;
  if (has_model_name()) {
    ::google::protobuf::internal::WireFormat::VerifyUTF8StringNamedField(
      this->model_name().data(), this->model_name().length(),
      ::google::protobuf::internal::WireFormat::SERIALIZE,
      "mw.internal.robotics.gazebotransport.ApplyJointTorque.model_name");
    ::google::protobuf::internal::WireFormatLite::WriteStringMaybeAliased(
      1, this->model_name(), output);
  }

  // required string joint_name = 2;
  if (has_joint_name()) {
    ::google::protobuf::internal::WireFormat::VerifyUTF8StringNamedField(
      this->joint_name().data(), this->joint_name().length(),
      ::google::protobuf::internal::WireFormat::SERIALIZE,
      "mw.internal.robotics.gazebotransport.ApplyJointTorque.joint_name");
    ::google::protobuf::internal::WireFormatLite::WriteStringMaybeAliased(
      2, this->joint_name(), output);
  }

  // required uint32 index = 3;
  if (has_index()) {
    ::google::protobuf::internal::WireFormatLite::WriteUInt32(3, this->index(), output);
  }

  // required double effort = 4;
  if (has_effort()) {
    ::google::protobuf::internal::WireFormatLite::WriteDouble(4, this->effort(), output);
  }

  // required .mw.internal.robotics.gazebotransport.Time duration = 5;
  if (has_duration()) {
    ::google::protobuf::internal::WireFormatLite::WriteMessageMaybeToArray(
      5, *this->duration_, output);
  }

  if (_internal_metadata_.have_unknown_fields()) {
    ::google::protobuf::internal::WireFormat::SerializeUnknownFields(
        unknown_fields(), output);
  }
  // @@protoc_insertion_point(serialize_end:mw.internal.robotics.gazebotransport.ApplyJointTorque)
}

::google::protobuf::uint8* ApplyJointTorque::InternalSerializeWithCachedSizesToArray(
    bool deterministic, ::google::protobuf::uint8* target) const {
  // @@protoc_insertion_point(serialize_to_array_start:mw.internal.robotics.gazebotransport.ApplyJointTorque)
  // required string model_name = 1;
  if (has_model_name()) {
    ::google::protobuf::internal::WireFormat::VerifyUTF8StringNamedField(
      this->model_name().data(), this->model_name().length(),
      ::google::protobuf::internal::WireFormat::SERIALIZE,
      "mw.internal.robotics.gazebotransport.ApplyJointTorque.model_name");
    target =
      ::google::protobuf::internal::WireFormatLite::WriteStringToArray(
        1, this->model_name(), target);
  }

  // required string joint_name = 2;
  if (has_joint_name()) {
    ::google::protobuf::internal::WireFormat::VerifyUTF8StringNamedField(
      this->joint_name().data(), this->joint_name().length(),
      ::google::protobuf::internal::WireFormat::SERIALIZE,
      "mw.internal.robotics.gazebotransport.ApplyJointTorque.joint_name");
    target =
      ::google::protobuf::internal::WireFormatLite::WriteStringToArray(
        2, this->joint_name(), target);
  }

  // required uint32 index = 3;
  if (has_index()) {
    target = ::google::protobuf::internal::WireFormatLite::WriteUInt32ToArray(3, this->index(), target);
  }

  // required double effort = 4;
  if (has_effort()) {
    target = ::google::protobuf::internal::WireFormatLite::WriteDoubleToArray(4, this->effort(), target);
  }

  // required .mw.internal.robotics.gazebotransport.Time duration = 5;
  if (has_duration()) {
    target = ::google::protobuf::internal::WireFormatLite::
      InternalWriteMessageNoVirtualToArray(
        5, *this->duration_, false, target);
  }

  if (_internal_metadata_.have_unknown_fields()) {
    target = ::google::protobuf::internal::WireFormat::SerializeUnknownFieldsToArray(
        unknown_fields(), target);
  }
  // @@protoc_insertion_point(serialize_to_array_end:mw.internal.robotics.gazebotransport.ApplyJointTorque)
  return target;
}

int ApplyJointTorque::RequiredFieldsByteSizeFallback() const {
// @@protoc_insertion_point(required_fields_byte_size_fallback_start:mw.internal.robotics.gazebotransport.ApplyJointTorque)
  int total_size = 0;

  if (has_model_name()) {
    // required string model_name = 1;
    total_size += 1 +
      ::google::protobuf::internal::WireFormatLite::StringSize(
        this->model_name());
  }

  if (has_joint_name()) {
    // required string joint_name = 2;
    total_size += 1 +
      ::google::protobuf::internal::WireFormatLite::StringSize(
        this->joint_name());
  }

  if (has_index()) {
    // required uint32 index = 3;
    total_size += 1 +
      ::google::protobuf::internal::WireFormatLite::UInt32Size(
        this->index());
  }

  if (has_effort()) {
    // required double effort = 4;
    total_size += 1 + 8;
  }

  if (has_duration()) {
    // required .mw.internal.robotics.gazebotransport.Time duration = 5;
    total_size += 1 +
      ::google::protobuf::internal::WireFormatLite::MessageSizeNoVirtual(
        *this->duration_);
  }

  return total_size;
}
int ApplyJointTorque::ByteSize() const {
// @@protoc_insertion_point(message_byte_size_start:mw.internal.robotics.gazebotransport.ApplyJointTorque)
  int total_size = 0;

  if (((_has_bits_[0] & 0x0000001f) ^ 0x0000001f) == 0) {  // All required fields are present.
    // required string model_name = 1;
    total_size += 1 +
      ::google::protobuf::internal::WireFormatLite::StringSize(
        this->model_name());

    // required string joint_name = 2;
    total_size += 1 +
      ::google::protobuf::internal::WireFormatLite::StringSize(
        this->joint_name());

    // required uint32 index = 3;
    total_size += 1 +
      ::google::protobuf::internal::WireFormatLite::UInt32Size(
        this->index());

    // required double effort = 4;
    total_size += 1 + 8;

    // required .mw.internal.robotics.gazebotransport.Time duration = 5;
    total_size += 1 +
      ::google::protobuf::internal::WireFormatLite::MessageSizeNoVirtual(
        *this->duration_);

  } else {
    total_size += RequiredFieldsByteSizeFallback();
  }
  if (_internal_metadata_.have_unknown_fields()) {
    total_size +=
      ::google::protobuf::internal::WireFormat::ComputeUnknownFieldsSize(
        unknown_fields());
  }
  GOOGLE_SAFE_CONCURRENT_WRITES_BEGIN();
  _cached_size_ = total_size;
  GOOGLE_SAFE_CONCURRENT_WRITES_END();
  return total_size;
}

void ApplyJointTorque::MergeFrom(const ::google::protobuf::Message& from) {
// @@protoc_insertion_point(generalized_merge_from_start:mw.internal.robotics.gazebotransport.ApplyJointTorque)
  if (GOOGLE_PREDICT_FALSE(&from == this)) {
    ::google::protobuf::internal::MergeFromFail(__FILE__, __LINE__);
  }
  const ApplyJointTorque* source = 
      ::google::protobuf::internal::DynamicCastToGenerated<const ApplyJointTorque>(
          &from);
  if (source == NULL) {
  // @@protoc_insertion_point(generalized_merge_from_cast_fail:mw.internal.robotics.gazebotransport.ApplyJointTorque)
    ::google::protobuf::internal::ReflectionOps::Merge(from, this);
  } else {
  // @@protoc_insertion_point(generalized_merge_from_cast_success:mw.internal.robotics.gazebotransport.ApplyJointTorque)
    MergeFrom(*source);
  }
}

void ApplyJointTorque::MergeFrom(const ApplyJointTorque& from) {
// @@protoc_insertion_point(class_specific_merge_from_start:mw.internal.robotics.gazebotransport.ApplyJointTorque)
  if (GOOGLE_PREDICT_FALSE(&from == this)) {
    ::google::protobuf::internal::MergeFromFail(__FILE__, __LINE__);
  }
  if (from._has_bits_[0 / 32] & (0xffu << (0 % 32))) {
    if (from.has_model_name()) {
      set_has_model_name();
      model_name_.AssignWithDefault(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), from.model_name_);
    }
    if (from.has_joint_name()) {
      set_has_joint_name();
      joint_name_.AssignWithDefault(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), from.joint_name_);
    }
    if (from.has_index()) {
      set_index(from.index());
    }
    if (from.has_effort()) {
      set_effort(from.effort());
    }
    if (from.has_duration()) {
      mutable_duration()->::mw::internal::robotics::gazebotransport::Time::MergeFrom(from.duration());
    }
  }
  if (from._internal_metadata_.have_unknown_fields()) {
    mutable_unknown_fields()->MergeFrom(from.unknown_fields());
  }
}

void ApplyJointTorque::CopyFrom(const ::google::protobuf::Message& from) {
// @@protoc_insertion_point(generalized_copy_from_start:mw.internal.robotics.gazebotransport.ApplyJointTorque)
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

void ApplyJointTorque::CopyFrom(const ApplyJointTorque& from) {
// @@protoc_insertion_point(class_specific_copy_from_start:mw.internal.robotics.gazebotransport.ApplyJointTorque)
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

bool ApplyJointTorque::IsInitialized() const {
  if ((_has_bits_[0] & 0x0000001f) != 0x0000001f) return false;

  if (has_duration()) {
    if (!this->duration_->IsInitialized()) return false;
  }
  return true;
}

void ApplyJointTorque::Swap(ApplyJointTorque* other) {
  if (other == this) return;
  InternalSwap(other);
}
void ApplyJointTorque::InternalSwap(ApplyJointTorque* other) {
  model_name_.Swap(&other->model_name_);
  joint_name_.Swap(&other->joint_name_);
  std::swap(index_, other->index_);
  std::swap(effort_, other->effort_);
  std::swap(duration_, other->duration_);
  std::swap(_has_bits_[0], other->_has_bits_[0]);
  _internal_metadata_.Swap(&other->_internal_metadata_);
  std::swap(_cached_size_, other->_cached_size_);
}

::google::protobuf::Metadata ApplyJointTorque::GetMetadata() const {
  protobuf_AssignDescriptorsOnce();
  ::google::protobuf::Metadata metadata;
  metadata.descriptor = ApplyJointTorque_descriptor_;
  metadata.reflection = ApplyJointTorque_reflection_;
  return metadata;
}

#if PROTOBUF_INLINE_NOT_IN_HEADERS
// ApplyJointTorque

// required string model_name = 1;
bool ApplyJointTorque::has_model_name() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
void ApplyJointTorque::set_has_model_name() {
  _has_bits_[0] |= 0x00000001u;
}
void ApplyJointTorque::clear_has_model_name() {
  _has_bits_[0] &= ~0x00000001u;
}
void ApplyJointTorque::clear_model_name() {
  model_name_.ClearToEmptyNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
  clear_has_model_name();
}
 const ::std::string& ApplyJointTorque::model_name() const {
  // @@protoc_insertion_point(field_get:mw.internal.robotics.gazebotransport.ApplyJointTorque.model_name)
  return model_name_.GetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
 void ApplyJointTorque::set_model_name(const ::std::string& value) {
  set_has_model_name();
  model_name_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), value);
  // @@protoc_insertion_point(field_set:mw.internal.robotics.gazebotransport.ApplyJointTorque.model_name)
}
 void ApplyJointTorque::set_model_name(const char* value) {
  set_has_model_name();
  model_name_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::string(value));
  // @@protoc_insertion_point(field_set_char:mw.internal.robotics.gazebotransport.ApplyJointTorque.model_name)
}
 void ApplyJointTorque::set_model_name(const char* value, size_t size) {
  set_has_model_name();
  model_name_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(),
      ::std::string(reinterpret_cast<const char*>(value), size));
  // @@protoc_insertion_point(field_set_pointer:mw.internal.robotics.gazebotransport.ApplyJointTorque.model_name)
}
 ::std::string* ApplyJointTorque::mutable_model_name() {
  set_has_model_name();
  // @@protoc_insertion_point(field_mutable:mw.internal.robotics.gazebotransport.ApplyJointTorque.model_name)
  return model_name_.MutableNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
 ::std::string* ApplyJointTorque::release_model_name() {
  // @@protoc_insertion_point(field_release:mw.internal.robotics.gazebotransport.ApplyJointTorque.model_name)
  clear_has_model_name();
  return model_name_.ReleaseNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
 void ApplyJointTorque::set_allocated_model_name(::std::string* model_name) {
  if (model_name != NULL) {
    set_has_model_name();
  } else {
    clear_has_model_name();
  }
  model_name_.SetAllocatedNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), model_name);
  // @@protoc_insertion_point(field_set_allocated:mw.internal.robotics.gazebotransport.ApplyJointTorque.model_name)
}

// required string joint_name = 2;
bool ApplyJointTorque::has_joint_name() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
void ApplyJointTorque::set_has_joint_name() {
  _has_bits_[0] |= 0x00000002u;
}
void ApplyJointTorque::clear_has_joint_name() {
  _has_bits_[0] &= ~0x00000002u;
}
void ApplyJointTorque::clear_joint_name() {
  joint_name_.ClearToEmptyNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
  clear_has_joint_name();
}
 const ::std::string& ApplyJointTorque::joint_name() const {
  // @@protoc_insertion_point(field_get:mw.internal.robotics.gazebotransport.ApplyJointTorque.joint_name)
  return joint_name_.GetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
 void ApplyJointTorque::set_joint_name(const ::std::string& value) {
  set_has_joint_name();
  joint_name_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), value);
  // @@protoc_insertion_point(field_set:mw.internal.robotics.gazebotransport.ApplyJointTorque.joint_name)
}
 void ApplyJointTorque::set_joint_name(const char* value) {
  set_has_joint_name();
  joint_name_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::string(value));
  // @@protoc_insertion_point(field_set_char:mw.internal.robotics.gazebotransport.ApplyJointTorque.joint_name)
}
 void ApplyJointTorque::set_joint_name(const char* value, size_t size) {
  set_has_joint_name();
  joint_name_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(),
      ::std::string(reinterpret_cast<const char*>(value), size));
  // @@protoc_insertion_point(field_set_pointer:mw.internal.robotics.gazebotransport.ApplyJointTorque.joint_name)
}
 ::std::string* ApplyJointTorque::mutable_joint_name() {
  set_has_joint_name();
  // @@protoc_insertion_point(field_mutable:mw.internal.robotics.gazebotransport.ApplyJointTorque.joint_name)
  return joint_name_.MutableNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
 ::std::string* ApplyJointTorque::release_joint_name() {
  // @@protoc_insertion_point(field_release:mw.internal.robotics.gazebotransport.ApplyJointTorque.joint_name)
  clear_has_joint_name();
  return joint_name_.ReleaseNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
 void ApplyJointTorque::set_allocated_joint_name(::std::string* joint_name) {
  if (joint_name != NULL) {
    set_has_joint_name();
  } else {
    clear_has_joint_name();
  }
  joint_name_.SetAllocatedNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), joint_name);
  // @@protoc_insertion_point(field_set_allocated:mw.internal.robotics.gazebotransport.ApplyJointTorque.joint_name)
}

// required uint32 index = 3;
bool ApplyJointTorque::has_index() const {
  return (_has_bits_[0] & 0x00000004u) != 0;
}
void ApplyJointTorque::set_has_index() {
  _has_bits_[0] |= 0x00000004u;
}
void ApplyJointTorque::clear_has_index() {
  _has_bits_[0] &= ~0x00000004u;
}
void ApplyJointTorque::clear_index() {
  index_ = 0u;
  clear_has_index();
}
 ::google::protobuf::uint32 ApplyJointTorque::index() const {
  // @@protoc_insertion_point(field_get:mw.internal.robotics.gazebotransport.ApplyJointTorque.index)
  return index_;
}
 void ApplyJointTorque::set_index(::google::protobuf::uint32 value) {
  set_has_index();
  index_ = value;
  // @@protoc_insertion_point(field_set:mw.internal.robotics.gazebotransport.ApplyJointTorque.index)
}

// required double effort = 4;
bool ApplyJointTorque::has_effort() const {
  return (_has_bits_[0] & 0x00000008u) != 0;
}
void ApplyJointTorque::set_has_effort() {
  _has_bits_[0] |= 0x00000008u;
}
void ApplyJointTorque::clear_has_effort() {
  _has_bits_[0] &= ~0x00000008u;
}
void ApplyJointTorque::clear_effort() {
  effort_ = 0;
  clear_has_effort();
}
 double ApplyJointTorque::effort() const {
  // @@protoc_insertion_point(field_get:mw.internal.robotics.gazebotransport.ApplyJointTorque.effort)
  return effort_;
}
 void ApplyJointTorque::set_effort(double value) {
  set_has_effort();
  effort_ = value;
  // @@protoc_insertion_point(field_set:mw.internal.robotics.gazebotransport.ApplyJointTorque.effort)
}

// required .mw.internal.robotics.gazebotransport.Time duration = 5;
bool ApplyJointTorque::has_duration() const {
  return (_has_bits_[0] & 0x00000010u) != 0;
}
void ApplyJointTorque::set_has_duration() {
  _has_bits_[0] |= 0x00000010u;
}
void ApplyJointTorque::clear_has_duration() {
  _has_bits_[0] &= ~0x00000010u;
}
void ApplyJointTorque::clear_duration() {
  if (duration_ != NULL) duration_->::mw::internal::robotics::gazebotransport::Time::Clear();
  clear_has_duration();
}
const ::mw::internal::robotics::gazebotransport::Time& ApplyJointTorque::duration() const {
  // @@protoc_insertion_point(field_get:mw.internal.robotics.gazebotransport.ApplyJointTorque.duration)
  return duration_ != NULL ? *duration_ : *default_instance_->duration_;
}
::mw::internal::robotics::gazebotransport::Time* ApplyJointTorque::mutable_duration() {
  set_has_duration();
  if (duration_ == NULL) {
    duration_ = new ::mw::internal::robotics::gazebotransport::Time;
  }
  // @@protoc_insertion_point(field_mutable:mw.internal.robotics.gazebotransport.ApplyJointTorque.duration)
  return duration_;
}
::mw::internal::robotics::gazebotransport::Time* ApplyJointTorque::release_duration() {
  // @@protoc_insertion_point(field_release:mw.internal.robotics.gazebotransport.ApplyJointTorque.duration)
  clear_has_duration();
  ::mw::internal::robotics::gazebotransport::Time* temp = duration_;
  duration_ = NULL;
  return temp;
}
void ApplyJointTorque::set_allocated_duration(::mw::internal::robotics::gazebotransport::Time* duration) {
  delete duration_;
  duration_ = duration;
  if (duration) {
    set_has_duration();
  } else {
    clear_has_duration();
  }
  // @@protoc_insertion_point(field_set_allocated:mw.internal.robotics.gazebotransport.ApplyJointTorque.duration)
}

#endif  // PROTOBUF_INLINE_NOT_IN_HEADERS

// ===================================================================

#if !defined(_MSC_VER) || _MSC_VER >= 1900
const int GetPose::kModelNameFieldNumber;
#endif  // !defined(_MSC_VER) || _MSC_VER >= 1900

GetPose::GetPose()
  : ::google::protobuf::Message(), _internal_metadata_(NULL) {
  SharedCtor();
  // @@protoc_insertion_point(constructor:mw.internal.robotics.gazebotransport.GetPose)
}

void GetPose::InitAsDefaultInstance() {
}

GetPose::GetPose(const GetPose& from)
  : ::google::protobuf::Message(),
    _internal_metadata_(NULL) {
  SharedCtor();
  MergeFrom(from);
  // @@protoc_insertion_point(copy_constructor:mw.internal.robotics.gazebotransport.GetPose)
}

void GetPose::SharedCtor() {
  ::google::protobuf::internal::GetEmptyString();
  _cached_size_ = 0;
  model_name_.UnsafeSetDefault(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
  ::memset(_has_bits_, 0, sizeof(_has_bits_));
}

GetPose::~GetPose() {
  // @@protoc_insertion_point(destructor:mw.internal.robotics.gazebotransport.GetPose)
  SharedDtor();
}

void GetPose::SharedDtor() {
  model_name_.DestroyNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
  if (this != default_instance_) {
  }
}

void GetPose::SetCachedSize(int size) const {
  GOOGLE_SAFE_CONCURRENT_WRITES_BEGIN();
  _cached_size_ = size;
  GOOGLE_SAFE_CONCURRENT_WRITES_END();
}
const ::google::protobuf::Descriptor* GetPose::descriptor() {
  protobuf_AssignDescriptorsOnce();
  return GetPose_descriptor_;
}

const GetPose& GetPose::default_instance() {
  if (default_instance_ == NULL) protobuf_AddDesc_mw_2einternal_2erobotics_2egazebotransport_2eCoSimMsgs_2eproto();
  return *default_instance_;
}

GetPose* GetPose::default_instance_ = NULL;

GetPose* GetPose::New(::google::protobuf::Arena* arena) const {
  GetPose* n = new GetPose;
  if (arena != NULL) {
    arena->Own(n);
  }
  return n;
}

void GetPose::Clear() {
// @@protoc_insertion_point(message_clear_start:mw.internal.robotics.gazebotransport.GetPose)
  if (has_model_name()) {
    model_name_.ClearToEmptyNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
  }
  ::memset(_has_bits_, 0, sizeof(_has_bits_));
  if (_internal_metadata_.have_unknown_fields()) {
    mutable_unknown_fields()->Clear();
  }
}

bool GetPose::MergePartialFromCodedStream(
    ::google::protobuf::io::CodedInputStream* input) {
#define DO_(EXPRESSION) if (!GOOGLE_PREDICT_TRUE(EXPRESSION)) goto failure
  ::google::protobuf::uint32 tag;
  // @@protoc_insertion_point(parse_start:mw.internal.robotics.gazebotransport.GetPose)
  for (;;) {
    ::std::pair< ::google::protobuf::uint32, bool> p = input->ReadTagWithCutoff(127);
    tag = p.first;
    if (!p.second) goto handle_unusual;
    switch (::google::protobuf::internal::WireFormatLite::GetTagFieldNumber(tag)) {
      // required string model_name = 1;
      case 1: {
        if (tag == 10) {
          DO_(::google::protobuf::internal::WireFormatLite::ReadString(
                input, this->mutable_model_name()));
          ::google::protobuf::internal::WireFormat::VerifyUTF8StringNamedField(
            this->model_name().data(), this->model_name().length(),
            ::google::protobuf::internal::WireFormat::PARSE,
            "mw.internal.robotics.gazebotransport.GetPose.model_name");
        } else {
          goto handle_unusual;
        }
        if (input->ExpectAtEnd()) goto success;
        break;
      }

      default: {
      handle_unusual:
        if (tag == 0 ||
            ::google::protobuf::internal::WireFormatLite::GetTagWireType(tag) ==
            ::google::protobuf::internal::WireFormatLite::WIRETYPE_END_GROUP) {
          goto success;
        }
        DO_(::google::protobuf::internal::WireFormat::SkipField(
              input, tag, mutable_unknown_fields()));
        break;
      }
    }
  }
success:
  // @@protoc_insertion_point(parse_success:mw.internal.robotics.gazebotransport.GetPose)
  return true;
failure:
  // @@protoc_insertion_point(parse_failure:mw.internal.robotics.gazebotransport.GetPose)
  return false;
#undef DO_
}

void GetPose::SerializeWithCachedSizes(
    ::google::protobuf::io::CodedOutputStream* output) const {
  // @@protoc_insertion_point(serialize_start:mw.internal.robotics.gazebotransport.GetPose)
  // required string model_name = 1;
  if (has_model_name()) {
    ::google::protobuf::internal::WireFormat::VerifyUTF8StringNamedField(
      this->model_name().data(), this->model_name().length(),
      ::google::protobuf::internal::WireFormat::SERIALIZE,
      "mw.internal.robotics.gazebotransport.GetPose.model_name");
    ::google::protobuf::internal::WireFormatLite::WriteStringMaybeAliased(
      1, this->model_name(), output);
  }

  if (_internal_metadata_.have_unknown_fields()) {
    ::google::protobuf::internal::WireFormat::SerializeUnknownFields(
        unknown_fields(), output);
  }
  // @@protoc_insertion_point(serialize_end:mw.internal.robotics.gazebotransport.GetPose)
}

::google::protobuf::uint8* GetPose::InternalSerializeWithCachedSizesToArray(
    bool deterministic, ::google::protobuf::uint8* target) const {
  // @@protoc_insertion_point(serialize_to_array_start:mw.internal.robotics.gazebotransport.GetPose)
  // required string model_name = 1;
  if (has_model_name()) {
    ::google::protobuf::internal::WireFormat::VerifyUTF8StringNamedField(
      this->model_name().data(), this->model_name().length(),
      ::google::protobuf::internal::WireFormat::SERIALIZE,
      "mw.internal.robotics.gazebotransport.GetPose.model_name");
    target =
      ::google::protobuf::internal::WireFormatLite::WriteStringToArray(
        1, this->model_name(), target);
  }

  if (_internal_metadata_.have_unknown_fields()) {
    target = ::google::protobuf::internal::WireFormat::SerializeUnknownFieldsToArray(
        unknown_fields(), target);
  }
  // @@protoc_insertion_point(serialize_to_array_end:mw.internal.robotics.gazebotransport.GetPose)
  return target;
}

int GetPose::ByteSize() const {
// @@protoc_insertion_point(message_byte_size_start:mw.internal.robotics.gazebotransport.GetPose)
  int total_size = 0;

  // required string model_name = 1;
  if (has_model_name()) {
    total_size += 1 +
      ::google::protobuf::internal::WireFormatLite::StringSize(
        this->model_name());
  }
  if (_internal_metadata_.have_unknown_fields()) {
    total_size +=
      ::google::protobuf::internal::WireFormat::ComputeUnknownFieldsSize(
        unknown_fields());
  }
  GOOGLE_SAFE_CONCURRENT_WRITES_BEGIN();
  _cached_size_ = total_size;
  GOOGLE_SAFE_CONCURRENT_WRITES_END();
  return total_size;
}

void GetPose::MergeFrom(const ::google::protobuf::Message& from) {
// @@protoc_insertion_point(generalized_merge_from_start:mw.internal.robotics.gazebotransport.GetPose)
  if (GOOGLE_PREDICT_FALSE(&from == this)) {
    ::google::protobuf::internal::MergeFromFail(__FILE__, __LINE__);
  }
  const GetPose* source = 
      ::google::protobuf::internal::DynamicCastToGenerated<const GetPose>(
          &from);
  if (source == NULL) {
  // @@protoc_insertion_point(generalized_merge_from_cast_fail:mw.internal.robotics.gazebotransport.GetPose)
    ::google::protobuf::internal::ReflectionOps::Merge(from, this);
  } else {
  // @@protoc_insertion_point(generalized_merge_from_cast_success:mw.internal.robotics.gazebotransport.GetPose)
    MergeFrom(*source);
  }
}

void GetPose::MergeFrom(const GetPose& from) {
// @@protoc_insertion_point(class_specific_merge_from_start:mw.internal.robotics.gazebotransport.GetPose)
  if (GOOGLE_PREDICT_FALSE(&from == this)) {
    ::google::protobuf::internal::MergeFromFail(__FILE__, __LINE__);
  }
  if (from._has_bits_[0 / 32] & (0xffu << (0 % 32))) {
    if (from.has_model_name()) {
      set_has_model_name();
      model_name_.AssignWithDefault(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), from.model_name_);
    }
  }
  if (from._internal_metadata_.have_unknown_fields()) {
    mutable_unknown_fields()->MergeFrom(from.unknown_fields());
  }
}

void GetPose::CopyFrom(const ::google::protobuf::Message& from) {
// @@protoc_insertion_point(generalized_copy_from_start:mw.internal.robotics.gazebotransport.GetPose)
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

void GetPose::CopyFrom(const GetPose& from) {
// @@protoc_insertion_point(class_specific_copy_from_start:mw.internal.robotics.gazebotransport.GetPose)
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

bool GetPose::IsInitialized() const {
  if ((_has_bits_[0] & 0x00000001) != 0x00000001) return false;

  return true;
}

void GetPose::Swap(GetPose* other) {
  if (other == this) return;
  InternalSwap(other);
}
void GetPose::InternalSwap(GetPose* other) {
  model_name_.Swap(&other->model_name_);
  std::swap(_has_bits_[0], other->_has_bits_[0]);
  _internal_metadata_.Swap(&other->_internal_metadata_);
  std::swap(_cached_size_, other->_cached_size_);
}

::google::protobuf::Metadata GetPose::GetMetadata() const {
  protobuf_AssignDescriptorsOnce();
  ::google::protobuf::Metadata metadata;
  metadata.descriptor = GetPose_descriptor_;
  metadata.reflection = GetPose_reflection_;
  return metadata;
}

#if PROTOBUF_INLINE_NOT_IN_HEADERS
// GetPose

// required string model_name = 1;
bool GetPose::has_model_name() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
void GetPose::set_has_model_name() {
  _has_bits_[0] |= 0x00000001u;
}
void GetPose::clear_has_model_name() {
  _has_bits_[0] &= ~0x00000001u;
}
void GetPose::clear_model_name() {
  model_name_.ClearToEmptyNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
  clear_has_model_name();
}
 const ::std::string& GetPose::model_name() const {
  // @@protoc_insertion_point(field_get:mw.internal.robotics.gazebotransport.GetPose.model_name)
  return model_name_.GetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
 void GetPose::set_model_name(const ::std::string& value) {
  set_has_model_name();
  model_name_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), value);
  // @@protoc_insertion_point(field_set:mw.internal.robotics.gazebotransport.GetPose.model_name)
}
 void GetPose::set_model_name(const char* value) {
  set_has_model_name();
  model_name_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::string(value));
  // @@protoc_insertion_point(field_set_char:mw.internal.robotics.gazebotransport.GetPose.model_name)
}
 void GetPose::set_model_name(const char* value, size_t size) {
  set_has_model_name();
  model_name_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(),
      ::std::string(reinterpret_cast<const char*>(value), size));
  // @@protoc_insertion_point(field_set_pointer:mw.internal.robotics.gazebotransport.GetPose.model_name)
}
 ::std::string* GetPose::mutable_model_name() {
  set_has_model_name();
  // @@protoc_insertion_point(field_mutable:mw.internal.robotics.gazebotransport.GetPose.model_name)
  return model_name_.MutableNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
 ::std::string* GetPose::release_model_name() {
  // @@protoc_insertion_point(field_release:mw.internal.robotics.gazebotransport.GetPose.model_name)
  clear_has_model_name();
  return model_name_.ReleaseNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
 void GetPose::set_allocated_model_name(::std::string* model_name) {
  if (model_name != NULL) {
    set_has_model_name();
  } else {
    clear_has_model_name();
  }
  model_name_.SetAllocatedNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), model_name);
  // @@protoc_insertion_point(field_set_allocated:mw.internal.robotics.gazebotransport.GetPose.model_name)
}

#endif  // PROTOBUF_INLINE_NOT_IN_HEADERS

// ===================================================================

#if !defined(_MSC_VER) || _MSC_VER >= 1900
const int GetTopicList::kTopicNameFieldNumber;
#endif  // !defined(_MSC_VER) || _MSC_VER >= 1900

GetTopicList::GetTopicList()
  : ::google::protobuf::Message(), _internal_metadata_(NULL) {
  SharedCtor();
  // @@protoc_insertion_point(constructor:mw.internal.robotics.gazebotransport.GetTopicList)
}

void GetTopicList::InitAsDefaultInstance() {
}

GetTopicList::GetTopicList(const GetTopicList& from)
  : ::google::protobuf::Message(),
    _internal_metadata_(NULL) {
  SharedCtor();
  MergeFrom(from);
  // @@protoc_insertion_point(copy_constructor:mw.internal.robotics.gazebotransport.GetTopicList)
}

void GetTopicList::SharedCtor() {
  ::google::protobuf::internal::GetEmptyString();
  _cached_size_ = 0;
  topic_name_.UnsafeSetDefault(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
  ::memset(_has_bits_, 0, sizeof(_has_bits_));
}

GetTopicList::~GetTopicList() {
  // @@protoc_insertion_point(destructor:mw.internal.robotics.gazebotransport.GetTopicList)
  SharedDtor();
}

void GetTopicList::SharedDtor() {
  topic_name_.DestroyNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
  if (this != default_instance_) {
  }
}

void GetTopicList::SetCachedSize(int size) const {
  GOOGLE_SAFE_CONCURRENT_WRITES_BEGIN();
  _cached_size_ = size;
  GOOGLE_SAFE_CONCURRENT_WRITES_END();
}
const ::google::protobuf::Descriptor* GetTopicList::descriptor() {
  protobuf_AssignDescriptorsOnce();
  return GetTopicList_descriptor_;
}

const GetTopicList& GetTopicList::default_instance() {
  if (default_instance_ == NULL) protobuf_AddDesc_mw_2einternal_2erobotics_2egazebotransport_2eCoSimMsgs_2eproto();
  return *default_instance_;
}

GetTopicList* GetTopicList::default_instance_ = NULL;

GetTopicList* GetTopicList::New(::google::protobuf::Arena* arena) const {
  GetTopicList* n = new GetTopicList;
  if (arena != NULL) {
    arena->Own(n);
  }
  return n;
}

void GetTopicList::Clear() {
// @@protoc_insertion_point(message_clear_start:mw.internal.robotics.gazebotransport.GetTopicList)
  if (has_topic_name()) {
    topic_name_.ClearToEmptyNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
  }
  ::memset(_has_bits_, 0, sizeof(_has_bits_));
  if (_internal_metadata_.have_unknown_fields()) {
    mutable_unknown_fields()->Clear();
  }
}

bool GetTopicList::MergePartialFromCodedStream(
    ::google::protobuf::io::CodedInputStream* input) {
#define DO_(EXPRESSION) if (!GOOGLE_PREDICT_TRUE(EXPRESSION)) goto failure
  ::google::protobuf::uint32 tag;
  // @@protoc_insertion_point(parse_start:mw.internal.robotics.gazebotransport.GetTopicList)
  for (;;) {
    ::std::pair< ::google::protobuf::uint32, bool> p = input->ReadTagWithCutoff(127);
    tag = p.first;
    if (!p.second) goto handle_unusual;
    switch (::google::protobuf::internal::WireFormatLite::GetTagFieldNumber(tag)) {
      // required string topic_name = 1;
      case 1: {
        if (tag == 10) {
          DO_(::google::protobuf::internal::WireFormatLite::ReadString(
                input, this->mutable_topic_name()));
          ::google::protobuf::internal::WireFormat::VerifyUTF8StringNamedField(
            this->topic_name().data(), this->topic_name().length(),
            ::google::protobuf::internal::WireFormat::PARSE,
            "mw.internal.robotics.gazebotransport.GetTopicList.topic_name");
        } else {
          goto handle_unusual;
        }
        if (input->ExpectAtEnd()) goto success;
        break;
      }

      default: {
      handle_unusual:
        if (tag == 0 ||
            ::google::protobuf::internal::WireFormatLite::GetTagWireType(tag) ==
            ::google::protobuf::internal::WireFormatLite::WIRETYPE_END_GROUP) {
          goto success;
        }
        DO_(::google::protobuf::internal::WireFormat::SkipField(
              input, tag, mutable_unknown_fields()));
        break;
      }
    }
  }
success:
  // @@protoc_insertion_point(parse_success:mw.internal.robotics.gazebotransport.GetTopicList)
  return true;
failure:
  // @@protoc_insertion_point(parse_failure:mw.internal.robotics.gazebotransport.GetTopicList)
  return false;
#undef DO_
}

void GetTopicList::SerializeWithCachedSizes(
    ::google::protobuf::io::CodedOutputStream* output) const {
  // @@protoc_insertion_point(serialize_start:mw.internal.robotics.gazebotransport.GetTopicList)
  // required string topic_name = 1;
  if (has_topic_name()) {
    ::google::protobuf::internal::WireFormat::VerifyUTF8StringNamedField(
      this->topic_name().data(), this->topic_name().length(),
      ::google::protobuf::internal::WireFormat::SERIALIZE,
      "mw.internal.robotics.gazebotransport.GetTopicList.topic_name");
    ::google::protobuf::internal::WireFormatLite::WriteStringMaybeAliased(
      1, this->topic_name(), output);
  }

  if (_internal_metadata_.have_unknown_fields()) {
    ::google::protobuf::internal::WireFormat::SerializeUnknownFields(
        unknown_fields(), output);
  }
  // @@protoc_insertion_point(serialize_end:mw.internal.robotics.gazebotransport.GetTopicList)
}

::google::protobuf::uint8* GetTopicList::InternalSerializeWithCachedSizesToArray(
    bool deterministic, ::google::protobuf::uint8* target) const {
  // @@protoc_insertion_point(serialize_to_array_start:mw.internal.robotics.gazebotransport.GetTopicList)
  // required string topic_name = 1;
  if (has_topic_name()) {
    ::google::protobuf::internal::WireFormat::VerifyUTF8StringNamedField(
      this->topic_name().data(), this->topic_name().length(),
      ::google::protobuf::internal::WireFormat::SERIALIZE,
      "mw.internal.robotics.gazebotransport.GetTopicList.topic_name");
    target =
      ::google::protobuf::internal::WireFormatLite::WriteStringToArray(
        1, this->topic_name(), target);
  }

  if (_internal_metadata_.have_unknown_fields()) {
    target = ::google::protobuf::internal::WireFormat::SerializeUnknownFieldsToArray(
        unknown_fields(), target);
  }
  // @@protoc_insertion_point(serialize_to_array_end:mw.internal.robotics.gazebotransport.GetTopicList)
  return target;
}

int GetTopicList::ByteSize() const {
// @@protoc_insertion_point(message_byte_size_start:mw.internal.robotics.gazebotransport.GetTopicList)
  int total_size = 0;

  // required string topic_name = 1;
  if (has_topic_name()) {
    total_size += 1 +
      ::google::protobuf::internal::WireFormatLite::StringSize(
        this->topic_name());
  }
  if (_internal_metadata_.have_unknown_fields()) {
    total_size +=
      ::google::protobuf::internal::WireFormat::ComputeUnknownFieldsSize(
        unknown_fields());
  }
  GOOGLE_SAFE_CONCURRENT_WRITES_BEGIN();
  _cached_size_ = total_size;
  GOOGLE_SAFE_CONCURRENT_WRITES_END();
  return total_size;
}

void GetTopicList::MergeFrom(const ::google::protobuf::Message& from) {
// @@protoc_insertion_point(generalized_merge_from_start:mw.internal.robotics.gazebotransport.GetTopicList)
  if (GOOGLE_PREDICT_FALSE(&from == this)) {
    ::google::protobuf::internal::MergeFromFail(__FILE__, __LINE__);
  }
  const GetTopicList* source = 
      ::google::protobuf::internal::DynamicCastToGenerated<const GetTopicList>(
          &from);
  if (source == NULL) {
  // @@protoc_insertion_point(generalized_merge_from_cast_fail:mw.internal.robotics.gazebotransport.GetTopicList)
    ::google::protobuf::internal::ReflectionOps::Merge(from, this);
  } else {
  // @@protoc_insertion_point(generalized_merge_from_cast_success:mw.internal.robotics.gazebotransport.GetTopicList)
    MergeFrom(*source);
  }
}

void GetTopicList::MergeFrom(const GetTopicList& from) {
// @@protoc_insertion_point(class_specific_merge_from_start:mw.internal.robotics.gazebotransport.GetTopicList)
  if (GOOGLE_PREDICT_FALSE(&from == this)) {
    ::google::protobuf::internal::MergeFromFail(__FILE__, __LINE__);
  }
  if (from._has_bits_[0 / 32] & (0xffu << (0 % 32))) {
    if (from.has_topic_name()) {
      set_has_topic_name();
      topic_name_.AssignWithDefault(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), from.topic_name_);
    }
  }
  if (from._internal_metadata_.have_unknown_fields()) {
    mutable_unknown_fields()->MergeFrom(from.unknown_fields());
  }
}

void GetTopicList::CopyFrom(const ::google::protobuf::Message& from) {
// @@protoc_insertion_point(generalized_copy_from_start:mw.internal.robotics.gazebotransport.GetTopicList)
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

void GetTopicList::CopyFrom(const GetTopicList& from) {
// @@protoc_insertion_point(class_specific_copy_from_start:mw.internal.robotics.gazebotransport.GetTopicList)
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

bool GetTopicList::IsInitialized() const {
  if ((_has_bits_[0] & 0x00000001) != 0x00000001) return false;

  return true;
}

void GetTopicList::Swap(GetTopicList* other) {
  if (other == this) return;
  InternalSwap(other);
}
void GetTopicList::InternalSwap(GetTopicList* other) {
  topic_name_.Swap(&other->topic_name_);
  std::swap(_has_bits_[0], other->_has_bits_[0]);
  _internal_metadata_.Swap(&other->_internal_metadata_);
  std::swap(_cached_size_, other->_cached_size_);
}

::google::protobuf::Metadata GetTopicList::GetMetadata() const {
  protobuf_AssignDescriptorsOnce();
  ::google::protobuf::Metadata metadata;
  metadata.descriptor = GetTopicList_descriptor_;
  metadata.reflection = GetTopicList_reflection_;
  return metadata;
}

#if PROTOBUF_INLINE_NOT_IN_HEADERS
// GetTopicList

// required string topic_name = 1;
bool GetTopicList::has_topic_name() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
void GetTopicList::set_has_topic_name() {
  _has_bits_[0] |= 0x00000001u;
}
void GetTopicList::clear_has_topic_name() {
  _has_bits_[0] &= ~0x00000001u;
}
void GetTopicList::clear_topic_name() {
  topic_name_.ClearToEmptyNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
  clear_has_topic_name();
}
 const ::std::string& GetTopicList::topic_name() const {
  // @@protoc_insertion_point(field_get:mw.internal.robotics.gazebotransport.GetTopicList.topic_name)
  return topic_name_.GetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
 void GetTopicList::set_topic_name(const ::std::string& value) {
  set_has_topic_name();
  topic_name_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), value);
  // @@protoc_insertion_point(field_set:mw.internal.robotics.gazebotransport.GetTopicList.topic_name)
}
 void GetTopicList::set_topic_name(const char* value) {
  set_has_topic_name();
  topic_name_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::string(value));
  // @@protoc_insertion_point(field_set_char:mw.internal.robotics.gazebotransport.GetTopicList.topic_name)
}
 void GetTopicList::set_topic_name(const char* value, size_t size) {
  set_has_topic_name();
  topic_name_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(),
      ::std::string(reinterpret_cast<const char*>(value), size));
  // @@protoc_insertion_point(field_set_pointer:mw.internal.robotics.gazebotransport.GetTopicList.topic_name)
}
 ::std::string* GetTopicList::mutable_topic_name() {
  set_has_topic_name();
  // @@protoc_insertion_point(field_mutable:mw.internal.robotics.gazebotransport.GetTopicList.topic_name)
  return topic_name_.MutableNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
 ::std::string* GetTopicList::release_topic_name() {
  // @@protoc_insertion_point(field_release:mw.internal.robotics.gazebotransport.GetTopicList.topic_name)
  clear_has_topic_name();
  return topic_name_.ReleaseNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
 void GetTopicList::set_allocated_topic_name(::std::string* topic_name) {
  if (topic_name != NULL) {
    set_has_topic_name();
  } else {
    clear_has_topic_name();
  }
  topic_name_.SetAllocatedNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), topic_name);
  // @@protoc_insertion_point(field_set_allocated:mw.internal.robotics.gazebotransport.GetTopicList.topic_name)
}

#endif  // PROTOBUF_INLINE_NOT_IN_HEADERS

// ===================================================================

#if !defined(_MSC_VER) || _MSC_VER >= 1900
const int TopicList_TopicInfo::kNameFieldNumber;
const int TopicList_TopicInfo::kTypeFieldNumber;
#endif  // !defined(_MSC_VER) || _MSC_VER >= 1900

TopicList_TopicInfo::TopicList_TopicInfo()
  : ::google::protobuf::Message(), _internal_metadata_(NULL) {
  SharedCtor();
  // @@protoc_insertion_point(constructor:mw.internal.robotics.gazebotransport.TopicList.TopicInfo)
}

void TopicList_TopicInfo::InitAsDefaultInstance() {
}

TopicList_TopicInfo::TopicList_TopicInfo(const TopicList_TopicInfo& from)
  : ::google::protobuf::Message(),
    _internal_metadata_(NULL) {
  SharedCtor();
  MergeFrom(from);
  // @@protoc_insertion_point(copy_constructor:mw.internal.robotics.gazebotransport.TopicList.TopicInfo)
}

void TopicList_TopicInfo::SharedCtor() {
  ::google::protobuf::internal::GetEmptyString();
  _cached_size_ = 0;
  name_.UnsafeSetDefault(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
  type_.UnsafeSetDefault(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
  ::memset(_has_bits_, 0, sizeof(_has_bits_));
}

TopicList_TopicInfo::~TopicList_TopicInfo() {
  // @@protoc_insertion_point(destructor:mw.internal.robotics.gazebotransport.TopicList.TopicInfo)
  SharedDtor();
}

void TopicList_TopicInfo::SharedDtor() {
  name_.DestroyNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
  type_.DestroyNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
  if (this != default_instance_) {
  }
}

void TopicList_TopicInfo::SetCachedSize(int size) const {
  GOOGLE_SAFE_CONCURRENT_WRITES_BEGIN();
  _cached_size_ = size;
  GOOGLE_SAFE_CONCURRENT_WRITES_END();
}
const ::google::protobuf::Descriptor* TopicList_TopicInfo::descriptor() {
  protobuf_AssignDescriptorsOnce();
  return TopicList_TopicInfo_descriptor_;
}

const TopicList_TopicInfo& TopicList_TopicInfo::default_instance() {
  if (default_instance_ == NULL) protobuf_AddDesc_mw_2einternal_2erobotics_2egazebotransport_2eCoSimMsgs_2eproto();
  return *default_instance_;
}

TopicList_TopicInfo* TopicList_TopicInfo::default_instance_ = NULL;

TopicList_TopicInfo* TopicList_TopicInfo::New(::google::protobuf::Arena* arena) const {
  TopicList_TopicInfo* n = new TopicList_TopicInfo;
  if (arena != NULL) {
    arena->Own(n);
  }
  return n;
}

void TopicList_TopicInfo::Clear() {
// @@protoc_insertion_point(message_clear_start:mw.internal.robotics.gazebotransport.TopicList.TopicInfo)
  if (_has_bits_[0 / 32] & 3u) {
    if (has_name()) {
      name_.ClearToEmptyNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
    }
    if (has_type()) {
      type_.ClearToEmptyNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
    }
  }
  ::memset(_has_bits_, 0, sizeof(_has_bits_));
  if (_internal_metadata_.have_unknown_fields()) {
    mutable_unknown_fields()->Clear();
  }
}

bool TopicList_TopicInfo::MergePartialFromCodedStream(
    ::google::protobuf::io::CodedInputStream* input) {
#define DO_(EXPRESSION) if (!GOOGLE_PREDICT_TRUE(EXPRESSION)) goto failure
  ::google::protobuf::uint32 tag;
  // @@protoc_insertion_point(parse_start:mw.internal.robotics.gazebotransport.TopicList.TopicInfo)
  for (;;) {
    ::std::pair< ::google::protobuf::uint32, bool> p = input->ReadTagWithCutoff(127);
    tag = p.first;
    if (!p.second) goto handle_unusual;
    switch (::google::protobuf::internal::WireFormatLite::GetTagFieldNumber(tag)) {
      // required string name = 1;
      case 1: {
        if (tag == 10) {
          DO_(::google::protobuf::internal::WireFormatLite::ReadString(
                input, this->mutable_name()));
          ::google::protobuf::internal::WireFormat::VerifyUTF8StringNamedField(
            this->name().data(), this->name().length(),
            ::google::protobuf::internal::WireFormat::PARSE,
            "mw.internal.robotics.gazebotransport.TopicList.TopicInfo.name");
        } else {
          goto handle_unusual;
        }
        if (input->ExpectTag(18)) goto parse_type;
        break;
      }

      // required string type = 2;
      case 2: {
        if (tag == 18) {
         parse_type:
          DO_(::google::protobuf::internal::WireFormatLite::ReadString(
                input, this->mutable_type()));
          ::google::protobuf::internal::WireFormat::VerifyUTF8StringNamedField(
            this->type().data(), this->type().length(),
            ::google::protobuf::internal::WireFormat::PARSE,
            "mw.internal.robotics.gazebotransport.TopicList.TopicInfo.type");
        } else {
          goto handle_unusual;
        }
        if (input->ExpectAtEnd()) goto success;
        break;
      }

      default: {
      handle_unusual:
        if (tag == 0 ||
            ::google::protobuf::internal::WireFormatLite::GetTagWireType(tag) ==
            ::google::protobuf::internal::WireFormatLite::WIRETYPE_END_GROUP) {
          goto success;
        }
        DO_(::google::protobuf::internal::WireFormat::SkipField(
              input, tag, mutable_unknown_fields()));
        break;
      }
    }
  }
success:
  // @@protoc_insertion_point(parse_success:mw.internal.robotics.gazebotransport.TopicList.TopicInfo)
  return true;
failure:
  // @@protoc_insertion_point(parse_failure:mw.internal.robotics.gazebotransport.TopicList.TopicInfo)
  return false;
#undef DO_
}

void TopicList_TopicInfo::SerializeWithCachedSizes(
    ::google::protobuf::io::CodedOutputStream* output) const {
  // @@protoc_insertion_point(serialize_start:mw.internal.robotics.gazebotransport.TopicList.TopicInfo)
  // required string name = 1;
  if (has_name()) {
    ::google::protobuf::internal::WireFormat::VerifyUTF8StringNamedField(
      this->name().data(), this->name().length(),
      ::google::protobuf::internal::WireFormat::SERIALIZE,
      "mw.internal.robotics.gazebotransport.TopicList.TopicInfo.name");
    ::google::protobuf::internal::WireFormatLite::WriteStringMaybeAliased(
      1, this->name(), output);
  }

  // required string type = 2;
  if (has_type()) {
    ::google::protobuf::internal::WireFormat::VerifyUTF8StringNamedField(
      this->type().data(), this->type().length(),
      ::google::protobuf::internal::WireFormat::SERIALIZE,
      "mw.internal.robotics.gazebotransport.TopicList.TopicInfo.type");
    ::google::protobuf::internal::WireFormatLite::WriteStringMaybeAliased(
      2, this->type(), output);
  }

  if (_internal_metadata_.have_unknown_fields()) {
    ::google::protobuf::internal::WireFormat::SerializeUnknownFields(
        unknown_fields(), output);
  }
  // @@protoc_insertion_point(serialize_end:mw.internal.robotics.gazebotransport.TopicList.TopicInfo)
}

::google::protobuf::uint8* TopicList_TopicInfo::InternalSerializeWithCachedSizesToArray(
    bool deterministic, ::google::protobuf::uint8* target) const {
  // @@protoc_insertion_point(serialize_to_array_start:mw.internal.robotics.gazebotransport.TopicList.TopicInfo)
  // required string name = 1;
  if (has_name()) {
    ::google::protobuf::internal::WireFormat::VerifyUTF8StringNamedField(
      this->name().data(), this->name().length(),
      ::google::protobuf::internal::WireFormat::SERIALIZE,
      "mw.internal.robotics.gazebotransport.TopicList.TopicInfo.name");
    target =
      ::google::protobuf::internal::WireFormatLite::WriteStringToArray(
        1, this->name(), target);
  }

  // required string type = 2;
  if (has_type()) {
    ::google::protobuf::internal::WireFormat::VerifyUTF8StringNamedField(
      this->type().data(), this->type().length(),
      ::google::protobuf::internal::WireFormat::SERIALIZE,
      "mw.internal.robotics.gazebotransport.TopicList.TopicInfo.type");
    target =
      ::google::protobuf::internal::WireFormatLite::WriteStringToArray(
        2, this->type(), target);
  }

  if (_internal_metadata_.have_unknown_fields()) {
    target = ::google::protobuf::internal::WireFormat::SerializeUnknownFieldsToArray(
        unknown_fields(), target);
  }
  // @@protoc_insertion_point(serialize_to_array_end:mw.internal.robotics.gazebotransport.TopicList.TopicInfo)
  return target;
}

int TopicList_TopicInfo::RequiredFieldsByteSizeFallback() const {
// @@protoc_insertion_point(required_fields_byte_size_fallback_start:mw.internal.robotics.gazebotransport.TopicList.TopicInfo)
  int total_size = 0;

  if (has_name()) {
    // required string name = 1;
    total_size += 1 +
      ::google::protobuf::internal::WireFormatLite::StringSize(
        this->name());
  }

  if (has_type()) {
    // required string type = 2;
    total_size += 1 +
      ::google::protobuf::internal::WireFormatLite::StringSize(
        this->type());
  }

  return total_size;
}
int TopicList_TopicInfo::ByteSize() const {
// @@protoc_insertion_point(message_byte_size_start:mw.internal.robotics.gazebotransport.TopicList.TopicInfo)
  int total_size = 0;

  if (((_has_bits_[0] & 0x00000003) ^ 0x00000003) == 0) {  // All required fields are present.
    // required string name = 1;
    total_size += 1 +
      ::google::protobuf::internal::WireFormatLite::StringSize(
        this->name());

    // required string type = 2;
    total_size += 1 +
      ::google::protobuf::internal::WireFormatLite::StringSize(
        this->type());

  } else {
    total_size += RequiredFieldsByteSizeFallback();
  }
  if (_internal_metadata_.have_unknown_fields()) {
    total_size +=
      ::google::protobuf::internal::WireFormat::ComputeUnknownFieldsSize(
        unknown_fields());
  }
  GOOGLE_SAFE_CONCURRENT_WRITES_BEGIN();
  _cached_size_ = total_size;
  GOOGLE_SAFE_CONCURRENT_WRITES_END();
  return total_size;
}

void TopicList_TopicInfo::MergeFrom(const ::google::protobuf::Message& from) {
// @@protoc_insertion_point(generalized_merge_from_start:mw.internal.robotics.gazebotransport.TopicList.TopicInfo)
  if (GOOGLE_PREDICT_FALSE(&from == this)) {
    ::google::protobuf::internal::MergeFromFail(__FILE__, __LINE__);
  }
  const TopicList_TopicInfo* source = 
      ::google::protobuf::internal::DynamicCastToGenerated<const TopicList_TopicInfo>(
          &from);
  if (source == NULL) {
  // @@protoc_insertion_point(generalized_merge_from_cast_fail:mw.internal.robotics.gazebotransport.TopicList.TopicInfo)
    ::google::protobuf::internal::ReflectionOps::Merge(from, this);
  } else {
  // @@protoc_insertion_point(generalized_merge_from_cast_success:mw.internal.robotics.gazebotransport.TopicList.TopicInfo)
    MergeFrom(*source);
  }
}

void TopicList_TopicInfo::MergeFrom(const TopicList_TopicInfo& from) {
// @@protoc_insertion_point(class_specific_merge_from_start:mw.internal.robotics.gazebotransport.TopicList.TopicInfo)
  if (GOOGLE_PREDICT_FALSE(&from == this)) {
    ::google::protobuf::internal::MergeFromFail(__FILE__, __LINE__);
  }
  if (from._has_bits_[0 / 32] & (0xffu << (0 % 32))) {
    if (from.has_name()) {
      set_has_name();
      name_.AssignWithDefault(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), from.name_);
    }
    if (from.has_type()) {
      set_has_type();
      type_.AssignWithDefault(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), from.type_);
    }
  }
  if (from._internal_metadata_.have_unknown_fields()) {
    mutable_unknown_fields()->MergeFrom(from.unknown_fields());
  }
}

void TopicList_TopicInfo::CopyFrom(const ::google::protobuf::Message& from) {
// @@protoc_insertion_point(generalized_copy_from_start:mw.internal.robotics.gazebotransport.TopicList.TopicInfo)
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

void TopicList_TopicInfo::CopyFrom(const TopicList_TopicInfo& from) {
// @@protoc_insertion_point(class_specific_copy_from_start:mw.internal.robotics.gazebotransport.TopicList.TopicInfo)
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

bool TopicList_TopicInfo::IsInitialized() const {
  if ((_has_bits_[0] & 0x00000003) != 0x00000003) return false;

  return true;
}

void TopicList_TopicInfo::Swap(TopicList_TopicInfo* other) {
  if (other == this) return;
  InternalSwap(other);
}
void TopicList_TopicInfo::InternalSwap(TopicList_TopicInfo* other) {
  name_.Swap(&other->name_);
  type_.Swap(&other->type_);
  std::swap(_has_bits_[0], other->_has_bits_[0]);
  _internal_metadata_.Swap(&other->_internal_metadata_);
  std::swap(_cached_size_, other->_cached_size_);
}

::google::protobuf::Metadata TopicList_TopicInfo::GetMetadata() const {
  protobuf_AssignDescriptorsOnce();
  ::google::protobuf::Metadata metadata;
  metadata.descriptor = TopicList_TopicInfo_descriptor_;
  metadata.reflection = TopicList_TopicInfo_reflection_;
  return metadata;
}


// -------------------------------------------------------------------

#if !defined(_MSC_VER) || _MSC_VER >= 1900
const int TopicList::kDataFieldNumber;
#endif  // !defined(_MSC_VER) || _MSC_VER >= 1900

TopicList::TopicList()
  : ::google::protobuf::Message(), _internal_metadata_(NULL) {
  SharedCtor();
  // @@protoc_insertion_point(constructor:mw.internal.robotics.gazebotransport.TopicList)
}

void TopicList::InitAsDefaultInstance() {
}

TopicList::TopicList(const TopicList& from)
  : ::google::protobuf::Message(),
    _internal_metadata_(NULL) {
  SharedCtor();
  MergeFrom(from);
  // @@protoc_insertion_point(copy_constructor:mw.internal.robotics.gazebotransport.TopicList)
}

void TopicList::SharedCtor() {
  _cached_size_ = 0;
  ::memset(_has_bits_, 0, sizeof(_has_bits_));
}

TopicList::~TopicList() {
  // @@protoc_insertion_point(destructor:mw.internal.robotics.gazebotransport.TopicList)
  SharedDtor();
}

void TopicList::SharedDtor() {
  if (this != default_instance_) {
  }
}

void TopicList::SetCachedSize(int size) const {
  GOOGLE_SAFE_CONCURRENT_WRITES_BEGIN();
  _cached_size_ = size;
  GOOGLE_SAFE_CONCURRENT_WRITES_END();
}
const ::google::protobuf::Descriptor* TopicList::descriptor() {
  protobuf_AssignDescriptorsOnce();
  return TopicList_descriptor_;
}

const TopicList& TopicList::default_instance() {
  if (default_instance_ == NULL) protobuf_AddDesc_mw_2einternal_2erobotics_2egazebotransport_2eCoSimMsgs_2eproto();
  return *default_instance_;
}

TopicList* TopicList::default_instance_ = NULL;

TopicList* TopicList::New(::google::protobuf::Arena* arena) const {
  TopicList* n = new TopicList;
  if (arena != NULL) {
    arena->Own(n);
  }
  return n;
}

void TopicList::Clear() {
// @@protoc_insertion_point(message_clear_start:mw.internal.robotics.gazebotransport.TopicList)
  data_.Clear();
  ::memset(_has_bits_, 0, sizeof(_has_bits_));
  if (_internal_metadata_.have_unknown_fields()) {
    mutable_unknown_fields()->Clear();
  }
}

bool TopicList::MergePartialFromCodedStream(
    ::google::protobuf::io::CodedInputStream* input) {
#define DO_(EXPRESSION) if (!GOOGLE_PREDICT_TRUE(EXPRESSION)) goto failure
  ::google::protobuf::uint32 tag;
  // @@protoc_insertion_point(parse_start:mw.internal.robotics.gazebotransport.TopicList)
  for (;;) {
    ::std::pair< ::google::protobuf::uint32, bool> p = input->ReadTagWithCutoff(127);
    tag = p.first;
    if (!p.second) goto handle_unusual;
    switch (::google::protobuf::internal::WireFormatLite::GetTagFieldNumber(tag)) {
      // repeated .mw.internal.robotics.gazebotransport.TopicList.TopicInfo data = 1;
      case 1: {
        if (tag == 10) {
          DO_(input->IncrementRecursionDepth());
         parse_loop_data:
          DO_(::google::protobuf::internal::WireFormatLite::ReadMessageNoVirtualNoRecursionDepth(
                input, add_data()));
        } else {
          goto handle_unusual;
        }
        if (input->ExpectTag(10)) goto parse_loop_data;
        input->UnsafeDecrementRecursionDepth();
        if (input->ExpectAtEnd()) goto success;
        break;
      }

      default: {
      handle_unusual:
        if (tag == 0 ||
            ::google::protobuf::internal::WireFormatLite::GetTagWireType(tag) ==
            ::google::protobuf::internal::WireFormatLite::WIRETYPE_END_GROUP) {
          goto success;
        }
        DO_(::google::protobuf::internal::WireFormat::SkipField(
              input, tag, mutable_unknown_fields()));
        break;
      }
    }
  }
success:
  // @@protoc_insertion_point(parse_success:mw.internal.robotics.gazebotransport.TopicList)
  return true;
failure:
  // @@protoc_insertion_point(parse_failure:mw.internal.robotics.gazebotransport.TopicList)
  return false;
#undef DO_
}

void TopicList::SerializeWithCachedSizes(
    ::google::protobuf::io::CodedOutputStream* output) const {
  // @@protoc_insertion_point(serialize_start:mw.internal.robotics.gazebotransport.TopicList)
  // repeated .mw.internal.robotics.gazebotransport.TopicList.TopicInfo data = 1;
  for (unsigned int i = 0, n = this->data_size(); i < n; i++) {
    ::google::protobuf::internal::WireFormatLite::WriteMessageMaybeToArray(
      1, this->data(i), output);
  }

  if (_internal_metadata_.have_unknown_fields()) {
    ::google::protobuf::internal::WireFormat::SerializeUnknownFields(
        unknown_fields(), output);
  }
  // @@protoc_insertion_point(serialize_end:mw.internal.robotics.gazebotransport.TopicList)
}

::google::protobuf::uint8* TopicList::InternalSerializeWithCachedSizesToArray(
    bool deterministic, ::google::protobuf::uint8* target) const {
  // @@protoc_insertion_point(serialize_to_array_start:mw.internal.robotics.gazebotransport.TopicList)
  // repeated .mw.internal.robotics.gazebotransport.TopicList.TopicInfo data = 1;
  for (unsigned int i = 0, n = this->data_size(); i < n; i++) {
    target = ::google::protobuf::internal::WireFormatLite::
      InternalWriteMessageNoVirtualToArray(
        1, this->data(i), false, target);
  }

  if (_internal_metadata_.have_unknown_fields()) {
    target = ::google::protobuf::internal::WireFormat::SerializeUnknownFieldsToArray(
        unknown_fields(), target);
  }
  // @@protoc_insertion_point(serialize_to_array_end:mw.internal.robotics.gazebotransport.TopicList)
  return target;
}

int TopicList::ByteSize() const {
// @@protoc_insertion_point(message_byte_size_start:mw.internal.robotics.gazebotransport.TopicList)
  int total_size = 0;

  // repeated .mw.internal.robotics.gazebotransport.TopicList.TopicInfo data = 1;
  total_size += 1 * this->data_size();
  for (int i = 0; i < this->data_size(); i++) {
    total_size +=
      ::google::protobuf::internal::WireFormatLite::MessageSizeNoVirtual(
        this->data(i));
  }

  if (_internal_metadata_.have_unknown_fields()) {
    total_size +=
      ::google::protobuf::internal::WireFormat::ComputeUnknownFieldsSize(
        unknown_fields());
  }
  GOOGLE_SAFE_CONCURRENT_WRITES_BEGIN();
  _cached_size_ = total_size;
  GOOGLE_SAFE_CONCURRENT_WRITES_END();
  return total_size;
}

void TopicList::MergeFrom(const ::google::protobuf::Message& from) {
// @@protoc_insertion_point(generalized_merge_from_start:mw.internal.robotics.gazebotransport.TopicList)
  if (GOOGLE_PREDICT_FALSE(&from == this)) {
    ::google::protobuf::internal::MergeFromFail(__FILE__, __LINE__);
  }
  const TopicList* source = 
      ::google::protobuf::internal::DynamicCastToGenerated<const TopicList>(
          &from);
  if (source == NULL) {
  // @@protoc_insertion_point(generalized_merge_from_cast_fail:mw.internal.robotics.gazebotransport.TopicList)
    ::google::protobuf::internal::ReflectionOps::Merge(from, this);
  } else {
  // @@protoc_insertion_point(generalized_merge_from_cast_success:mw.internal.robotics.gazebotransport.TopicList)
    MergeFrom(*source);
  }
}

void TopicList::MergeFrom(const TopicList& from) {
// @@protoc_insertion_point(class_specific_merge_from_start:mw.internal.robotics.gazebotransport.TopicList)
  if (GOOGLE_PREDICT_FALSE(&from == this)) {
    ::google::protobuf::internal::MergeFromFail(__FILE__, __LINE__);
  }
  data_.MergeFrom(from.data_);
  if (from._internal_metadata_.have_unknown_fields()) {
    mutable_unknown_fields()->MergeFrom(from.unknown_fields());
  }
}

void TopicList::CopyFrom(const ::google::protobuf::Message& from) {
// @@protoc_insertion_point(generalized_copy_from_start:mw.internal.robotics.gazebotransport.TopicList)
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

void TopicList::CopyFrom(const TopicList& from) {
// @@protoc_insertion_point(class_specific_copy_from_start:mw.internal.robotics.gazebotransport.TopicList)
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

bool TopicList::IsInitialized() const {

  if (!::google::protobuf::internal::AllAreInitialized(this->data())) return false;
  return true;
}

void TopicList::Swap(TopicList* other) {
  if (other == this) return;
  InternalSwap(other);
}
void TopicList::InternalSwap(TopicList* other) {
  data_.UnsafeArenaSwap(&other->data_);
  std::swap(_has_bits_[0], other->_has_bits_[0]);
  _internal_metadata_.Swap(&other->_internal_metadata_);
  std::swap(_cached_size_, other->_cached_size_);
}

::google::protobuf::Metadata TopicList::GetMetadata() const {
  protobuf_AssignDescriptorsOnce();
  ::google::protobuf::Metadata metadata;
  metadata.descriptor = TopicList_descriptor_;
  metadata.reflection = TopicList_reflection_;
  return metadata;
}

#if PROTOBUF_INLINE_NOT_IN_HEADERS
// TopicList_TopicInfo

// required string name = 1;
bool TopicList_TopicInfo::has_name() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
void TopicList_TopicInfo::set_has_name() {
  _has_bits_[0] |= 0x00000001u;
}
void TopicList_TopicInfo::clear_has_name() {
  _has_bits_[0] &= ~0x00000001u;
}
void TopicList_TopicInfo::clear_name() {
  name_.ClearToEmptyNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
  clear_has_name();
}
 const ::std::string& TopicList_TopicInfo::name() const {
  // @@protoc_insertion_point(field_get:mw.internal.robotics.gazebotransport.TopicList.TopicInfo.name)
  return name_.GetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
 void TopicList_TopicInfo::set_name(const ::std::string& value) {
  set_has_name();
  name_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), value);
  // @@protoc_insertion_point(field_set:mw.internal.robotics.gazebotransport.TopicList.TopicInfo.name)
}
 void TopicList_TopicInfo::set_name(const char* value) {
  set_has_name();
  name_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::string(value));
  // @@protoc_insertion_point(field_set_char:mw.internal.robotics.gazebotransport.TopicList.TopicInfo.name)
}
 void TopicList_TopicInfo::set_name(const char* value, size_t size) {
  set_has_name();
  name_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(),
      ::std::string(reinterpret_cast<const char*>(value), size));
  // @@protoc_insertion_point(field_set_pointer:mw.internal.robotics.gazebotransport.TopicList.TopicInfo.name)
}
 ::std::string* TopicList_TopicInfo::mutable_name() {
  set_has_name();
  // @@protoc_insertion_point(field_mutable:mw.internal.robotics.gazebotransport.TopicList.TopicInfo.name)
  return name_.MutableNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
 ::std::string* TopicList_TopicInfo::release_name() {
  // @@protoc_insertion_point(field_release:mw.internal.robotics.gazebotransport.TopicList.TopicInfo.name)
  clear_has_name();
  return name_.ReleaseNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
 void TopicList_TopicInfo::set_allocated_name(::std::string* name) {
  if (name != NULL) {
    set_has_name();
  } else {
    clear_has_name();
  }
  name_.SetAllocatedNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), name);
  // @@protoc_insertion_point(field_set_allocated:mw.internal.robotics.gazebotransport.TopicList.TopicInfo.name)
}

// required string type = 2;
bool TopicList_TopicInfo::has_type() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
void TopicList_TopicInfo::set_has_type() {
  _has_bits_[0] |= 0x00000002u;
}
void TopicList_TopicInfo::clear_has_type() {
  _has_bits_[0] &= ~0x00000002u;
}
void TopicList_TopicInfo::clear_type() {
  type_.ClearToEmptyNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
  clear_has_type();
}
 const ::std::string& TopicList_TopicInfo::type() const {
  // @@protoc_insertion_point(field_get:mw.internal.robotics.gazebotransport.TopicList.TopicInfo.type)
  return type_.GetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
 void TopicList_TopicInfo::set_type(const ::std::string& value) {
  set_has_type();
  type_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), value);
  // @@protoc_insertion_point(field_set:mw.internal.robotics.gazebotransport.TopicList.TopicInfo.type)
}
 void TopicList_TopicInfo::set_type(const char* value) {
  set_has_type();
  type_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::string(value));
  // @@protoc_insertion_point(field_set_char:mw.internal.robotics.gazebotransport.TopicList.TopicInfo.type)
}
 void TopicList_TopicInfo::set_type(const char* value, size_t size) {
  set_has_type();
  type_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(),
      ::std::string(reinterpret_cast<const char*>(value), size));
  // @@protoc_insertion_point(field_set_pointer:mw.internal.robotics.gazebotransport.TopicList.TopicInfo.type)
}
 ::std::string* TopicList_TopicInfo::mutable_type() {
  set_has_type();
  // @@protoc_insertion_point(field_mutable:mw.internal.robotics.gazebotransport.TopicList.TopicInfo.type)
  return type_.MutableNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
 ::std::string* TopicList_TopicInfo::release_type() {
  // @@protoc_insertion_point(field_release:mw.internal.robotics.gazebotransport.TopicList.TopicInfo.type)
  clear_has_type();
  return type_.ReleaseNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
 void TopicList_TopicInfo::set_allocated_type(::std::string* type) {
  if (type != NULL) {
    set_has_type();
  } else {
    clear_has_type();
  }
  type_.SetAllocatedNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), type);
  // @@protoc_insertion_point(field_set_allocated:mw.internal.robotics.gazebotransport.TopicList.TopicInfo.type)
}

// -------------------------------------------------------------------

// TopicList

// repeated .mw.internal.robotics.gazebotransport.TopicList.TopicInfo data = 1;
int TopicList::data_size() const {
  return data_.size();
}
void TopicList::clear_data() {
  data_.Clear();
}
const ::mw::internal::robotics::gazebotransport::TopicList_TopicInfo& TopicList::data(int index) const {
  // @@protoc_insertion_point(field_get:mw.internal.robotics.gazebotransport.TopicList.data)
  return data_.Get(index);
}
::mw::internal::robotics::gazebotransport::TopicList_TopicInfo* TopicList::mutable_data(int index) {
  // @@protoc_insertion_point(field_mutable:mw.internal.robotics.gazebotransport.TopicList.data)
  return data_.Mutable(index);
}
::mw::internal::robotics::gazebotransport::TopicList_TopicInfo* TopicList::add_data() {
  // @@protoc_insertion_point(field_add:mw.internal.robotics.gazebotransport.TopicList.data)
  return data_.Add();
}
::google::protobuf::RepeatedPtrField< ::mw::internal::robotics::gazebotransport::TopicList_TopicInfo >*
TopicList::mutable_data() {
  // @@protoc_insertion_point(field_mutable_list:mw.internal.robotics.gazebotransport.TopicList.data)
  return &data_;
}
const ::google::protobuf::RepeatedPtrField< ::mw::internal::robotics::gazebotransport::TopicList_TopicInfo >&
TopicList::data() const {
  // @@protoc_insertion_point(field_list:mw.internal.robotics.gazebotransport.TopicList.data)
  return data_;
}

#endif  // PROTOBUF_INLINE_NOT_IN_HEADERS

// ===================================================================

#if !defined(_MSC_VER) || _MSC_VER >= 1900
const int GetModelInfo::kTopicNameFieldNumber;
#endif  // !defined(_MSC_VER) || _MSC_VER >= 1900

GetModelInfo::GetModelInfo()
  : ::google::protobuf::Message(), _internal_metadata_(NULL) {
  SharedCtor();
  // @@protoc_insertion_point(constructor:mw.internal.robotics.gazebotransport.GetModelInfo)
}

void GetModelInfo::InitAsDefaultInstance() {
}

GetModelInfo::GetModelInfo(const GetModelInfo& from)
  : ::google::protobuf::Message(),
    _internal_metadata_(NULL) {
  SharedCtor();
  MergeFrom(from);
  // @@protoc_insertion_point(copy_constructor:mw.internal.robotics.gazebotransport.GetModelInfo)
}

void GetModelInfo::SharedCtor() {
  ::google::protobuf::internal::GetEmptyString();
  _cached_size_ = 0;
  topic_name_.UnsafeSetDefault(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
  ::memset(_has_bits_, 0, sizeof(_has_bits_));
}

GetModelInfo::~GetModelInfo() {
  // @@protoc_insertion_point(destructor:mw.internal.robotics.gazebotransport.GetModelInfo)
  SharedDtor();
}

void GetModelInfo::SharedDtor() {
  topic_name_.DestroyNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
  if (this != default_instance_) {
  }
}

void GetModelInfo::SetCachedSize(int size) const {
  GOOGLE_SAFE_CONCURRENT_WRITES_BEGIN();
  _cached_size_ = size;
  GOOGLE_SAFE_CONCURRENT_WRITES_END();
}
const ::google::protobuf::Descriptor* GetModelInfo::descriptor() {
  protobuf_AssignDescriptorsOnce();
  return GetModelInfo_descriptor_;
}

const GetModelInfo& GetModelInfo::default_instance() {
  if (default_instance_ == NULL) protobuf_AddDesc_mw_2einternal_2erobotics_2egazebotransport_2eCoSimMsgs_2eproto();
  return *default_instance_;
}

GetModelInfo* GetModelInfo::default_instance_ = NULL;

GetModelInfo* GetModelInfo::New(::google::protobuf::Arena* arena) const {
  GetModelInfo* n = new GetModelInfo;
  if (arena != NULL) {
    arena->Own(n);
  }
  return n;
}

void GetModelInfo::Clear() {
// @@protoc_insertion_point(message_clear_start:mw.internal.robotics.gazebotransport.GetModelInfo)
  if (has_topic_name()) {
    topic_name_.ClearToEmptyNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
  }
  ::memset(_has_bits_, 0, sizeof(_has_bits_));
  if (_internal_metadata_.have_unknown_fields()) {
    mutable_unknown_fields()->Clear();
  }
}

bool GetModelInfo::MergePartialFromCodedStream(
    ::google::protobuf::io::CodedInputStream* input) {
#define DO_(EXPRESSION) if (!GOOGLE_PREDICT_TRUE(EXPRESSION)) goto failure
  ::google::protobuf::uint32 tag;
  // @@protoc_insertion_point(parse_start:mw.internal.robotics.gazebotransport.GetModelInfo)
  for (;;) {
    ::std::pair< ::google::protobuf::uint32, bool> p = input->ReadTagWithCutoff(127);
    tag = p.first;
    if (!p.second) goto handle_unusual;
    switch (::google::protobuf::internal::WireFormatLite::GetTagFieldNumber(tag)) {
      // required string topic_name = 1;
      case 1: {
        if (tag == 10) {
          DO_(::google::protobuf::internal::WireFormatLite::ReadString(
                input, this->mutable_topic_name()));
          ::google::protobuf::internal::WireFormat::VerifyUTF8StringNamedField(
            this->topic_name().data(), this->topic_name().length(),
            ::google::protobuf::internal::WireFormat::PARSE,
            "mw.internal.robotics.gazebotransport.GetModelInfo.topic_name");
        } else {
          goto handle_unusual;
        }
        if (input->ExpectAtEnd()) goto success;
        break;
      }

      default: {
      handle_unusual:
        if (tag == 0 ||
            ::google::protobuf::internal::WireFormatLite::GetTagWireType(tag) ==
            ::google::protobuf::internal::WireFormatLite::WIRETYPE_END_GROUP) {
          goto success;
        }
        DO_(::google::protobuf::internal::WireFormat::SkipField(
              input, tag, mutable_unknown_fields()));
        break;
      }
    }
  }
success:
  // @@protoc_insertion_point(parse_success:mw.internal.robotics.gazebotransport.GetModelInfo)
  return true;
failure:
  // @@protoc_insertion_point(parse_failure:mw.internal.robotics.gazebotransport.GetModelInfo)
  return false;
#undef DO_
}

void GetModelInfo::SerializeWithCachedSizes(
    ::google::protobuf::io::CodedOutputStream* output) const {
  // @@protoc_insertion_point(serialize_start:mw.internal.robotics.gazebotransport.GetModelInfo)
  // required string topic_name = 1;
  if (has_topic_name()) {
    ::google::protobuf::internal::WireFormat::VerifyUTF8StringNamedField(
      this->topic_name().data(), this->topic_name().length(),
      ::google::protobuf::internal::WireFormat::SERIALIZE,
      "mw.internal.robotics.gazebotransport.GetModelInfo.topic_name");
    ::google::protobuf::internal::WireFormatLite::WriteStringMaybeAliased(
      1, this->topic_name(), output);
  }

  if (_internal_metadata_.have_unknown_fields()) {
    ::google::protobuf::internal::WireFormat::SerializeUnknownFields(
        unknown_fields(), output);
  }
  // @@protoc_insertion_point(serialize_end:mw.internal.robotics.gazebotransport.GetModelInfo)
}

::google::protobuf::uint8* GetModelInfo::InternalSerializeWithCachedSizesToArray(
    bool deterministic, ::google::protobuf::uint8* target) const {
  // @@protoc_insertion_point(serialize_to_array_start:mw.internal.robotics.gazebotransport.GetModelInfo)
  // required string topic_name = 1;
  if (has_topic_name()) {
    ::google::protobuf::internal::WireFormat::VerifyUTF8StringNamedField(
      this->topic_name().data(), this->topic_name().length(),
      ::google::protobuf::internal::WireFormat::SERIALIZE,
      "mw.internal.robotics.gazebotransport.GetModelInfo.topic_name");
    target =
      ::google::protobuf::internal::WireFormatLite::WriteStringToArray(
        1, this->topic_name(), target);
  }

  if (_internal_metadata_.have_unknown_fields()) {
    target = ::google::protobuf::internal::WireFormat::SerializeUnknownFieldsToArray(
        unknown_fields(), target);
  }
  // @@protoc_insertion_point(serialize_to_array_end:mw.internal.robotics.gazebotransport.GetModelInfo)
  return target;
}

int GetModelInfo::ByteSize() const {
// @@protoc_insertion_point(message_byte_size_start:mw.internal.robotics.gazebotransport.GetModelInfo)
  int total_size = 0;

  // required string topic_name = 1;
  if (has_topic_name()) {
    total_size += 1 +
      ::google::protobuf::internal::WireFormatLite::StringSize(
        this->topic_name());
  }
  if (_internal_metadata_.have_unknown_fields()) {
    total_size +=
      ::google::protobuf::internal::WireFormat::ComputeUnknownFieldsSize(
        unknown_fields());
  }
  GOOGLE_SAFE_CONCURRENT_WRITES_BEGIN();
  _cached_size_ = total_size;
  GOOGLE_SAFE_CONCURRENT_WRITES_END();
  return total_size;
}

void GetModelInfo::MergeFrom(const ::google::protobuf::Message& from) {
// @@protoc_insertion_point(generalized_merge_from_start:mw.internal.robotics.gazebotransport.GetModelInfo)
  if (GOOGLE_PREDICT_FALSE(&from == this)) {
    ::google::protobuf::internal::MergeFromFail(__FILE__, __LINE__);
  }
  const GetModelInfo* source = 
      ::google::protobuf::internal::DynamicCastToGenerated<const GetModelInfo>(
          &from);
  if (source == NULL) {
  // @@protoc_insertion_point(generalized_merge_from_cast_fail:mw.internal.robotics.gazebotransport.GetModelInfo)
    ::google::protobuf::internal::ReflectionOps::Merge(from, this);
  } else {
  // @@protoc_insertion_point(generalized_merge_from_cast_success:mw.internal.robotics.gazebotransport.GetModelInfo)
    MergeFrom(*source);
  }
}

void GetModelInfo::MergeFrom(const GetModelInfo& from) {
// @@protoc_insertion_point(class_specific_merge_from_start:mw.internal.robotics.gazebotransport.GetModelInfo)
  if (GOOGLE_PREDICT_FALSE(&from == this)) {
    ::google::protobuf::internal::MergeFromFail(__FILE__, __LINE__);
  }
  if (from._has_bits_[0 / 32] & (0xffu << (0 % 32))) {
    if (from.has_topic_name()) {
      set_has_topic_name();
      topic_name_.AssignWithDefault(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), from.topic_name_);
    }
  }
  if (from._internal_metadata_.have_unknown_fields()) {
    mutable_unknown_fields()->MergeFrom(from.unknown_fields());
  }
}

void GetModelInfo::CopyFrom(const ::google::protobuf::Message& from) {
// @@protoc_insertion_point(generalized_copy_from_start:mw.internal.robotics.gazebotransport.GetModelInfo)
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

void GetModelInfo::CopyFrom(const GetModelInfo& from) {
// @@protoc_insertion_point(class_specific_copy_from_start:mw.internal.robotics.gazebotransport.GetModelInfo)
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

bool GetModelInfo::IsInitialized() const {
  if ((_has_bits_[0] & 0x00000001) != 0x00000001) return false;

  return true;
}

void GetModelInfo::Swap(GetModelInfo* other) {
  if (other == this) return;
  InternalSwap(other);
}
void GetModelInfo::InternalSwap(GetModelInfo* other) {
  topic_name_.Swap(&other->topic_name_);
  std::swap(_has_bits_[0], other->_has_bits_[0]);
  _internal_metadata_.Swap(&other->_internal_metadata_);
  std::swap(_cached_size_, other->_cached_size_);
}

::google::protobuf::Metadata GetModelInfo::GetMetadata() const {
  protobuf_AssignDescriptorsOnce();
  ::google::protobuf::Metadata metadata;
  metadata.descriptor = GetModelInfo_descriptor_;
  metadata.reflection = GetModelInfo_reflection_;
  return metadata;
}

#if PROTOBUF_INLINE_NOT_IN_HEADERS
// GetModelInfo

// required string topic_name = 1;
bool GetModelInfo::has_topic_name() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
void GetModelInfo::set_has_topic_name() {
  _has_bits_[0] |= 0x00000001u;
}
void GetModelInfo::clear_has_topic_name() {
  _has_bits_[0] &= ~0x00000001u;
}
void GetModelInfo::clear_topic_name() {
  topic_name_.ClearToEmptyNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
  clear_has_topic_name();
}
 const ::std::string& GetModelInfo::topic_name() const {
  // @@protoc_insertion_point(field_get:mw.internal.robotics.gazebotransport.GetModelInfo.topic_name)
  return topic_name_.GetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
 void GetModelInfo::set_topic_name(const ::std::string& value) {
  set_has_topic_name();
  topic_name_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), value);
  // @@protoc_insertion_point(field_set:mw.internal.robotics.gazebotransport.GetModelInfo.topic_name)
}
 void GetModelInfo::set_topic_name(const char* value) {
  set_has_topic_name();
  topic_name_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::string(value));
  // @@protoc_insertion_point(field_set_char:mw.internal.robotics.gazebotransport.GetModelInfo.topic_name)
}
 void GetModelInfo::set_topic_name(const char* value, size_t size) {
  set_has_topic_name();
  topic_name_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(),
      ::std::string(reinterpret_cast<const char*>(value), size));
  // @@protoc_insertion_point(field_set_pointer:mw.internal.robotics.gazebotransport.GetModelInfo.topic_name)
}
 ::std::string* GetModelInfo::mutable_topic_name() {
  set_has_topic_name();
  // @@protoc_insertion_point(field_mutable:mw.internal.robotics.gazebotransport.GetModelInfo.topic_name)
  return topic_name_.MutableNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
 ::std::string* GetModelInfo::release_topic_name() {
  // @@protoc_insertion_point(field_release:mw.internal.robotics.gazebotransport.GetModelInfo.topic_name)
  clear_has_topic_name();
  return topic_name_.ReleaseNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
 void GetModelInfo::set_allocated_topic_name(::std::string* topic_name) {
  if (topic_name != NULL) {
    set_has_topic_name();
  } else {
    clear_has_topic_name();
  }
  topic_name_.SetAllocatedNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), topic_name);
  // @@protoc_insertion_point(field_set_allocated:mw.internal.robotics.gazebotransport.GetModelInfo.topic_name)
}

#endif  // PROTOBUF_INLINE_NOT_IN_HEADERS

// ===================================================================

#if !defined(_MSC_VER) || _MSC_VER >= 1900
const int ModelInfo_LINKS::kLinkNameFieldNumber;
#endif  // !defined(_MSC_VER) || _MSC_VER >= 1900

ModelInfo_LINKS::ModelInfo_LINKS()
  : ::google::protobuf::Message(), _internal_metadata_(NULL) {
  SharedCtor();
  // @@protoc_insertion_point(constructor:mw.internal.robotics.gazebotransport.ModelInfo.LINKS)
}

void ModelInfo_LINKS::InitAsDefaultInstance() {
}

ModelInfo_LINKS::ModelInfo_LINKS(const ModelInfo_LINKS& from)
  : ::google::protobuf::Message(),
    _internal_metadata_(NULL) {
  SharedCtor();
  MergeFrom(from);
  // @@protoc_insertion_point(copy_constructor:mw.internal.robotics.gazebotransport.ModelInfo.LINKS)
}

void ModelInfo_LINKS::SharedCtor() {
  ::google::protobuf::internal::GetEmptyString();
  _cached_size_ = 0;
  ::memset(_has_bits_, 0, sizeof(_has_bits_));
}

ModelInfo_LINKS::~ModelInfo_LINKS() {
  // @@protoc_insertion_point(destructor:mw.internal.robotics.gazebotransport.ModelInfo.LINKS)
  SharedDtor();
}

void ModelInfo_LINKS::SharedDtor() {
  if (this != default_instance_) {
  }
}

void ModelInfo_LINKS::SetCachedSize(int size) const {
  GOOGLE_SAFE_CONCURRENT_WRITES_BEGIN();
  _cached_size_ = size;
  GOOGLE_SAFE_CONCURRENT_WRITES_END();
}
const ::google::protobuf::Descriptor* ModelInfo_LINKS::descriptor() {
  protobuf_AssignDescriptorsOnce();
  return ModelInfo_LINKS_descriptor_;
}

const ModelInfo_LINKS& ModelInfo_LINKS::default_instance() {
  if (default_instance_ == NULL) protobuf_AddDesc_mw_2einternal_2erobotics_2egazebotransport_2eCoSimMsgs_2eproto();
  return *default_instance_;
}

ModelInfo_LINKS* ModelInfo_LINKS::default_instance_ = NULL;

ModelInfo_LINKS* ModelInfo_LINKS::New(::google::protobuf::Arena* arena) const {
  ModelInfo_LINKS* n = new ModelInfo_LINKS;
  if (arena != NULL) {
    arena->Own(n);
  }
  return n;
}

void ModelInfo_LINKS::Clear() {
// @@protoc_insertion_point(message_clear_start:mw.internal.robotics.gazebotransport.ModelInfo.LINKS)
  link_name_.Clear();
  ::memset(_has_bits_, 0, sizeof(_has_bits_));
  if (_internal_metadata_.have_unknown_fields()) {
    mutable_unknown_fields()->Clear();
  }
}

bool ModelInfo_LINKS::MergePartialFromCodedStream(
    ::google::protobuf::io::CodedInputStream* input) {
#define DO_(EXPRESSION) if (!GOOGLE_PREDICT_TRUE(EXPRESSION)) goto failure
  ::google::protobuf::uint32 tag;
  // @@protoc_insertion_point(parse_start:mw.internal.robotics.gazebotransport.ModelInfo.LINKS)
  for (;;) {
    ::std::pair< ::google::protobuf::uint32, bool> p = input->ReadTagWithCutoff(127);
    tag = p.first;
    if (!p.second) goto handle_unusual;
    switch (::google::protobuf::internal::WireFormatLite::GetTagFieldNumber(tag)) {
      // repeated string link_name = 1;
      case 1: {
        if (tag == 10) {
         parse_link_name:
          DO_(::google::protobuf::internal::WireFormatLite::ReadString(
                input, this->add_link_name()));
          ::google::protobuf::internal::WireFormat::VerifyUTF8StringNamedField(
            this->link_name(this->link_name_size() - 1).data(),
            this->link_name(this->link_name_size() - 1).length(),
            ::google::protobuf::internal::WireFormat::PARSE,
            "mw.internal.robotics.gazebotransport.ModelInfo.LINKS.link_name");
        } else {
          goto handle_unusual;
        }
        if (input->ExpectTag(10)) goto parse_link_name;
        if (input->ExpectAtEnd()) goto success;
        break;
      }

      default: {
      handle_unusual:
        if (tag == 0 ||
            ::google::protobuf::internal::WireFormatLite::GetTagWireType(tag) ==
            ::google::protobuf::internal::WireFormatLite::WIRETYPE_END_GROUP) {
          goto success;
        }
        DO_(::google::protobuf::internal::WireFormat::SkipField(
              input, tag, mutable_unknown_fields()));
        break;
      }
    }
  }
success:
  // @@protoc_insertion_point(parse_success:mw.internal.robotics.gazebotransport.ModelInfo.LINKS)
  return true;
failure:
  // @@protoc_insertion_point(parse_failure:mw.internal.robotics.gazebotransport.ModelInfo.LINKS)
  return false;
#undef DO_
}

void ModelInfo_LINKS::SerializeWithCachedSizes(
    ::google::protobuf::io::CodedOutputStream* output) const {
  // @@protoc_insertion_point(serialize_start:mw.internal.robotics.gazebotransport.ModelInfo.LINKS)
  // repeated string link_name = 1;
  for (int i = 0; i < this->link_name_size(); i++) {
    ::google::protobuf::internal::WireFormat::VerifyUTF8StringNamedField(
      this->link_name(i).data(), this->link_name(i).length(),
      ::google::protobuf::internal::WireFormat::SERIALIZE,
      "mw.internal.robotics.gazebotransport.ModelInfo.LINKS.link_name");
    ::google::protobuf::internal::WireFormatLite::WriteString(
      1, this->link_name(i), output);
  }

  if (_internal_metadata_.have_unknown_fields()) {
    ::google::protobuf::internal::WireFormat::SerializeUnknownFields(
        unknown_fields(), output);
  }
  // @@protoc_insertion_point(serialize_end:mw.internal.robotics.gazebotransport.ModelInfo.LINKS)
}

::google::protobuf::uint8* ModelInfo_LINKS::InternalSerializeWithCachedSizesToArray(
    bool deterministic, ::google::protobuf::uint8* target) const {
  // @@protoc_insertion_point(serialize_to_array_start:mw.internal.robotics.gazebotransport.ModelInfo.LINKS)
  // repeated string link_name = 1;
  for (int i = 0; i < this->link_name_size(); i++) {
    ::google::protobuf::internal::WireFormat::VerifyUTF8StringNamedField(
      this->link_name(i).data(), this->link_name(i).length(),
      ::google::protobuf::internal::WireFormat::SERIALIZE,
      "mw.internal.robotics.gazebotransport.ModelInfo.LINKS.link_name");
    target = ::google::protobuf::internal::WireFormatLite::
      WriteStringToArray(1, this->link_name(i), target);
  }

  if (_internal_metadata_.have_unknown_fields()) {
    target = ::google::protobuf::internal::WireFormat::SerializeUnknownFieldsToArray(
        unknown_fields(), target);
  }
  // @@protoc_insertion_point(serialize_to_array_end:mw.internal.robotics.gazebotransport.ModelInfo.LINKS)
  return target;
}

int ModelInfo_LINKS::ByteSize() const {
// @@protoc_insertion_point(message_byte_size_start:mw.internal.robotics.gazebotransport.ModelInfo.LINKS)
  int total_size = 0;

  // repeated string link_name = 1;
  total_size += 1 * this->link_name_size();
  for (int i = 0; i < this->link_name_size(); i++) {
    total_size += ::google::protobuf::internal::WireFormatLite::StringSize(
      this->link_name(i));
  }

  if (_internal_metadata_.have_unknown_fields()) {
    total_size +=
      ::google::protobuf::internal::WireFormat::ComputeUnknownFieldsSize(
        unknown_fields());
  }
  GOOGLE_SAFE_CONCURRENT_WRITES_BEGIN();
  _cached_size_ = total_size;
  GOOGLE_SAFE_CONCURRENT_WRITES_END();
  return total_size;
}

void ModelInfo_LINKS::MergeFrom(const ::google::protobuf::Message& from) {
// @@protoc_insertion_point(generalized_merge_from_start:mw.internal.robotics.gazebotransport.ModelInfo.LINKS)
  if (GOOGLE_PREDICT_FALSE(&from == this)) {
    ::google::protobuf::internal::MergeFromFail(__FILE__, __LINE__);
  }
  const ModelInfo_LINKS* source = 
      ::google::protobuf::internal::DynamicCastToGenerated<const ModelInfo_LINKS>(
          &from);
  if (source == NULL) {
  // @@protoc_insertion_point(generalized_merge_from_cast_fail:mw.internal.robotics.gazebotransport.ModelInfo.LINKS)
    ::google::protobuf::internal::ReflectionOps::Merge(from, this);
  } else {
  // @@protoc_insertion_point(generalized_merge_from_cast_success:mw.internal.robotics.gazebotransport.ModelInfo.LINKS)
    MergeFrom(*source);
  }
}

void ModelInfo_LINKS::MergeFrom(const ModelInfo_LINKS& from) {
// @@protoc_insertion_point(class_specific_merge_from_start:mw.internal.robotics.gazebotransport.ModelInfo.LINKS)
  if (GOOGLE_PREDICT_FALSE(&from == this)) {
    ::google::protobuf::internal::MergeFromFail(__FILE__, __LINE__);
  }
  link_name_.MergeFrom(from.link_name_);
  if (from._internal_metadata_.have_unknown_fields()) {
    mutable_unknown_fields()->MergeFrom(from.unknown_fields());
  }
}

void ModelInfo_LINKS::CopyFrom(const ::google::protobuf::Message& from) {
// @@protoc_insertion_point(generalized_copy_from_start:mw.internal.robotics.gazebotransport.ModelInfo.LINKS)
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

void ModelInfo_LINKS::CopyFrom(const ModelInfo_LINKS& from) {
// @@protoc_insertion_point(class_specific_copy_from_start:mw.internal.robotics.gazebotransport.ModelInfo.LINKS)
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

bool ModelInfo_LINKS::IsInitialized() const {

  return true;
}

void ModelInfo_LINKS::Swap(ModelInfo_LINKS* other) {
  if (other == this) return;
  InternalSwap(other);
}
void ModelInfo_LINKS::InternalSwap(ModelInfo_LINKS* other) {
  link_name_.UnsafeArenaSwap(&other->link_name_);
  std::swap(_has_bits_[0], other->_has_bits_[0]);
  _internal_metadata_.Swap(&other->_internal_metadata_);
  std::swap(_cached_size_, other->_cached_size_);
}

::google::protobuf::Metadata ModelInfo_LINKS::GetMetadata() const {
  protobuf_AssignDescriptorsOnce();
  ::google::protobuf::Metadata metadata;
  metadata.descriptor = ModelInfo_LINKS_descriptor_;
  metadata.reflection = ModelInfo_LINKS_reflection_;
  return metadata;
}


// -------------------------------------------------------------------

#if !defined(_MSC_VER) || _MSC_VER >= 1900
const int ModelInfo_JOINTS::kJointNameFieldNumber;
#endif  // !defined(_MSC_VER) || _MSC_VER >= 1900

ModelInfo_JOINTS::ModelInfo_JOINTS()
  : ::google::protobuf::Message(), _internal_metadata_(NULL) {
  SharedCtor();
  // @@protoc_insertion_point(constructor:mw.internal.robotics.gazebotransport.ModelInfo.JOINTS)
}

void ModelInfo_JOINTS::InitAsDefaultInstance() {
}

ModelInfo_JOINTS::ModelInfo_JOINTS(const ModelInfo_JOINTS& from)
  : ::google::protobuf::Message(),
    _internal_metadata_(NULL) {
  SharedCtor();
  MergeFrom(from);
  // @@protoc_insertion_point(copy_constructor:mw.internal.robotics.gazebotransport.ModelInfo.JOINTS)
}

void ModelInfo_JOINTS::SharedCtor() {
  ::google::protobuf::internal::GetEmptyString();
  _cached_size_ = 0;
  ::memset(_has_bits_, 0, sizeof(_has_bits_));
}

ModelInfo_JOINTS::~ModelInfo_JOINTS() {
  // @@protoc_insertion_point(destructor:mw.internal.robotics.gazebotransport.ModelInfo.JOINTS)
  SharedDtor();
}

void ModelInfo_JOINTS::SharedDtor() {
  if (this != default_instance_) {
  }
}

void ModelInfo_JOINTS::SetCachedSize(int size) const {
  GOOGLE_SAFE_CONCURRENT_WRITES_BEGIN();
  _cached_size_ = size;
  GOOGLE_SAFE_CONCURRENT_WRITES_END();
}
const ::google::protobuf::Descriptor* ModelInfo_JOINTS::descriptor() {
  protobuf_AssignDescriptorsOnce();
  return ModelInfo_JOINTS_descriptor_;
}

const ModelInfo_JOINTS& ModelInfo_JOINTS::default_instance() {
  if (default_instance_ == NULL) protobuf_AddDesc_mw_2einternal_2erobotics_2egazebotransport_2eCoSimMsgs_2eproto();
  return *default_instance_;
}

ModelInfo_JOINTS* ModelInfo_JOINTS::default_instance_ = NULL;

ModelInfo_JOINTS* ModelInfo_JOINTS::New(::google::protobuf::Arena* arena) const {
  ModelInfo_JOINTS* n = new ModelInfo_JOINTS;
  if (arena != NULL) {
    arena->Own(n);
  }
  return n;
}

void ModelInfo_JOINTS::Clear() {
// @@protoc_insertion_point(message_clear_start:mw.internal.robotics.gazebotransport.ModelInfo.JOINTS)
  joint_name_.Clear();
  ::memset(_has_bits_, 0, sizeof(_has_bits_));
  if (_internal_metadata_.have_unknown_fields()) {
    mutable_unknown_fields()->Clear();
  }
}

bool ModelInfo_JOINTS::MergePartialFromCodedStream(
    ::google::protobuf::io::CodedInputStream* input) {
#define DO_(EXPRESSION) if (!GOOGLE_PREDICT_TRUE(EXPRESSION)) goto failure
  ::google::protobuf::uint32 tag;
  // @@protoc_insertion_point(parse_start:mw.internal.robotics.gazebotransport.ModelInfo.JOINTS)
  for (;;) {
    ::std::pair< ::google::protobuf::uint32, bool> p = input->ReadTagWithCutoff(127);
    tag = p.first;
    if (!p.second) goto handle_unusual;
    switch (::google::protobuf::internal::WireFormatLite::GetTagFieldNumber(tag)) {
      // repeated string joint_name = 1;
      case 1: {
        if (tag == 10) {
         parse_joint_name:
          DO_(::google::protobuf::internal::WireFormatLite::ReadString(
                input, this->add_joint_name()));
          ::google::protobuf::internal::WireFormat::VerifyUTF8StringNamedField(
            this->joint_name(this->joint_name_size() - 1).data(),
            this->joint_name(this->joint_name_size() - 1).length(),
            ::google::protobuf::internal::WireFormat::PARSE,
            "mw.internal.robotics.gazebotransport.ModelInfo.JOINTS.joint_name");
        } else {
          goto handle_unusual;
        }
        if (input->ExpectTag(10)) goto parse_joint_name;
        if (input->ExpectAtEnd()) goto success;
        break;
      }

      default: {
      handle_unusual:
        if (tag == 0 ||
            ::google::protobuf::internal::WireFormatLite::GetTagWireType(tag) ==
            ::google::protobuf::internal::WireFormatLite::WIRETYPE_END_GROUP) {
          goto success;
        }
        DO_(::google::protobuf::internal::WireFormat::SkipField(
              input, tag, mutable_unknown_fields()));
        break;
      }
    }
  }
success:
  // @@protoc_insertion_point(parse_success:mw.internal.robotics.gazebotransport.ModelInfo.JOINTS)
  return true;
failure:
  // @@protoc_insertion_point(parse_failure:mw.internal.robotics.gazebotransport.ModelInfo.JOINTS)
  return false;
#undef DO_
}

void ModelInfo_JOINTS::SerializeWithCachedSizes(
    ::google::protobuf::io::CodedOutputStream* output) const {
  // @@protoc_insertion_point(serialize_start:mw.internal.robotics.gazebotransport.ModelInfo.JOINTS)
  // repeated string joint_name = 1;
  for (int i = 0; i < this->joint_name_size(); i++) {
    ::google::protobuf::internal::WireFormat::VerifyUTF8StringNamedField(
      this->joint_name(i).data(), this->joint_name(i).length(),
      ::google::protobuf::internal::WireFormat::SERIALIZE,
      "mw.internal.robotics.gazebotransport.ModelInfo.JOINTS.joint_name");
    ::google::protobuf::internal::WireFormatLite::WriteString(
      1, this->joint_name(i), output);
  }

  if (_internal_metadata_.have_unknown_fields()) {
    ::google::protobuf::internal::WireFormat::SerializeUnknownFields(
        unknown_fields(), output);
  }
  // @@protoc_insertion_point(serialize_end:mw.internal.robotics.gazebotransport.ModelInfo.JOINTS)
}

::google::protobuf::uint8* ModelInfo_JOINTS::InternalSerializeWithCachedSizesToArray(
    bool deterministic, ::google::protobuf::uint8* target) const {
  // @@protoc_insertion_point(serialize_to_array_start:mw.internal.robotics.gazebotransport.ModelInfo.JOINTS)
  // repeated string joint_name = 1;
  for (int i = 0; i < this->joint_name_size(); i++) {
    ::google::protobuf::internal::WireFormat::VerifyUTF8StringNamedField(
      this->joint_name(i).data(), this->joint_name(i).length(),
      ::google::protobuf::internal::WireFormat::SERIALIZE,
      "mw.internal.robotics.gazebotransport.ModelInfo.JOINTS.joint_name");
    target = ::google::protobuf::internal::WireFormatLite::
      WriteStringToArray(1, this->joint_name(i), target);
  }

  if (_internal_metadata_.have_unknown_fields()) {
    target = ::google::protobuf::internal::WireFormat::SerializeUnknownFieldsToArray(
        unknown_fields(), target);
  }
  // @@protoc_insertion_point(serialize_to_array_end:mw.internal.robotics.gazebotransport.ModelInfo.JOINTS)
  return target;
}

int ModelInfo_JOINTS::ByteSize() const {
// @@protoc_insertion_point(message_byte_size_start:mw.internal.robotics.gazebotransport.ModelInfo.JOINTS)
  int total_size = 0;

  // repeated string joint_name = 1;
  total_size += 1 * this->joint_name_size();
  for (int i = 0; i < this->joint_name_size(); i++) {
    total_size += ::google::protobuf::internal::WireFormatLite::StringSize(
      this->joint_name(i));
  }

  if (_internal_metadata_.have_unknown_fields()) {
    total_size +=
      ::google::protobuf::internal::WireFormat::ComputeUnknownFieldsSize(
        unknown_fields());
  }
  GOOGLE_SAFE_CONCURRENT_WRITES_BEGIN();
  _cached_size_ = total_size;
  GOOGLE_SAFE_CONCURRENT_WRITES_END();
  return total_size;
}

void ModelInfo_JOINTS::MergeFrom(const ::google::protobuf::Message& from) {
// @@protoc_insertion_point(generalized_merge_from_start:mw.internal.robotics.gazebotransport.ModelInfo.JOINTS)
  if (GOOGLE_PREDICT_FALSE(&from == this)) {
    ::google::protobuf::internal::MergeFromFail(__FILE__, __LINE__);
  }
  const ModelInfo_JOINTS* source = 
      ::google::protobuf::internal::DynamicCastToGenerated<const ModelInfo_JOINTS>(
          &from);
  if (source == NULL) {
  // @@protoc_insertion_point(generalized_merge_from_cast_fail:mw.internal.robotics.gazebotransport.ModelInfo.JOINTS)
    ::google::protobuf::internal::ReflectionOps::Merge(from, this);
  } else {
  // @@protoc_insertion_point(generalized_merge_from_cast_success:mw.internal.robotics.gazebotransport.ModelInfo.JOINTS)
    MergeFrom(*source);
  }
}

void ModelInfo_JOINTS::MergeFrom(const ModelInfo_JOINTS& from) {
// @@protoc_insertion_point(class_specific_merge_from_start:mw.internal.robotics.gazebotransport.ModelInfo.JOINTS)
  if (GOOGLE_PREDICT_FALSE(&from == this)) {
    ::google::protobuf::internal::MergeFromFail(__FILE__, __LINE__);
  }
  joint_name_.MergeFrom(from.joint_name_);
  if (from._internal_metadata_.have_unknown_fields()) {
    mutable_unknown_fields()->MergeFrom(from.unknown_fields());
  }
}

void ModelInfo_JOINTS::CopyFrom(const ::google::protobuf::Message& from) {
// @@protoc_insertion_point(generalized_copy_from_start:mw.internal.robotics.gazebotransport.ModelInfo.JOINTS)
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

void ModelInfo_JOINTS::CopyFrom(const ModelInfo_JOINTS& from) {
// @@protoc_insertion_point(class_specific_copy_from_start:mw.internal.robotics.gazebotransport.ModelInfo.JOINTS)
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

bool ModelInfo_JOINTS::IsInitialized() const {

  return true;
}

void ModelInfo_JOINTS::Swap(ModelInfo_JOINTS* other) {
  if (other == this) return;
  InternalSwap(other);
}
void ModelInfo_JOINTS::InternalSwap(ModelInfo_JOINTS* other) {
  joint_name_.UnsafeArenaSwap(&other->joint_name_);
  std::swap(_has_bits_[0], other->_has_bits_[0]);
  _internal_metadata_.Swap(&other->_internal_metadata_);
  std::swap(_cached_size_, other->_cached_size_);
}

::google::protobuf::Metadata ModelInfo_JOINTS::GetMetadata() const {
  protobuf_AssignDescriptorsOnce();
  ::google::protobuf::Metadata metadata;
  metadata.descriptor = ModelInfo_JOINTS_descriptor_;
  metadata.reflection = ModelInfo_JOINTS_reflection_;
  return metadata;
}


// -------------------------------------------------------------------

#if !defined(_MSC_VER) || _MSC_VER >= 1900
const int ModelInfo_Model::kModelNameFieldNumber;
const int ModelInfo_Model::kLinksFieldNumber;
const int ModelInfo_Model::kJointsFieldNumber;
#endif  // !defined(_MSC_VER) || _MSC_VER >= 1900

ModelInfo_Model::ModelInfo_Model()
  : ::google::protobuf::Message(), _internal_metadata_(NULL) {
  SharedCtor();
  // @@protoc_insertion_point(constructor:mw.internal.robotics.gazebotransport.ModelInfo.Model)
}

void ModelInfo_Model::InitAsDefaultInstance() {
  links_ = const_cast< ::mw::internal::robotics::gazebotransport::ModelInfo_LINKS*>(&::mw::internal::robotics::gazebotransport::ModelInfo_LINKS::default_instance());
  joints_ = const_cast< ::mw::internal::robotics::gazebotransport::ModelInfo_JOINTS*>(&::mw::internal::robotics::gazebotransport::ModelInfo_JOINTS::default_instance());
}

ModelInfo_Model::ModelInfo_Model(const ModelInfo_Model& from)
  : ::google::protobuf::Message(),
    _internal_metadata_(NULL) {
  SharedCtor();
  MergeFrom(from);
  // @@protoc_insertion_point(copy_constructor:mw.internal.robotics.gazebotransport.ModelInfo.Model)
}

void ModelInfo_Model::SharedCtor() {
  ::google::protobuf::internal::GetEmptyString();
  _cached_size_ = 0;
  model_name_.UnsafeSetDefault(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
  links_ = NULL;
  joints_ = NULL;
  ::memset(_has_bits_, 0, sizeof(_has_bits_));
}

ModelInfo_Model::~ModelInfo_Model() {
  // @@protoc_insertion_point(destructor:mw.internal.robotics.gazebotransport.ModelInfo.Model)
  SharedDtor();
}

void ModelInfo_Model::SharedDtor() {
  model_name_.DestroyNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
  if (this != default_instance_) {
    delete links_;
    delete joints_;
  }
}

void ModelInfo_Model::SetCachedSize(int size) const {
  GOOGLE_SAFE_CONCURRENT_WRITES_BEGIN();
  _cached_size_ = size;
  GOOGLE_SAFE_CONCURRENT_WRITES_END();
}
const ::google::protobuf::Descriptor* ModelInfo_Model::descriptor() {
  protobuf_AssignDescriptorsOnce();
  return ModelInfo_Model_descriptor_;
}

const ModelInfo_Model& ModelInfo_Model::default_instance() {
  if (default_instance_ == NULL) protobuf_AddDesc_mw_2einternal_2erobotics_2egazebotransport_2eCoSimMsgs_2eproto();
  return *default_instance_;
}

ModelInfo_Model* ModelInfo_Model::default_instance_ = NULL;

ModelInfo_Model* ModelInfo_Model::New(::google::protobuf::Arena* arena) const {
  ModelInfo_Model* n = new ModelInfo_Model;
  if (arena != NULL) {
    arena->Own(n);
  }
  return n;
}

void ModelInfo_Model::Clear() {
// @@protoc_insertion_point(message_clear_start:mw.internal.robotics.gazebotransport.ModelInfo.Model)
  if (_has_bits_[0 / 32] & 7u) {
    if (has_model_name()) {
      model_name_.ClearToEmptyNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
    }
    if (has_links()) {
      if (links_ != NULL) links_->::mw::internal::robotics::gazebotransport::ModelInfo_LINKS::Clear();
    }
    if (has_joints()) {
      if (joints_ != NULL) joints_->::mw::internal::robotics::gazebotransport::ModelInfo_JOINTS::Clear();
    }
  }
  ::memset(_has_bits_, 0, sizeof(_has_bits_));
  if (_internal_metadata_.have_unknown_fields()) {
    mutable_unknown_fields()->Clear();
  }
}

bool ModelInfo_Model::MergePartialFromCodedStream(
    ::google::protobuf::io::CodedInputStream* input) {
#define DO_(EXPRESSION) if (!GOOGLE_PREDICT_TRUE(EXPRESSION)) goto failure
  ::google::protobuf::uint32 tag;
  // @@protoc_insertion_point(parse_start:mw.internal.robotics.gazebotransport.ModelInfo.Model)
  for (;;) {
    ::std::pair< ::google::protobuf::uint32, bool> p = input->ReadTagWithCutoff(127);
    tag = p.first;
    if (!p.second) goto handle_unusual;
    switch (::google::protobuf::internal::WireFormatLite::GetTagFieldNumber(tag)) {
      // required string model_name = 1;
      case 1: {
        if (tag == 10) {
          DO_(::google::protobuf::internal::WireFormatLite::ReadString(
                input, this->mutable_model_name()));
          ::google::protobuf::internal::WireFormat::VerifyUTF8StringNamedField(
            this->model_name().data(), this->model_name().length(),
            ::google::protobuf::internal::WireFormat::PARSE,
            "mw.internal.robotics.gazebotransport.ModelInfo.Model.model_name");
        } else {
          goto handle_unusual;
        }
        if (input->ExpectTag(18)) goto parse_links;
        break;
      }

      // optional .mw.internal.robotics.gazebotransport.ModelInfo.LINKS links = 2;
      case 2: {
        if (tag == 18) {
         parse_links:
          DO_(::google::protobuf::internal::WireFormatLite::ReadMessageNoVirtual(
               input, mutable_links()));
        } else {
          goto handle_unusual;
        }
        if (input->ExpectTag(26)) goto parse_joints;
        break;
      }

      // optional .mw.internal.robotics.gazebotransport.ModelInfo.JOINTS joints = 3;
      case 3: {
        if (tag == 26) {
         parse_joints:
          DO_(::google::protobuf::internal::WireFormatLite::ReadMessageNoVirtual(
               input, mutable_joints()));
        } else {
          goto handle_unusual;
        }
        if (input->ExpectAtEnd()) goto success;
        break;
      }

      default: {
      handle_unusual:
        if (tag == 0 ||
            ::google::protobuf::internal::WireFormatLite::GetTagWireType(tag) ==
            ::google::protobuf::internal::WireFormatLite::WIRETYPE_END_GROUP) {
          goto success;
        }
        DO_(::google::protobuf::internal::WireFormat::SkipField(
              input, tag, mutable_unknown_fields()));
        break;
      }
    }
  }
success:
  // @@protoc_insertion_point(parse_success:mw.internal.robotics.gazebotransport.ModelInfo.Model)
  return true;
failure:
  // @@protoc_insertion_point(parse_failure:mw.internal.robotics.gazebotransport.ModelInfo.Model)
  return false;
#undef DO_
}

void ModelInfo_Model::SerializeWithCachedSizes(
    ::google::protobuf::io::CodedOutputStream* output) const {
  // @@protoc_insertion_point(serialize_start:mw.internal.robotics.gazebotransport.ModelInfo.Model)
  // required string model_name = 1;
  if (has_model_name()) {
    ::google::protobuf::internal::WireFormat::VerifyUTF8StringNamedField(
      this->model_name().data(), this->model_name().length(),
      ::google::protobuf::internal::WireFormat::SERIALIZE,
      "mw.internal.robotics.gazebotransport.ModelInfo.Model.model_name");
    ::google::protobuf::internal::WireFormatLite::WriteStringMaybeAliased(
      1, this->model_name(), output);
  }

  // optional .mw.internal.robotics.gazebotransport.ModelInfo.LINKS links = 2;
  if (has_links()) {
    ::google::protobuf::internal::WireFormatLite::WriteMessageMaybeToArray(
      2, *this->links_, output);
  }

  // optional .mw.internal.robotics.gazebotransport.ModelInfo.JOINTS joints = 3;
  if (has_joints()) {
    ::google::protobuf::internal::WireFormatLite::WriteMessageMaybeToArray(
      3, *this->joints_, output);
  }

  if (_internal_metadata_.have_unknown_fields()) {
    ::google::protobuf::internal::WireFormat::SerializeUnknownFields(
        unknown_fields(), output);
  }
  // @@protoc_insertion_point(serialize_end:mw.internal.robotics.gazebotransport.ModelInfo.Model)
}

::google::protobuf::uint8* ModelInfo_Model::InternalSerializeWithCachedSizesToArray(
    bool deterministic, ::google::protobuf::uint8* target) const {
  // @@protoc_insertion_point(serialize_to_array_start:mw.internal.robotics.gazebotransport.ModelInfo.Model)
  // required string model_name = 1;
  if (has_model_name()) {
    ::google::protobuf::internal::WireFormat::VerifyUTF8StringNamedField(
      this->model_name().data(), this->model_name().length(),
      ::google::protobuf::internal::WireFormat::SERIALIZE,
      "mw.internal.robotics.gazebotransport.ModelInfo.Model.model_name");
    target =
      ::google::protobuf::internal::WireFormatLite::WriteStringToArray(
        1, this->model_name(), target);
  }

  // optional .mw.internal.robotics.gazebotransport.ModelInfo.LINKS links = 2;
  if (has_links()) {
    target = ::google::protobuf::internal::WireFormatLite::
      InternalWriteMessageNoVirtualToArray(
        2, *this->links_, false, target);
  }

  // optional .mw.internal.robotics.gazebotransport.ModelInfo.JOINTS joints = 3;
  if (has_joints()) {
    target = ::google::protobuf::internal::WireFormatLite::
      InternalWriteMessageNoVirtualToArray(
        3, *this->joints_, false, target);
  }

  if (_internal_metadata_.have_unknown_fields()) {
    target = ::google::protobuf::internal::WireFormat::SerializeUnknownFieldsToArray(
        unknown_fields(), target);
  }
  // @@protoc_insertion_point(serialize_to_array_end:mw.internal.robotics.gazebotransport.ModelInfo.Model)
  return target;
}

int ModelInfo_Model::ByteSize() const {
// @@protoc_insertion_point(message_byte_size_start:mw.internal.robotics.gazebotransport.ModelInfo.Model)
  int total_size = 0;

  // required string model_name = 1;
  if (has_model_name()) {
    total_size += 1 +
      ::google::protobuf::internal::WireFormatLite::StringSize(
        this->model_name());
  }
  if (_has_bits_[1 / 32] & 6u) {
    // optional .mw.internal.robotics.gazebotransport.ModelInfo.LINKS links = 2;
    if (has_links()) {
      total_size += 1 +
        ::google::protobuf::internal::WireFormatLite::MessageSizeNoVirtual(
          *this->links_);
    }

    // optional .mw.internal.robotics.gazebotransport.ModelInfo.JOINTS joints = 3;
    if (has_joints()) {
      total_size += 1 +
        ::google::protobuf::internal::WireFormatLite::MessageSizeNoVirtual(
          *this->joints_);
    }

  }
  if (_internal_metadata_.have_unknown_fields()) {
    total_size +=
      ::google::protobuf::internal::WireFormat::ComputeUnknownFieldsSize(
        unknown_fields());
  }
  GOOGLE_SAFE_CONCURRENT_WRITES_BEGIN();
  _cached_size_ = total_size;
  GOOGLE_SAFE_CONCURRENT_WRITES_END();
  return total_size;
}

void ModelInfo_Model::MergeFrom(const ::google::protobuf::Message& from) {
// @@protoc_insertion_point(generalized_merge_from_start:mw.internal.robotics.gazebotransport.ModelInfo.Model)
  if (GOOGLE_PREDICT_FALSE(&from == this)) {
    ::google::protobuf::internal::MergeFromFail(__FILE__, __LINE__);
  }
  const ModelInfo_Model* source = 
      ::google::protobuf::internal::DynamicCastToGenerated<const ModelInfo_Model>(
          &from);
  if (source == NULL) {
  // @@protoc_insertion_point(generalized_merge_from_cast_fail:mw.internal.robotics.gazebotransport.ModelInfo.Model)
    ::google::protobuf::internal::ReflectionOps::Merge(from, this);
  } else {
  // @@protoc_insertion_point(generalized_merge_from_cast_success:mw.internal.robotics.gazebotransport.ModelInfo.Model)
    MergeFrom(*source);
  }
}

void ModelInfo_Model::MergeFrom(const ModelInfo_Model& from) {
// @@protoc_insertion_point(class_specific_merge_from_start:mw.internal.robotics.gazebotransport.ModelInfo.Model)
  if (GOOGLE_PREDICT_FALSE(&from == this)) {
    ::google::protobuf::internal::MergeFromFail(__FILE__, __LINE__);
  }
  if (from._has_bits_[0 / 32] & (0xffu << (0 % 32))) {
    if (from.has_model_name()) {
      set_has_model_name();
      model_name_.AssignWithDefault(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), from.model_name_);
    }
    if (from.has_links()) {
      mutable_links()->::mw::internal::robotics::gazebotransport::ModelInfo_LINKS::MergeFrom(from.links());
    }
    if (from.has_joints()) {
      mutable_joints()->::mw::internal::robotics::gazebotransport::ModelInfo_JOINTS::MergeFrom(from.joints());
    }
  }
  if (from._internal_metadata_.have_unknown_fields()) {
    mutable_unknown_fields()->MergeFrom(from.unknown_fields());
  }
}

void ModelInfo_Model::CopyFrom(const ::google::protobuf::Message& from) {
// @@protoc_insertion_point(generalized_copy_from_start:mw.internal.robotics.gazebotransport.ModelInfo.Model)
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

void ModelInfo_Model::CopyFrom(const ModelInfo_Model& from) {
// @@protoc_insertion_point(class_specific_copy_from_start:mw.internal.robotics.gazebotransport.ModelInfo.Model)
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

bool ModelInfo_Model::IsInitialized() const {
  if ((_has_bits_[0] & 0x00000001) != 0x00000001) return false;

  return true;
}

void ModelInfo_Model::Swap(ModelInfo_Model* other) {
  if (other == this) return;
  InternalSwap(other);
}
void ModelInfo_Model::InternalSwap(ModelInfo_Model* other) {
  model_name_.Swap(&other->model_name_);
  std::swap(links_, other->links_);
  std::swap(joints_, other->joints_);
  std::swap(_has_bits_[0], other->_has_bits_[0]);
  _internal_metadata_.Swap(&other->_internal_metadata_);
  std::swap(_cached_size_, other->_cached_size_);
}

::google::protobuf::Metadata ModelInfo_Model::GetMetadata() const {
  protobuf_AssignDescriptorsOnce();
  ::google::protobuf::Metadata metadata;
  metadata.descriptor = ModelInfo_Model_descriptor_;
  metadata.reflection = ModelInfo_Model_reflection_;
  return metadata;
}


// -------------------------------------------------------------------

#if !defined(_MSC_VER) || _MSC_VER >= 1900
const int ModelInfo::kModelDataFieldNumber;
#endif  // !defined(_MSC_VER) || _MSC_VER >= 1900

ModelInfo::ModelInfo()
  : ::google::protobuf::Message(), _internal_metadata_(NULL) {
  SharedCtor();
  // @@protoc_insertion_point(constructor:mw.internal.robotics.gazebotransport.ModelInfo)
}

void ModelInfo::InitAsDefaultInstance() {
}

ModelInfo::ModelInfo(const ModelInfo& from)
  : ::google::protobuf::Message(),
    _internal_metadata_(NULL) {
  SharedCtor();
  MergeFrom(from);
  // @@protoc_insertion_point(copy_constructor:mw.internal.robotics.gazebotransport.ModelInfo)
}

void ModelInfo::SharedCtor() {
  _cached_size_ = 0;
  ::memset(_has_bits_, 0, sizeof(_has_bits_));
}

ModelInfo::~ModelInfo() {
  // @@protoc_insertion_point(destructor:mw.internal.robotics.gazebotransport.ModelInfo)
  SharedDtor();
}

void ModelInfo::SharedDtor() {
  if (this != default_instance_) {
  }
}

void ModelInfo::SetCachedSize(int size) const {
  GOOGLE_SAFE_CONCURRENT_WRITES_BEGIN();
  _cached_size_ = size;
  GOOGLE_SAFE_CONCURRENT_WRITES_END();
}
const ::google::protobuf::Descriptor* ModelInfo::descriptor() {
  protobuf_AssignDescriptorsOnce();
  return ModelInfo_descriptor_;
}

const ModelInfo& ModelInfo::default_instance() {
  if (default_instance_ == NULL) protobuf_AddDesc_mw_2einternal_2erobotics_2egazebotransport_2eCoSimMsgs_2eproto();
  return *default_instance_;
}

ModelInfo* ModelInfo::default_instance_ = NULL;

ModelInfo* ModelInfo::New(::google::protobuf::Arena* arena) const {
  ModelInfo* n = new ModelInfo;
  if (arena != NULL) {
    arena->Own(n);
  }
  return n;
}

void ModelInfo::Clear() {
// @@protoc_insertion_point(message_clear_start:mw.internal.robotics.gazebotransport.ModelInfo)
  model_data_.Clear();
  ::memset(_has_bits_, 0, sizeof(_has_bits_));
  if (_internal_metadata_.have_unknown_fields()) {
    mutable_unknown_fields()->Clear();
  }
}

bool ModelInfo::MergePartialFromCodedStream(
    ::google::protobuf::io::CodedInputStream* input) {
#define DO_(EXPRESSION) if (!GOOGLE_PREDICT_TRUE(EXPRESSION)) goto failure
  ::google::protobuf::uint32 tag;
  // @@protoc_insertion_point(parse_start:mw.internal.robotics.gazebotransport.ModelInfo)
  for (;;) {
    ::std::pair< ::google::protobuf::uint32, bool> p = input->ReadTagWithCutoff(127);
    tag = p.first;
    if (!p.second) goto handle_unusual;
    switch (::google::protobuf::internal::WireFormatLite::GetTagFieldNumber(tag)) {
      // repeated .mw.internal.robotics.gazebotransport.ModelInfo.Model model_data = 1;
      case 1: {
        if (tag == 10) {
          DO_(input->IncrementRecursionDepth());
         parse_loop_model_data:
          DO_(::google::protobuf::internal::WireFormatLite::ReadMessageNoVirtualNoRecursionDepth(
                input, add_model_data()));
        } else {
          goto handle_unusual;
        }
        if (input->ExpectTag(10)) goto parse_loop_model_data;
        input->UnsafeDecrementRecursionDepth();
        if (input->ExpectAtEnd()) goto success;
        break;
      }

      default: {
      handle_unusual:
        if (tag == 0 ||
            ::google::protobuf::internal::WireFormatLite::GetTagWireType(tag) ==
            ::google::protobuf::internal::WireFormatLite::WIRETYPE_END_GROUP) {
          goto success;
        }
        DO_(::google::protobuf::internal::WireFormat::SkipField(
              input, tag, mutable_unknown_fields()));
        break;
      }
    }
  }
success:
  // @@protoc_insertion_point(parse_success:mw.internal.robotics.gazebotransport.ModelInfo)
  return true;
failure:
  // @@protoc_insertion_point(parse_failure:mw.internal.robotics.gazebotransport.ModelInfo)
  return false;
#undef DO_
}

void ModelInfo::SerializeWithCachedSizes(
    ::google::protobuf::io::CodedOutputStream* output) const {
  // @@protoc_insertion_point(serialize_start:mw.internal.robotics.gazebotransport.ModelInfo)
  // repeated .mw.internal.robotics.gazebotransport.ModelInfo.Model model_data = 1;
  for (unsigned int i = 0, n = this->model_data_size(); i < n; i++) {
    ::google::protobuf::internal::WireFormatLite::WriteMessageMaybeToArray(
      1, this->model_data(i), output);
  }

  if (_internal_metadata_.have_unknown_fields()) {
    ::google::protobuf::internal::WireFormat::SerializeUnknownFields(
        unknown_fields(), output);
  }
  // @@protoc_insertion_point(serialize_end:mw.internal.robotics.gazebotransport.ModelInfo)
}

::google::protobuf::uint8* ModelInfo::InternalSerializeWithCachedSizesToArray(
    bool deterministic, ::google::protobuf::uint8* target) const {
  // @@protoc_insertion_point(serialize_to_array_start:mw.internal.robotics.gazebotransport.ModelInfo)
  // repeated .mw.internal.robotics.gazebotransport.ModelInfo.Model model_data = 1;
  for (unsigned int i = 0, n = this->model_data_size(); i < n; i++) {
    target = ::google::protobuf::internal::WireFormatLite::
      InternalWriteMessageNoVirtualToArray(
        1, this->model_data(i), false, target);
  }

  if (_internal_metadata_.have_unknown_fields()) {
    target = ::google::protobuf::internal::WireFormat::SerializeUnknownFieldsToArray(
        unknown_fields(), target);
  }
  // @@protoc_insertion_point(serialize_to_array_end:mw.internal.robotics.gazebotransport.ModelInfo)
  return target;
}

int ModelInfo::ByteSize() const {
// @@protoc_insertion_point(message_byte_size_start:mw.internal.robotics.gazebotransport.ModelInfo)
  int total_size = 0;

  // repeated .mw.internal.robotics.gazebotransport.ModelInfo.Model model_data = 1;
  total_size += 1 * this->model_data_size();
  for (int i = 0; i < this->model_data_size(); i++) {
    total_size +=
      ::google::protobuf::internal::WireFormatLite::MessageSizeNoVirtual(
        this->model_data(i));
  }

  if (_internal_metadata_.have_unknown_fields()) {
    total_size +=
      ::google::protobuf::internal::WireFormat::ComputeUnknownFieldsSize(
        unknown_fields());
  }
  GOOGLE_SAFE_CONCURRENT_WRITES_BEGIN();
  _cached_size_ = total_size;
  GOOGLE_SAFE_CONCURRENT_WRITES_END();
  return total_size;
}

void ModelInfo::MergeFrom(const ::google::protobuf::Message& from) {
// @@protoc_insertion_point(generalized_merge_from_start:mw.internal.robotics.gazebotransport.ModelInfo)
  if (GOOGLE_PREDICT_FALSE(&from == this)) {
    ::google::protobuf::internal::MergeFromFail(__FILE__, __LINE__);
  }
  const ModelInfo* source = 
      ::google::protobuf::internal::DynamicCastToGenerated<const ModelInfo>(
          &from);
  if (source == NULL) {
  // @@protoc_insertion_point(generalized_merge_from_cast_fail:mw.internal.robotics.gazebotransport.ModelInfo)
    ::google::protobuf::internal::ReflectionOps::Merge(from, this);
  } else {
  // @@protoc_insertion_point(generalized_merge_from_cast_success:mw.internal.robotics.gazebotransport.ModelInfo)
    MergeFrom(*source);
  }
}

void ModelInfo::MergeFrom(const ModelInfo& from) {
// @@protoc_insertion_point(class_specific_merge_from_start:mw.internal.robotics.gazebotransport.ModelInfo)
  if (GOOGLE_PREDICT_FALSE(&from == this)) {
    ::google::protobuf::internal::MergeFromFail(__FILE__, __LINE__);
  }
  model_data_.MergeFrom(from.model_data_);
  if (from._internal_metadata_.have_unknown_fields()) {
    mutable_unknown_fields()->MergeFrom(from.unknown_fields());
  }
}

void ModelInfo::CopyFrom(const ::google::protobuf::Message& from) {
// @@protoc_insertion_point(generalized_copy_from_start:mw.internal.robotics.gazebotransport.ModelInfo)
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

void ModelInfo::CopyFrom(const ModelInfo& from) {
// @@protoc_insertion_point(class_specific_copy_from_start:mw.internal.robotics.gazebotransport.ModelInfo)
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

bool ModelInfo::IsInitialized() const {

  if (!::google::protobuf::internal::AllAreInitialized(this->model_data())) return false;
  return true;
}

void ModelInfo::Swap(ModelInfo* other) {
  if (other == this) return;
  InternalSwap(other);
}
void ModelInfo::InternalSwap(ModelInfo* other) {
  model_data_.UnsafeArenaSwap(&other->model_data_);
  std::swap(_has_bits_[0], other->_has_bits_[0]);
  _internal_metadata_.Swap(&other->_internal_metadata_);
  std::swap(_cached_size_, other->_cached_size_);
}

::google::protobuf::Metadata ModelInfo::GetMetadata() const {
  protobuf_AssignDescriptorsOnce();
  ::google::protobuf::Metadata metadata;
  metadata.descriptor = ModelInfo_descriptor_;
  metadata.reflection = ModelInfo_reflection_;
  return metadata;
}

#if PROTOBUF_INLINE_NOT_IN_HEADERS
// ModelInfo_LINKS

// repeated string link_name = 1;
int ModelInfo_LINKS::link_name_size() const {
  return link_name_.size();
}
void ModelInfo_LINKS::clear_link_name() {
  link_name_.Clear();
}
 const ::std::string& ModelInfo_LINKS::link_name(int index) const {
  // @@protoc_insertion_point(field_get:mw.internal.robotics.gazebotransport.ModelInfo.LINKS.link_name)
  return link_name_.Get(index);
}
 ::std::string* ModelInfo_LINKS::mutable_link_name(int index) {
  // @@protoc_insertion_point(field_mutable:mw.internal.robotics.gazebotransport.ModelInfo.LINKS.link_name)
  return link_name_.Mutable(index);
}
 void ModelInfo_LINKS::set_link_name(int index, const ::std::string& value) {
  // @@protoc_insertion_point(field_set:mw.internal.robotics.gazebotransport.ModelInfo.LINKS.link_name)
  link_name_.Mutable(index)->assign(value);
}
 void ModelInfo_LINKS::set_link_name(int index, const char* value) {
  link_name_.Mutable(index)->assign(value);
  // @@protoc_insertion_point(field_set_char:mw.internal.robotics.gazebotransport.ModelInfo.LINKS.link_name)
}
 void ModelInfo_LINKS::set_link_name(int index, const char* value, size_t size) {
  link_name_.Mutable(index)->assign(
    reinterpret_cast<const char*>(value), size);
  // @@protoc_insertion_point(field_set_pointer:mw.internal.robotics.gazebotransport.ModelInfo.LINKS.link_name)
}
 ::std::string* ModelInfo_LINKS::add_link_name() {
  // @@protoc_insertion_point(field_add_mutable:mw.internal.robotics.gazebotransport.ModelInfo.LINKS.link_name)
  return link_name_.Add();
}
 void ModelInfo_LINKS::add_link_name(const ::std::string& value) {
  link_name_.Add()->assign(value);
  // @@protoc_insertion_point(field_add:mw.internal.robotics.gazebotransport.ModelInfo.LINKS.link_name)
}
 void ModelInfo_LINKS::add_link_name(const char* value) {
  link_name_.Add()->assign(value);
  // @@protoc_insertion_point(field_add_char:mw.internal.robotics.gazebotransport.ModelInfo.LINKS.link_name)
}
 void ModelInfo_LINKS::add_link_name(const char* value, size_t size) {
  link_name_.Add()->assign(reinterpret_cast<const char*>(value), size);
  // @@protoc_insertion_point(field_add_pointer:mw.internal.robotics.gazebotransport.ModelInfo.LINKS.link_name)
}
 const ::google::protobuf::RepeatedPtrField< ::std::string>&
ModelInfo_LINKS::link_name() const {
  // @@protoc_insertion_point(field_list:mw.internal.robotics.gazebotransport.ModelInfo.LINKS.link_name)
  return link_name_;
}
 ::google::protobuf::RepeatedPtrField< ::std::string>*
ModelInfo_LINKS::mutable_link_name() {
  // @@protoc_insertion_point(field_mutable_list:mw.internal.robotics.gazebotransport.ModelInfo.LINKS.link_name)
  return &link_name_;
}

// -------------------------------------------------------------------

// ModelInfo_JOINTS

// repeated string joint_name = 1;
int ModelInfo_JOINTS::joint_name_size() const {
  return joint_name_.size();
}
void ModelInfo_JOINTS::clear_joint_name() {
  joint_name_.Clear();
}
 const ::std::string& ModelInfo_JOINTS::joint_name(int index) const {
  // @@protoc_insertion_point(field_get:mw.internal.robotics.gazebotransport.ModelInfo.JOINTS.joint_name)
  return joint_name_.Get(index);
}
 ::std::string* ModelInfo_JOINTS::mutable_joint_name(int index) {
  // @@protoc_insertion_point(field_mutable:mw.internal.robotics.gazebotransport.ModelInfo.JOINTS.joint_name)
  return joint_name_.Mutable(index);
}
 void ModelInfo_JOINTS::set_joint_name(int index, const ::std::string& value) {
  // @@protoc_insertion_point(field_set:mw.internal.robotics.gazebotransport.ModelInfo.JOINTS.joint_name)
  joint_name_.Mutable(index)->assign(value);
}
 void ModelInfo_JOINTS::set_joint_name(int index, const char* value) {
  joint_name_.Mutable(index)->assign(value);
  // @@protoc_insertion_point(field_set_char:mw.internal.robotics.gazebotransport.ModelInfo.JOINTS.joint_name)
}
 void ModelInfo_JOINTS::set_joint_name(int index, const char* value, size_t size) {
  joint_name_.Mutable(index)->assign(
    reinterpret_cast<const char*>(value), size);
  // @@protoc_insertion_point(field_set_pointer:mw.internal.robotics.gazebotransport.ModelInfo.JOINTS.joint_name)
}
 ::std::string* ModelInfo_JOINTS::add_joint_name() {
  // @@protoc_insertion_point(field_add_mutable:mw.internal.robotics.gazebotransport.ModelInfo.JOINTS.joint_name)
  return joint_name_.Add();
}
 void ModelInfo_JOINTS::add_joint_name(const ::std::string& value) {
  joint_name_.Add()->assign(value);
  // @@protoc_insertion_point(field_add:mw.internal.robotics.gazebotransport.ModelInfo.JOINTS.joint_name)
}
 void ModelInfo_JOINTS::add_joint_name(const char* value) {
  joint_name_.Add()->assign(value);
  // @@protoc_insertion_point(field_add_char:mw.internal.robotics.gazebotransport.ModelInfo.JOINTS.joint_name)
}
 void ModelInfo_JOINTS::add_joint_name(const char* value, size_t size) {
  joint_name_.Add()->assign(reinterpret_cast<const char*>(value), size);
  // @@protoc_insertion_point(field_add_pointer:mw.internal.robotics.gazebotransport.ModelInfo.JOINTS.joint_name)
}
 const ::google::protobuf::RepeatedPtrField< ::std::string>&
ModelInfo_JOINTS::joint_name() const {
  // @@protoc_insertion_point(field_list:mw.internal.robotics.gazebotransport.ModelInfo.JOINTS.joint_name)
  return joint_name_;
}
 ::google::protobuf::RepeatedPtrField< ::std::string>*
ModelInfo_JOINTS::mutable_joint_name() {
  // @@protoc_insertion_point(field_mutable_list:mw.internal.robotics.gazebotransport.ModelInfo.JOINTS.joint_name)
  return &joint_name_;
}

// -------------------------------------------------------------------

// ModelInfo_Model

// required string model_name = 1;
bool ModelInfo_Model::has_model_name() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
void ModelInfo_Model::set_has_model_name() {
  _has_bits_[0] |= 0x00000001u;
}
void ModelInfo_Model::clear_has_model_name() {
  _has_bits_[0] &= ~0x00000001u;
}
void ModelInfo_Model::clear_model_name() {
  model_name_.ClearToEmptyNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
  clear_has_model_name();
}
 const ::std::string& ModelInfo_Model::model_name() const {
  // @@protoc_insertion_point(field_get:mw.internal.robotics.gazebotransport.ModelInfo.Model.model_name)
  return model_name_.GetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
 void ModelInfo_Model::set_model_name(const ::std::string& value) {
  set_has_model_name();
  model_name_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), value);
  // @@protoc_insertion_point(field_set:mw.internal.robotics.gazebotransport.ModelInfo.Model.model_name)
}
 void ModelInfo_Model::set_model_name(const char* value) {
  set_has_model_name();
  model_name_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::string(value));
  // @@protoc_insertion_point(field_set_char:mw.internal.robotics.gazebotransport.ModelInfo.Model.model_name)
}
 void ModelInfo_Model::set_model_name(const char* value, size_t size) {
  set_has_model_name();
  model_name_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(),
      ::std::string(reinterpret_cast<const char*>(value), size));
  // @@protoc_insertion_point(field_set_pointer:mw.internal.robotics.gazebotransport.ModelInfo.Model.model_name)
}
 ::std::string* ModelInfo_Model::mutable_model_name() {
  set_has_model_name();
  // @@protoc_insertion_point(field_mutable:mw.internal.robotics.gazebotransport.ModelInfo.Model.model_name)
  return model_name_.MutableNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
 ::std::string* ModelInfo_Model::release_model_name() {
  // @@protoc_insertion_point(field_release:mw.internal.robotics.gazebotransport.ModelInfo.Model.model_name)
  clear_has_model_name();
  return model_name_.ReleaseNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
 void ModelInfo_Model::set_allocated_model_name(::std::string* model_name) {
  if (model_name != NULL) {
    set_has_model_name();
  } else {
    clear_has_model_name();
  }
  model_name_.SetAllocatedNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), model_name);
  // @@protoc_insertion_point(field_set_allocated:mw.internal.robotics.gazebotransport.ModelInfo.Model.model_name)
}

// optional .mw.internal.robotics.gazebotransport.ModelInfo.LINKS links = 2;
bool ModelInfo_Model::has_links() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
void ModelInfo_Model::set_has_links() {
  _has_bits_[0] |= 0x00000002u;
}
void ModelInfo_Model::clear_has_links() {
  _has_bits_[0] &= ~0x00000002u;
}
void ModelInfo_Model::clear_links() {
  if (links_ != NULL) links_->::mw::internal::robotics::gazebotransport::ModelInfo_LINKS::Clear();
  clear_has_links();
}
const ::mw::internal::robotics::gazebotransport::ModelInfo_LINKS& ModelInfo_Model::links() const {
  // @@protoc_insertion_point(field_get:mw.internal.robotics.gazebotransport.ModelInfo.Model.links)
  return links_ != NULL ? *links_ : *default_instance_->links_;
}
::mw::internal::robotics::gazebotransport::ModelInfo_LINKS* ModelInfo_Model::mutable_links() {
  set_has_links();
  if (links_ == NULL) {
    links_ = new ::mw::internal::robotics::gazebotransport::ModelInfo_LINKS;
  }
  // @@protoc_insertion_point(field_mutable:mw.internal.robotics.gazebotransport.ModelInfo.Model.links)
  return links_;
}
::mw::internal::robotics::gazebotransport::ModelInfo_LINKS* ModelInfo_Model::release_links() {
  // @@protoc_insertion_point(field_release:mw.internal.robotics.gazebotransport.ModelInfo.Model.links)
  clear_has_links();
  ::mw::internal::robotics::gazebotransport::ModelInfo_LINKS* temp = links_;
  links_ = NULL;
  return temp;
}
void ModelInfo_Model::set_allocated_links(::mw::internal::robotics::gazebotransport::ModelInfo_LINKS* links) {
  delete links_;
  links_ = links;
  if (links) {
    set_has_links();
  } else {
    clear_has_links();
  }
  // @@protoc_insertion_point(field_set_allocated:mw.internal.robotics.gazebotransport.ModelInfo.Model.links)
}

// optional .mw.internal.robotics.gazebotransport.ModelInfo.JOINTS joints = 3;
bool ModelInfo_Model::has_joints() const {
  return (_has_bits_[0] & 0x00000004u) != 0;
}
void ModelInfo_Model::set_has_joints() {
  _has_bits_[0] |= 0x00000004u;
}
void ModelInfo_Model::clear_has_joints() {
  _has_bits_[0] &= ~0x00000004u;
}
void ModelInfo_Model::clear_joints() {
  if (joints_ != NULL) joints_->::mw::internal::robotics::gazebotransport::ModelInfo_JOINTS::Clear();
  clear_has_joints();
}
const ::mw::internal::robotics::gazebotransport::ModelInfo_JOINTS& ModelInfo_Model::joints() const {
  // @@protoc_insertion_point(field_get:mw.internal.robotics.gazebotransport.ModelInfo.Model.joints)
  return joints_ != NULL ? *joints_ : *default_instance_->joints_;
}
::mw::internal::robotics::gazebotransport::ModelInfo_JOINTS* ModelInfo_Model::mutable_joints() {
  set_has_joints();
  if (joints_ == NULL) {
    joints_ = new ::mw::internal::robotics::gazebotransport::ModelInfo_JOINTS;
  }
  // @@protoc_insertion_point(field_mutable:mw.internal.robotics.gazebotransport.ModelInfo.Model.joints)
  return joints_;
}
::mw::internal::robotics::gazebotransport::ModelInfo_JOINTS* ModelInfo_Model::release_joints() {
  // @@protoc_insertion_point(field_release:mw.internal.robotics.gazebotransport.ModelInfo.Model.joints)
  clear_has_joints();
  ::mw::internal::robotics::gazebotransport::ModelInfo_JOINTS* temp = joints_;
  joints_ = NULL;
  return temp;
}
void ModelInfo_Model::set_allocated_joints(::mw::internal::robotics::gazebotransport::ModelInfo_JOINTS* joints) {
  delete joints_;
  joints_ = joints;
  if (joints) {
    set_has_joints();
  } else {
    clear_has_joints();
  }
  // @@protoc_insertion_point(field_set_allocated:mw.internal.robotics.gazebotransport.ModelInfo.Model.joints)
}

// -------------------------------------------------------------------

// ModelInfo

// repeated .mw.internal.robotics.gazebotransport.ModelInfo.Model model_data = 1;
int ModelInfo::model_data_size() const {
  return model_data_.size();
}
void ModelInfo::clear_model_data() {
  model_data_.Clear();
}
const ::mw::internal::robotics::gazebotransport::ModelInfo_Model& ModelInfo::model_data(int index) const {
  // @@protoc_insertion_point(field_get:mw.internal.robotics.gazebotransport.ModelInfo.model_data)
  return model_data_.Get(index);
}
::mw::internal::robotics::gazebotransport::ModelInfo_Model* ModelInfo::mutable_model_data(int index) {
  // @@protoc_insertion_point(field_mutable:mw.internal.robotics.gazebotransport.ModelInfo.model_data)
  return model_data_.Mutable(index);
}
::mw::internal::robotics::gazebotransport::ModelInfo_Model* ModelInfo::add_model_data() {
  // @@protoc_insertion_point(field_add:mw.internal.robotics.gazebotransport.ModelInfo.model_data)
  return model_data_.Add();
}
::google::protobuf::RepeatedPtrField< ::mw::internal::robotics::gazebotransport::ModelInfo_Model >*
ModelInfo::mutable_model_data() {
  // @@protoc_insertion_point(field_mutable_list:mw.internal.robotics.gazebotransport.ModelInfo.model_data)
  return &model_data_;
}
const ::google::protobuf::RepeatedPtrField< ::mw::internal::robotics::gazebotransport::ModelInfo_Model >&
ModelInfo::model_data() const {
  // @@protoc_insertion_point(field_list:mw.internal.robotics.gazebotransport.ModelInfo.model_data)
  return model_data_;
}

#endif  // PROTOBUF_INLINE_NOT_IN_HEADERS

// ===================================================================

const ::google::protobuf::EnumDescriptor* MaxStepSize_TYPE_descriptor() {
  protobuf_AssignDescriptorsOnce();
  return MaxStepSize_TYPE_descriptor_;
}
bool MaxStepSize_TYPE_IsValid(int value) {
  switch(value) {
    case 0:
    case 1:
      return true;
    default:
      return false;
  }
}

#if !defined(_MSC_VER) || _MSC_VER >= 1900
const MaxStepSize_TYPE MaxStepSize::SET_STEP_SIZE;
const MaxStepSize_TYPE MaxStepSize::GET_STEP_SIZE;
const MaxStepSize_TYPE MaxStepSize::TYPE_MIN;
const MaxStepSize_TYPE MaxStepSize::TYPE_MAX;
const int MaxStepSize::TYPE_ARRAYSIZE;
#endif  // !defined(_MSC_VER) || _MSC_VER >= 1900
#if !defined(_MSC_VER) || _MSC_VER >= 1900
const int MaxStepSize::kTypeFieldNumber;
const int MaxStepSize::kSizeFieldNumber;
#endif  // !defined(_MSC_VER) || _MSC_VER >= 1900

MaxStepSize::MaxStepSize()
  : ::google::protobuf::Message(), _internal_metadata_(NULL) {
  SharedCtor();
  // @@protoc_insertion_point(constructor:mw.internal.robotics.gazebotransport.MaxStepSize)
}

void MaxStepSize::InitAsDefaultInstance() {
}

MaxStepSize::MaxStepSize(const MaxStepSize& from)
  : ::google::protobuf::Message(),
    _internal_metadata_(NULL) {
  SharedCtor();
  MergeFrom(from);
  // @@protoc_insertion_point(copy_constructor:mw.internal.robotics.gazebotransport.MaxStepSize)
}

void MaxStepSize::SharedCtor() {
  _cached_size_ = 0;
  type_ = 0;
  size_ = 0;
  ::memset(_has_bits_, 0, sizeof(_has_bits_));
}

MaxStepSize::~MaxStepSize() {
  // @@protoc_insertion_point(destructor:mw.internal.robotics.gazebotransport.MaxStepSize)
  SharedDtor();
}

void MaxStepSize::SharedDtor() {
  if (this != default_instance_) {
  }
}

void MaxStepSize::SetCachedSize(int size) const {
  GOOGLE_SAFE_CONCURRENT_WRITES_BEGIN();
  _cached_size_ = size;
  GOOGLE_SAFE_CONCURRENT_WRITES_END();
}
const ::google::protobuf::Descriptor* MaxStepSize::descriptor() {
  protobuf_AssignDescriptorsOnce();
  return MaxStepSize_descriptor_;
}

const MaxStepSize& MaxStepSize::default_instance() {
  if (default_instance_ == NULL) protobuf_AddDesc_mw_2einternal_2erobotics_2egazebotransport_2eCoSimMsgs_2eproto();
  return *default_instance_;
}

MaxStepSize* MaxStepSize::default_instance_ = NULL;

MaxStepSize* MaxStepSize::New(::google::protobuf::Arena* arena) const {
  MaxStepSize* n = new MaxStepSize;
  if (arena != NULL) {
    arena->Own(n);
  }
  return n;
}

void MaxStepSize::Clear() {
// @@protoc_insertion_point(message_clear_start:mw.internal.robotics.gazebotransport.MaxStepSize)
#if defined(__clang__)
#define ZR_HELPER_(f) \
  _Pragma("clang diagnostic push") \
  _Pragma("clang diagnostic ignored \"-Winvalid-offsetof\"") \
  __builtin_offsetof(MaxStepSize, f) \
  _Pragma("clang diagnostic pop")
#else
#define ZR_HELPER_(f) reinterpret_cast<char*>(\
  &reinterpret_cast<MaxStepSize*>(16)->f)
#endif

#define ZR_(first, last) do {\
  ::memset(&first, 0,\
           ZR_HELPER_(last) - ZR_HELPER_(first) + sizeof(last));\
} while (0)

  ZR_(size_, type_);

#undef ZR_HELPER_
#undef ZR_

  ::memset(_has_bits_, 0, sizeof(_has_bits_));
  if (_internal_metadata_.have_unknown_fields()) {
    mutable_unknown_fields()->Clear();
  }
}

bool MaxStepSize::MergePartialFromCodedStream(
    ::google::protobuf::io::CodedInputStream* input) {
#define DO_(EXPRESSION) if (!GOOGLE_PREDICT_TRUE(EXPRESSION)) goto failure
  ::google::protobuf::uint32 tag;
  // @@protoc_insertion_point(parse_start:mw.internal.robotics.gazebotransport.MaxStepSize)
  for (;;) {
    ::std::pair< ::google::protobuf::uint32, bool> p = input->ReadTagWithCutoff(127);
    tag = p.first;
    if (!p.second) goto handle_unusual;
    switch (::google::protobuf::internal::WireFormatLite::GetTagFieldNumber(tag)) {
      // required .mw.internal.robotics.gazebotransport.MaxStepSize.TYPE type = 1;
      case 1: {
        if (tag == 8) {
          int value;
          DO_((::google::protobuf::internal::WireFormatLite::ReadPrimitive<
                   int, ::google::protobuf::internal::WireFormatLite::TYPE_ENUM>(
                 input, &value)));
          if (::mw::internal::robotics::gazebotransport::MaxStepSize_TYPE_IsValid(value)) {
            set_type(static_cast< ::mw::internal::robotics::gazebotransport::MaxStepSize_TYPE >(value));
          } else {
            mutable_unknown_fields()->AddVarint(1, value);
          }
        } else {
          goto handle_unusual;
        }
        if (input->ExpectTag(17)) goto parse_size;
        break;
      }

      // required double size = 2;
      case 2: {
        if (tag == 17) {
         parse_size:
          DO_((::google::protobuf::internal::WireFormatLite::ReadPrimitive<
                   double, ::google::protobuf::internal::WireFormatLite::TYPE_DOUBLE>(
                 input, &size_)));
          set_has_size();
        } else {
          goto handle_unusual;
        }
        if (input->ExpectAtEnd()) goto success;
        break;
      }

      default: {
      handle_unusual:
        if (tag == 0 ||
            ::google::protobuf::internal::WireFormatLite::GetTagWireType(tag) ==
            ::google::protobuf::internal::WireFormatLite::WIRETYPE_END_GROUP) {
          goto success;
        }
        DO_(::google::protobuf::internal::WireFormat::SkipField(
              input, tag, mutable_unknown_fields()));
        break;
      }
    }
  }
success:
  // @@protoc_insertion_point(parse_success:mw.internal.robotics.gazebotransport.MaxStepSize)
  return true;
failure:
  // @@protoc_insertion_point(parse_failure:mw.internal.robotics.gazebotransport.MaxStepSize)
  return false;
#undef DO_
}

void MaxStepSize::SerializeWithCachedSizes(
    ::google::protobuf::io::CodedOutputStream* output) const {
  // @@protoc_insertion_point(serialize_start:mw.internal.robotics.gazebotransport.MaxStepSize)
  // required .mw.internal.robotics.gazebotransport.MaxStepSize.TYPE type = 1;
  if (has_type()) {
    ::google::protobuf::internal::WireFormatLite::WriteEnum(
      1, this->type(), output);
  }

  // required double size = 2;
  if (has_size()) {
    ::google::protobuf::internal::WireFormatLite::WriteDouble(2, this->size(), output);
  }

  if (_internal_metadata_.have_unknown_fields()) {
    ::google::protobuf::internal::WireFormat::SerializeUnknownFields(
        unknown_fields(), output);
  }
  // @@protoc_insertion_point(serialize_end:mw.internal.robotics.gazebotransport.MaxStepSize)
}

::google::protobuf::uint8* MaxStepSize::InternalSerializeWithCachedSizesToArray(
    bool deterministic, ::google::protobuf::uint8* target) const {
  // @@protoc_insertion_point(serialize_to_array_start:mw.internal.robotics.gazebotransport.MaxStepSize)
  // required .mw.internal.robotics.gazebotransport.MaxStepSize.TYPE type = 1;
  if (has_type()) {
    target = ::google::protobuf::internal::WireFormatLite::WriteEnumToArray(
      1, this->type(), target);
  }

  // required double size = 2;
  if (has_size()) {
    target = ::google::protobuf::internal::WireFormatLite::WriteDoubleToArray(2, this->size(), target);
  }

  if (_internal_metadata_.have_unknown_fields()) {
    target = ::google::protobuf::internal::WireFormat::SerializeUnknownFieldsToArray(
        unknown_fields(), target);
  }
  // @@protoc_insertion_point(serialize_to_array_end:mw.internal.robotics.gazebotransport.MaxStepSize)
  return target;
}

int MaxStepSize::RequiredFieldsByteSizeFallback() const {
// @@protoc_insertion_point(required_fields_byte_size_fallback_start:mw.internal.robotics.gazebotransport.MaxStepSize)
  int total_size = 0;

  if (has_type()) {
    // required .mw.internal.robotics.gazebotransport.MaxStepSize.TYPE type = 1;
    total_size += 1 +
      ::google::protobuf::internal::WireFormatLite::EnumSize(this->type());
  }

  if (has_size()) {
    // required double size = 2;
    total_size += 1 + 8;
  }

  return total_size;
}
int MaxStepSize::ByteSize() const {
// @@protoc_insertion_point(message_byte_size_start:mw.internal.robotics.gazebotransport.MaxStepSize)
  int total_size = 0;

  if (((_has_bits_[0] & 0x00000003) ^ 0x00000003) == 0) {  // All required fields are present.
    // required .mw.internal.robotics.gazebotransport.MaxStepSize.TYPE type = 1;
    total_size += 1 +
      ::google::protobuf::internal::WireFormatLite::EnumSize(this->type());

    // required double size = 2;
    total_size += 1 + 8;

  } else {
    total_size += RequiredFieldsByteSizeFallback();
  }
  if (_internal_metadata_.have_unknown_fields()) {
    total_size +=
      ::google::protobuf::internal::WireFormat::ComputeUnknownFieldsSize(
        unknown_fields());
  }
  GOOGLE_SAFE_CONCURRENT_WRITES_BEGIN();
  _cached_size_ = total_size;
  GOOGLE_SAFE_CONCURRENT_WRITES_END();
  return total_size;
}

void MaxStepSize::MergeFrom(const ::google::protobuf::Message& from) {
// @@protoc_insertion_point(generalized_merge_from_start:mw.internal.robotics.gazebotransport.MaxStepSize)
  if (GOOGLE_PREDICT_FALSE(&from == this)) {
    ::google::protobuf::internal::MergeFromFail(__FILE__, __LINE__);
  }
  const MaxStepSize* source = 
      ::google::protobuf::internal::DynamicCastToGenerated<const MaxStepSize>(
          &from);
  if (source == NULL) {
  // @@protoc_insertion_point(generalized_merge_from_cast_fail:mw.internal.robotics.gazebotransport.MaxStepSize)
    ::google::protobuf::internal::ReflectionOps::Merge(from, this);
  } else {
  // @@protoc_insertion_point(generalized_merge_from_cast_success:mw.internal.robotics.gazebotransport.MaxStepSize)
    MergeFrom(*source);
  }
}

void MaxStepSize::MergeFrom(const MaxStepSize& from) {
// @@protoc_insertion_point(class_specific_merge_from_start:mw.internal.robotics.gazebotransport.MaxStepSize)
  if (GOOGLE_PREDICT_FALSE(&from == this)) {
    ::google::protobuf::internal::MergeFromFail(__FILE__, __LINE__);
  }
  if (from._has_bits_[0 / 32] & (0xffu << (0 % 32))) {
    if (from.has_type()) {
      set_type(from.type());
    }
    if (from.has_size()) {
      set_size(from.size());
    }
  }
  if (from._internal_metadata_.have_unknown_fields()) {
    mutable_unknown_fields()->MergeFrom(from.unknown_fields());
  }
}

void MaxStepSize::CopyFrom(const ::google::protobuf::Message& from) {
// @@protoc_insertion_point(generalized_copy_from_start:mw.internal.robotics.gazebotransport.MaxStepSize)
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

void MaxStepSize::CopyFrom(const MaxStepSize& from) {
// @@protoc_insertion_point(class_specific_copy_from_start:mw.internal.robotics.gazebotransport.MaxStepSize)
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

bool MaxStepSize::IsInitialized() const {
  if ((_has_bits_[0] & 0x00000003) != 0x00000003) return false;

  return true;
}

void MaxStepSize::Swap(MaxStepSize* other) {
  if (other == this) return;
  InternalSwap(other);
}
void MaxStepSize::InternalSwap(MaxStepSize* other) {
  std::swap(type_, other->type_);
  std::swap(size_, other->size_);
  std::swap(_has_bits_[0], other->_has_bits_[0]);
  _internal_metadata_.Swap(&other->_internal_metadata_);
  std::swap(_cached_size_, other->_cached_size_);
}

::google::protobuf::Metadata MaxStepSize::GetMetadata() const {
  protobuf_AssignDescriptorsOnce();
  ::google::protobuf::Metadata metadata;
  metadata.descriptor = MaxStepSize_descriptor_;
  metadata.reflection = MaxStepSize_reflection_;
  return metadata;
}

#if PROTOBUF_INLINE_NOT_IN_HEADERS
// MaxStepSize

// required .mw.internal.robotics.gazebotransport.MaxStepSize.TYPE type = 1;
bool MaxStepSize::has_type() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
void MaxStepSize::set_has_type() {
  _has_bits_[0] |= 0x00000001u;
}
void MaxStepSize::clear_has_type() {
  _has_bits_[0] &= ~0x00000001u;
}
void MaxStepSize::clear_type() {
  type_ = 0;
  clear_has_type();
}
 ::mw::internal::robotics::gazebotransport::MaxStepSize_TYPE MaxStepSize::type() const {
  // @@protoc_insertion_point(field_get:mw.internal.robotics.gazebotransport.MaxStepSize.type)
  return static_cast< ::mw::internal::robotics::gazebotransport::MaxStepSize_TYPE >(type_);
}
 void MaxStepSize::set_type(::mw::internal::robotics::gazebotransport::MaxStepSize_TYPE value) {
  assert(::mw::internal::robotics::gazebotransport::MaxStepSize_TYPE_IsValid(value));
  set_has_type();
  type_ = value;
  // @@protoc_insertion_point(field_set:mw.internal.robotics.gazebotransport.MaxStepSize.type)
}

// required double size = 2;
bool MaxStepSize::has_size() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
void MaxStepSize::set_has_size() {
  _has_bits_[0] |= 0x00000002u;
}
void MaxStepSize::clear_has_size() {
  _has_bits_[0] &= ~0x00000002u;
}
void MaxStepSize::clear_size() {
  size_ = 0;
  clear_has_size();
}
 double MaxStepSize::size() const {
  // @@protoc_insertion_point(field_get:mw.internal.robotics.gazebotransport.MaxStepSize.size)
  return size_;
}
 void MaxStepSize::set_size(double value) {
  set_has_size();
  size_ = value;
  // @@protoc_insertion_point(field_set:mw.internal.robotics.gazebotransport.MaxStepSize.size)
}

#endif  // PROTOBUF_INLINE_NOT_IN_HEADERS

// ===================================================================

#if !defined(_MSC_VER) || _MSC_VER >= 1900
const int InitCustomPublisher::kTopicNameFieldNumber;
const int InitCustomPublisher::kMessageTypeFieldNumber;
#endif  // !defined(_MSC_VER) || _MSC_VER >= 1900

InitCustomPublisher::InitCustomPublisher()
  : ::google::protobuf::Message(), _internal_metadata_(NULL) {
  SharedCtor();
  // @@protoc_insertion_point(constructor:mw.internal.robotics.gazebotransport.InitCustomPublisher)
}

void InitCustomPublisher::InitAsDefaultInstance() {
}

InitCustomPublisher::InitCustomPublisher(const InitCustomPublisher& from)
  : ::google::protobuf::Message(),
    _internal_metadata_(NULL) {
  SharedCtor();
  MergeFrom(from);
  // @@protoc_insertion_point(copy_constructor:mw.internal.robotics.gazebotransport.InitCustomPublisher)
}

void InitCustomPublisher::SharedCtor() {
  ::google::protobuf::internal::GetEmptyString();
  _cached_size_ = 0;
  topic_name_.UnsafeSetDefault(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
  message_type_.UnsafeSetDefault(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
  ::memset(_has_bits_, 0, sizeof(_has_bits_));
}

InitCustomPublisher::~InitCustomPublisher() {
  // @@protoc_insertion_point(destructor:mw.internal.robotics.gazebotransport.InitCustomPublisher)
  SharedDtor();
}

void InitCustomPublisher::SharedDtor() {
  topic_name_.DestroyNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
  message_type_.DestroyNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
  if (this != default_instance_) {
  }
}

void InitCustomPublisher::SetCachedSize(int size) const {
  GOOGLE_SAFE_CONCURRENT_WRITES_BEGIN();
  _cached_size_ = size;
  GOOGLE_SAFE_CONCURRENT_WRITES_END();
}
const ::google::protobuf::Descriptor* InitCustomPublisher::descriptor() {
  protobuf_AssignDescriptorsOnce();
  return InitCustomPublisher_descriptor_;
}

const InitCustomPublisher& InitCustomPublisher::default_instance() {
  if (default_instance_ == NULL) protobuf_AddDesc_mw_2einternal_2erobotics_2egazebotransport_2eCoSimMsgs_2eproto();
  return *default_instance_;
}

InitCustomPublisher* InitCustomPublisher::default_instance_ = NULL;

InitCustomPublisher* InitCustomPublisher::New(::google::protobuf::Arena* arena) const {
  InitCustomPublisher* n = new InitCustomPublisher;
  if (arena != NULL) {
    arena->Own(n);
  }
  return n;
}

void InitCustomPublisher::Clear() {
// @@protoc_insertion_point(message_clear_start:mw.internal.robotics.gazebotransport.InitCustomPublisher)
  if (_has_bits_[0 / 32] & 3u) {
    if (has_topic_name()) {
      topic_name_.ClearToEmptyNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
    }
    if (has_message_type()) {
      message_type_.ClearToEmptyNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
    }
  }
  ::memset(_has_bits_, 0, sizeof(_has_bits_));
  if (_internal_metadata_.have_unknown_fields()) {
    mutable_unknown_fields()->Clear();
  }
}

bool InitCustomPublisher::MergePartialFromCodedStream(
    ::google::protobuf::io::CodedInputStream* input) {
#define DO_(EXPRESSION) if (!GOOGLE_PREDICT_TRUE(EXPRESSION)) goto failure
  ::google::protobuf::uint32 tag;
  // @@protoc_insertion_point(parse_start:mw.internal.robotics.gazebotransport.InitCustomPublisher)
  for (;;) {
    ::std::pair< ::google::protobuf::uint32, bool> p = input->ReadTagWithCutoff(127);
    tag = p.first;
    if (!p.second) goto handle_unusual;
    switch (::google::protobuf::internal::WireFormatLite::GetTagFieldNumber(tag)) {
      // required string topic_name = 1;
      case 1: {
        if (tag == 10) {
          DO_(::google::protobuf::internal::WireFormatLite::ReadString(
                input, this->mutable_topic_name()));
          ::google::protobuf::internal::WireFormat::VerifyUTF8StringNamedField(
            this->topic_name().data(), this->topic_name().length(),
            ::google::protobuf::internal::WireFormat::PARSE,
            "mw.internal.robotics.gazebotransport.InitCustomPublisher.topic_name");
        } else {
          goto handle_unusual;
        }
        if (input->ExpectTag(18)) goto parse_message_type;
        break;
      }

      // required string message_type = 2;
      case 2: {
        if (tag == 18) {
         parse_message_type:
          DO_(::google::protobuf::internal::WireFormatLite::ReadString(
                input, this->mutable_message_type()));
          ::google::protobuf::internal::WireFormat::VerifyUTF8StringNamedField(
            this->message_type().data(), this->message_type().length(),
            ::google::protobuf::internal::WireFormat::PARSE,
            "mw.internal.robotics.gazebotransport.InitCustomPublisher.message_type");
        } else {
          goto handle_unusual;
        }
        if (input->ExpectAtEnd()) goto success;
        break;
      }

      default: {
      handle_unusual:
        if (tag == 0 ||
            ::google::protobuf::internal::WireFormatLite::GetTagWireType(tag) ==
            ::google::protobuf::internal::WireFormatLite::WIRETYPE_END_GROUP) {
          goto success;
        }
        DO_(::google::protobuf::internal::WireFormat::SkipField(
              input, tag, mutable_unknown_fields()));
        break;
      }
    }
  }
success:
  // @@protoc_insertion_point(parse_success:mw.internal.robotics.gazebotransport.InitCustomPublisher)
  return true;
failure:
  // @@protoc_insertion_point(parse_failure:mw.internal.robotics.gazebotransport.InitCustomPublisher)
  return false;
#undef DO_
}

void InitCustomPublisher::SerializeWithCachedSizes(
    ::google::protobuf::io::CodedOutputStream* output) const {
  // @@protoc_insertion_point(serialize_start:mw.internal.robotics.gazebotransport.InitCustomPublisher)
  // required string topic_name = 1;
  if (has_topic_name()) {
    ::google::protobuf::internal::WireFormat::VerifyUTF8StringNamedField(
      this->topic_name().data(), this->topic_name().length(),
      ::google::protobuf::internal::WireFormat::SERIALIZE,
      "mw.internal.robotics.gazebotransport.InitCustomPublisher.topic_name");
    ::google::protobuf::internal::WireFormatLite::WriteStringMaybeAliased(
      1, this->topic_name(), output);
  }

  // required string message_type = 2;
  if (has_message_type()) {
    ::google::protobuf::internal::WireFormat::VerifyUTF8StringNamedField(
      this->message_type().data(), this->message_type().length(),
      ::google::protobuf::internal::WireFormat::SERIALIZE,
      "mw.internal.robotics.gazebotransport.InitCustomPublisher.message_type");
    ::google::protobuf::internal::WireFormatLite::WriteStringMaybeAliased(
      2, this->message_type(), output);
  }

  if (_internal_metadata_.have_unknown_fields()) {
    ::google::protobuf::internal::WireFormat::SerializeUnknownFields(
        unknown_fields(), output);
  }
  // @@protoc_insertion_point(serialize_end:mw.internal.robotics.gazebotransport.InitCustomPublisher)
}

::google::protobuf::uint8* InitCustomPublisher::InternalSerializeWithCachedSizesToArray(
    bool deterministic, ::google::protobuf::uint8* target) const {
  // @@protoc_insertion_point(serialize_to_array_start:mw.internal.robotics.gazebotransport.InitCustomPublisher)
  // required string topic_name = 1;
  if (has_topic_name()) {
    ::google::protobuf::internal::WireFormat::VerifyUTF8StringNamedField(
      this->topic_name().data(), this->topic_name().length(),
      ::google::protobuf::internal::WireFormat::SERIALIZE,
      "mw.internal.robotics.gazebotransport.InitCustomPublisher.topic_name");
    target =
      ::google::protobuf::internal::WireFormatLite::WriteStringToArray(
        1, this->topic_name(), target);
  }

  // required string message_type = 2;
  if (has_message_type()) {
    ::google::protobuf::internal::WireFormat::VerifyUTF8StringNamedField(
      this->message_type().data(), this->message_type().length(),
      ::google::protobuf::internal::WireFormat::SERIALIZE,
      "mw.internal.robotics.gazebotransport.InitCustomPublisher.message_type");
    target =
      ::google::protobuf::internal::WireFormatLite::WriteStringToArray(
        2, this->message_type(), target);
  }

  if (_internal_metadata_.have_unknown_fields()) {
    target = ::google::protobuf::internal::WireFormat::SerializeUnknownFieldsToArray(
        unknown_fields(), target);
  }
  // @@protoc_insertion_point(serialize_to_array_end:mw.internal.robotics.gazebotransport.InitCustomPublisher)
  return target;
}

int InitCustomPublisher::RequiredFieldsByteSizeFallback() const {
// @@protoc_insertion_point(required_fields_byte_size_fallback_start:mw.internal.robotics.gazebotransport.InitCustomPublisher)
  int total_size = 0;

  if (has_topic_name()) {
    // required string topic_name = 1;
    total_size += 1 +
      ::google::protobuf::internal::WireFormatLite::StringSize(
        this->topic_name());
  }

  if (has_message_type()) {
    // required string message_type = 2;
    total_size += 1 +
      ::google::protobuf::internal::WireFormatLite::StringSize(
        this->message_type());
  }

  return total_size;
}
int InitCustomPublisher::ByteSize() const {
// @@protoc_insertion_point(message_byte_size_start:mw.internal.robotics.gazebotransport.InitCustomPublisher)
  int total_size = 0;

  if (((_has_bits_[0] & 0x00000003) ^ 0x00000003) == 0) {  // All required fields are present.
    // required string topic_name = 1;
    total_size += 1 +
      ::google::protobuf::internal::WireFormatLite::StringSize(
        this->topic_name());

    // required string message_type = 2;
    total_size += 1 +
      ::google::protobuf::internal::WireFormatLite::StringSize(
        this->message_type());

  } else {
    total_size += RequiredFieldsByteSizeFallback();
  }
  if (_internal_metadata_.have_unknown_fields()) {
    total_size +=
      ::google::protobuf::internal::WireFormat::ComputeUnknownFieldsSize(
        unknown_fields());
  }
  GOOGLE_SAFE_CONCURRENT_WRITES_BEGIN();
  _cached_size_ = total_size;
  GOOGLE_SAFE_CONCURRENT_WRITES_END();
  return total_size;
}

void InitCustomPublisher::MergeFrom(const ::google::protobuf::Message& from) {
// @@protoc_insertion_point(generalized_merge_from_start:mw.internal.robotics.gazebotransport.InitCustomPublisher)
  if (GOOGLE_PREDICT_FALSE(&from == this)) {
    ::google::protobuf::internal::MergeFromFail(__FILE__, __LINE__);
  }
  const InitCustomPublisher* source = 
      ::google::protobuf::internal::DynamicCastToGenerated<const InitCustomPublisher>(
          &from);
  if (source == NULL) {
  // @@protoc_insertion_point(generalized_merge_from_cast_fail:mw.internal.robotics.gazebotransport.InitCustomPublisher)
    ::google::protobuf::internal::ReflectionOps::Merge(from, this);
  } else {
  // @@protoc_insertion_point(generalized_merge_from_cast_success:mw.internal.robotics.gazebotransport.InitCustomPublisher)
    MergeFrom(*source);
  }
}

void InitCustomPublisher::MergeFrom(const InitCustomPublisher& from) {
// @@protoc_insertion_point(class_specific_merge_from_start:mw.internal.robotics.gazebotransport.InitCustomPublisher)
  if (GOOGLE_PREDICT_FALSE(&from == this)) {
    ::google::protobuf::internal::MergeFromFail(__FILE__, __LINE__);
  }
  if (from._has_bits_[0 / 32] & (0xffu << (0 % 32))) {
    if (from.has_topic_name()) {
      set_has_topic_name();
      topic_name_.AssignWithDefault(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), from.topic_name_);
    }
    if (from.has_message_type()) {
      set_has_message_type();
      message_type_.AssignWithDefault(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), from.message_type_);
    }
  }
  if (from._internal_metadata_.have_unknown_fields()) {
    mutable_unknown_fields()->MergeFrom(from.unknown_fields());
  }
}

void InitCustomPublisher::CopyFrom(const ::google::protobuf::Message& from) {
// @@protoc_insertion_point(generalized_copy_from_start:mw.internal.robotics.gazebotransport.InitCustomPublisher)
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

void InitCustomPublisher::CopyFrom(const InitCustomPublisher& from) {
// @@protoc_insertion_point(class_specific_copy_from_start:mw.internal.robotics.gazebotransport.InitCustomPublisher)
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

bool InitCustomPublisher::IsInitialized() const {
  if ((_has_bits_[0] & 0x00000003) != 0x00000003) return false;

  return true;
}

void InitCustomPublisher::Swap(InitCustomPublisher* other) {
  if (other == this) return;
  InternalSwap(other);
}
void InitCustomPublisher::InternalSwap(InitCustomPublisher* other) {
  topic_name_.Swap(&other->topic_name_);
  message_type_.Swap(&other->message_type_);
  std::swap(_has_bits_[0], other->_has_bits_[0]);
  _internal_metadata_.Swap(&other->_internal_metadata_);
  std::swap(_cached_size_, other->_cached_size_);
}

::google::protobuf::Metadata InitCustomPublisher::GetMetadata() const {
  protobuf_AssignDescriptorsOnce();
  ::google::protobuf::Metadata metadata;
  metadata.descriptor = InitCustomPublisher_descriptor_;
  metadata.reflection = InitCustomPublisher_reflection_;
  return metadata;
}

#if PROTOBUF_INLINE_NOT_IN_HEADERS
// InitCustomPublisher

// required string topic_name = 1;
bool InitCustomPublisher::has_topic_name() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
void InitCustomPublisher::set_has_topic_name() {
  _has_bits_[0] |= 0x00000001u;
}
void InitCustomPublisher::clear_has_topic_name() {
  _has_bits_[0] &= ~0x00000001u;
}
void InitCustomPublisher::clear_topic_name() {
  topic_name_.ClearToEmptyNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
  clear_has_topic_name();
}
 const ::std::string& InitCustomPublisher::topic_name() const {
  // @@protoc_insertion_point(field_get:mw.internal.robotics.gazebotransport.InitCustomPublisher.topic_name)
  return topic_name_.GetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
 void InitCustomPublisher::set_topic_name(const ::std::string& value) {
  set_has_topic_name();
  topic_name_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), value);
  // @@protoc_insertion_point(field_set:mw.internal.robotics.gazebotransport.InitCustomPublisher.topic_name)
}
 void InitCustomPublisher::set_topic_name(const char* value) {
  set_has_topic_name();
  topic_name_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::string(value));
  // @@protoc_insertion_point(field_set_char:mw.internal.robotics.gazebotransport.InitCustomPublisher.topic_name)
}
 void InitCustomPublisher::set_topic_name(const char* value, size_t size) {
  set_has_topic_name();
  topic_name_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(),
      ::std::string(reinterpret_cast<const char*>(value), size));
  // @@protoc_insertion_point(field_set_pointer:mw.internal.robotics.gazebotransport.InitCustomPublisher.topic_name)
}
 ::std::string* InitCustomPublisher::mutable_topic_name() {
  set_has_topic_name();
  // @@protoc_insertion_point(field_mutable:mw.internal.robotics.gazebotransport.InitCustomPublisher.topic_name)
  return topic_name_.MutableNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
 ::std::string* InitCustomPublisher::release_topic_name() {
  // @@protoc_insertion_point(field_release:mw.internal.robotics.gazebotransport.InitCustomPublisher.topic_name)
  clear_has_topic_name();
  return topic_name_.ReleaseNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
 void InitCustomPublisher::set_allocated_topic_name(::std::string* topic_name) {
  if (topic_name != NULL) {
    set_has_topic_name();
  } else {
    clear_has_topic_name();
  }
  topic_name_.SetAllocatedNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), topic_name);
  // @@protoc_insertion_point(field_set_allocated:mw.internal.robotics.gazebotransport.InitCustomPublisher.topic_name)
}

// required string message_type = 2;
bool InitCustomPublisher::has_message_type() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
void InitCustomPublisher::set_has_message_type() {
  _has_bits_[0] |= 0x00000002u;
}
void InitCustomPublisher::clear_has_message_type() {
  _has_bits_[0] &= ~0x00000002u;
}
void InitCustomPublisher::clear_message_type() {
  message_type_.ClearToEmptyNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
  clear_has_message_type();
}
 const ::std::string& InitCustomPublisher::message_type() const {
  // @@protoc_insertion_point(field_get:mw.internal.robotics.gazebotransport.InitCustomPublisher.message_type)
  return message_type_.GetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
 void InitCustomPublisher::set_message_type(const ::std::string& value) {
  set_has_message_type();
  message_type_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), value);
  // @@protoc_insertion_point(field_set:mw.internal.robotics.gazebotransport.InitCustomPublisher.message_type)
}
 void InitCustomPublisher::set_message_type(const char* value) {
  set_has_message_type();
  message_type_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::string(value));
  // @@protoc_insertion_point(field_set_char:mw.internal.robotics.gazebotransport.InitCustomPublisher.message_type)
}
 void InitCustomPublisher::set_message_type(const char* value, size_t size) {
  set_has_message_type();
  message_type_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(),
      ::std::string(reinterpret_cast<const char*>(value), size));
  // @@protoc_insertion_point(field_set_pointer:mw.internal.robotics.gazebotransport.InitCustomPublisher.message_type)
}
 ::std::string* InitCustomPublisher::mutable_message_type() {
  set_has_message_type();
  // @@protoc_insertion_point(field_mutable:mw.internal.robotics.gazebotransport.InitCustomPublisher.message_type)
  return message_type_.MutableNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
 ::std::string* InitCustomPublisher::release_message_type() {
  // @@protoc_insertion_point(field_release:mw.internal.robotics.gazebotransport.InitCustomPublisher.message_type)
  clear_has_message_type();
  return message_type_.ReleaseNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
 void InitCustomPublisher::set_allocated_message_type(::std::string* message_type) {
  if (message_type != NULL) {
    set_has_message_type();
  } else {
    clear_has_message_type();
  }
  message_type_.SetAllocatedNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), message_type);
  // @@protoc_insertion_point(field_set_allocated:mw.internal.robotics.gazebotransport.InitCustomPublisher.message_type)
}

#endif  // PROTOBUF_INLINE_NOT_IN_HEADERS

// ===================================================================

#if !defined(_MSC_VER) || _MSC_VER >= 1900
const int InitCustomSubscriber::kTopicNameFieldNumber;
const int InitCustomSubscriber::kMessageTypeFieldNumber;
#endif  // !defined(_MSC_VER) || _MSC_VER >= 1900

InitCustomSubscriber::InitCustomSubscriber()
  : ::google::protobuf::Message(), _internal_metadata_(NULL) {
  SharedCtor();
  // @@protoc_insertion_point(constructor:mw.internal.robotics.gazebotransport.InitCustomSubscriber)
}

void InitCustomSubscriber::InitAsDefaultInstance() {
}

InitCustomSubscriber::InitCustomSubscriber(const InitCustomSubscriber& from)
  : ::google::protobuf::Message(),
    _internal_metadata_(NULL) {
  SharedCtor();
  MergeFrom(from);
  // @@protoc_insertion_point(copy_constructor:mw.internal.robotics.gazebotransport.InitCustomSubscriber)
}

void InitCustomSubscriber::SharedCtor() {
  ::google::protobuf::internal::GetEmptyString();
  _cached_size_ = 0;
  topic_name_.UnsafeSetDefault(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
  message_type_.UnsafeSetDefault(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
  ::memset(_has_bits_, 0, sizeof(_has_bits_));
}

InitCustomSubscriber::~InitCustomSubscriber() {
  // @@protoc_insertion_point(destructor:mw.internal.robotics.gazebotransport.InitCustomSubscriber)
  SharedDtor();
}

void InitCustomSubscriber::SharedDtor() {
  topic_name_.DestroyNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
  message_type_.DestroyNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
  if (this != default_instance_) {
  }
}

void InitCustomSubscriber::SetCachedSize(int size) const {
  GOOGLE_SAFE_CONCURRENT_WRITES_BEGIN();
  _cached_size_ = size;
  GOOGLE_SAFE_CONCURRENT_WRITES_END();
}
const ::google::protobuf::Descriptor* InitCustomSubscriber::descriptor() {
  protobuf_AssignDescriptorsOnce();
  return InitCustomSubscriber_descriptor_;
}

const InitCustomSubscriber& InitCustomSubscriber::default_instance() {
  if (default_instance_ == NULL) protobuf_AddDesc_mw_2einternal_2erobotics_2egazebotransport_2eCoSimMsgs_2eproto();
  return *default_instance_;
}

InitCustomSubscriber* InitCustomSubscriber::default_instance_ = NULL;

InitCustomSubscriber* InitCustomSubscriber::New(::google::protobuf::Arena* arena) const {
  InitCustomSubscriber* n = new InitCustomSubscriber;
  if (arena != NULL) {
    arena->Own(n);
  }
  return n;
}

void InitCustomSubscriber::Clear() {
// @@protoc_insertion_point(message_clear_start:mw.internal.robotics.gazebotransport.InitCustomSubscriber)
  if (_has_bits_[0 / 32] & 3u) {
    if (has_topic_name()) {
      topic_name_.ClearToEmptyNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
    }
    if (has_message_type()) {
      message_type_.ClearToEmptyNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
    }
  }
  ::memset(_has_bits_, 0, sizeof(_has_bits_));
  if (_internal_metadata_.have_unknown_fields()) {
    mutable_unknown_fields()->Clear();
  }
}

bool InitCustomSubscriber::MergePartialFromCodedStream(
    ::google::protobuf::io::CodedInputStream* input) {
#define DO_(EXPRESSION) if (!GOOGLE_PREDICT_TRUE(EXPRESSION)) goto failure
  ::google::protobuf::uint32 tag;
  // @@protoc_insertion_point(parse_start:mw.internal.robotics.gazebotransport.InitCustomSubscriber)
  for (;;) {
    ::std::pair< ::google::protobuf::uint32, bool> p = input->ReadTagWithCutoff(127);
    tag = p.first;
    if (!p.second) goto handle_unusual;
    switch (::google::protobuf::internal::WireFormatLite::GetTagFieldNumber(tag)) {
      // required string topic_name = 1;
      case 1: {
        if (tag == 10) {
          DO_(::google::protobuf::internal::WireFormatLite::ReadString(
                input, this->mutable_topic_name()));
          ::google::protobuf::internal::WireFormat::VerifyUTF8StringNamedField(
            this->topic_name().data(), this->topic_name().length(),
            ::google::protobuf::internal::WireFormat::PARSE,
            "mw.internal.robotics.gazebotransport.InitCustomSubscriber.topic_name");
        } else {
          goto handle_unusual;
        }
        if (input->ExpectTag(18)) goto parse_message_type;
        break;
      }

      // required string message_type = 2;
      case 2: {
        if (tag == 18) {
         parse_message_type:
          DO_(::google::protobuf::internal::WireFormatLite::ReadString(
                input, this->mutable_message_type()));
          ::google::protobuf::internal::WireFormat::VerifyUTF8StringNamedField(
            this->message_type().data(), this->message_type().length(),
            ::google::protobuf::internal::WireFormat::PARSE,
            "mw.internal.robotics.gazebotransport.InitCustomSubscriber.message_type");
        } else {
          goto handle_unusual;
        }
        if (input->ExpectAtEnd()) goto success;
        break;
      }

      default: {
      handle_unusual:
        if (tag == 0 ||
            ::google::protobuf::internal::WireFormatLite::GetTagWireType(tag) ==
            ::google::protobuf::internal::WireFormatLite::WIRETYPE_END_GROUP) {
          goto success;
        }
        DO_(::google::protobuf::internal::WireFormat::SkipField(
              input, tag, mutable_unknown_fields()));
        break;
      }
    }
  }
success:
  // @@protoc_insertion_point(parse_success:mw.internal.robotics.gazebotransport.InitCustomSubscriber)
  return true;
failure:
  // @@protoc_insertion_point(parse_failure:mw.internal.robotics.gazebotransport.InitCustomSubscriber)
  return false;
#undef DO_
}

void InitCustomSubscriber::SerializeWithCachedSizes(
    ::google::protobuf::io::CodedOutputStream* output) const {
  // @@protoc_insertion_point(serialize_start:mw.internal.robotics.gazebotransport.InitCustomSubscriber)
  // required string topic_name = 1;
  if (has_topic_name()) {
    ::google::protobuf::internal::WireFormat::VerifyUTF8StringNamedField(
      this->topic_name().data(), this->topic_name().length(),
      ::google::protobuf::internal::WireFormat::SERIALIZE,
      "mw.internal.robotics.gazebotransport.InitCustomSubscriber.topic_name");
    ::google::protobuf::internal::WireFormatLite::WriteStringMaybeAliased(
      1, this->topic_name(), output);
  }

  // required string message_type = 2;
  if (has_message_type()) {
    ::google::protobuf::internal::WireFormat::VerifyUTF8StringNamedField(
      this->message_type().data(), this->message_type().length(),
      ::google::protobuf::internal::WireFormat::SERIALIZE,
      "mw.internal.robotics.gazebotransport.InitCustomSubscriber.message_type");
    ::google::protobuf::internal::WireFormatLite::WriteStringMaybeAliased(
      2, this->message_type(), output);
  }

  if (_internal_metadata_.have_unknown_fields()) {
    ::google::protobuf::internal::WireFormat::SerializeUnknownFields(
        unknown_fields(), output);
  }
  // @@protoc_insertion_point(serialize_end:mw.internal.robotics.gazebotransport.InitCustomSubscriber)
}

::google::protobuf::uint8* InitCustomSubscriber::InternalSerializeWithCachedSizesToArray(
    bool deterministic, ::google::protobuf::uint8* target) const {
  // @@protoc_insertion_point(serialize_to_array_start:mw.internal.robotics.gazebotransport.InitCustomSubscriber)
  // required string topic_name = 1;
  if (has_topic_name()) {
    ::google::protobuf::internal::WireFormat::VerifyUTF8StringNamedField(
      this->topic_name().data(), this->topic_name().length(),
      ::google::protobuf::internal::WireFormat::SERIALIZE,
      "mw.internal.robotics.gazebotransport.InitCustomSubscriber.topic_name");
    target =
      ::google::protobuf::internal::WireFormatLite::WriteStringToArray(
        1, this->topic_name(), target);
  }

  // required string message_type = 2;
  if (has_message_type()) {
    ::google::protobuf::internal::WireFormat::VerifyUTF8StringNamedField(
      this->message_type().data(), this->message_type().length(),
      ::google::protobuf::internal::WireFormat::SERIALIZE,
      "mw.internal.robotics.gazebotransport.InitCustomSubscriber.message_type");
    target =
      ::google::protobuf::internal::WireFormatLite::WriteStringToArray(
        2, this->message_type(), target);
  }

  if (_internal_metadata_.have_unknown_fields()) {
    target = ::google::protobuf::internal::WireFormat::SerializeUnknownFieldsToArray(
        unknown_fields(), target);
  }
  // @@protoc_insertion_point(serialize_to_array_end:mw.internal.robotics.gazebotransport.InitCustomSubscriber)
  return target;
}

int InitCustomSubscriber::RequiredFieldsByteSizeFallback() const {
// @@protoc_insertion_point(required_fields_byte_size_fallback_start:mw.internal.robotics.gazebotransport.InitCustomSubscriber)
  int total_size = 0;

  if (has_topic_name()) {
    // required string topic_name = 1;
    total_size += 1 +
      ::google::protobuf::internal::WireFormatLite::StringSize(
        this->topic_name());
  }

  if (has_message_type()) {
    // required string message_type = 2;
    total_size += 1 +
      ::google::protobuf::internal::WireFormatLite::StringSize(
        this->message_type());
  }

  return total_size;
}
int InitCustomSubscriber::ByteSize() const {
// @@protoc_insertion_point(message_byte_size_start:mw.internal.robotics.gazebotransport.InitCustomSubscriber)
  int total_size = 0;

  if (((_has_bits_[0] & 0x00000003) ^ 0x00000003) == 0) {  // All required fields are present.
    // required string topic_name = 1;
    total_size += 1 +
      ::google::protobuf::internal::WireFormatLite::StringSize(
        this->topic_name());

    // required string message_type = 2;
    total_size += 1 +
      ::google::protobuf::internal::WireFormatLite::StringSize(
        this->message_type());

  } else {
    total_size += RequiredFieldsByteSizeFallback();
  }
  if (_internal_metadata_.have_unknown_fields()) {
    total_size +=
      ::google::protobuf::internal::WireFormat::ComputeUnknownFieldsSize(
        unknown_fields());
  }
  GOOGLE_SAFE_CONCURRENT_WRITES_BEGIN();
  _cached_size_ = total_size;
  GOOGLE_SAFE_CONCURRENT_WRITES_END();
  return total_size;
}

void InitCustomSubscriber::MergeFrom(const ::google::protobuf::Message& from) {
// @@protoc_insertion_point(generalized_merge_from_start:mw.internal.robotics.gazebotransport.InitCustomSubscriber)
  if (GOOGLE_PREDICT_FALSE(&from == this)) {
    ::google::protobuf::internal::MergeFromFail(__FILE__, __LINE__);
  }
  const InitCustomSubscriber* source = 
      ::google::protobuf::internal::DynamicCastToGenerated<const InitCustomSubscriber>(
          &from);
  if (source == NULL) {
  // @@protoc_insertion_point(generalized_merge_from_cast_fail:mw.internal.robotics.gazebotransport.InitCustomSubscriber)
    ::google::protobuf::internal::ReflectionOps::Merge(from, this);
  } else {
  // @@protoc_insertion_point(generalized_merge_from_cast_success:mw.internal.robotics.gazebotransport.InitCustomSubscriber)
    MergeFrom(*source);
  }
}

void InitCustomSubscriber::MergeFrom(const InitCustomSubscriber& from) {
// @@protoc_insertion_point(class_specific_merge_from_start:mw.internal.robotics.gazebotransport.InitCustomSubscriber)
  if (GOOGLE_PREDICT_FALSE(&from == this)) {
    ::google::protobuf::internal::MergeFromFail(__FILE__, __LINE__);
  }
  if (from._has_bits_[0 / 32] & (0xffu << (0 % 32))) {
    if (from.has_topic_name()) {
      set_has_topic_name();
      topic_name_.AssignWithDefault(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), from.topic_name_);
    }
    if (from.has_message_type()) {
      set_has_message_type();
      message_type_.AssignWithDefault(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), from.message_type_);
    }
  }
  if (from._internal_metadata_.have_unknown_fields()) {
    mutable_unknown_fields()->MergeFrom(from.unknown_fields());
  }
}

void InitCustomSubscriber::CopyFrom(const ::google::protobuf::Message& from) {
// @@protoc_insertion_point(generalized_copy_from_start:mw.internal.robotics.gazebotransport.InitCustomSubscriber)
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

void InitCustomSubscriber::CopyFrom(const InitCustomSubscriber& from) {
// @@protoc_insertion_point(class_specific_copy_from_start:mw.internal.robotics.gazebotransport.InitCustomSubscriber)
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

bool InitCustomSubscriber::IsInitialized() const {
  if ((_has_bits_[0] & 0x00000003) != 0x00000003) return false;

  return true;
}

void InitCustomSubscriber::Swap(InitCustomSubscriber* other) {
  if (other == this) return;
  InternalSwap(other);
}
void InitCustomSubscriber::InternalSwap(InitCustomSubscriber* other) {
  topic_name_.Swap(&other->topic_name_);
  message_type_.Swap(&other->message_type_);
  std::swap(_has_bits_[0], other->_has_bits_[0]);
  _internal_metadata_.Swap(&other->_internal_metadata_);
  std::swap(_cached_size_, other->_cached_size_);
}

::google::protobuf::Metadata InitCustomSubscriber::GetMetadata() const {
  protobuf_AssignDescriptorsOnce();
  ::google::protobuf::Metadata metadata;
  metadata.descriptor = InitCustomSubscriber_descriptor_;
  metadata.reflection = InitCustomSubscriber_reflection_;
  return metadata;
}

#if PROTOBUF_INLINE_NOT_IN_HEADERS
// InitCustomSubscriber

// required string topic_name = 1;
bool InitCustomSubscriber::has_topic_name() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
void InitCustomSubscriber::set_has_topic_name() {
  _has_bits_[0] |= 0x00000001u;
}
void InitCustomSubscriber::clear_has_topic_name() {
  _has_bits_[0] &= ~0x00000001u;
}
void InitCustomSubscriber::clear_topic_name() {
  topic_name_.ClearToEmptyNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
  clear_has_topic_name();
}
 const ::std::string& InitCustomSubscriber::topic_name() const {
  // @@protoc_insertion_point(field_get:mw.internal.robotics.gazebotransport.InitCustomSubscriber.topic_name)
  return topic_name_.GetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
 void InitCustomSubscriber::set_topic_name(const ::std::string& value) {
  set_has_topic_name();
  topic_name_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), value);
  // @@protoc_insertion_point(field_set:mw.internal.robotics.gazebotransport.InitCustomSubscriber.topic_name)
}
 void InitCustomSubscriber::set_topic_name(const char* value) {
  set_has_topic_name();
  topic_name_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::string(value));
  // @@protoc_insertion_point(field_set_char:mw.internal.robotics.gazebotransport.InitCustomSubscriber.topic_name)
}
 void InitCustomSubscriber::set_topic_name(const char* value, size_t size) {
  set_has_topic_name();
  topic_name_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(),
      ::std::string(reinterpret_cast<const char*>(value), size));
  // @@protoc_insertion_point(field_set_pointer:mw.internal.robotics.gazebotransport.InitCustomSubscriber.topic_name)
}
 ::std::string* InitCustomSubscriber::mutable_topic_name() {
  set_has_topic_name();
  // @@protoc_insertion_point(field_mutable:mw.internal.robotics.gazebotransport.InitCustomSubscriber.topic_name)
  return topic_name_.MutableNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
 ::std::string* InitCustomSubscriber::release_topic_name() {
  // @@protoc_insertion_point(field_release:mw.internal.robotics.gazebotransport.InitCustomSubscriber.topic_name)
  clear_has_topic_name();
  return topic_name_.ReleaseNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
 void InitCustomSubscriber::set_allocated_topic_name(::std::string* topic_name) {
  if (topic_name != NULL) {
    set_has_topic_name();
  } else {
    clear_has_topic_name();
  }
  topic_name_.SetAllocatedNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), topic_name);
  // @@protoc_insertion_point(field_set_allocated:mw.internal.robotics.gazebotransport.InitCustomSubscriber.topic_name)
}

// required string message_type = 2;
bool InitCustomSubscriber::has_message_type() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
void InitCustomSubscriber::set_has_message_type() {
  _has_bits_[0] |= 0x00000002u;
}
void InitCustomSubscriber::clear_has_message_type() {
  _has_bits_[0] &= ~0x00000002u;
}
void InitCustomSubscriber::clear_message_type() {
  message_type_.ClearToEmptyNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
  clear_has_message_type();
}
 const ::std::string& InitCustomSubscriber::message_type() const {
  // @@protoc_insertion_point(field_get:mw.internal.robotics.gazebotransport.InitCustomSubscriber.message_type)
  return message_type_.GetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
 void InitCustomSubscriber::set_message_type(const ::std::string& value) {
  set_has_message_type();
  message_type_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), value);
  // @@protoc_insertion_point(field_set:mw.internal.robotics.gazebotransport.InitCustomSubscriber.message_type)
}
 void InitCustomSubscriber::set_message_type(const char* value) {
  set_has_message_type();
  message_type_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::string(value));
  // @@protoc_insertion_point(field_set_char:mw.internal.robotics.gazebotransport.InitCustomSubscriber.message_type)
}
 void InitCustomSubscriber::set_message_type(const char* value, size_t size) {
  set_has_message_type();
  message_type_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(),
      ::std::string(reinterpret_cast<const char*>(value), size));
  // @@protoc_insertion_point(field_set_pointer:mw.internal.robotics.gazebotransport.InitCustomSubscriber.message_type)
}
 ::std::string* InitCustomSubscriber::mutable_message_type() {
  set_has_message_type();
  // @@protoc_insertion_point(field_mutable:mw.internal.robotics.gazebotransport.InitCustomSubscriber.message_type)
  return message_type_.MutableNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
 ::std::string* InitCustomSubscriber::release_message_type() {
  // @@protoc_insertion_point(field_release:mw.internal.robotics.gazebotransport.InitCustomSubscriber.message_type)
  clear_has_message_type();
  return message_type_.ReleaseNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
 void InitCustomSubscriber::set_allocated_message_type(::std::string* message_type) {
  if (message_type != NULL) {
    set_has_message_type();
  } else {
    clear_has_message_type();
  }
  message_type_.SetAllocatedNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), message_type);
  // @@protoc_insertion_point(field_set_allocated:mw.internal.robotics.gazebotransport.InitCustomSubscriber.message_type)
}

#endif  // PROTOBUF_INLINE_NOT_IN_HEADERS

// ===================================================================

#if !defined(_MSC_VER) || _MSC_VER >= 1900
const int CustomMessageSupport::kTopicNameFieldNumber;
const int CustomMessageSupport::kMessageTypeFieldNumber;
const int CustomMessageSupport::kDataFieldNumber;
const int CustomMessageSupport::kIsNewFieldNumber;
#endif  // !defined(_MSC_VER) || _MSC_VER >= 1900

CustomMessageSupport::CustomMessageSupport()
  : ::google::protobuf::Message(), _internal_metadata_(NULL) {
  SharedCtor();
  // @@protoc_insertion_point(constructor:mw.internal.robotics.gazebotransport.CustomMessageSupport)
}

void CustomMessageSupport::InitAsDefaultInstance() {
}

CustomMessageSupport::CustomMessageSupport(const CustomMessageSupport& from)
  : ::google::protobuf::Message(),
    _internal_metadata_(NULL) {
  SharedCtor();
  MergeFrom(from);
  // @@protoc_insertion_point(copy_constructor:mw.internal.robotics.gazebotransport.CustomMessageSupport)
}

void CustomMessageSupport::SharedCtor() {
  ::google::protobuf::internal::GetEmptyString();
  _cached_size_ = 0;
  topic_name_.UnsafeSetDefault(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
  message_type_.UnsafeSetDefault(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
  data_.UnsafeSetDefault(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
  is_new_ = false;
  ::memset(_has_bits_, 0, sizeof(_has_bits_));
}

CustomMessageSupport::~CustomMessageSupport() {
  // @@protoc_insertion_point(destructor:mw.internal.robotics.gazebotransport.CustomMessageSupport)
  SharedDtor();
}

void CustomMessageSupport::SharedDtor() {
  topic_name_.DestroyNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
  message_type_.DestroyNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
  data_.DestroyNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
  if (this != default_instance_) {
  }
}

void CustomMessageSupport::SetCachedSize(int size) const {
  GOOGLE_SAFE_CONCURRENT_WRITES_BEGIN();
  _cached_size_ = size;
  GOOGLE_SAFE_CONCURRENT_WRITES_END();
}
const ::google::protobuf::Descriptor* CustomMessageSupport::descriptor() {
  protobuf_AssignDescriptorsOnce();
  return CustomMessageSupport_descriptor_;
}

const CustomMessageSupport& CustomMessageSupport::default_instance() {
  if (default_instance_ == NULL) protobuf_AddDesc_mw_2einternal_2erobotics_2egazebotransport_2eCoSimMsgs_2eproto();
  return *default_instance_;
}

CustomMessageSupport* CustomMessageSupport::default_instance_ = NULL;

CustomMessageSupport* CustomMessageSupport::New(::google::protobuf::Arena* arena) const {
  CustomMessageSupport* n = new CustomMessageSupport;
  if (arena != NULL) {
    arena->Own(n);
  }
  return n;
}

void CustomMessageSupport::Clear() {
// @@protoc_insertion_point(message_clear_start:mw.internal.robotics.gazebotransport.CustomMessageSupport)
  if (_has_bits_[0 / 32] & 15u) {
    if (has_topic_name()) {
      topic_name_.ClearToEmptyNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
    }
    if (has_message_type()) {
      message_type_.ClearToEmptyNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
    }
    if (has_data()) {
      data_.ClearToEmptyNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
    }
    is_new_ = false;
  }
  ::memset(_has_bits_, 0, sizeof(_has_bits_));
  if (_internal_metadata_.have_unknown_fields()) {
    mutable_unknown_fields()->Clear();
  }
}

bool CustomMessageSupport::MergePartialFromCodedStream(
    ::google::protobuf::io::CodedInputStream* input) {
#define DO_(EXPRESSION) if (!GOOGLE_PREDICT_TRUE(EXPRESSION)) goto failure
  ::google::protobuf::uint32 tag;
  // @@protoc_insertion_point(parse_start:mw.internal.robotics.gazebotransport.CustomMessageSupport)
  for (;;) {
    ::std::pair< ::google::protobuf::uint32, bool> p = input->ReadTagWithCutoff(127);
    tag = p.first;
    if (!p.second) goto handle_unusual;
    switch (::google::protobuf::internal::WireFormatLite::GetTagFieldNumber(tag)) {
      // required string topic_name = 1;
      case 1: {
        if (tag == 10) {
          DO_(::google::protobuf::internal::WireFormatLite::ReadString(
                input, this->mutable_topic_name()));
          ::google::protobuf::internal::WireFormat::VerifyUTF8StringNamedField(
            this->topic_name().data(), this->topic_name().length(),
            ::google::protobuf::internal::WireFormat::PARSE,
            "mw.internal.robotics.gazebotransport.CustomMessageSupport.topic_name");
        } else {
          goto handle_unusual;
        }
        if (input->ExpectTag(18)) goto parse_message_type;
        break;
      }

      // required string message_type = 2;
      case 2: {
        if (tag == 18) {
         parse_message_type:
          DO_(::google::protobuf::internal::WireFormatLite::ReadString(
                input, this->mutable_message_type()));
          ::google::protobuf::internal::WireFormat::VerifyUTF8StringNamedField(
            this->message_type().data(), this->message_type().length(),
            ::google::protobuf::internal::WireFormat::PARSE,
            "mw.internal.robotics.gazebotransport.CustomMessageSupport.message_type");
        } else {
          goto handle_unusual;
        }
        if (input->ExpectTag(26)) goto parse_data;
        break;
      }

      // required bytes data = 3;
      case 3: {
        if (tag == 26) {
         parse_data:
          DO_(::google::protobuf::internal::WireFormatLite::ReadBytes(
                input, this->mutable_data()));
        } else {
          goto handle_unusual;
        }
        if (input->ExpectTag(32)) goto parse_is_new;
        break;
      }

      // optional bool is_new = 4;
      case 4: {
        if (tag == 32) {
         parse_is_new:
          DO_((::google::protobuf::internal::WireFormatLite::ReadPrimitive<
                   bool, ::google::protobuf::internal::WireFormatLite::TYPE_BOOL>(
                 input, &is_new_)));
          set_has_is_new();
        } else {
          goto handle_unusual;
        }
        if (input->ExpectAtEnd()) goto success;
        break;
      }

      default: {
      handle_unusual:
        if (tag == 0 ||
            ::google::protobuf::internal::WireFormatLite::GetTagWireType(tag) ==
            ::google::protobuf::internal::WireFormatLite::WIRETYPE_END_GROUP) {
          goto success;
        }
        DO_(::google::protobuf::internal::WireFormat::SkipField(
              input, tag, mutable_unknown_fields()));
        break;
      }
    }
  }
success:
  // @@protoc_insertion_point(parse_success:mw.internal.robotics.gazebotransport.CustomMessageSupport)
  return true;
failure:
  // @@protoc_insertion_point(parse_failure:mw.internal.robotics.gazebotransport.CustomMessageSupport)
  return false;
#undef DO_
}

void CustomMessageSupport::SerializeWithCachedSizes(
    ::google::protobuf::io::CodedOutputStream* output) const {
  // @@protoc_insertion_point(serialize_start:mw.internal.robotics.gazebotransport.CustomMessageSupport)
  // required string topic_name = 1;
  if (has_topic_name()) {
    ::google::protobuf::internal::WireFormat::VerifyUTF8StringNamedField(
      this->topic_name().data(), this->topic_name().length(),
      ::google::protobuf::internal::WireFormat::SERIALIZE,
      "mw.internal.robotics.gazebotransport.CustomMessageSupport.topic_name");
    ::google::protobuf::internal::WireFormatLite::WriteStringMaybeAliased(
      1, this->topic_name(), output);
  }

  // required string message_type = 2;
  if (has_message_type()) {
    ::google::protobuf::internal::WireFormat::VerifyUTF8StringNamedField(
      this->message_type().data(), this->message_type().length(),
      ::google::protobuf::internal::WireFormat::SERIALIZE,
      "mw.internal.robotics.gazebotransport.CustomMessageSupport.message_type");
    ::google::protobuf::internal::WireFormatLite::WriteStringMaybeAliased(
      2, this->message_type(), output);
  }

  // required bytes data = 3;
  if (has_data()) {
    ::google::protobuf::internal::WireFormatLite::WriteBytesMaybeAliased(
      3, this->data(), output);
  }

  // optional bool is_new = 4;
  if (has_is_new()) {
    ::google::protobuf::internal::WireFormatLite::WriteBool(4, this->is_new(), output);
  }

  if (_internal_metadata_.have_unknown_fields()) {
    ::google::protobuf::internal::WireFormat::SerializeUnknownFields(
        unknown_fields(), output);
  }
  // @@protoc_insertion_point(serialize_end:mw.internal.robotics.gazebotransport.CustomMessageSupport)
}

::google::protobuf::uint8* CustomMessageSupport::InternalSerializeWithCachedSizesToArray(
    bool deterministic, ::google::protobuf::uint8* target) const {
  // @@protoc_insertion_point(serialize_to_array_start:mw.internal.robotics.gazebotransport.CustomMessageSupport)
  // required string topic_name = 1;
  if (has_topic_name()) {
    ::google::protobuf::internal::WireFormat::VerifyUTF8StringNamedField(
      this->topic_name().data(), this->topic_name().length(),
      ::google::protobuf::internal::WireFormat::SERIALIZE,
      "mw.internal.robotics.gazebotransport.CustomMessageSupport.topic_name");
    target =
      ::google::protobuf::internal::WireFormatLite::WriteStringToArray(
        1, this->topic_name(), target);
  }

  // required string message_type = 2;
  if (has_message_type()) {
    ::google::protobuf::internal::WireFormat::VerifyUTF8StringNamedField(
      this->message_type().data(), this->message_type().length(),
      ::google::protobuf::internal::WireFormat::SERIALIZE,
      "mw.internal.robotics.gazebotransport.CustomMessageSupport.message_type");
    target =
      ::google::protobuf::internal::WireFormatLite::WriteStringToArray(
        2, this->message_type(), target);
  }

  // required bytes data = 3;
  if (has_data()) {
    target =
      ::google::protobuf::internal::WireFormatLite::WriteBytesToArray(
        3, this->data(), target);
  }

  // optional bool is_new = 4;
  if (has_is_new()) {
    target = ::google::protobuf::internal::WireFormatLite::WriteBoolToArray(4, this->is_new(), target);
  }

  if (_internal_metadata_.have_unknown_fields()) {
    target = ::google::protobuf::internal::WireFormat::SerializeUnknownFieldsToArray(
        unknown_fields(), target);
  }
  // @@protoc_insertion_point(serialize_to_array_end:mw.internal.robotics.gazebotransport.CustomMessageSupport)
  return target;
}

int CustomMessageSupport::RequiredFieldsByteSizeFallback() const {
// @@protoc_insertion_point(required_fields_byte_size_fallback_start:mw.internal.robotics.gazebotransport.CustomMessageSupport)
  int total_size = 0;

  if (has_topic_name()) {
    // required string topic_name = 1;
    total_size += 1 +
      ::google::protobuf::internal::WireFormatLite::StringSize(
        this->topic_name());
  }

  if (has_message_type()) {
    // required string message_type = 2;
    total_size += 1 +
      ::google::protobuf::internal::WireFormatLite::StringSize(
        this->message_type());
  }

  if (has_data()) {
    // required bytes data = 3;
    total_size += 1 +
      ::google::protobuf::internal::WireFormatLite::BytesSize(
        this->data());
  }

  return total_size;
}
int CustomMessageSupport::ByteSize() const {
// @@protoc_insertion_point(message_byte_size_start:mw.internal.robotics.gazebotransport.CustomMessageSupport)
  int total_size = 0;

  if (((_has_bits_[0] & 0x00000007) ^ 0x00000007) == 0) {  // All required fields are present.
    // required string topic_name = 1;
    total_size += 1 +
      ::google::protobuf::internal::WireFormatLite::StringSize(
        this->topic_name());

    // required string message_type = 2;
    total_size += 1 +
      ::google::protobuf::internal::WireFormatLite::StringSize(
        this->message_type());

    // required bytes data = 3;
    total_size += 1 +
      ::google::protobuf::internal::WireFormatLite::BytesSize(
        this->data());

  } else {
    total_size += RequiredFieldsByteSizeFallback();
  }
  // optional bool is_new = 4;
  if (has_is_new()) {
    total_size += 1 + 1;
  }

  if (_internal_metadata_.have_unknown_fields()) {
    total_size +=
      ::google::protobuf::internal::WireFormat::ComputeUnknownFieldsSize(
        unknown_fields());
  }
  GOOGLE_SAFE_CONCURRENT_WRITES_BEGIN();
  _cached_size_ = total_size;
  GOOGLE_SAFE_CONCURRENT_WRITES_END();
  return total_size;
}

void CustomMessageSupport::MergeFrom(const ::google::protobuf::Message& from) {
// @@protoc_insertion_point(generalized_merge_from_start:mw.internal.robotics.gazebotransport.CustomMessageSupport)
  if (GOOGLE_PREDICT_FALSE(&from == this)) {
    ::google::protobuf::internal::MergeFromFail(__FILE__, __LINE__);
  }
  const CustomMessageSupport* source = 
      ::google::protobuf::internal::DynamicCastToGenerated<const CustomMessageSupport>(
          &from);
  if (source == NULL) {
  // @@protoc_insertion_point(generalized_merge_from_cast_fail:mw.internal.robotics.gazebotransport.CustomMessageSupport)
    ::google::protobuf::internal::ReflectionOps::Merge(from, this);
  } else {
  // @@protoc_insertion_point(generalized_merge_from_cast_success:mw.internal.robotics.gazebotransport.CustomMessageSupport)
    MergeFrom(*source);
  }
}

void CustomMessageSupport::MergeFrom(const CustomMessageSupport& from) {
// @@protoc_insertion_point(class_specific_merge_from_start:mw.internal.robotics.gazebotransport.CustomMessageSupport)
  if (GOOGLE_PREDICT_FALSE(&from == this)) {
    ::google::protobuf::internal::MergeFromFail(__FILE__, __LINE__);
  }
  if (from._has_bits_[0 / 32] & (0xffu << (0 % 32))) {
    if (from.has_topic_name()) {
      set_has_topic_name();
      topic_name_.AssignWithDefault(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), from.topic_name_);
    }
    if (from.has_message_type()) {
      set_has_message_type();
      message_type_.AssignWithDefault(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), from.message_type_);
    }
    if (from.has_data()) {
      set_has_data();
      data_.AssignWithDefault(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), from.data_);
    }
    if (from.has_is_new()) {
      set_is_new(from.is_new());
    }
  }
  if (from._internal_metadata_.have_unknown_fields()) {
    mutable_unknown_fields()->MergeFrom(from.unknown_fields());
  }
}

void CustomMessageSupport::CopyFrom(const ::google::protobuf::Message& from) {
// @@protoc_insertion_point(generalized_copy_from_start:mw.internal.robotics.gazebotransport.CustomMessageSupport)
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

void CustomMessageSupport::CopyFrom(const CustomMessageSupport& from) {
// @@protoc_insertion_point(class_specific_copy_from_start:mw.internal.robotics.gazebotransport.CustomMessageSupport)
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

bool CustomMessageSupport::IsInitialized() const {
  if ((_has_bits_[0] & 0x00000007) != 0x00000007) return false;

  return true;
}

void CustomMessageSupport::Swap(CustomMessageSupport* other) {
  if (other == this) return;
  InternalSwap(other);
}
void CustomMessageSupport::InternalSwap(CustomMessageSupport* other) {
  topic_name_.Swap(&other->topic_name_);
  message_type_.Swap(&other->message_type_);
  data_.Swap(&other->data_);
  std::swap(is_new_, other->is_new_);
  std::swap(_has_bits_[0], other->_has_bits_[0]);
  _internal_metadata_.Swap(&other->_internal_metadata_);
  std::swap(_cached_size_, other->_cached_size_);
}

::google::protobuf::Metadata CustomMessageSupport::GetMetadata() const {
  protobuf_AssignDescriptorsOnce();
  ::google::protobuf::Metadata metadata;
  metadata.descriptor = CustomMessageSupport_descriptor_;
  metadata.reflection = CustomMessageSupport_reflection_;
  return metadata;
}

#if PROTOBUF_INLINE_NOT_IN_HEADERS
// CustomMessageSupport

// required string topic_name = 1;
bool CustomMessageSupport::has_topic_name() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
void CustomMessageSupport::set_has_topic_name() {
  _has_bits_[0] |= 0x00000001u;
}
void CustomMessageSupport::clear_has_topic_name() {
  _has_bits_[0] &= ~0x00000001u;
}
void CustomMessageSupport::clear_topic_name() {
  topic_name_.ClearToEmptyNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
  clear_has_topic_name();
}
 const ::std::string& CustomMessageSupport::topic_name() const {
  // @@protoc_insertion_point(field_get:mw.internal.robotics.gazebotransport.CustomMessageSupport.topic_name)
  return topic_name_.GetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
 void CustomMessageSupport::set_topic_name(const ::std::string& value) {
  set_has_topic_name();
  topic_name_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), value);
  // @@protoc_insertion_point(field_set:mw.internal.robotics.gazebotransport.CustomMessageSupport.topic_name)
}
 void CustomMessageSupport::set_topic_name(const char* value) {
  set_has_topic_name();
  topic_name_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::string(value));
  // @@protoc_insertion_point(field_set_char:mw.internal.robotics.gazebotransport.CustomMessageSupport.topic_name)
}
 void CustomMessageSupport::set_topic_name(const char* value, size_t size) {
  set_has_topic_name();
  topic_name_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(),
      ::std::string(reinterpret_cast<const char*>(value), size));
  // @@protoc_insertion_point(field_set_pointer:mw.internal.robotics.gazebotransport.CustomMessageSupport.topic_name)
}
 ::std::string* CustomMessageSupport::mutable_topic_name() {
  set_has_topic_name();
  // @@protoc_insertion_point(field_mutable:mw.internal.robotics.gazebotransport.CustomMessageSupport.topic_name)
  return topic_name_.MutableNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
 ::std::string* CustomMessageSupport::release_topic_name() {
  // @@protoc_insertion_point(field_release:mw.internal.robotics.gazebotransport.CustomMessageSupport.topic_name)
  clear_has_topic_name();
  return topic_name_.ReleaseNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
 void CustomMessageSupport::set_allocated_topic_name(::std::string* topic_name) {
  if (topic_name != NULL) {
    set_has_topic_name();
  } else {
    clear_has_topic_name();
  }
  topic_name_.SetAllocatedNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), topic_name);
  // @@protoc_insertion_point(field_set_allocated:mw.internal.robotics.gazebotransport.CustomMessageSupport.topic_name)
}

// required string message_type = 2;
bool CustomMessageSupport::has_message_type() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
void CustomMessageSupport::set_has_message_type() {
  _has_bits_[0] |= 0x00000002u;
}
void CustomMessageSupport::clear_has_message_type() {
  _has_bits_[0] &= ~0x00000002u;
}
void CustomMessageSupport::clear_message_type() {
  message_type_.ClearToEmptyNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
  clear_has_message_type();
}
 const ::std::string& CustomMessageSupport::message_type() const {
  // @@protoc_insertion_point(field_get:mw.internal.robotics.gazebotransport.CustomMessageSupport.message_type)
  return message_type_.GetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
 void CustomMessageSupport::set_message_type(const ::std::string& value) {
  set_has_message_type();
  message_type_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), value);
  // @@protoc_insertion_point(field_set:mw.internal.robotics.gazebotransport.CustomMessageSupport.message_type)
}
 void CustomMessageSupport::set_message_type(const char* value) {
  set_has_message_type();
  message_type_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::string(value));
  // @@protoc_insertion_point(field_set_char:mw.internal.robotics.gazebotransport.CustomMessageSupport.message_type)
}
 void CustomMessageSupport::set_message_type(const char* value, size_t size) {
  set_has_message_type();
  message_type_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(),
      ::std::string(reinterpret_cast<const char*>(value), size));
  // @@protoc_insertion_point(field_set_pointer:mw.internal.robotics.gazebotransport.CustomMessageSupport.message_type)
}
 ::std::string* CustomMessageSupport::mutable_message_type() {
  set_has_message_type();
  // @@protoc_insertion_point(field_mutable:mw.internal.robotics.gazebotransport.CustomMessageSupport.message_type)
  return message_type_.MutableNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
 ::std::string* CustomMessageSupport::release_message_type() {
  // @@protoc_insertion_point(field_release:mw.internal.robotics.gazebotransport.CustomMessageSupport.message_type)
  clear_has_message_type();
  return message_type_.ReleaseNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
 void CustomMessageSupport::set_allocated_message_type(::std::string* message_type) {
  if (message_type != NULL) {
    set_has_message_type();
  } else {
    clear_has_message_type();
  }
  message_type_.SetAllocatedNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), message_type);
  // @@protoc_insertion_point(field_set_allocated:mw.internal.robotics.gazebotransport.CustomMessageSupport.message_type)
}

// required bytes data = 3;
bool CustomMessageSupport::has_data() const {
  return (_has_bits_[0] & 0x00000004u) != 0;
}
void CustomMessageSupport::set_has_data() {
  _has_bits_[0] |= 0x00000004u;
}
void CustomMessageSupport::clear_has_data() {
  _has_bits_[0] &= ~0x00000004u;
}
void CustomMessageSupport::clear_data() {
  data_.ClearToEmptyNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
  clear_has_data();
}
 const ::std::string& CustomMessageSupport::data() const {
  // @@protoc_insertion_point(field_get:mw.internal.robotics.gazebotransport.CustomMessageSupport.data)
  return data_.GetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
 void CustomMessageSupport::set_data(const ::std::string& value) {
  set_has_data();
  data_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), value);
  // @@protoc_insertion_point(field_set:mw.internal.robotics.gazebotransport.CustomMessageSupport.data)
}
 void CustomMessageSupport::set_data(const char* value) {
  set_has_data();
  data_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::string(value));
  // @@protoc_insertion_point(field_set_char:mw.internal.robotics.gazebotransport.CustomMessageSupport.data)
}
 void CustomMessageSupport::set_data(const void* value, size_t size) {
  set_has_data();
  data_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(),
      ::std::string(reinterpret_cast<const char*>(value), size));
  // @@protoc_insertion_point(field_set_pointer:mw.internal.robotics.gazebotransport.CustomMessageSupport.data)
}
 ::std::string* CustomMessageSupport::mutable_data() {
  set_has_data();
  // @@protoc_insertion_point(field_mutable:mw.internal.robotics.gazebotransport.CustomMessageSupport.data)
  return data_.MutableNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
 ::std::string* CustomMessageSupport::release_data() {
  // @@protoc_insertion_point(field_release:mw.internal.robotics.gazebotransport.CustomMessageSupport.data)
  clear_has_data();
  return data_.ReleaseNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
 void CustomMessageSupport::set_allocated_data(::std::string* data) {
  if (data != NULL) {
    set_has_data();
  } else {
    clear_has_data();
  }
  data_.SetAllocatedNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), data);
  // @@protoc_insertion_point(field_set_allocated:mw.internal.robotics.gazebotransport.CustomMessageSupport.data)
}

// optional bool is_new = 4;
bool CustomMessageSupport::has_is_new() const {
  return (_has_bits_[0] & 0x00000008u) != 0;
}
void CustomMessageSupport::set_has_is_new() {
  _has_bits_[0] |= 0x00000008u;
}
void CustomMessageSupport::clear_has_is_new() {
  _has_bits_[0] &= ~0x00000008u;
}
void CustomMessageSupport::clear_is_new() {
  is_new_ = false;
  clear_has_is_new();
}
 bool CustomMessageSupport::is_new() const {
  // @@protoc_insertion_point(field_get:mw.internal.robotics.gazebotransport.CustomMessageSupport.is_new)
  return is_new_;
}
 void CustomMessageSupport::set_is_new(bool value) {
  set_has_is_new();
  is_new_ = value;
  // @@protoc_insertion_point(field_set:mw.internal.robotics.gazebotransport.CustomMessageSupport.is_new)
}

#endif  // PROTOBUF_INLINE_NOT_IN_HEADERS

// ===================================================================

#if !defined(_MSC_VER) || _MSC_VER >= 1900
const int RequestCustomMessageSupport::kTopicNameFieldNumber;
const int RequestCustomMessageSupport::kMessageTypeFieldNumber;
#endif  // !defined(_MSC_VER) || _MSC_VER >= 1900

RequestCustomMessageSupport::RequestCustomMessageSupport()
  : ::google::protobuf::Message(), _internal_metadata_(NULL) {
  SharedCtor();
  // @@protoc_insertion_point(constructor:mw.internal.robotics.gazebotransport.RequestCustomMessageSupport)
}

void RequestCustomMessageSupport::InitAsDefaultInstance() {
}

RequestCustomMessageSupport::RequestCustomMessageSupport(const RequestCustomMessageSupport& from)
  : ::google::protobuf::Message(),
    _internal_metadata_(NULL) {
  SharedCtor();
  MergeFrom(from);
  // @@protoc_insertion_point(copy_constructor:mw.internal.robotics.gazebotransport.RequestCustomMessageSupport)
}

void RequestCustomMessageSupport::SharedCtor() {
  ::google::protobuf::internal::GetEmptyString();
  _cached_size_ = 0;
  topic_name_.UnsafeSetDefault(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
  message_type_.UnsafeSetDefault(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
  ::memset(_has_bits_, 0, sizeof(_has_bits_));
}

RequestCustomMessageSupport::~RequestCustomMessageSupport() {
  // @@protoc_insertion_point(destructor:mw.internal.robotics.gazebotransport.RequestCustomMessageSupport)
  SharedDtor();
}

void RequestCustomMessageSupport::SharedDtor() {
  topic_name_.DestroyNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
  message_type_.DestroyNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
  if (this != default_instance_) {
  }
}

void RequestCustomMessageSupport::SetCachedSize(int size) const {
  GOOGLE_SAFE_CONCURRENT_WRITES_BEGIN();
  _cached_size_ = size;
  GOOGLE_SAFE_CONCURRENT_WRITES_END();
}
const ::google::protobuf::Descriptor* RequestCustomMessageSupport::descriptor() {
  protobuf_AssignDescriptorsOnce();
  return RequestCustomMessageSupport_descriptor_;
}

const RequestCustomMessageSupport& RequestCustomMessageSupport::default_instance() {
  if (default_instance_ == NULL) protobuf_AddDesc_mw_2einternal_2erobotics_2egazebotransport_2eCoSimMsgs_2eproto();
  return *default_instance_;
}

RequestCustomMessageSupport* RequestCustomMessageSupport::default_instance_ = NULL;

RequestCustomMessageSupport* RequestCustomMessageSupport::New(::google::protobuf::Arena* arena) const {
  RequestCustomMessageSupport* n = new RequestCustomMessageSupport;
  if (arena != NULL) {
    arena->Own(n);
  }
  return n;
}

void RequestCustomMessageSupport::Clear() {
// @@protoc_insertion_point(message_clear_start:mw.internal.robotics.gazebotransport.RequestCustomMessageSupport)
  if (_has_bits_[0 / 32] & 3u) {
    if (has_topic_name()) {
      topic_name_.ClearToEmptyNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
    }
    if (has_message_type()) {
      message_type_.ClearToEmptyNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
    }
  }
  ::memset(_has_bits_, 0, sizeof(_has_bits_));
  if (_internal_metadata_.have_unknown_fields()) {
    mutable_unknown_fields()->Clear();
  }
}

bool RequestCustomMessageSupport::MergePartialFromCodedStream(
    ::google::protobuf::io::CodedInputStream* input) {
#define DO_(EXPRESSION) if (!GOOGLE_PREDICT_TRUE(EXPRESSION)) goto failure
  ::google::protobuf::uint32 tag;
  // @@protoc_insertion_point(parse_start:mw.internal.robotics.gazebotransport.RequestCustomMessageSupport)
  for (;;) {
    ::std::pair< ::google::protobuf::uint32, bool> p = input->ReadTagWithCutoff(127);
    tag = p.first;
    if (!p.second) goto handle_unusual;
    switch (::google::protobuf::internal::WireFormatLite::GetTagFieldNumber(tag)) {
      // required string topic_name = 1;
      case 1: {
        if (tag == 10) {
          DO_(::google::protobuf::internal::WireFormatLite::ReadString(
                input, this->mutable_topic_name()));
          ::google::protobuf::internal::WireFormat::VerifyUTF8StringNamedField(
            this->topic_name().data(), this->topic_name().length(),
            ::google::protobuf::internal::WireFormat::PARSE,
            "mw.internal.robotics.gazebotransport.RequestCustomMessageSupport.topic_name");
        } else {
          goto handle_unusual;
        }
        if (input->ExpectTag(18)) goto parse_message_type;
        break;
      }

      // required string message_type = 2;
      case 2: {
        if (tag == 18) {
         parse_message_type:
          DO_(::google::protobuf::internal::WireFormatLite::ReadString(
                input, this->mutable_message_type()));
          ::google::protobuf::internal::WireFormat::VerifyUTF8StringNamedField(
            this->message_type().data(), this->message_type().length(),
            ::google::protobuf::internal::WireFormat::PARSE,
            "mw.internal.robotics.gazebotransport.RequestCustomMessageSupport.message_type");
        } else {
          goto handle_unusual;
        }
        if (input->ExpectAtEnd()) goto success;
        break;
      }

      default: {
      handle_unusual:
        if (tag == 0 ||
            ::google::protobuf::internal::WireFormatLite::GetTagWireType(tag) ==
            ::google::protobuf::internal::WireFormatLite::WIRETYPE_END_GROUP) {
          goto success;
        }
        DO_(::google::protobuf::internal::WireFormat::SkipField(
              input, tag, mutable_unknown_fields()));
        break;
      }
    }
  }
success:
  // @@protoc_insertion_point(parse_success:mw.internal.robotics.gazebotransport.RequestCustomMessageSupport)
  return true;
failure:
  // @@protoc_insertion_point(parse_failure:mw.internal.robotics.gazebotransport.RequestCustomMessageSupport)
  return false;
#undef DO_
}

void RequestCustomMessageSupport::SerializeWithCachedSizes(
    ::google::protobuf::io::CodedOutputStream* output) const {
  // @@protoc_insertion_point(serialize_start:mw.internal.robotics.gazebotransport.RequestCustomMessageSupport)
  // required string topic_name = 1;
  if (has_topic_name()) {
    ::google::protobuf::internal::WireFormat::VerifyUTF8StringNamedField(
      this->topic_name().data(), this->topic_name().length(),
      ::google::protobuf::internal::WireFormat::SERIALIZE,
      "mw.internal.robotics.gazebotransport.RequestCustomMessageSupport.topic_name");
    ::google::protobuf::internal::WireFormatLite::WriteStringMaybeAliased(
      1, this->topic_name(), output);
  }

  // required string message_type = 2;
  if (has_message_type()) {
    ::google::protobuf::internal::WireFormat::VerifyUTF8StringNamedField(
      this->message_type().data(), this->message_type().length(),
      ::google::protobuf::internal::WireFormat::SERIALIZE,
      "mw.internal.robotics.gazebotransport.RequestCustomMessageSupport.message_type");
    ::google::protobuf::internal::WireFormatLite::WriteStringMaybeAliased(
      2, this->message_type(), output);
  }

  if (_internal_metadata_.have_unknown_fields()) {
    ::google::protobuf::internal::WireFormat::SerializeUnknownFields(
        unknown_fields(), output);
  }
  // @@protoc_insertion_point(serialize_end:mw.internal.robotics.gazebotransport.RequestCustomMessageSupport)
}

::google::protobuf::uint8* RequestCustomMessageSupport::InternalSerializeWithCachedSizesToArray(
    bool deterministic, ::google::protobuf::uint8* target) const {
  // @@protoc_insertion_point(serialize_to_array_start:mw.internal.robotics.gazebotransport.RequestCustomMessageSupport)
  // required string topic_name = 1;
  if (has_topic_name()) {
    ::google::protobuf::internal::WireFormat::VerifyUTF8StringNamedField(
      this->topic_name().data(), this->topic_name().length(),
      ::google::protobuf::internal::WireFormat::SERIALIZE,
      "mw.internal.robotics.gazebotransport.RequestCustomMessageSupport.topic_name");
    target =
      ::google::protobuf::internal::WireFormatLite::WriteStringToArray(
        1, this->topic_name(), target);
  }

  // required string message_type = 2;
  if (has_message_type()) {
    ::google::protobuf::internal::WireFormat::VerifyUTF8StringNamedField(
      this->message_type().data(), this->message_type().length(),
      ::google::protobuf::internal::WireFormat::SERIALIZE,
      "mw.internal.robotics.gazebotransport.RequestCustomMessageSupport.message_type");
    target =
      ::google::protobuf::internal::WireFormatLite::WriteStringToArray(
        2, this->message_type(), target);
  }

  if (_internal_metadata_.have_unknown_fields()) {
    target = ::google::protobuf::internal::WireFormat::SerializeUnknownFieldsToArray(
        unknown_fields(), target);
  }
  // @@protoc_insertion_point(serialize_to_array_end:mw.internal.robotics.gazebotransport.RequestCustomMessageSupport)
  return target;
}

int RequestCustomMessageSupport::RequiredFieldsByteSizeFallback() const {
// @@protoc_insertion_point(required_fields_byte_size_fallback_start:mw.internal.robotics.gazebotransport.RequestCustomMessageSupport)
  int total_size = 0;

  if (has_topic_name()) {
    // required string topic_name = 1;
    total_size += 1 +
      ::google::protobuf::internal::WireFormatLite::StringSize(
        this->topic_name());
  }

  if (has_message_type()) {
    // required string message_type = 2;
    total_size += 1 +
      ::google::protobuf::internal::WireFormatLite::StringSize(
        this->message_type());
  }

  return total_size;
}
int RequestCustomMessageSupport::ByteSize() const {
// @@protoc_insertion_point(message_byte_size_start:mw.internal.robotics.gazebotransport.RequestCustomMessageSupport)
  int total_size = 0;

  if (((_has_bits_[0] & 0x00000003) ^ 0x00000003) == 0) {  // All required fields are present.
    // required string topic_name = 1;
    total_size += 1 +
      ::google::protobuf::internal::WireFormatLite::StringSize(
        this->topic_name());

    // required string message_type = 2;
    total_size += 1 +
      ::google::protobuf::internal::WireFormatLite::StringSize(
        this->message_type());

  } else {
    total_size += RequiredFieldsByteSizeFallback();
  }
  if (_internal_metadata_.have_unknown_fields()) {
    total_size +=
      ::google::protobuf::internal::WireFormat::ComputeUnknownFieldsSize(
        unknown_fields());
  }
  GOOGLE_SAFE_CONCURRENT_WRITES_BEGIN();
  _cached_size_ = total_size;
  GOOGLE_SAFE_CONCURRENT_WRITES_END();
  return total_size;
}

void RequestCustomMessageSupport::MergeFrom(const ::google::protobuf::Message& from) {
// @@protoc_insertion_point(generalized_merge_from_start:mw.internal.robotics.gazebotransport.RequestCustomMessageSupport)
  if (GOOGLE_PREDICT_FALSE(&from == this)) {
    ::google::protobuf::internal::MergeFromFail(__FILE__, __LINE__);
  }
  const RequestCustomMessageSupport* source = 
      ::google::protobuf::internal::DynamicCastToGenerated<const RequestCustomMessageSupport>(
          &from);
  if (source == NULL) {
  // @@protoc_insertion_point(generalized_merge_from_cast_fail:mw.internal.robotics.gazebotransport.RequestCustomMessageSupport)
    ::google::protobuf::internal::ReflectionOps::Merge(from, this);
  } else {
  // @@protoc_insertion_point(generalized_merge_from_cast_success:mw.internal.robotics.gazebotransport.RequestCustomMessageSupport)
    MergeFrom(*source);
  }
}

void RequestCustomMessageSupport::MergeFrom(const RequestCustomMessageSupport& from) {
// @@protoc_insertion_point(class_specific_merge_from_start:mw.internal.robotics.gazebotransport.RequestCustomMessageSupport)
  if (GOOGLE_PREDICT_FALSE(&from == this)) {
    ::google::protobuf::internal::MergeFromFail(__FILE__, __LINE__);
  }
  if (from._has_bits_[0 / 32] & (0xffu << (0 % 32))) {
    if (from.has_topic_name()) {
      set_has_topic_name();
      topic_name_.AssignWithDefault(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), from.topic_name_);
    }
    if (from.has_message_type()) {
      set_has_message_type();
      message_type_.AssignWithDefault(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), from.message_type_);
    }
  }
  if (from._internal_metadata_.have_unknown_fields()) {
    mutable_unknown_fields()->MergeFrom(from.unknown_fields());
  }
}

void RequestCustomMessageSupport::CopyFrom(const ::google::protobuf::Message& from) {
// @@protoc_insertion_point(generalized_copy_from_start:mw.internal.robotics.gazebotransport.RequestCustomMessageSupport)
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

void RequestCustomMessageSupport::CopyFrom(const RequestCustomMessageSupport& from) {
// @@protoc_insertion_point(class_specific_copy_from_start:mw.internal.robotics.gazebotransport.RequestCustomMessageSupport)
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

bool RequestCustomMessageSupport::IsInitialized() const {
  if ((_has_bits_[0] & 0x00000003) != 0x00000003) return false;

  return true;
}

void RequestCustomMessageSupport::Swap(RequestCustomMessageSupport* other) {
  if (other == this) return;
  InternalSwap(other);
}
void RequestCustomMessageSupport::InternalSwap(RequestCustomMessageSupport* other) {
  topic_name_.Swap(&other->topic_name_);
  message_type_.Swap(&other->message_type_);
  std::swap(_has_bits_[0], other->_has_bits_[0]);
  _internal_metadata_.Swap(&other->_internal_metadata_);
  std::swap(_cached_size_, other->_cached_size_);
}

::google::protobuf::Metadata RequestCustomMessageSupport::GetMetadata() const {
  protobuf_AssignDescriptorsOnce();
  ::google::protobuf::Metadata metadata;
  metadata.descriptor = RequestCustomMessageSupport_descriptor_;
  metadata.reflection = RequestCustomMessageSupport_reflection_;
  return metadata;
}

#if PROTOBUF_INLINE_NOT_IN_HEADERS
// RequestCustomMessageSupport

// required string topic_name = 1;
bool RequestCustomMessageSupport::has_topic_name() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
void RequestCustomMessageSupport::set_has_topic_name() {
  _has_bits_[0] |= 0x00000001u;
}
void RequestCustomMessageSupport::clear_has_topic_name() {
  _has_bits_[0] &= ~0x00000001u;
}
void RequestCustomMessageSupport::clear_topic_name() {
  topic_name_.ClearToEmptyNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
  clear_has_topic_name();
}
 const ::std::string& RequestCustomMessageSupport::topic_name() const {
  // @@protoc_insertion_point(field_get:mw.internal.robotics.gazebotransport.RequestCustomMessageSupport.topic_name)
  return topic_name_.GetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
 void RequestCustomMessageSupport::set_topic_name(const ::std::string& value) {
  set_has_topic_name();
  topic_name_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), value);
  // @@protoc_insertion_point(field_set:mw.internal.robotics.gazebotransport.RequestCustomMessageSupport.topic_name)
}
 void RequestCustomMessageSupport::set_topic_name(const char* value) {
  set_has_topic_name();
  topic_name_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::string(value));
  // @@protoc_insertion_point(field_set_char:mw.internal.robotics.gazebotransport.RequestCustomMessageSupport.topic_name)
}
 void RequestCustomMessageSupport::set_topic_name(const char* value, size_t size) {
  set_has_topic_name();
  topic_name_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(),
      ::std::string(reinterpret_cast<const char*>(value), size));
  // @@protoc_insertion_point(field_set_pointer:mw.internal.robotics.gazebotransport.RequestCustomMessageSupport.topic_name)
}
 ::std::string* RequestCustomMessageSupport::mutable_topic_name() {
  set_has_topic_name();
  // @@protoc_insertion_point(field_mutable:mw.internal.robotics.gazebotransport.RequestCustomMessageSupport.topic_name)
  return topic_name_.MutableNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
 ::std::string* RequestCustomMessageSupport::release_topic_name() {
  // @@protoc_insertion_point(field_release:mw.internal.robotics.gazebotransport.RequestCustomMessageSupport.topic_name)
  clear_has_topic_name();
  return topic_name_.ReleaseNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
 void RequestCustomMessageSupport::set_allocated_topic_name(::std::string* topic_name) {
  if (topic_name != NULL) {
    set_has_topic_name();
  } else {
    clear_has_topic_name();
  }
  topic_name_.SetAllocatedNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), topic_name);
  // @@protoc_insertion_point(field_set_allocated:mw.internal.robotics.gazebotransport.RequestCustomMessageSupport.topic_name)
}

// required string message_type = 2;
bool RequestCustomMessageSupport::has_message_type() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
void RequestCustomMessageSupport::set_has_message_type() {
  _has_bits_[0] |= 0x00000002u;
}
void RequestCustomMessageSupport::clear_has_message_type() {
  _has_bits_[0] &= ~0x00000002u;
}
void RequestCustomMessageSupport::clear_message_type() {
  message_type_.ClearToEmptyNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
  clear_has_message_type();
}
 const ::std::string& RequestCustomMessageSupport::message_type() const {
  // @@protoc_insertion_point(field_get:mw.internal.robotics.gazebotransport.RequestCustomMessageSupport.message_type)
  return message_type_.GetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
 void RequestCustomMessageSupport::set_message_type(const ::std::string& value) {
  set_has_message_type();
  message_type_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), value);
  // @@protoc_insertion_point(field_set:mw.internal.robotics.gazebotransport.RequestCustomMessageSupport.message_type)
}
 void RequestCustomMessageSupport::set_message_type(const char* value) {
  set_has_message_type();
  message_type_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::string(value));
  // @@protoc_insertion_point(field_set_char:mw.internal.robotics.gazebotransport.RequestCustomMessageSupport.message_type)
}
 void RequestCustomMessageSupport::set_message_type(const char* value, size_t size) {
  set_has_message_type();
  message_type_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(),
      ::std::string(reinterpret_cast<const char*>(value), size));
  // @@protoc_insertion_point(field_set_pointer:mw.internal.robotics.gazebotransport.RequestCustomMessageSupport.message_type)
}
 ::std::string* RequestCustomMessageSupport::mutable_message_type() {
  set_has_message_type();
  // @@protoc_insertion_point(field_mutable:mw.internal.robotics.gazebotransport.RequestCustomMessageSupport.message_type)
  return message_type_.MutableNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
 ::std::string* RequestCustomMessageSupport::release_message_type() {
  // @@protoc_insertion_point(field_release:mw.internal.robotics.gazebotransport.RequestCustomMessageSupport.message_type)
  clear_has_message_type();
  return message_type_.ReleaseNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
 void RequestCustomMessageSupport::set_allocated_message_type(::std::string* message_type) {
  if (message_type != NULL) {
    set_has_message_type();
  } else {
    clear_has_message_type();
  }
  message_type_.SetAllocatedNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), message_type);
  // @@protoc_insertion_point(field_set_allocated:mw.internal.robotics.gazebotransport.RequestCustomMessageSupport.message_type)
}

#endif  // PROTOBUF_INLINE_NOT_IN_HEADERS

// ===================================================================

#if !defined(_MSC_VER) || _MSC_VER >= 1900
const int SetJointPosition::kModelNameFieldNumber;
const int SetJointPosition::kJointNameFieldNumber;
const int SetJointPosition::kIndexFieldNumber;
const int SetJointPosition::kPositionFieldNumber;
const int SetJointPosition::kDurationFieldNumber;
#endif  // !defined(_MSC_VER) || _MSC_VER >= 1900

SetJointPosition::SetJointPosition()
  : ::google::protobuf::Message(), _internal_metadata_(NULL) {
  SharedCtor();
  // @@protoc_insertion_point(constructor:mw.internal.robotics.gazebotransport.SetJointPosition)
}

void SetJointPosition::InitAsDefaultInstance() {
  duration_ = const_cast< ::mw::internal::robotics::gazebotransport::Time*>(&::mw::internal::robotics::gazebotransport::Time::default_instance());
}

SetJointPosition::SetJointPosition(const SetJointPosition& from)
  : ::google::protobuf::Message(),
    _internal_metadata_(NULL) {
  SharedCtor();
  MergeFrom(from);
  // @@protoc_insertion_point(copy_constructor:mw.internal.robotics.gazebotransport.SetJointPosition)
}

void SetJointPosition::SharedCtor() {
  ::google::protobuf::internal::GetEmptyString();
  _cached_size_ = 0;
  model_name_.UnsafeSetDefault(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
  joint_name_.UnsafeSetDefault(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
  index_ = 0u;
  position_ = 0;
  duration_ = NULL;
  ::memset(_has_bits_, 0, sizeof(_has_bits_));
}

SetJointPosition::~SetJointPosition() {
  // @@protoc_insertion_point(destructor:mw.internal.robotics.gazebotransport.SetJointPosition)
  SharedDtor();
}

void SetJointPosition::SharedDtor() {
  model_name_.DestroyNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
  joint_name_.DestroyNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
  if (this != default_instance_) {
    delete duration_;
  }
}

void SetJointPosition::SetCachedSize(int size) const {
  GOOGLE_SAFE_CONCURRENT_WRITES_BEGIN();
  _cached_size_ = size;
  GOOGLE_SAFE_CONCURRENT_WRITES_END();
}
const ::google::protobuf::Descriptor* SetJointPosition::descriptor() {
  protobuf_AssignDescriptorsOnce();
  return SetJointPosition_descriptor_;
}

const SetJointPosition& SetJointPosition::default_instance() {
  if (default_instance_ == NULL) protobuf_AddDesc_mw_2einternal_2erobotics_2egazebotransport_2eCoSimMsgs_2eproto();
  return *default_instance_;
}

SetJointPosition* SetJointPosition::default_instance_ = NULL;

SetJointPosition* SetJointPosition::New(::google::protobuf::Arena* arena) const {
  SetJointPosition* n = new SetJointPosition;
  if (arena != NULL) {
    arena->Own(n);
  }
  return n;
}

void SetJointPosition::Clear() {
// @@protoc_insertion_point(message_clear_start:mw.internal.robotics.gazebotransport.SetJointPosition)
  if (_has_bits_[0 / 32] & 31u) {
    if (has_model_name()) {
      model_name_.ClearToEmptyNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
    }
    if (has_joint_name()) {
      joint_name_.ClearToEmptyNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
    }
    index_ = 0u;
    position_ = 0;
    if (has_duration()) {
      if (duration_ != NULL) duration_->::mw::internal::robotics::gazebotransport::Time::Clear();
    }
  }
  ::memset(_has_bits_, 0, sizeof(_has_bits_));
  if (_internal_metadata_.have_unknown_fields()) {
    mutable_unknown_fields()->Clear();
  }
}

bool SetJointPosition::MergePartialFromCodedStream(
    ::google::protobuf::io::CodedInputStream* input) {
#define DO_(EXPRESSION) if (!GOOGLE_PREDICT_TRUE(EXPRESSION)) goto failure
  ::google::protobuf::uint32 tag;
  // @@protoc_insertion_point(parse_start:mw.internal.robotics.gazebotransport.SetJointPosition)
  for (;;) {
    ::std::pair< ::google::protobuf::uint32, bool> p = input->ReadTagWithCutoff(127);
    tag = p.first;
    if (!p.second) goto handle_unusual;
    switch (::google::protobuf::internal::WireFormatLite::GetTagFieldNumber(tag)) {
      // required string model_name = 1;
      case 1: {
        if (tag == 10) {
          DO_(::google::protobuf::internal::WireFormatLite::ReadString(
                input, this->mutable_model_name()));
          ::google::protobuf::internal::WireFormat::VerifyUTF8StringNamedField(
            this->model_name().data(), this->model_name().length(),
            ::google::protobuf::internal::WireFormat::PARSE,
            "mw.internal.robotics.gazebotransport.SetJointPosition.model_name");
        } else {
          goto handle_unusual;
        }
        if (input->ExpectTag(18)) goto parse_joint_name;
        break;
      }

      // required string joint_name = 2;
      case 2: {
        if (tag == 18) {
         parse_joint_name:
          DO_(::google::protobuf::internal::WireFormatLite::ReadString(
                input, this->mutable_joint_name()));
          ::google::protobuf::internal::WireFormat::VerifyUTF8StringNamedField(
            this->joint_name().data(), this->joint_name().length(),
            ::google::protobuf::internal::WireFormat::PARSE,
            "mw.internal.robotics.gazebotransport.SetJointPosition.joint_name");
        } else {
          goto handle_unusual;
        }
        if (input->ExpectTag(24)) goto parse_index;
        break;
      }

      // required uint32 index = 3;
      case 3: {
        if (tag == 24) {
         parse_index:
          DO_((::google::protobuf::internal::WireFormatLite::ReadPrimitive<
                   ::google::protobuf::uint32, ::google::protobuf::internal::WireFormatLite::TYPE_UINT32>(
                 input, &index_)));
          set_has_index();
        } else {
          goto handle_unusual;
        }
        if (input->ExpectTag(33)) goto parse_position;
        break;
      }

      // required double position = 4;
      case 4: {
        if (tag == 33) {
         parse_position:
          DO_((::google::protobuf::internal::WireFormatLite::ReadPrimitive<
                   double, ::google::protobuf::internal::WireFormatLite::TYPE_DOUBLE>(
                 input, &position_)));
          set_has_position();
        } else {
          goto handle_unusual;
        }
        if (input->ExpectTag(42)) goto parse_duration;
        break;
      }

      // required .mw.internal.robotics.gazebotransport.Time duration = 5;
      case 5: {
        if (tag == 42) {
         parse_duration:
          DO_(::google::protobuf::internal::WireFormatLite::ReadMessageNoVirtual(
               input, mutable_duration()));
        } else {
          goto handle_unusual;
        }
        if (input->ExpectAtEnd()) goto success;
        break;
      }

      default: {
      handle_unusual:
        if (tag == 0 ||
            ::google::protobuf::internal::WireFormatLite::GetTagWireType(tag) ==
            ::google::protobuf::internal::WireFormatLite::WIRETYPE_END_GROUP) {
          goto success;
        }
        DO_(::google::protobuf::internal::WireFormat::SkipField(
              input, tag, mutable_unknown_fields()));
        break;
      }
    }
  }
success:
  // @@protoc_insertion_point(parse_success:mw.internal.robotics.gazebotransport.SetJointPosition)
  return true;
failure:
  // @@protoc_insertion_point(parse_failure:mw.internal.robotics.gazebotransport.SetJointPosition)
  return false;
#undef DO_
}

void SetJointPosition::SerializeWithCachedSizes(
    ::google::protobuf::io::CodedOutputStream* output) const {
  // @@protoc_insertion_point(serialize_start:mw.internal.robotics.gazebotransport.SetJointPosition)
  // required string model_name = 1;
  if (has_model_name()) {
    ::google::protobuf::internal::WireFormat::VerifyUTF8StringNamedField(
      this->model_name().data(), this->model_name().length(),
      ::google::protobuf::internal::WireFormat::SERIALIZE,
      "mw.internal.robotics.gazebotransport.SetJointPosition.model_name");
    ::google::protobuf::internal::WireFormatLite::WriteStringMaybeAliased(
      1, this->model_name(), output);
  }

  // required string joint_name = 2;
  if (has_joint_name()) {
    ::google::protobuf::internal::WireFormat::VerifyUTF8StringNamedField(
      this->joint_name().data(), this->joint_name().length(),
      ::google::protobuf::internal::WireFormat::SERIALIZE,
      "mw.internal.robotics.gazebotransport.SetJointPosition.joint_name");
    ::google::protobuf::internal::WireFormatLite::WriteStringMaybeAliased(
      2, this->joint_name(), output);
  }

  // required uint32 index = 3;
  if (has_index()) {
    ::google::protobuf::internal::WireFormatLite::WriteUInt32(3, this->index(), output);
  }

  // required double position = 4;
  if (has_position()) {
    ::google::protobuf::internal::WireFormatLite::WriteDouble(4, this->position(), output);
  }

  // required .mw.internal.robotics.gazebotransport.Time duration = 5;
  if (has_duration()) {
    ::google::protobuf::internal::WireFormatLite::WriteMessageMaybeToArray(
      5, *this->duration_, output);
  }

  if (_internal_metadata_.have_unknown_fields()) {
    ::google::protobuf::internal::WireFormat::SerializeUnknownFields(
        unknown_fields(), output);
  }
  // @@protoc_insertion_point(serialize_end:mw.internal.robotics.gazebotransport.SetJointPosition)
}

::google::protobuf::uint8* SetJointPosition::InternalSerializeWithCachedSizesToArray(
    bool deterministic, ::google::protobuf::uint8* target) const {
  // @@protoc_insertion_point(serialize_to_array_start:mw.internal.robotics.gazebotransport.SetJointPosition)
  // required string model_name = 1;
  if (has_model_name()) {
    ::google::protobuf::internal::WireFormat::VerifyUTF8StringNamedField(
      this->model_name().data(), this->model_name().length(),
      ::google::protobuf::internal::WireFormat::SERIALIZE,
      "mw.internal.robotics.gazebotransport.SetJointPosition.model_name");
    target =
      ::google::protobuf::internal::WireFormatLite::WriteStringToArray(
        1, this->model_name(), target);
  }

  // required string joint_name = 2;
  if (has_joint_name()) {
    ::google::protobuf::internal::WireFormat::VerifyUTF8StringNamedField(
      this->joint_name().data(), this->joint_name().length(),
      ::google::protobuf::internal::WireFormat::SERIALIZE,
      "mw.internal.robotics.gazebotransport.SetJointPosition.joint_name");
    target =
      ::google::protobuf::internal::WireFormatLite::WriteStringToArray(
        2, this->joint_name(), target);
  }

  // required uint32 index = 3;
  if (has_index()) {
    target = ::google::protobuf::internal::WireFormatLite::WriteUInt32ToArray(3, this->index(), target);
  }

  // required double position = 4;
  if (has_position()) {
    target = ::google::protobuf::internal::WireFormatLite::WriteDoubleToArray(4, this->position(), target);
  }

  // required .mw.internal.robotics.gazebotransport.Time duration = 5;
  if (has_duration()) {
    target = ::google::protobuf::internal::WireFormatLite::
      InternalWriteMessageNoVirtualToArray(
        5, *this->duration_, false, target);
  }

  if (_internal_metadata_.have_unknown_fields()) {
    target = ::google::protobuf::internal::WireFormat::SerializeUnknownFieldsToArray(
        unknown_fields(), target);
  }
  // @@protoc_insertion_point(serialize_to_array_end:mw.internal.robotics.gazebotransport.SetJointPosition)
  return target;
}

int SetJointPosition::RequiredFieldsByteSizeFallback() const {
// @@protoc_insertion_point(required_fields_byte_size_fallback_start:mw.internal.robotics.gazebotransport.SetJointPosition)
  int total_size = 0;

  if (has_model_name()) {
    // required string model_name = 1;
    total_size += 1 +
      ::google::protobuf::internal::WireFormatLite::StringSize(
        this->model_name());
  }

  if (has_joint_name()) {
    // required string joint_name = 2;
    total_size += 1 +
      ::google::protobuf::internal::WireFormatLite::StringSize(
        this->joint_name());
  }

  if (has_index()) {
    // required uint32 index = 3;
    total_size += 1 +
      ::google::protobuf::internal::WireFormatLite::UInt32Size(
        this->index());
  }

  if (has_position()) {
    // required double position = 4;
    total_size += 1 + 8;
  }

  if (has_duration()) {
    // required .mw.internal.robotics.gazebotransport.Time duration = 5;
    total_size += 1 +
      ::google::protobuf::internal::WireFormatLite::MessageSizeNoVirtual(
        *this->duration_);
  }

  return total_size;
}
int SetJointPosition::ByteSize() const {
// @@protoc_insertion_point(message_byte_size_start:mw.internal.robotics.gazebotransport.SetJointPosition)
  int total_size = 0;

  if (((_has_bits_[0] & 0x0000001f) ^ 0x0000001f) == 0) {  // All required fields are present.
    // required string model_name = 1;
    total_size += 1 +
      ::google::protobuf::internal::WireFormatLite::StringSize(
        this->model_name());

    // required string joint_name = 2;
    total_size += 1 +
      ::google::protobuf::internal::WireFormatLite::StringSize(
        this->joint_name());

    // required uint32 index = 3;
    total_size += 1 +
      ::google::protobuf::internal::WireFormatLite::UInt32Size(
        this->index());

    // required double position = 4;
    total_size += 1 + 8;

    // required .mw.internal.robotics.gazebotransport.Time duration = 5;
    total_size += 1 +
      ::google::protobuf::internal::WireFormatLite::MessageSizeNoVirtual(
        *this->duration_);

  } else {
    total_size += RequiredFieldsByteSizeFallback();
  }
  if (_internal_metadata_.have_unknown_fields()) {
    total_size +=
      ::google::protobuf::internal::WireFormat::ComputeUnknownFieldsSize(
        unknown_fields());
  }
  GOOGLE_SAFE_CONCURRENT_WRITES_BEGIN();
  _cached_size_ = total_size;
  GOOGLE_SAFE_CONCURRENT_WRITES_END();
  return total_size;
}

void SetJointPosition::MergeFrom(const ::google::protobuf::Message& from) {
// @@protoc_insertion_point(generalized_merge_from_start:mw.internal.robotics.gazebotransport.SetJointPosition)
  if (GOOGLE_PREDICT_FALSE(&from == this)) {
    ::google::protobuf::internal::MergeFromFail(__FILE__, __LINE__);
  }
  const SetJointPosition* source = 
      ::google::protobuf::internal::DynamicCastToGenerated<const SetJointPosition>(
          &from);
  if (source == NULL) {
  // @@protoc_insertion_point(generalized_merge_from_cast_fail:mw.internal.robotics.gazebotransport.SetJointPosition)
    ::google::protobuf::internal::ReflectionOps::Merge(from, this);
  } else {
  // @@protoc_insertion_point(generalized_merge_from_cast_success:mw.internal.robotics.gazebotransport.SetJointPosition)
    MergeFrom(*source);
  }
}

void SetJointPosition::MergeFrom(const SetJointPosition& from) {
// @@protoc_insertion_point(class_specific_merge_from_start:mw.internal.robotics.gazebotransport.SetJointPosition)
  if (GOOGLE_PREDICT_FALSE(&from == this)) {
    ::google::protobuf::internal::MergeFromFail(__FILE__, __LINE__);
  }
  if (from._has_bits_[0 / 32] & (0xffu << (0 % 32))) {
    if (from.has_model_name()) {
      set_has_model_name();
      model_name_.AssignWithDefault(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), from.model_name_);
    }
    if (from.has_joint_name()) {
      set_has_joint_name();
      joint_name_.AssignWithDefault(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), from.joint_name_);
    }
    if (from.has_index()) {
      set_index(from.index());
    }
    if (from.has_position()) {
      set_position(from.position());
    }
    if (from.has_duration()) {
      mutable_duration()->::mw::internal::robotics::gazebotransport::Time::MergeFrom(from.duration());
    }
  }
  if (from._internal_metadata_.have_unknown_fields()) {
    mutable_unknown_fields()->MergeFrom(from.unknown_fields());
  }
}

void SetJointPosition::CopyFrom(const ::google::protobuf::Message& from) {
// @@protoc_insertion_point(generalized_copy_from_start:mw.internal.robotics.gazebotransport.SetJointPosition)
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

void SetJointPosition::CopyFrom(const SetJointPosition& from) {
// @@protoc_insertion_point(class_specific_copy_from_start:mw.internal.robotics.gazebotransport.SetJointPosition)
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

bool SetJointPosition::IsInitialized() const {
  if ((_has_bits_[0] & 0x0000001f) != 0x0000001f) return false;

  if (has_duration()) {
    if (!this->duration_->IsInitialized()) return false;
  }
  return true;
}

void SetJointPosition::Swap(SetJointPosition* other) {
  if (other == this) return;
  InternalSwap(other);
}
void SetJointPosition::InternalSwap(SetJointPosition* other) {
  model_name_.Swap(&other->model_name_);
  joint_name_.Swap(&other->joint_name_);
  std::swap(index_, other->index_);
  std::swap(position_, other->position_);
  std::swap(duration_, other->duration_);
  std::swap(_has_bits_[0], other->_has_bits_[0]);
  _internal_metadata_.Swap(&other->_internal_metadata_);
  std::swap(_cached_size_, other->_cached_size_);
}

::google::protobuf::Metadata SetJointPosition::GetMetadata() const {
  protobuf_AssignDescriptorsOnce();
  ::google::protobuf::Metadata metadata;
  metadata.descriptor = SetJointPosition_descriptor_;
  metadata.reflection = SetJointPosition_reflection_;
  return metadata;
}

#if PROTOBUF_INLINE_NOT_IN_HEADERS
// SetJointPosition

// required string model_name = 1;
bool SetJointPosition::has_model_name() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
void SetJointPosition::set_has_model_name() {
  _has_bits_[0] |= 0x00000001u;
}
void SetJointPosition::clear_has_model_name() {
  _has_bits_[0] &= ~0x00000001u;
}
void SetJointPosition::clear_model_name() {
  model_name_.ClearToEmptyNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
  clear_has_model_name();
}
 const ::std::string& SetJointPosition::model_name() const {
  // @@protoc_insertion_point(field_get:mw.internal.robotics.gazebotransport.SetJointPosition.model_name)
  return model_name_.GetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
 void SetJointPosition::set_model_name(const ::std::string& value) {
  set_has_model_name();
  model_name_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), value);
  // @@protoc_insertion_point(field_set:mw.internal.robotics.gazebotransport.SetJointPosition.model_name)
}
 void SetJointPosition::set_model_name(const char* value) {
  set_has_model_name();
  model_name_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::string(value));
  // @@protoc_insertion_point(field_set_char:mw.internal.robotics.gazebotransport.SetJointPosition.model_name)
}
 void SetJointPosition::set_model_name(const char* value, size_t size) {
  set_has_model_name();
  model_name_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(),
      ::std::string(reinterpret_cast<const char*>(value), size));
  // @@protoc_insertion_point(field_set_pointer:mw.internal.robotics.gazebotransport.SetJointPosition.model_name)
}
 ::std::string* SetJointPosition::mutable_model_name() {
  set_has_model_name();
  // @@protoc_insertion_point(field_mutable:mw.internal.robotics.gazebotransport.SetJointPosition.model_name)
  return model_name_.MutableNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
 ::std::string* SetJointPosition::release_model_name() {
  // @@protoc_insertion_point(field_release:mw.internal.robotics.gazebotransport.SetJointPosition.model_name)
  clear_has_model_name();
  return model_name_.ReleaseNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
 void SetJointPosition::set_allocated_model_name(::std::string* model_name) {
  if (model_name != NULL) {
    set_has_model_name();
  } else {
    clear_has_model_name();
  }
  model_name_.SetAllocatedNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), model_name);
  // @@protoc_insertion_point(field_set_allocated:mw.internal.robotics.gazebotransport.SetJointPosition.model_name)
}

// required string joint_name = 2;
bool SetJointPosition::has_joint_name() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
void SetJointPosition::set_has_joint_name() {
  _has_bits_[0] |= 0x00000002u;
}
void SetJointPosition::clear_has_joint_name() {
  _has_bits_[0] &= ~0x00000002u;
}
void SetJointPosition::clear_joint_name() {
  joint_name_.ClearToEmptyNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
  clear_has_joint_name();
}
 const ::std::string& SetJointPosition::joint_name() const {
  // @@protoc_insertion_point(field_get:mw.internal.robotics.gazebotransport.SetJointPosition.joint_name)
  return joint_name_.GetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
 void SetJointPosition::set_joint_name(const ::std::string& value) {
  set_has_joint_name();
  joint_name_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), value);
  // @@protoc_insertion_point(field_set:mw.internal.robotics.gazebotransport.SetJointPosition.joint_name)
}
 void SetJointPosition::set_joint_name(const char* value) {
  set_has_joint_name();
  joint_name_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::string(value));
  // @@protoc_insertion_point(field_set_char:mw.internal.robotics.gazebotransport.SetJointPosition.joint_name)
}
 void SetJointPosition::set_joint_name(const char* value, size_t size) {
  set_has_joint_name();
  joint_name_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(),
      ::std::string(reinterpret_cast<const char*>(value), size));
  // @@protoc_insertion_point(field_set_pointer:mw.internal.robotics.gazebotransport.SetJointPosition.joint_name)
}
 ::std::string* SetJointPosition::mutable_joint_name() {
  set_has_joint_name();
  // @@protoc_insertion_point(field_mutable:mw.internal.robotics.gazebotransport.SetJointPosition.joint_name)
  return joint_name_.MutableNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
 ::std::string* SetJointPosition::release_joint_name() {
  // @@protoc_insertion_point(field_release:mw.internal.robotics.gazebotransport.SetJointPosition.joint_name)
  clear_has_joint_name();
  return joint_name_.ReleaseNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
 void SetJointPosition::set_allocated_joint_name(::std::string* joint_name) {
  if (joint_name != NULL) {
    set_has_joint_name();
  } else {
    clear_has_joint_name();
  }
  joint_name_.SetAllocatedNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), joint_name);
  // @@protoc_insertion_point(field_set_allocated:mw.internal.robotics.gazebotransport.SetJointPosition.joint_name)
}

// required uint32 index = 3;
bool SetJointPosition::has_index() const {
  return (_has_bits_[0] & 0x00000004u) != 0;
}
void SetJointPosition::set_has_index() {
  _has_bits_[0] |= 0x00000004u;
}
void SetJointPosition::clear_has_index() {
  _has_bits_[0] &= ~0x00000004u;
}
void SetJointPosition::clear_index() {
  index_ = 0u;
  clear_has_index();
}
 ::google::protobuf::uint32 SetJointPosition::index() const {
  // @@protoc_insertion_point(field_get:mw.internal.robotics.gazebotransport.SetJointPosition.index)
  return index_;
}
 void SetJointPosition::set_index(::google::protobuf::uint32 value) {
  set_has_index();
  index_ = value;
  // @@protoc_insertion_point(field_set:mw.internal.robotics.gazebotransport.SetJointPosition.index)
}

// required double position = 4;
bool SetJointPosition::has_position() const {
  return (_has_bits_[0] & 0x00000008u) != 0;
}
void SetJointPosition::set_has_position() {
  _has_bits_[0] |= 0x00000008u;
}
void SetJointPosition::clear_has_position() {
  _has_bits_[0] &= ~0x00000008u;
}
void SetJointPosition::clear_position() {
  position_ = 0;
  clear_has_position();
}
 double SetJointPosition::position() const {
  // @@protoc_insertion_point(field_get:mw.internal.robotics.gazebotransport.SetJointPosition.position)
  return position_;
}
 void SetJointPosition::set_position(double value) {
  set_has_position();
  position_ = value;
  // @@protoc_insertion_point(field_set:mw.internal.robotics.gazebotransport.SetJointPosition.position)
}

// required .mw.internal.robotics.gazebotransport.Time duration = 5;
bool SetJointPosition::has_duration() const {
  return (_has_bits_[0] & 0x00000010u) != 0;
}
void SetJointPosition::set_has_duration() {
  _has_bits_[0] |= 0x00000010u;
}
void SetJointPosition::clear_has_duration() {
  _has_bits_[0] &= ~0x00000010u;
}
void SetJointPosition::clear_duration() {
  if (duration_ != NULL) duration_->::mw::internal::robotics::gazebotransport::Time::Clear();
  clear_has_duration();
}
const ::mw::internal::robotics::gazebotransport::Time& SetJointPosition::duration() const {
  // @@protoc_insertion_point(field_get:mw.internal.robotics.gazebotransport.SetJointPosition.duration)
  return duration_ != NULL ? *duration_ : *default_instance_->duration_;
}
::mw::internal::robotics::gazebotransport::Time* SetJointPosition::mutable_duration() {
  set_has_duration();
  if (duration_ == NULL) {
    duration_ = new ::mw::internal::robotics::gazebotransport::Time;
  }
  // @@protoc_insertion_point(field_mutable:mw.internal.robotics.gazebotransport.SetJointPosition.duration)
  return duration_;
}
::mw::internal::robotics::gazebotransport::Time* SetJointPosition::release_duration() {
  // @@protoc_insertion_point(field_release:mw.internal.robotics.gazebotransport.SetJointPosition.duration)
  clear_has_duration();
  ::mw::internal::robotics::gazebotransport::Time* temp = duration_;
  duration_ = NULL;
  return temp;
}
void SetJointPosition::set_allocated_duration(::mw::internal::robotics::gazebotransport::Time* duration) {
  delete duration_;
  duration_ = duration;
  if (duration) {
    set_has_duration();
  } else {
    clear_has_duration();
  }
  // @@protoc_insertion_point(field_set_allocated:mw.internal.robotics.gazebotransport.SetJointPosition.duration)
}

#endif  // PROTOBUF_INLINE_NOT_IN_HEADERS

// ===================================================================

#if !defined(_MSC_VER) || _MSC_VER >= 1900
const int SetJointVelocity::kModelNameFieldNumber;
const int SetJointVelocity::kJointNameFieldNumber;
const int SetJointVelocity::kIndexFieldNumber;
const int SetJointVelocity::kVelocityFieldNumber;
const int SetJointVelocity::kDurationFieldNumber;
#endif  // !defined(_MSC_VER) || _MSC_VER >= 1900

SetJointVelocity::SetJointVelocity()
  : ::google::protobuf::Message(), _internal_metadata_(NULL) {
  SharedCtor();
  // @@protoc_insertion_point(constructor:mw.internal.robotics.gazebotransport.SetJointVelocity)
}

void SetJointVelocity::InitAsDefaultInstance() {
  duration_ = const_cast< ::mw::internal::robotics::gazebotransport::Time*>(&::mw::internal::robotics::gazebotransport::Time::default_instance());
}

SetJointVelocity::SetJointVelocity(const SetJointVelocity& from)
  : ::google::protobuf::Message(),
    _internal_metadata_(NULL) {
  SharedCtor();
  MergeFrom(from);
  // @@protoc_insertion_point(copy_constructor:mw.internal.robotics.gazebotransport.SetJointVelocity)
}

void SetJointVelocity::SharedCtor() {
  ::google::protobuf::internal::GetEmptyString();
  _cached_size_ = 0;
  model_name_.UnsafeSetDefault(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
  joint_name_.UnsafeSetDefault(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
  index_ = 0u;
  velocity_ = 0;
  duration_ = NULL;
  ::memset(_has_bits_, 0, sizeof(_has_bits_));
}

SetJointVelocity::~SetJointVelocity() {
  // @@protoc_insertion_point(destructor:mw.internal.robotics.gazebotransport.SetJointVelocity)
  SharedDtor();
}

void SetJointVelocity::SharedDtor() {
  model_name_.DestroyNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
  joint_name_.DestroyNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
  if (this != default_instance_) {
    delete duration_;
  }
}

void SetJointVelocity::SetCachedSize(int size) const {
  GOOGLE_SAFE_CONCURRENT_WRITES_BEGIN();
  _cached_size_ = size;
  GOOGLE_SAFE_CONCURRENT_WRITES_END();
}
const ::google::protobuf::Descriptor* SetJointVelocity::descriptor() {
  protobuf_AssignDescriptorsOnce();
  return SetJointVelocity_descriptor_;
}

const SetJointVelocity& SetJointVelocity::default_instance() {
  if (default_instance_ == NULL) protobuf_AddDesc_mw_2einternal_2erobotics_2egazebotransport_2eCoSimMsgs_2eproto();
  return *default_instance_;
}

SetJointVelocity* SetJointVelocity::default_instance_ = NULL;

SetJointVelocity* SetJointVelocity::New(::google::protobuf::Arena* arena) const {
  SetJointVelocity* n = new SetJointVelocity;
  if (arena != NULL) {
    arena->Own(n);
  }
  return n;
}

void SetJointVelocity::Clear() {
// @@protoc_insertion_point(message_clear_start:mw.internal.robotics.gazebotransport.SetJointVelocity)
  if (_has_bits_[0 / 32] & 31u) {
    if (has_model_name()) {
      model_name_.ClearToEmptyNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
    }
    if (has_joint_name()) {
      joint_name_.ClearToEmptyNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
    }
    index_ = 0u;
    velocity_ = 0;
    if (has_duration()) {
      if (duration_ != NULL) duration_->::mw::internal::robotics::gazebotransport::Time::Clear();
    }
  }
  ::memset(_has_bits_, 0, sizeof(_has_bits_));
  if (_internal_metadata_.have_unknown_fields()) {
    mutable_unknown_fields()->Clear();
  }
}

bool SetJointVelocity::MergePartialFromCodedStream(
    ::google::protobuf::io::CodedInputStream* input) {
#define DO_(EXPRESSION) if (!GOOGLE_PREDICT_TRUE(EXPRESSION)) goto failure
  ::google::protobuf::uint32 tag;
  // @@protoc_insertion_point(parse_start:mw.internal.robotics.gazebotransport.SetJointVelocity)
  for (;;) {
    ::std::pair< ::google::protobuf::uint32, bool> p = input->ReadTagWithCutoff(127);
    tag = p.first;
    if (!p.second) goto handle_unusual;
    switch (::google::protobuf::internal::WireFormatLite::GetTagFieldNumber(tag)) {
      // required string model_name = 1;
      case 1: {
        if (tag == 10) {
          DO_(::google::protobuf::internal::WireFormatLite::ReadString(
                input, this->mutable_model_name()));
          ::google::protobuf::internal::WireFormat::VerifyUTF8StringNamedField(
            this->model_name().data(), this->model_name().length(),
            ::google::protobuf::internal::WireFormat::PARSE,
            "mw.internal.robotics.gazebotransport.SetJointVelocity.model_name");
        } else {
          goto handle_unusual;
        }
        if (input->ExpectTag(18)) goto parse_joint_name;
        break;
      }

      // required string joint_name = 2;
      case 2: {
        if (tag == 18) {
         parse_joint_name:
          DO_(::google::protobuf::internal::WireFormatLite::ReadString(
                input, this->mutable_joint_name()));
          ::google::protobuf::internal::WireFormat::VerifyUTF8StringNamedField(
            this->joint_name().data(), this->joint_name().length(),
            ::google::protobuf::internal::WireFormat::PARSE,
            "mw.internal.robotics.gazebotransport.SetJointVelocity.joint_name");
        } else {
          goto handle_unusual;
        }
        if (input->ExpectTag(24)) goto parse_index;
        break;
      }

      // required uint32 index = 3;
      case 3: {
        if (tag == 24) {
         parse_index:
          DO_((::google::protobuf::internal::WireFormatLite::ReadPrimitive<
                   ::google::protobuf::uint32, ::google::protobuf::internal::WireFormatLite::TYPE_UINT32>(
                 input, &index_)));
          set_has_index();
        } else {
          goto handle_unusual;
        }
        if (input->ExpectTag(33)) goto parse_velocity;
        break;
      }

      // required double velocity = 4;
      case 4: {
        if (tag == 33) {
         parse_velocity:
          DO_((::google::protobuf::internal::WireFormatLite::ReadPrimitive<
                   double, ::google::protobuf::internal::WireFormatLite::TYPE_DOUBLE>(
                 input, &velocity_)));
          set_has_velocity();
        } else {
          goto handle_unusual;
        }
        if (input->ExpectTag(42)) goto parse_duration;
        break;
      }

      // required .mw.internal.robotics.gazebotransport.Time duration = 5;
      case 5: {
        if (tag == 42) {
         parse_duration:
          DO_(::google::protobuf::internal::WireFormatLite::ReadMessageNoVirtual(
               input, mutable_duration()));
        } else {
          goto handle_unusual;
        }
        if (input->ExpectAtEnd()) goto success;
        break;
      }

      default: {
      handle_unusual:
        if (tag == 0 ||
            ::google::protobuf::internal::WireFormatLite::GetTagWireType(tag) ==
            ::google::protobuf::internal::WireFormatLite::WIRETYPE_END_GROUP) {
          goto success;
        }
        DO_(::google::protobuf::internal::WireFormat::SkipField(
              input, tag, mutable_unknown_fields()));
        break;
      }
    }
  }
success:
  // @@protoc_insertion_point(parse_success:mw.internal.robotics.gazebotransport.SetJointVelocity)
  return true;
failure:
  // @@protoc_insertion_point(parse_failure:mw.internal.robotics.gazebotransport.SetJointVelocity)
  return false;
#undef DO_
}

void SetJointVelocity::SerializeWithCachedSizes(
    ::google::protobuf::io::CodedOutputStream* output) const {
  // @@protoc_insertion_point(serialize_start:mw.internal.robotics.gazebotransport.SetJointVelocity)
  // required string model_name = 1;
  if (has_model_name()) {
    ::google::protobuf::internal::WireFormat::VerifyUTF8StringNamedField(
      this->model_name().data(), this->model_name().length(),
      ::google::protobuf::internal::WireFormat::SERIALIZE,
      "mw.internal.robotics.gazebotransport.SetJointVelocity.model_name");
    ::google::protobuf::internal::WireFormatLite::WriteStringMaybeAliased(
      1, this->model_name(), output);
  }

  // required string joint_name = 2;
  if (has_joint_name()) {
    ::google::protobuf::internal::WireFormat::VerifyUTF8StringNamedField(
      this->joint_name().data(), this->joint_name().length(),
      ::google::protobuf::internal::WireFormat::SERIALIZE,
      "mw.internal.robotics.gazebotransport.SetJointVelocity.joint_name");
    ::google::protobuf::internal::WireFormatLite::WriteStringMaybeAliased(
      2, this->joint_name(), output);
  }

  // required uint32 index = 3;
  if (has_index()) {
    ::google::protobuf::internal::WireFormatLite::WriteUInt32(3, this->index(), output);
  }

  // required double velocity = 4;
  if (has_velocity()) {
    ::google::protobuf::internal::WireFormatLite::WriteDouble(4, this->velocity(), output);
  }

  // required .mw.internal.robotics.gazebotransport.Time duration = 5;
  if (has_duration()) {
    ::google::protobuf::internal::WireFormatLite::WriteMessageMaybeToArray(
      5, *this->duration_, output);
  }

  if (_internal_metadata_.have_unknown_fields()) {
    ::google::protobuf::internal::WireFormat::SerializeUnknownFields(
        unknown_fields(), output);
  }
  // @@protoc_insertion_point(serialize_end:mw.internal.robotics.gazebotransport.SetJointVelocity)
}

::google::protobuf::uint8* SetJointVelocity::InternalSerializeWithCachedSizesToArray(
    bool deterministic, ::google::protobuf::uint8* target) const {
  // @@protoc_insertion_point(serialize_to_array_start:mw.internal.robotics.gazebotransport.SetJointVelocity)
  // required string model_name = 1;
  if (has_model_name()) {
    ::google::protobuf::internal::WireFormat::VerifyUTF8StringNamedField(
      this->model_name().data(), this->model_name().length(),
      ::google::protobuf::internal::WireFormat::SERIALIZE,
      "mw.internal.robotics.gazebotransport.SetJointVelocity.model_name");
    target =
      ::google::protobuf::internal::WireFormatLite::WriteStringToArray(
        1, this->model_name(), target);
  }

  // required string joint_name = 2;
  if (has_joint_name()) {
    ::google::protobuf::internal::WireFormat::VerifyUTF8StringNamedField(
      this->joint_name().data(), this->joint_name().length(),
      ::google::protobuf::internal::WireFormat::SERIALIZE,
      "mw.internal.robotics.gazebotransport.SetJointVelocity.joint_name");
    target =
      ::google::protobuf::internal::WireFormatLite::WriteStringToArray(
        2, this->joint_name(), target);
  }

  // required uint32 index = 3;
  if (has_index()) {
    target = ::google::protobuf::internal::WireFormatLite::WriteUInt32ToArray(3, this->index(), target);
  }

  // required double velocity = 4;
  if (has_velocity()) {
    target = ::google::protobuf::internal::WireFormatLite::WriteDoubleToArray(4, this->velocity(), target);
  }

  // required .mw.internal.robotics.gazebotransport.Time duration = 5;
  if (has_duration()) {
    target = ::google::protobuf::internal::WireFormatLite::
      InternalWriteMessageNoVirtualToArray(
        5, *this->duration_, false, target);
  }

  if (_internal_metadata_.have_unknown_fields()) {
    target = ::google::protobuf::internal::WireFormat::SerializeUnknownFieldsToArray(
        unknown_fields(), target);
  }
  // @@protoc_insertion_point(serialize_to_array_end:mw.internal.robotics.gazebotransport.SetJointVelocity)
  return target;
}

int SetJointVelocity::RequiredFieldsByteSizeFallback() const {
// @@protoc_insertion_point(required_fields_byte_size_fallback_start:mw.internal.robotics.gazebotransport.SetJointVelocity)
  int total_size = 0;

  if (has_model_name()) {
    // required string model_name = 1;
    total_size += 1 +
      ::google::protobuf::internal::WireFormatLite::StringSize(
        this->model_name());
  }

  if (has_joint_name()) {
    // required string joint_name = 2;
    total_size += 1 +
      ::google::protobuf::internal::WireFormatLite::StringSize(
        this->joint_name());
  }

  if (has_index()) {
    // required uint32 index = 3;
    total_size += 1 +
      ::google::protobuf::internal::WireFormatLite::UInt32Size(
        this->index());
  }

  if (has_velocity()) {
    // required double velocity = 4;
    total_size += 1 + 8;
  }

  if (has_duration()) {
    // required .mw.internal.robotics.gazebotransport.Time duration = 5;
    total_size += 1 +
      ::google::protobuf::internal::WireFormatLite::MessageSizeNoVirtual(
        *this->duration_);
  }

  return total_size;
}
int SetJointVelocity::ByteSize() const {
// @@protoc_insertion_point(message_byte_size_start:mw.internal.robotics.gazebotransport.SetJointVelocity)
  int total_size = 0;

  if (((_has_bits_[0] & 0x0000001f) ^ 0x0000001f) == 0) {  // All required fields are present.
    // required string model_name = 1;
    total_size += 1 +
      ::google::protobuf::internal::WireFormatLite::StringSize(
        this->model_name());

    // required string joint_name = 2;
    total_size += 1 +
      ::google::protobuf::internal::WireFormatLite::StringSize(
        this->joint_name());

    // required uint32 index = 3;
    total_size += 1 +
      ::google::protobuf::internal::WireFormatLite::UInt32Size(
        this->index());

    // required double velocity = 4;
    total_size += 1 + 8;

    // required .mw.internal.robotics.gazebotransport.Time duration = 5;
    total_size += 1 +
      ::google::protobuf::internal::WireFormatLite::MessageSizeNoVirtual(
        *this->duration_);

  } else {
    total_size += RequiredFieldsByteSizeFallback();
  }
  if (_internal_metadata_.have_unknown_fields()) {
    total_size +=
      ::google::protobuf::internal::WireFormat::ComputeUnknownFieldsSize(
        unknown_fields());
  }
  GOOGLE_SAFE_CONCURRENT_WRITES_BEGIN();
  _cached_size_ = total_size;
  GOOGLE_SAFE_CONCURRENT_WRITES_END();
  return total_size;
}

void SetJointVelocity::MergeFrom(const ::google::protobuf::Message& from) {
// @@protoc_insertion_point(generalized_merge_from_start:mw.internal.robotics.gazebotransport.SetJointVelocity)
  if (GOOGLE_PREDICT_FALSE(&from == this)) {
    ::google::protobuf::internal::MergeFromFail(__FILE__, __LINE__);
  }
  const SetJointVelocity* source = 
      ::google::protobuf::internal::DynamicCastToGenerated<const SetJointVelocity>(
          &from);
  if (source == NULL) {
  // @@protoc_insertion_point(generalized_merge_from_cast_fail:mw.internal.robotics.gazebotransport.SetJointVelocity)
    ::google::protobuf::internal::ReflectionOps::Merge(from, this);
  } else {
  // @@protoc_insertion_point(generalized_merge_from_cast_success:mw.internal.robotics.gazebotransport.SetJointVelocity)
    MergeFrom(*source);
  }
}

void SetJointVelocity::MergeFrom(const SetJointVelocity& from) {
// @@protoc_insertion_point(class_specific_merge_from_start:mw.internal.robotics.gazebotransport.SetJointVelocity)
  if (GOOGLE_PREDICT_FALSE(&from == this)) {
    ::google::protobuf::internal::MergeFromFail(__FILE__, __LINE__);
  }
  if (from._has_bits_[0 / 32] & (0xffu << (0 % 32))) {
    if (from.has_model_name()) {
      set_has_model_name();
      model_name_.AssignWithDefault(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), from.model_name_);
    }
    if (from.has_joint_name()) {
      set_has_joint_name();
      joint_name_.AssignWithDefault(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), from.joint_name_);
    }
    if (from.has_index()) {
      set_index(from.index());
    }
    if (from.has_velocity()) {
      set_velocity(from.velocity());
    }
    if (from.has_duration()) {
      mutable_duration()->::mw::internal::robotics::gazebotransport::Time::MergeFrom(from.duration());
    }
  }
  if (from._internal_metadata_.have_unknown_fields()) {
    mutable_unknown_fields()->MergeFrom(from.unknown_fields());
  }
}

void SetJointVelocity::CopyFrom(const ::google::protobuf::Message& from) {
// @@protoc_insertion_point(generalized_copy_from_start:mw.internal.robotics.gazebotransport.SetJointVelocity)
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

void SetJointVelocity::CopyFrom(const SetJointVelocity& from) {
// @@protoc_insertion_point(class_specific_copy_from_start:mw.internal.robotics.gazebotransport.SetJointVelocity)
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

bool SetJointVelocity::IsInitialized() const {
  if ((_has_bits_[0] & 0x0000001f) != 0x0000001f) return false;

  if (has_duration()) {
    if (!this->duration_->IsInitialized()) return false;
  }
  return true;
}

void SetJointVelocity::Swap(SetJointVelocity* other) {
  if (other == this) return;
  InternalSwap(other);
}
void SetJointVelocity::InternalSwap(SetJointVelocity* other) {
  model_name_.Swap(&other->model_name_);
  joint_name_.Swap(&other->joint_name_);
  std::swap(index_, other->index_);
  std::swap(velocity_, other->velocity_);
  std::swap(duration_, other->duration_);
  std::swap(_has_bits_[0], other->_has_bits_[0]);
  _internal_metadata_.Swap(&other->_internal_metadata_);
  std::swap(_cached_size_, other->_cached_size_);
}

::google::protobuf::Metadata SetJointVelocity::GetMetadata() const {
  protobuf_AssignDescriptorsOnce();
  ::google::protobuf::Metadata metadata;
  metadata.descriptor = SetJointVelocity_descriptor_;
  metadata.reflection = SetJointVelocity_reflection_;
  return metadata;
}

#if PROTOBUF_INLINE_NOT_IN_HEADERS
// SetJointVelocity

// required string model_name = 1;
bool SetJointVelocity::has_model_name() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
void SetJointVelocity::set_has_model_name() {
  _has_bits_[0] |= 0x00000001u;
}
void SetJointVelocity::clear_has_model_name() {
  _has_bits_[0] &= ~0x00000001u;
}
void SetJointVelocity::clear_model_name() {
  model_name_.ClearToEmptyNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
  clear_has_model_name();
}
 const ::std::string& SetJointVelocity::model_name() const {
  // @@protoc_insertion_point(field_get:mw.internal.robotics.gazebotransport.SetJointVelocity.model_name)
  return model_name_.GetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
 void SetJointVelocity::set_model_name(const ::std::string& value) {
  set_has_model_name();
  model_name_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), value);
  // @@protoc_insertion_point(field_set:mw.internal.robotics.gazebotransport.SetJointVelocity.model_name)
}
 void SetJointVelocity::set_model_name(const char* value) {
  set_has_model_name();
  model_name_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::string(value));
  // @@protoc_insertion_point(field_set_char:mw.internal.robotics.gazebotransport.SetJointVelocity.model_name)
}
 void SetJointVelocity::set_model_name(const char* value, size_t size) {
  set_has_model_name();
  model_name_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(),
      ::std::string(reinterpret_cast<const char*>(value), size));
  // @@protoc_insertion_point(field_set_pointer:mw.internal.robotics.gazebotransport.SetJointVelocity.model_name)
}
 ::std::string* SetJointVelocity::mutable_model_name() {
  set_has_model_name();
  // @@protoc_insertion_point(field_mutable:mw.internal.robotics.gazebotransport.SetJointVelocity.model_name)
  return model_name_.MutableNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
 ::std::string* SetJointVelocity::release_model_name() {
  // @@protoc_insertion_point(field_release:mw.internal.robotics.gazebotransport.SetJointVelocity.model_name)
  clear_has_model_name();
  return model_name_.ReleaseNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
 void SetJointVelocity::set_allocated_model_name(::std::string* model_name) {
  if (model_name != NULL) {
    set_has_model_name();
  } else {
    clear_has_model_name();
  }
  model_name_.SetAllocatedNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), model_name);
  // @@protoc_insertion_point(field_set_allocated:mw.internal.robotics.gazebotransport.SetJointVelocity.model_name)
}

// required string joint_name = 2;
bool SetJointVelocity::has_joint_name() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
void SetJointVelocity::set_has_joint_name() {
  _has_bits_[0] |= 0x00000002u;
}
void SetJointVelocity::clear_has_joint_name() {
  _has_bits_[0] &= ~0x00000002u;
}
void SetJointVelocity::clear_joint_name() {
  joint_name_.ClearToEmptyNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
  clear_has_joint_name();
}
 const ::std::string& SetJointVelocity::joint_name() const {
  // @@protoc_insertion_point(field_get:mw.internal.robotics.gazebotransport.SetJointVelocity.joint_name)
  return joint_name_.GetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
 void SetJointVelocity::set_joint_name(const ::std::string& value) {
  set_has_joint_name();
  joint_name_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), value);
  // @@protoc_insertion_point(field_set:mw.internal.robotics.gazebotransport.SetJointVelocity.joint_name)
}
 void SetJointVelocity::set_joint_name(const char* value) {
  set_has_joint_name();
  joint_name_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::string(value));
  // @@protoc_insertion_point(field_set_char:mw.internal.robotics.gazebotransport.SetJointVelocity.joint_name)
}
 void SetJointVelocity::set_joint_name(const char* value, size_t size) {
  set_has_joint_name();
  joint_name_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(),
      ::std::string(reinterpret_cast<const char*>(value), size));
  // @@protoc_insertion_point(field_set_pointer:mw.internal.robotics.gazebotransport.SetJointVelocity.joint_name)
}
 ::std::string* SetJointVelocity::mutable_joint_name() {
  set_has_joint_name();
  // @@protoc_insertion_point(field_mutable:mw.internal.robotics.gazebotransport.SetJointVelocity.joint_name)
  return joint_name_.MutableNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
 ::std::string* SetJointVelocity::release_joint_name() {
  // @@protoc_insertion_point(field_release:mw.internal.robotics.gazebotransport.SetJointVelocity.joint_name)
  clear_has_joint_name();
  return joint_name_.ReleaseNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
 void SetJointVelocity::set_allocated_joint_name(::std::string* joint_name) {
  if (joint_name != NULL) {
    set_has_joint_name();
  } else {
    clear_has_joint_name();
  }
  joint_name_.SetAllocatedNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), joint_name);
  // @@protoc_insertion_point(field_set_allocated:mw.internal.robotics.gazebotransport.SetJointVelocity.joint_name)
}

// required uint32 index = 3;
bool SetJointVelocity::has_index() const {
  return (_has_bits_[0] & 0x00000004u) != 0;
}
void SetJointVelocity::set_has_index() {
  _has_bits_[0] |= 0x00000004u;
}
void SetJointVelocity::clear_has_index() {
  _has_bits_[0] &= ~0x00000004u;
}
void SetJointVelocity::clear_index() {
  index_ = 0u;
  clear_has_index();
}
 ::google::protobuf::uint32 SetJointVelocity::index() const {
  // @@protoc_insertion_point(field_get:mw.internal.robotics.gazebotransport.SetJointVelocity.index)
  return index_;
}
 void SetJointVelocity::set_index(::google::protobuf::uint32 value) {
  set_has_index();
  index_ = value;
  // @@protoc_insertion_point(field_set:mw.internal.robotics.gazebotransport.SetJointVelocity.index)
}

// required double velocity = 4;
bool SetJointVelocity::has_velocity() const {
  return (_has_bits_[0] & 0x00000008u) != 0;
}
void SetJointVelocity::set_has_velocity() {
  _has_bits_[0] |= 0x00000008u;
}
void SetJointVelocity::clear_has_velocity() {
  _has_bits_[0] &= ~0x00000008u;
}
void SetJointVelocity::clear_velocity() {
  velocity_ = 0;
  clear_has_velocity();
}
 double SetJointVelocity::velocity() const {
  // @@protoc_insertion_point(field_get:mw.internal.robotics.gazebotransport.SetJointVelocity.velocity)
  return velocity_;
}
 void SetJointVelocity::set_velocity(double value) {
  set_has_velocity();
  velocity_ = value;
  // @@protoc_insertion_point(field_set:mw.internal.robotics.gazebotransport.SetJointVelocity.velocity)
}

// required .mw.internal.robotics.gazebotransport.Time duration = 5;
bool SetJointVelocity::has_duration() const {
  return (_has_bits_[0] & 0x00000010u) != 0;
}
void SetJointVelocity::set_has_duration() {
  _has_bits_[0] |= 0x00000010u;
}
void SetJointVelocity::clear_has_duration() {
  _has_bits_[0] &= ~0x00000010u;
}
void SetJointVelocity::clear_duration() {
  if (duration_ != NULL) duration_->::mw::internal::robotics::gazebotransport::Time::Clear();
  clear_has_duration();
}
const ::mw::internal::robotics::gazebotransport::Time& SetJointVelocity::duration() const {
  // @@protoc_insertion_point(field_get:mw.internal.robotics.gazebotransport.SetJointVelocity.duration)
  return duration_ != NULL ? *duration_ : *default_instance_->duration_;
}
::mw::internal::robotics::gazebotransport::Time* SetJointVelocity::mutable_duration() {
  set_has_duration();
  if (duration_ == NULL) {
    duration_ = new ::mw::internal::robotics::gazebotransport::Time;
  }
  // @@protoc_insertion_point(field_mutable:mw.internal.robotics.gazebotransport.SetJointVelocity.duration)
  return duration_;
}
::mw::internal::robotics::gazebotransport::Time* SetJointVelocity::release_duration() {
  // @@protoc_insertion_point(field_release:mw.internal.robotics.gazebotransport.SetJointVelocity.duration)
  clear_has_duration();
  ::mw::internal::robotics::gazebotransport::Time* temp = duration_;
  duration_ = NULL;
  return temp;
}
void SetJointVelocity::set_allocated_duration(::mw::internal::robotics::gazebotransport::Time* duration) {
  delete duration_;
  duration_ = duration;
  if (duration) {
    set_has_duration();
  } else {
    clear_has_duration();
  }
  // @@protoc_insertion_point(field_set_allocated:mw.internal.robotics.gazebotransport.SetJointVelocity.duration)
}

#endif  // PROTOBUF_INLINE_NOT_IN_HEADERS

// ===================================================================

#if !defined(_MSC_VER) || _MSC_VER >= 1900
const int GetJointState::kModelNameFieldNumber;
const int GetJointState::kJointNameFieldNumber;
#endif  // !defined(_MSC_VER) || _MSC_VER >= 1900

GetJointState::GetJointState()
  : ::google::protobuf::Message(), _internal_metadata_(NULL) {
  SharedCtor();
  // @@protoc_insertion_point(constructor:mw.internal.robotics.gazebotransport.GetJointState)
}

void GetJointState::InitAsDefaultInstance() {
}

GetJointState::GetJointState(const GetJointState& from)
  : ::google::protobuf::Message(),
    _internal_metadata_(NULL) {
  SharedCtor();
  MergeFrom(from);
  // @@protoc_insertion_point(copy_constructor:mw.internal.robotics.gazebotransport.GetJointState)
}

void GetJointState::SharedCtor() {
  ::google::protobuf::internal::GetEmptyString();
  _cached_size_ = 0;
  model_name_.UnsafeSetDefault(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
  joint_name_.UnsafeSetDefault(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
  ::memset(_has_bits_, 0, sizeof(_has_bits_));
}

GetJointState::~GetJointState() {
  // @@protoc_insertion_point(destructor:mw.internal.robotics.gazebotransport.GetJointState)
  SharedDtor();
}

void GetJointState::SharedDtor() {
  model_name_.DestroyNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
  joint_name_.DestroyNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
  if (this != default_instance_) {
  }
}

void GetJointState::SetCachedSize(int size) const {
  GOOGLE_SAFE_CONCURRENT_WRITES_BEGIN();
  _cached_size_ = size;
  GOOGLE_SAFE_CONCURRENT_WRITES_END();
}
const ::google::protobuf::Descriptor* GetJointState::descriptor() {
  protobuf_AssignDescriptorsOnce();
  return GetJointState_descriptor_;
}

const GetJointState& GetJointState::default_instance() {
  if (default_instance_ == NULL) protobuf_AddDesc_mw_2einternal_2erobotics_2egazebotransport_2eCoSimMsgs_2eproto();
  return *default_instance_;
}

GetJointState* GetJointState::default_instance_ = NULL;

GetJointState* GetJointState::New(::google::protobuf::Arena* arena) const {
  GetJointState* n = new GetJointState;
  if (arena != NULL) {
    arena->Own(n);
  }
  return n;
}

void GetJointState::Clear() {
// @@protoc_insertion_point(message_clear_start:mw.internal.robotics.gazebotransport.GetJointState)
  if (_has_bits_[0 / 32] & 3u) {
    if (has_model_name()) {
      model_name_.ClearToEmptyNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
    }
    if (has_joint_name()) {
      joint_name_.ClearToEmptyNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
    }
  }
  ::memset(_has_bits_, 0, sizeof(_has_bits_));
  if (_internal_metadata_.have_unknown_fields()) {
    mutable_unknown_fields()->Clear();
  }
}

bool GetJointState::MergePartialFromCodedStream(
    ::google::protobuf::io::CodedInputStream* input) {
#define DO_(EXPRESSION) if (!GOOGLE_PREDICT_TRUE(EXPRESSION)) goto failure
  ::google::protobuf::uint32 tag;
  // @@protoc_insertion_point(parse_start:mw.internal.robotics.gazebotransport.GetJointState)
  for (;;) {
    ::std::pair< ::google::protobuf::uint32, bool> p = input->ReadTagWithCutoff(127);
    tag = p.first;
    if (!p.second) goto handle_unusual;
    switch (::google::protobuf::internal::WireFormatLite::GetTagFieldNumber(tag)) {
      // required string model_name = 1;
      case 1: {
        if (tag == 10) {
          DO_(::google::protobuf::internal::WireFormatLite::ReadString(
                input, this->mutable_model_name()));
          ::google::protobuf::internal::WireFormat::VerifyUTF8StringNamedField(
            this->model_name().data(), this->model_name().length(),
            ::google::protobuf::internal::WireFormat::PARSE,
            "mw.internal.robotics.gazebotransport.GetJointState.model_name");
        } else {
          goto handle_unusual;
        }
        if (input->ExpectTag(18)) goto parse_joint_name;
        break;
      }

      // required string joint_name = 2;
      case 2: {
        if (tag == 18) {
         parse_joint_name:
          DO_(::google::protobuf::internal::WireFormatLite::ReadString(
                input, this->mutable_joint_name()));
          ::google::protobuf::internal::WireFormat::VerifyUTF8StringNamedField(
            this->joint_name().data(), this->joint_name().length(),
            ::google::protobuf::internal::WireFormat::PARSE,
            "mw.internal.robotics.gazebotransport.GetJointState.joint_name");
        } else {
          goto handle_unusual;
        }
        if (input->ExpectAtEnd()) goto success;
        break;
      }

      default: {
      handle_unusual:
        if (tag == 0 ||
            ::google::protobuf::internal::WireFormatLite::GetTagWireType(tag) ==
            ::google::protobuf::internal::WireFormatLite::WIRETYPE_END_GROUP) {
          goto success;
        }
        DO_(::google::protobuf::internal::WireFormat::SkipField(
              input, tag, mutable_unknown_fields()));
        break;
      }
    }
  }
success:
  // @@protoc_insertion_point(parse_success:mw.internal.robotics.gazebotransport.GetJointState)
  return true;
failure:
  // @@protoc_insertion_point(parse_failure:mw.internal.robotics.gazebotransport.GetJointState)
  return false;
#undef DO_
}

void GetJointState::SerializeWithCachedSizes(
    ::google::protobuf::io::CodedOutputStream* output) const {
  // @@protoc_insertion_point(serialize_start:mw.internal.robotics.gazebotransport.GetJointState)
  // required string model_name = 1;
  if (has_model_name()) {
    ::google::protobuf::internal::WireFormat::VerifyUTF8StringNamedField(
      this->model_name().data(), this->model_name().length(),
      ::google::protobuf::internal::WireFormat::SERIALIZE,
      "mw.internal.robotics.gazebotransport.GetJointState.model_name");
    ::google::protobuf::internal::WireFormatLite::WriteStringMaybeAliased(
      1, this->model_name(), output);
  }

  // required string joint_name = 2;
  if (has_joint_name()) {
    ::google::protobuf::internal::WireFormat::VerifyUTF8StringNamedField(
      this->joint_name().data(), this->joint_name().length(),
      ::google::protobuf::internal::WireFormat::SERIALIZE,
      "mw.internal.robotics.gazebotransport.GetJointState.joint_name");
    ::google::protobuf::internal::WireFormatLite::WriteStringMaybeAliased(
      2, this->joint_name(), output);
  }

  if (_internal_metadata_.have_unknown_fields()) {
    ::google::protobuf::internal::WireFormat::SerializeUnknownFields(
        unknown_fields(), output);
  }
  // @@protoc_insertion_point(serialize_end:mw.internal.robotics.gazebotransport.GetJointState)
}

::google::protobuf::uint8* GetJointState::InternalSerializeWithCachedSizesToArray(
    bool deterministic, ::google::protobuf::uint8* target) const {
  // @@protoc_insertion_point(serialize_to_array_start:mw.internal.robotics.gazebotransport.GetJointState)
  // required string model_name = 1;
  if (has_model_name()) {
    ::google::protobuf::internal::WireFormat::VerifyUTF8StringNamedField(
      this->model_name().data(), this->model_name().length(),
      ::google::protobuf::internal::WireFormat::SERIALIZE,
      "mw.internal.robotics.gazebotransport.GetJointState.model_name");
    target =
      ::google::protobuf::internal::WireFormatLite::WriteStringToArray(
        1, this->model_name(), target);
  }

  // required string joint_name = 2;
  if (has_joint_name()) {
    ::google::protobuf::internal::WireFormat::VerifyUTF8StringNamedField(
      this->joint_name().data(), this->joint_name().length(),
      ::google::protobuf::internal::WireFormat::SERIALIZE,
      "mw.internal.robotics.gazebotransport.GetJointState.joint_name");
    target =
      ::google::protobuf::internal::WireFormatLite::WriteStringToArray(
        2, this->joint_name(), target);
  }

  if (_internal_metadata_.have_unknown_fields()) {
    target = ::google::protobuf::internal::WireFormat::SerializeUnknownFieldsToArray(
        unknown_fields(), target);
  }
  // @@protoc_insertion_point(serialize_to_array_end:mw.internal.robotics.gazebotransport.GetJointState)
  return target;
}

int GetJointState::RequiredFieldsByteSizeFallback() const {
// @@protoc_insertion_point(required_fields_byte_size_fallback_start:mw.internal.robotics.gazebotransport.GetJointState)
  int total_size = 0;

  if (has_model_name()) {
    // required string model_name = 1;
    total_size += 1 +
      ::google::protobuf::internal::WireFormatLite::StringSize(
        this->model_name());
  }

  if (has_joint_name()) {
    // required string joint_name = 2;
    total_size += 1 +
      ::google::protobuf::internal::WireFormatLite::StringSize(
        this->joint_name());
  }

  return total_size;
}
int GetJointState::ByteSize() const {
// @@protoc_insertion_point(message_byte_size_start:mw.internal.robotics.gazebotransport.GetJointState)
  int total_size = 0;

  if (((_has_bits_[0] & 0x00000003) ^ 0x00000003) == 0) {  // All required fields are present.
    // required string model_name = 1;
    total_size += 1 +
      ::google::protobuf::internal::WireFormatLite::StringSize(
        this->model_name());

    // required string joint_name = 2;
    total_size += 1 +
      ::google::protobuf::internal::WireFormatLite::StringSize(
        this->joint_name());

  } else {
    total_size += RequiredFieldsByteSizeFallback();
  }
  if (_internal_metadata_.have_unknown_fields()) {
    total_size +=
      ::google::protobuf::internal::WireFormat::ComputeUnknownFieldsSize(
        unknown_fields());
  }
  GOOGLE_SAFE_CONCURRENT_WRITES_BEGIN();
  _cached_size_ = total_size;
  GOOGLE_SAFE_CONCURRENT_WRITES_END();
  return total_size;
}

void GetJointState::MergeFrom(const ::google::protobuf::Message& from) {
// @@protoc_insertion_point(generalized_merge_from_start:mw.internal.robotics.gazebotransport.GetJointState)
  if (GOOGLE_PREDICT_FALSE(&from == this)) {
    ::google::protobuf::internal::MergeFromFail(__FILE__, __LINE__);
  }
  const GetJointState* source = 
      ::google::protobuf::internal::DynamicCastToGenerated<const GetJointState>(
          &from);
  if (source == NULL) {
  // @@protoc_insertion_point(generalized_merge_from_cast_fail:mw.internal.robotics.gazebotransport.GetJointState)
    ::google::protobuf::internal::ReflectionOps::Merge(from, this);
  } else {
  // @@protoc_insertion_point(generalized_merge_from_cast_success:mw.internal.robotics.gazebotransport.GetJointState)
    MergeFrom(*source);
  }
}

void GetJointState::MergeFrom(const GetJointState& from) {
// @@protoc_insertion_point(class_specific_merge_from_start:mw.internal.robotics.gazebotransport.GetJointState)
  if (GOOGLE_PREDICT_FALSE(&from == this)) {
    ::google::protobuf::internal::MergeFromFail(__FILE__, __LINE__);
  }
  if (from._has_bits_[0 / 32] & (0xffu << (0 % 32))) {
    if (from.has_model_name()) {
      set_has_model_name();
      model_name_.AssignWithDefault(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), from.model_name_);
    }
    if (from.has_joint_name()) {
      set_has_joint_name();
      joint_name_.AssignWithDefault(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), from.joint_name_);
    }
  }
  if (from._internal_metadata_.have_unknown_fields()) {
    mutable_unknown_fields()->MergeFrom(from.unknown_fields());
  }
}

void GetJointState::CopyFrom(const ::google::protobuf::Message& from) {
// @@protoc_insertion_point(generalized_copy_from_start:mw.internal.robotics.gazebotransport.GetJointState)
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

void GetJointState::CopyFrom(const GetJointState& from) {
// @@protoc_insertion_point(class_specific_copy_from_start:mw.internal.robotics.gazebotransport.GetJointState)
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

bool GetJointState::IsInitialized() const {
  if ((_has_bits_[0] & 0x00000003) != 0x00000003) return false;

  return true;
}

void GetJointState::Swap(GetJointState* other) {
  if (other == this) return;
  InternalSwap(other);
}
void GetJointState::InternalSwap(GetJointState* other) {
  model_name_.Swap(&other->model_name_);
  joint_name_.Swap(&other->joint_name_);
  std::swap(_has_bits_[0], other->_has_bits_[0]);
  _internal_metadata_.Swap(&other->_internal_metadata_);
  std::swap(_cached_size_, other->_cached_size_);
}

::google::protobuf::Metadata GetJointState::GetMetadata() const {
  protobuf_AssignDescriptorsOnce();
  ::google::protobuf::Metadata metadata;
  metadata.descriptor = GetJointState_descriptor_;
  metadata.reflection = GetJointState_reflection_;
  return metadata;
}

#if PROTOBUF_INLINE_NOT_IN_HEADERS
// GetJointState

// required string model_name = 1;
bool GetJointState::has_model_name() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
void GetJointState::set_has_model_name() {
  _has_bits_[0] |= 0x00000001u;
}
void GetJointState::clear_has_model_name() {
  _has_bits_[0] &= ~0x00000001u;
}
void GetJointState::clear_model_name() {
  model_name_.ClearToEmptyNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
  clear_has_model_name();
}
 const ::std::string& GetJointState::model_name() const {
  // @@protoc_insertion_point(field_get:mw.internal.robotics.gazebotransport.GetJointState.model_name)
  return model_name_.GetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
 void GetJointState::set_model_name(const ::std::string& value) {
  set_has_model_name();
  model_name_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), value);
  // @@protoc_insertion_point(field_set:mw.internal.robotics.gazebotransport.GetJointState.model_name)
}
 void GetJointState::set_model_name(const char* value) {
  set_has_model_name();
  model_name_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::string(value));
  // @@protoc_insertion_point(field_set_char:mw.internal.robotics.gazebotransport.GetJointState.model_name)
}
 void GetJointState::set_model_name(const char* value, size_t size) {
  set_has_model_name();
  model_name_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(),
      ::std::string(reinterpret_cast<const char*>(value), size));
  // @@protoc_insertion_point(field_set_pointer:mw.internal.robotics.gazebotransport.GetJointState.model_name)
}
 ::std::string* GetJointState::mutable_model_name() {
  set_has_model_name();
  // @@protoc_insertion_point(field_mutable:mw.internal.robotics.gazebotransport.GetJointState.model_name)
  return model_name_.MutableNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
 ::std::string* GetJointState::release_model_name() {
  // @@protoc_insertion_point(field_release:mw.internal.robotics.gazebotransport.GetJointState.model_name)
  clear_has_model_name();
  return model_name_.ReleaseNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
 void GetJointState::set_allocated_model_name(::std::string* model_name) {
  if (model_name != NULL) {
    set_has_model_name();
  } else {
    clear_has_model_name();
  }
  model_name_.SetAllocatedNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), model_name);
  // @@protoc_insertion_point(field_set_allocated:mw.internal.robotics.gazebotransport.GetJointState.model_name)
}

// required string joint_name = 2;
bool GetJointState::has_joint_name() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
void GetJointState::set_has_joint_name() {
  _has_bits_[0] |= 0x00000002u;
}
void GetJointState::clear_has_joint_name() {
  _has_bits_[0] &= ~0x00000002u;
}
void GetJointState::clear_joint_name() {
  joint_name_.ClearToEmptyNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
  clear_has_joint_name();
}
 const ::std::string& GetJointState::joint_name() const {
  // @@protoc_insertion_point(field_get:mw.internal.robotics.gazebotransport.GetJointState.joint_name)
  return joint_name_.GetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
 void GetJointState::set_joint_name(const ::std::string& value) {
  set_has_joint_name();
  joint_name_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), value);
  // @@protoc_insertion_point(field_set:mw.internal.robotics.gazebotransport.GetJointState.joint_name)
}
 void GetJointState::set_joint_name(const char* value) {
  set_has_joint_name();
  joint_name_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::string(value));
  // @@protoc_insertion_point(field_set_char:mw.internal.robotics.gazebotransport.GetJointState.joint_name)
}
 void GetJointState::set_joint_name(const char* value, size_t size) {
  set_has_joint_name();
  joint_name_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(),
      ::std::string(reinterpret_cast<const char*>(value), size));
  // @@protoc_insertion_point(field_set_pointer:mw.internal.robotics.gazebotransport.GetJointState.joint_name)
}
 ::std::string* GetJointState::mutable_joint_name() {
  set_has_joint_name();
  // @@protoc_insertion_point(field_mutable:mw.internal.robotics.gazebotransport.GetJointState.joint_name)
  return joint_name_.MutableNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
 ::std::string* GetJointState::release_joint_name() {
  // @@protoc_insertion_point(field_release:mw.internal.robotics.gazebotransport.GetJointState.joint_name)
  clear_has_joint_name();
  return joint_name_.ReleaseNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
 void GetJointState::set_allocated_joint_name(::std::string* joint_name) {
  if (joint_name != NULL) {
    set_has_joint_name();
  } else {
    clear_has_joint_name();
  }
  joint_name_.SetAllocatedNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), joint_name);
  // @@protoc_insertion_point(field_set_allocated:mw.internal.robotics.gazebotransport.GetJointState.joint_name)
}

#endif  // PROTOBUF_INLINE_NOT_IN_HEADERS

// ===================================================================

#if !defined(_MSC_VER) || _MSC_VER >= 1900
const int Axis::kXyzFieldNumber;
const int Axis::kLimitLowerFieldNumber;
const int Axis::kLimitUpperFieldNumber;
const int Axis::kLimitEffortFieldNumber;
const int Axis::kLimitVelocityFieldNumber;
const int Axis::kDampingFieldNumber;
const int Axis::kFrictionFieldNumber;
const int Axis::kUseParentModelFrameFieldNumber;
#endif  // !defined(_MSC_VER) || _MSC_VER >= 1900

Axis::Axis()
  : ::google::protobuf::Message(), _internal_metadata_(NULL) {
  SharedCtor();
  // @@protoc_insertion_point(constructor:mw.internal.robotics.gazebotransport.Axis)
}

void Axis::InitAsDefaultInstance() {
  xyz_ = const_cast< ::mw::internal::robotics::gazebotransport::Point*>(&::mw::internal::robotics::gazebotransport::Point::default_instance());
}

Axis::Axis(const Axis& from)
  : ::google::protobuf::Message(),
    _internal_metadata_(NULL) {
  SharedCtor();
  MergeFrom(from);
  // @@protoc_insertion_point(copy_constructor:mw.internal.robotics.gazebotransport.Axis)
}

void Axis::SharedCtor() {
  _cached_size_ = 0;
  xyz_ = NULL;
  limit_lower_ = 0;
  limit_upper_ = 0;
  limit_effort_ = 0;
  limit_velocity_ = 0;
  damping_ = 0;
  friction_ = 0;
  use_parent_model_frame_ = false;
  ::memset(_has_bits_, 0, sizeof(_has_bits_));
}

Axis::~Axis() {
  // @@protoc_insertion_point(destructor:mw.internal.robotics.gazebotransport.Axis)
  SharedDtor();
}

void Axis::SharedDtor() {
  if (this != default_instance_) {
    delete xyz_;
  }
}

void Axis::SetCachedSize(int size) const {
  GOOGLE_SAFE_CONCURRENT_WRITES_BEGIN();
  _cached_size_ = size;
  GOOGLE_SAFE_CONCURRENT_WRITES_END();
}
const ::google::protobuf::Descriptor* Axis::descriptor() {
  protobuf_AssignDescriptorsOnce();
  return Axis_descriptor_;
}

const Axis& Axis::default_instance() {
  if (default_instance_ == NULL) protobuf_AddDesc_mw_2einternal_2erobotics_2egazebotransport_2eCoSimMsgs_2eproto();
  return *default_instance_;
}

Axis* Axis::default_instance_ = NULL;

Axis* Axis::New(::google::protobuf::Arena* arena) const {
  Axis* n = new Axis;
  if (arena != NULL) {
    arena->Own(n);
  }
  return n;
}

void Axis::Clear() {
// @@protoc_insertion_point(message_clear_start:mw.internal.robotics.gazebotransport.Axis)
#if defined(__clang__)
#define ZR_HELPER_(f) \
  _Pragma("clang diagnostic push") \
  _Pragma("clang diagnostic ignored \"-Winvalid-offsetof\"") \
  __builtin_offsetof(Axis, f) \
  _Pragma("clang diagnostic pop")
#else
#define ZR_HELPER_(f) reinterpret_cast<char*>(\
  &reinterpret_cast<Axis*>(16)->f)
#endif

#define ZR_(first, last) do {\
  ::memset(&first, 0,\
           ZR_HELPER_(last) - ZR_HELPER_(first) + sizeof(last));\
} while (0)

  if (_has_bits_[0 / 32] & 255u) {
    ZR_(limit_lower_, use_parent_model_frame_);
    if (has_xyz()) {
      if (xyz_ != NULL) xyz_->::mw::internal::robotics::gazebotransport::Point::Clear();
    }
  }

#undef ZR_HELPER_
#undef ZR_

  ::memset(_has_bits_, 0, sizeof(_has_bits_));
  if (_internal_metadata_.have_unknown_fields()) {
    mutable_unknown_fields()->Clear();
  }
}

bool Axis::MergePartialFromCodedStream(
    ::google::protobuf::io::CodedInputStream* input) {
#define DO_(EXPRESSION) if (!GOOGLE_PREDICT_TRUE(EXPRESSION)) goto failure
  ::google::protobuf::uint32 tag;
  // @@protoc_insertion_point(parse_start:mw.internal.robotics.gazebotransport.Axis)
  for (;;) {
    ::std::pair< ::google::protobuf::uint32, bool> p = input->ReadTagWithCutoff(127);
    tag = p.first;
    if (!p.second) goto handle_unusual;
    switch (::google::protobuf::internal::WireFormatLite::GetTagFieldNumber(tag)) {
      // required .mw.internal.robotics.gazebotransport.Point xyz = 1;
      case 1: {
        if (tag == 10) {
          DO_(::google::protobuf::internal::WireFormatLite::ReadMessageNoVirtual(
               input, mutable_xyz()));
        } else {
          goto handle_unusual;
        }
        if (input->ExpectTag(17)) goto parse_limit_lower;
        break;
      }

      // required double limit_lower = 2;
      case 2: {
        if (tag == 17) {
         parse_limit_lower:
          DO_((::google::protobuf::internal::WireFormatLite::ReadPrimitive<
                   double, ::google::protobuf::internal::WireFormatLite::TYPE_DOUBLE>(
                 input, &limit_lower_)));
          set_has_limit_lower();
        } else {
          goto handle_unusual;
        }
        if (input->ExpectTag(25)) goto parse_limit_upper;
        break;
      }

      // required double limit_upper = 3;
      case 3: {
        if (tag == 25) {
         parse_limit_upper:
          DO_((::google::protobuf::internal::WireFormatLite::ReadPrimitive<
                   double, ::google::protobuf::internal::WireFormatLite::TYPE_DOUBLE>(
                 input, &limit_upper_)));
          set_has_limit_upper();
        } else {
          goto handle_unusual;
        }
        if (input->ExpectTag(33)) goto parse_limit_effort;
        break;
      }

      // required double limit_effort = 4;
      case 4: {
        if (tag == 33) {
         parse_limit_effort:
          DO_((::google::protobuf::internal::WireFormatLite::ReadPrimitive<
                   double, ::google::protobuf::internal::WireFormatLite::TYPE_DOUBLE>(
                 input, &limit_effort_)));
          set_has_limit_effort();
        } else {
          goto handle_unusual;
        }
        if (input->ExpectTag(41)) goto parse_limit_velocity;
        break;
      }

      // required double limit_velocity = 5;
      case 5: {
        if (tag == 41) {
         parse_limit_velocity:
          DO_((::google::protobuf::internal::WireFormatLite::ReadPrimitive<
                   double, ::google::protobuf::internal::WireFormatLite::TYPE_DOUBLE>(
                 input, &limit_velocity_)));
          set_has_limit_velocity();
        } else {
          goto handle_unusual;
        }
        if (input->ExpectTag(49)) goto parse_damping;
        break;
      }

      // required double damping = 6;
      case 6: {
        if (tag == 49) {
         parse_damping:
          DO_((::google::protobuf::internal::WireFormatLite::ReadPrimitive<
                   double, ::google::protobuf::internal::WireFormatLite::TYPE_DOUBLE>(
                 input, &damping_)));
          set_has_damping();
        } else {
          goto handle_unusual;
        }
        if (input->ExpectTag(57)) goto parse_friction;
        break;
      }

      // required double friction = 7;
      case 7: {
        if (tag == 57) {
         parse_friction:
          DO_((::google::protobuf::internal::WireFormatLite::ReadPrimitive<
                   double, ::google::protobuf::internal::WireFormatLite::TYPE_DOUBLE>(
                 input, &friction_)));
          set_has_friction();
        } else {
          goto handle_unusual;
        }
        if (input->ExpectTag(64)) goto parse_use_parent_model_frame;
        break;
      }

      // required bool use_parent_model_frame = 8;
      case 8: {
        if (tag == 64) {
         parse_use_parent_model_frame:
          DO_((::google::protobuf::internal::WireFormatLite::ReadPrimitive<
                   bool, ::google::protobuf::internal::WireFormatLite::TYPE_BOOL>(
                 input, &use_parent_model_frame_)));
          set_has_use_parent_model_frame();
        } else {
          goto handle_unusual;
        }
        if (input->ExpectAtEnd()) goto success;
        break;
      }

      default: {
      handle_unusual:
        if (tag == 0 ||
            ::google::protobuf::internal::WireFormatLite::GetTagWireType(tag) ==
            ::google::protobuf::internal::WireFormatLite::WIRETYPE_END_GROUP) {
          goto success;
        }
        DO_(::google::protobuf::internal::WireFormat::SkipField(
              input, tag, mutable_unknown_fields()));
        break;
      }
    }
  }
success:
  // @@protoc_insertion_point(parse_success:mw.internal.robotics.gazebotransport.Axis)
  return true;
failure:
  // @@protoc_insertion_point(parse_failure:mw.internal.robotics.gazebotransport.Axis)
  return false;
#undef DO_
}

void Axis::SerializeWithCachedSizes(
    ::google::protobuf::io::CodedOutputStream* output) const {
  // @@protoc_insertion_point(serialize_start:mw.internal.robotics.gazebotransport.Axis)
  // required .mw.internal.robotics.gazebotransport.Point xyz = 1;
  if (has_xyz()) {
    ::google::protobuf::internal::WireFormatLite::WriteMessageMaybeToArray(
      1, *this->xyz_, output);
  }

  // required double limit_lower = 2;
  if (has_limit_lower()) {
    ::google::protobuf::internal::WireFormatLite::WriteDouble(2, this->limit_lower(), output);
  }

  // required double limit_upper = 3;
  if (has_limit_upper()) {
    ::google::protobuf::internal::WireFormatLite::WriteDouble(3, this->limit_upper(), output);
  }

  // required double limit_effort = 4;
  if (has_limit_effort()) {
    ::google::protobuf::internal::WireFormatLite::WriteDouble(4, this->limit_effort(), output);
  }

  // required double limit_velocity = 5;
  if (has_limit_velocity()) {
    ::google::protobuf::internal::WireFormatLite::WriteDouble(5, this->limit_velocity(), output);
  }

  // required double damping = 6;
  if (has_damping()) {
    ::google::protobuf::internal::WireFormatLite::WriteDouble(6, this->damping(), output);
  }

  // required double friction = 7;
  if (has_friction()) {
    ::google::protobuf::internal::WireFormatLite::WriteDouble(7, this->friction(), output);
  }

  // required bool use_parent_model_frame = 8;
  if (has_use_parent_model_frame()) {
    ::google::protobuf::internal::WireFormatLite::WriteBool(8, this->use_parent_model_frame(), output);
  }

  if (_internal_metadata_.have_unknown_fields()) {
    ::google::protobuf::internal::WireFormat::SerializeUnknownFields(
        unknown_fields(), output);
  }
  // @@protoc_insertion_point(serialize_end:mw.internal.robotics.gazebotransport.Axis)
}

::google::protobuf::uint8* Axis::InternalSerializeWithCachedSizesToArray(
    bool deterministic, ::google::protobuf::uint8* target) const {
  // @@protoc_insertion_point(serialize_to_array_start:mw.internal.robotics.gazebotransport.Axis)
  // required .mw.internal.robotics.gazebotransport.Point xyz = 1;
  if (has_xyz()) {
    target = ::google::protobuf::internal::WireFormatLite::
      InternalWriteMessageNoVirtualToArray(
        1, *this->xyz_, false, target);
  }

  // required double limit_lower = 2;
  if (has_limit_lower()) {
    target = ::google::protobuf::internal::WireFormatLite::WriteDoubleToArray(2, this->limit_lower(), target);
  }

  // required double limit_upper = 3;
  if (has_limit_upper()) {
    target = ::google::protobuf::internal::WireFormatLite::WriteDoubleToArray(3, this->limit_upper(), target);
  }

  // required double limit_effort = 4;
  if (has_limit_effort()) {
    target = ::google::protobuf::internal::WireFormatLite::WriteDoubleToArray(4, this->limit_effort(), target);
  }

  // required double limit_velocity = 5;
  if (has_limit_velocity()) {
    target = ::google::protobuf::internal::WireFormatLite::WriteDoubleToArray(5, this->limit_velocity(), target);
  }

  // required double damping = 6;
  if (has_damping()) {
    target = ::google::protobuf::internal::WireFormatLite::WriteDoubleToArray(6, this->damping(), target);
  }

  // required double friction = 7;
  if (has_friction()) {
    target = ::google::protobuf::internal::WireFormatLite::WriteDoubleToArray(7, this->friction(), target);
  }

  // required bool use_parent_model_frame = 8;
  if (has_use_parent_model_frame()) {
    target = ::google::protobuf::internal::WireFormatLite::WriteBoolToArray(8, this->use_parent_model_frame(), target);
  }

  if (_internal_metadata_.have_unknown_fields()) {
    target = ::google::protobuf::internal::WireFormat::SerializeUnknownFieldsToArray(
        unknown_fields(), target);
  }
  // @@protoc_insertion_point(serialize_to_array_end:mw.internal.robotics.gazebotransport.Axis)
  return target;
}

int Axis::RequiredFieldsByteSizeFallback() const {
// @@protoc_insertion_point(required_fields_byte_size_fallback_start:mw.internal.robotics.gazebotransport.Axis)
  int total_size = 0;

  if (has_xyz()) {
    // required .mw.internal.robotics.gazebotransport.Point xyz = 1;
    total_size += 1 +
      ::google::protobuf::internal::WireFormatLite::MessageSizeNoVirtual(
        *this->xyz_);
  }

  if (has_limit_lower()) {
    // required double limit_lower = 2;
    total_size += 1 + 8;
  }

  if (has_limit_upper()) {
    // required double limit_upper = 3;
    total_size += 1 + 8;
  }

  if (has_limit_effort()) {
    // required double limit_effort = 4;
    total_size += 1 + 8;
  }

  if (has_limit_velocity()) {
    // required double limit_velocity = 5;
    total_size += 1 + 8;
  }

  if (has_damping()) {
    // required double damping = 6;
    total_size += 1 + 8;
  }

  if (has_friction()) {
    // required double friction = 7;
    total_size += 1 + 8;
  }

  if (has_use_parent_model_frame()) {
    // required bool use_parent_model_frame = 8;
    total_size += 1 + 1;
  }

  return total_size;
}
int Axis::ByteSize() const {
// @@protoc_insertion_point(message_byte_size_start:mw.internal.robotics.gazebotransport.Axis)
  int total_size = 0;

  if (((_has_bits_[0] & 0x000000ff) ^ 0x000000ff) == 0) {  // All required fields are present.
    // required .mw.internal.robotics.gazebotransport.Point xyz = 1;
    total_size += 1 +
      ::google::protobuf::internal::WireFormatLite::MessageSizeNoVirtual(
        *this->xyz_);

    // required double limit_lower = 2;
    total_size += 1 + 8;

    // required double limit_upper = 3;
    total_size += 1 + 8;

    // required double limit_effort = 4;
    total_size += 1 + 8;

    // required double limit_velocity = 5;
    total_size += 1 + 8;

    // required double damping = 6;
    total_size += 1 + 8;

    // required double friction = 7;
    total_size += 1 + 8;

    // required bool use_parent_model_frame = 8;
    total_size += 1 + 1;

  } else {
    total_size += RequiredFieldsByteSizeFallback();
  }
  if (_internal_metadata_.have_unknown_fields()) {
    total_size +=
      ::google::protobuf::internal::WireFormat::ComputeUnknownFieldsSize(
        unknown_fields());
  }
  GOOGLE_SAFE_CONCURRENT_WRITES_BEGIN();
  _cached_size_ = total_size;
  GOOGLE_SAFE_CONCURRENT_WRITES_END();
  return total_size;
}

void Axis::MergeFrom(const ::google::protobuf::Message& from) {
// @@protoc_insertion_point(generalized_merge_from_start:mw.internal.robotics.gazebotransport.Axis)
  if (GOOGLE_PREDICT_FALSE(&from == this)) {
    ::google::protobuf::internal::MergeFromFail(__FILE__, __LINE__);
  }
  const Axis* source = 
      ::google::protobuf::internal::DynamicCastToGenerated<const Axis>(
          &from);
  if (source == NULL) {
  // @@protoc_insertion_point(generalized_merge_from_cast_fail:mw.internal.robotics.gazebotransport.Axis)
    ::google::protobuf::internal::ReflectionOps::Merge(from, this);
  } else {
  // @@protoc_insertion_point(generalized_merge_from_cast_success:mw.internal.robotics.gazebotransport.Axis)
    MergeFrom(*source);
  }
}

void Axis::MergeFrom(const Axis& from) {
// @@protoc_insertion_point(class_specific_merge_from_start:mw.internal.robotics.gazebotransport.Axis)
  if (GOOGLE_PREDICT_FALSE(&from == this)) {
    ::google::protobuf::internal::MergeFromFail(__FILE__, __LINE__);
  }
  if (from._has_bits_[0 / 32] & (0xffu << (0 % 32))) {
    if (from.has_xyz()) {
      mutable_xyz()->::mw::internal::robotics::gazebotransport::Point::MergeFrom(from.xyz());
    }
    if (from.has_limit_lower()) {
      set_limit_lower(from.limit_lower());
    }
    if (from.has_limit_upper()) {
      set_limit_upper(from.limit_upper());
    }
    if (from.has_limit_effort()) {
      set_limit_effort(from.limit_effort());
    }
    if (from.has_limit_velocity()) {
      set_limit_velocity(from.limit_velocity());
    }
    if (from.has_damping()) {
      set_damping(from.damping());
    }
    if (from.has_friction()) {
      set_friction(from.friction());
    }
    if (from.has_use_parent_model_frame()) {
      set_use_parent_model_frame(from.use_parent_model_frame());
    }
  }
  if (from._internal_metadata_.have_unknown_fields()) {
    mutable_unknown_fields()->MergeFrom(from.unknown_fields());
  }
}

void Axis::CopyFrom(const ::google::protobuf::Message& from) {
// @@protoc_insertion_point(generalized_copy_from_start:mw.internal.robotics.gazebotransport.Axis)
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

void Axis::CopyFrom(const Axis& from) {
// @@protoc_insertion_point(class_specific_copy_from_start:mw.internal.robotics.gazebotransport.Axis)
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

bool Axis::IsInitialized() const {
  if ((_has_bits_[0] & 0x000000ff) != 0x000000ff) return false;

  if (has_xyz()) {
    if (!this->xyz_->IsInitialized()) return false;
  }
  return true;
}

void Axis::Swap(Axis* other) {
  if (other == this) return;
  InternalSwap(other);
}
void Axis::InternalSwap(Axis* other) {
  std::swap(xyz_, other->xyz_);
  std::swap(limit_lower_, other->limit_lower_);
  std::swap(limit_upper_, other->limit_upper_);
  std::swap(limit_effort_, other->limit_effort_);
  std::swap(limit_velocity_, other->limit_velocity_);
  std::swap(damping_, other->damping_);
  std::swap(friction_, other->friction_);
  std::swap(use_parent_model_frame_, other->use_parent_model_frame_);
  std::swap(_has_bits_[0], other->_has_bits_[0]);
  _internal_metadata_.Swap(&other->_internal_metadata_);
  std::swap(_cached_size_, other->_cached_size_);
}

::google::protobuf::Metadata Axis::GetMetadata() const {
  protobuf_AssignDescriptorsOnce();
  ::google::protobuf::Metadata metadata;
  metadata.descriptor = Axis_descriptor_;
  metadata.reflection = Axis_reflection_;
  return metadata;
}

#if PROTOBUF_INLINE_NOT_IN_HEADERS
// Axis

// required .mw.internal.robotics.gazebotransport.Point xyz = 1;
bool Axis::has_xyz() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
void Axis::set_has_xyz() {
  _has_bits_[0] |= 0x00000001u;
}
void Axis::clear_has_xyz() {
  _has_bits_[0] &= ~0x00000001u;
}
void Axis::clear_xyz() {
  if (xyz_ != NULL) xyz_->::mw::internal::robotics::gazebotransport::Point::Clear();
  clear_has_xyz();
}
const ::mw::internal::robotics::gazebotransport::Point& Axis::xyz() const {
  // @@protoc_insertion_point(field_get:mw.internal.robotics.gazebotransport.Axis.xyz)
  return xyz_ != NULL ? *xyz_ : *default_instance_->xyz_;
}
::mw::internal::robotics::gazebotransport::Point* Axis::mutable_xyz() {
  set_has_xyz();
  if (xyz_ == NULL) {
    xyz_ = new ::mw::internal::robotics::gazebotransport::Point;
  }
  // @@protoc_insertion_point(field_mutable:mw.internal.robotics.gazebotransport.Axis.xyz)
  return xyz_;
}
::mw::internal::robotics::gazebotransport::Point* Axis::release_xyz() {
  // @@protoc_insertion_point(field_release:mw.internal.robotics.gazebotransport.Axis.xyz)
  clear_has_xyz();
  ::mw::internal::robotics::gazebotransport::Point* temp = xyz_;
  xyz_ = NULL;
  return temp;
}
void Axis::set_allocated_xyz(::mw::internal::robotics::gazebotransport::Point* xyz) {
  delete xyz_;
  xyz_ = xyz;
  if (xyz) {
    set_has_xyz();
  } else {
    clear_has_xyz();
  }
  // @@protoc_insertion_point(field_set_allocated:mw.internal.robotics.gazebotransport.Axis.xyz)
}

// required double limit_lower = 2;
bool Axis::has_limit_lower() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
void Axis::set_has_limit_lower() {
  _has_bits_[0] |= 0x00000002u;
}
void Axis::clear_has_limit_lower() {
  _has_bits_[0] &= ~0x00000002u;
}
void Axis::clear_limit_lower() {
  limit_lower_ = 0;
  clear_has_limit_lower();
}
 double Axis::limit_lower() const {
  // @@protoc_insertion_point(field_get:mw.internal.robotics.gazebotransport.Axis.limit_lower)
  return limit_lower_;
}
 void Axis::set_limit_lower(double value) {
  set_has_limit_lower();
  limit_lower_ = value;
  // @@protoc_insertion_point(field_set:mw.internal.robotics.gazebotransport.Axis.limit_lower)
}

// required double limit_upper = 3;
bool Axis::has_limit_upper() const {
  return (_has_bits_[0] & 0x00000004u) != 0;
}
void Axis::set_has_limit_upper() {
  _has_bits_[0] |= 0x00000004u;
}
void Axis::clear_has_limit_upper() {
  _has_bits_[0] &= ~0x00000004u;
}
void Axis::clear_limit_upper() {
  limit_upper_ = 0;
  clear_has_limit_upper();
}
 double Axis::limit_upper() const {
  // @@protoc_insertion_point(field_get:mw.internal.robotics.gazebotransport.Axis.limit_upper)
  return limit_upper_;
}
 void Axis::set_limit_upper(double value) {
  set_has_limit_upper();
  limit_upper_ = value;
  // @@protoc_insertion_point(field_set:mw.internal.robotics.gazebotransport.Axis.limit_upper)
}

// required double limit_effort = 4;
bool Axis::has_limit_effort() const {
  return (_has_bits_[0] & 0x00000008u) != 0;
}
void Axis::set_has_limit_effort() {
  _has_bits_[0] |= 0x00000008u;
}
void Axis::clear_has_limit_effort() {
  _has_bits_[0] &= ~0x00000008u;
}
void Axis::clear_limit_effort() {
  limit_effort_ = 0;
  clear_has_limit_effort();
}
 double Axis::limit_effort() const {
  // @@protoc_insertion_point(field_get:mw.internal.robotics.gazebotransport.Axis.limit_effort)
  return limit_effort_;
}
 void Axis::set_limit_effort(double value) {
  set_has_limit_effort();
  limit_effort_ = value;
  // @@protoc_insertion_point(field_set:mw.internal.robotics.gazebotransport.Axis.limit_effort)
}

// required double limit_velocity = 5;
bool Axis::has_limit_velocity() const {
  return (_has_bits_[0] & 0x00000010u) != 0;
}
void Axis::set_has_limit_velocity() {
  _has_bits_[0] |= 0x00000010u;
}
void Axis::clear_has_limit_velocity() {
  _has_bits_[0] &= ~0x00000010u;
}
void Axis::clear_limit_velocity() {
  limit_velocity_ = 0;
  clear_has_limit_velocity();
}
 double Axis::limit_velocity() const {
  // @@protoc_insertion_point(field_get:mw.internal.robotics.gazebotransport.Axis.limit_velocity)
  return limit_velocity_;
}
 void Axis::set_limit_velocity(double value) {
  set_has_limit_velocity();
  limit_velocity_ = value;
  // @@protoc_insertion_point(field_set:mw.internal.robotics.gazebotransport.Axis.limit_velocity)
}

// required double damping = 6;
bool Axis::has_damping() const {
  return (_has_bits_[0] & 0x00000020u) != 0;
}
void Axis::set_has_damping() {
  _has_bits_[0] |= 0x00000020u;
}
void Axis::clear_has_damping() {
  _has_bits_[0] &= ~0x00000020u;
}
void Axis::clear_damping() {
  damping_ = 0;
  clear_has_damping();
}
 double Axis::damping() const {
  // @@protoc_insertion_point(field_get:mw.internal.robotics.gazebotransport.Axis.damping)
  return damping_;
}
 void Axis::set_damping(double value) {
  set_has_damping();
  damping_ = value;
  // @@protoc_insertion_point(field_set:mw.internal.robotics.gazebotransport.Axis.damping)
}

// required double friction = 7;
bool Axis::has_friction() const {
  return (_has_bits_[0] & 0x00000040u) != 0;
}
void Axis::set_has_friction() {
  _has_bits_[0] |= 0x00000040u;
}
void Axis::clear_has_friction() {
  _has_bits_[0] &= ~0x00000040u;
}
void Axis::clear_friction() {
  friction_ = 0;
  clear_has_friction();
}
 double Axis::friction() const {
  // @@protoc_insertion_point(field_get:mw.internal.robotics.gazebotransport.Axis.friction)
  return friction_;
}
 void Axis::set_friction(double value) {
  set_has_friction();
  friction_ = value;
  // @@protoc_insertion_point(field_set:mw.internal.robotics.gazebotransport.Axis.friction)
}

// required bool use_parent_model_frame = 8;
bool Axis::has_use_parent_model_frame() const {
  return (_has_bits_[0] & 0x00000080u) != 0;
}
void Axis::set_has_use_parent_model_frame() {
  _has_bits_[0] |= 0x00000080u;
}
void Axis::clear_has_use_parent_model_frame() {
  _has_bits_[0] &= ~0x00000080u;
}
void Axis::clear_use_parent_model_frame() {
  use_parent_model_frame_ = false;
  clear_has_use_parent_model_frame();
}
 bool Axis::use_parent_model_frame() const {
  // @@protoc_insertion_point(field_get:mw.internal.robotics.gazebotransport.Axis.use_parent_model_frame)
  return use_parent_model_frame_;
}
 void Axis::set_use_parent_model_frame(bool value) {
  set_has_use_parent_model_frame();
  use_parent_model_frame_ = value;
  // @@protoc_insertion_point(field_set:mw.internal.robotics.gazebotransport.Axis.use_parent_model_frame)
}

#endif  // PROTOBUF_INLINE_NOT_IN_HEADERS

// ===================================================================

const ::google::protobuf::EnumDescriptor* JointState_Joint_Type_descriptor() {
  protobuf_AssignDescriptorsOnce();
  return JointState_Joint_Type_descriptor_;
}
bool JointState_Joint_Type_IsValid(int value) {
  switch(value) {
    case 1:
    case 2:
    case 3:
    case 4:
    case 5:
    case 6:
    case 7:
    case 8:
      return true;
    default:
      return false;
  }
}

#if !defined(_MSC_VER) || _MSC_VER >= 1900
const JointState_Joint_Type JointState::REVOLUTE;
const JointState_Joint_Type JointState::REVOLUTE2;
const JointState_Joint_Type JointState::PRISMATIC;
const JointState_Joint_Type JointState::UNIVERSAL;
const JointState_Joint_Type JointState::BALL;
const JointState_Joint_Type JointState::SCREW;
const JointState_Joint_Type JointState::GEARBOX;
const JointState_Joint_Type JointState::FIXED;
const JointState_Joint_Type JointState::Joint_Type_MIN;
const JointState_Joint_Type JointState::Joint_Type_MAX;
const int JointState::Joint_Type_ARRAYSIZE;
#endif  // !defined(_MSC_VER) || _MSC_VER >= 1900
#if !defined(_MSC_VER) || _MSC_VER >= 1900
const int JointState::kModelNameFieldNumber;
const int JointState::kJointNameFieldNumber;
const int JointState::kJointIdFieldNumber;
const int JointState::kJointPositionFieldNumber;
const int JointState::kJointVelocityFieldNumber;
const int JointState::kJointTypeFieldNumber;
const int JointState::kParentNameFieldNumber;
const int JointState::kParentIdFieldNumber;
const int JointState::kChildNameFieldNumber;
const int JointState::kChildIdFieldNumber;
const int JointState::kInitialAnchorPoseFieldNumber;
const int JointState::kWorldPoseFieldNumber;
const int JointState::kParentWorldPoseFieldNumber;
const int JointState::kAxisFieldNumber;
#endif  // !defined(_MSC_VER) || _MSC_VER >= 1900

JointState::JointState()
  : ::google::protobuf::Message(), _internal_metadata_(NULL) {
  SharedCtor();
  // @@protoc_insertion_point(constructor:mw.internal.robotics.gazebotransport.JointState)
}

void JointState::InitAsDefaultInstance() {
  initial_anchor_pose_ = const_cast< ::mw::internal::robotics::gazebotransport::Pose*>(&::mw::internal::robotics::gazebotransport::Pose::default_instance());
  world_pose_ = const_cast< ::mw::internal::robotics::gazebotransport::Pose*>(&::mw::internal::robotics::gazebotransport::Pose::default_instance());
  parent_world_pose_ = const_cast< ::mw::internal::robotics::gazebotransport::Pose*>(&::mw::internal::robotics::gazebotransport::Pose::default_instance());
}

JointState::JointState(const JointState& from)
  : ::google::protobuf::Message(),
    _internal_metadata_(NULL) {
  SharedCtor();
  MergeFrom(from);
  // @@protoc_insertion_point(copy_constructor:mw.internal.robotics.gazebotransport.JointState)
}

void JointState::SharedCtor() {
  ::google::protobuf::internal::GetEmptyString();
  _cached_size_ = 0;
  model_name_.UnsafeSetDefault(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
  joint_name_.UnsafeSetDefault(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
  joint_id_ = 0u;
  joint_type_ = 1;
  parent_name_.UnsafeSetDefault(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
  parent_id_ = 0u;
  child_name_.UnsafeSetDefault(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
  child_id_ = 0u;
  initial_anchor_pose_ = NULL;
  world_pose_ = NULL;
  parent_world_pose_ = NULL;
  ::memset(_has_bits_, 0, sizeof(_has_bits_));
}

JointState::~JointState() {
  // @@protoc_insertion_point(destructor:mw.internal.robotics.gazebotransport.JointState)
  SharedDtor();
}

void JointState::SharedDtor() {
  model_name_.DestroyNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
  joint_name_.DestroyNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
  parent_name_.DestroyNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
  child_name_.DestroyNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
  if (this != default_instance_) {
    delete initial_anchor_pose_;
    delete world_pose_;
    delete parent_world_pose_;
  }
}

void JointState::SetCachedSize(int size) const {
  GOOGLE_SAFE_CONCURRENT_WRITES_BEGIN();
  _cached_size_ = size;
  GOOGLE_SAFE_CONCURRENT_WRITES_END();
}
const ::google::protobuf::Descriptor* JointState::descriptor() {
  protobuf_AssignDescriptorsOnce();
  return JointState_descriptor_;
}

const JointState& JointState::default_instance() {
  if (default_instance_ == NULL) protobuf_AddDesc_mw_2einternal_2erobotics_2egazebotransport_2eCoSimMsgs_2eproto();
  return *default_instance_;
}

JointState* JointState::default_instance_ = NULL;

JointState* JointState::New(::google::protobuf::Arena* arena) const {
  JointState* n = new JointState;
  if (arena != NULL) {
    arena->Own(n);
  }
  return n;
}

void JointState::Clear() {
// @@protoc_insertion_point(message_clear_start:mw.internal.robotics.gazebotransport.JointState)
  if (_has_bits_[0 / 32] & 231u) {
    if (has_model_name()) {
      model_name_.ClearToEmptyNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
    }
    if (has_joint_name()) {
      joint_name_.ClearToEmptyNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
    }
    joint_id_ = 0u;
    joint_type_ = 1;
    if (has_parent_name()) {
      parent_name_.ClearToEmptyNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
    }
    parent_id_ = 0u;
  }
  if (_has_bits_[8 / 32] & 7936u) {
    if (has_child_name()) {
      child_name_.ClearToEmptyNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
    }
    child_id_ = 0u;
    if (has_initial_anchor_pose()) {
      if (initial_anchor_pose_ != NULL) initial_anchor_pose_->::mw::internal::robotics::gazebotransport::Pose::Clear();
    }
    if (has_world_pose()) {
      if (world_pose_ != NULL) world_pose_->::mw::internal::robotics::gazebotransport::Pose::Clear();
    }
    if (has_parent_world_pose()) {
      if (parent_world_pose_ != NULL) parent_world_pose_->::mw::internal::robotics::gazebotransport::Pose::Clear();
    }
  }
  joint_position_.Clear();
  joint_velocity_.Clear();
  axis_.Clear();
  ::memset(_has_bits_, 0, sizeof(_has_bits_));
  if (_internal_metadata_.have_unknown_fields()) {
    mutable_unknown_fields()->Clear();
  }
}

bool JointState::MergePartialFromCodedStream(
    ::google::protobuf::io::CodedInputStream* input) {
#define DO_(EXPRESSION) if (!GOOGLE_PREDICT_TRUE(EXPRESSION)) goto failure
  ::google::protobuf::uint32 tag;
  // @@protoc_insertion_point(parse_start:mw.internal.robotics.gazebotransport.JointState)
  for (;;) {
    ::std::pair< ::google::protobuf::uint32, bool> p = input->ReadTagWithCutoff(127);
    tag = p.first;
    if (!p.second) goto handle_unusual;
    switch (::google::protobuf::internal::WireFormatLite::GetTagFieldNumber(tag)) {
      // required string model_name = 1;
      case 1: {
        if (tag == 10) {
          DO_(::google::protobuf::internal::WireFormatLite::ReadString(
                input, this->mutable_model_name()));
          ::google::protobuf::internal::WireFormat::VerifyUTF8StringNamedField(
            this->model_name().data(), this->model_name().length(),
            ::google::protobuf::internal::WireFormat::PARSE,
            "mw.internal.robotics.gazebotransport.JointState.model_name");
        } else {
          goto handle_unusual;
        }
        if (input->ExpectTag(18)) goto parse_joint_name;
        break;
      }

      // required string joint_name = 2;
      case 2: {
        if (tag == 18) {
         parse_joint_name:
          DO_(::google::protobuf::internal::WireFormatLite::ReadString(
                input, this->mutable_joint_name()));
          ::google::protobuf::internal::WireFormat::VerifyUTF8StringNamedField(
            this->joint_name().data(), this->joint_name().length(),
            ::google::protobuf::internal::WireFormat::PARSE,
            "mw.internal.robotics.gazebotransport.JointState.joint_name");
        } else {
          goto handle_unusual;
        }
        if (input->ExpectTag(24)) goto parse_joint_id;
        break;
      }

      // required uint32 joint_id = 3;
      case 3: {
        if (tag == 24) {
         parse_joint_id:
          DO_((::google::protobuf::internal::WireFormatLite::ReadPrimitive<
                   ::google::protobuf::uint32, ::google::protobuf::internal::WireFormatLite::TYPE_UINT32>(
                 input, &joint_id_)));
          set_has_joint_id();
        } else {
          goto handle_unusual;
        }
        if (input->ExpectTag(33)) goto parse_joint_position;
        break;
      }

      // repeated double joint_position = 4;
      case 4: {
        if (tag == 33) {
         parse_joint_position:
          DO_((::google::protobuf::internal::WireFormatLite::ReadRepeatedPrimitive<
                   double, ::google::protobuf::internal::WireFormatLite::TYPE_DOUBLE>(
                 1, 33, input, this->mutable_joint_position())));
        } else if (tag == 34) {
          DO_((::google::protobuf::internal::WireFormatLite::ReadPackedPrimitiveNoInline<
                   double, ::google::protobuf::internal::WireFormatLite::TYPE_DOUBLE>(
                 input, this->mutable_joint_position())));
        } else {
          goto handle_unusual;
        }
        if (input->ExpectTag(33)) goto parse_joint_position;
        if (input->ExpectTag(41)) goto parse_joint_velocity;
        break;
      }

      // repeated double joint_velocity = 5;
      case 5: {
        if (tag == 41) {
         parse_joint_velocity:
          DO_((::google::protobuf::internal::WireFormatLite::ReadRepeatedPrimitive<
                   double, ::google::protobuf::internal::WireFormatLite::TYPE_DOUBLE>(
                 1, 41, input, this->mutable_joint_velocity())));
        } else if (tag == 42) {
          DO_((::google::protobuf::internal::WireFormatLite::ReadPackedPrimitiveNoInline<
                   double, ::google::protobuf::internal::WireFormatLite::TYPE_DOUBLE>(
                 input, this->mutable_joint_velocity())));
        } else {
          goto handle_unusual;
        }
        if (input->ExpectTag(41)) goto parse_joint_velocity;
        if (input->ExpectTag(48)) goto parse_joint_type;
        break;
      }

      // optional .mw.internal.robotics.gazebotransport.JointState.Joint_Type joint_type = 6;
      case 6: {
        if (tag == 48) {
         parse_joint_type:
          int value;
          DO_((::google::protobuf::internal::WireFormatLite::ReadPrimitive<
                   int, ::google::protobuf::internal::WireFormatLite::TYPE_ENUM>(
                 input, &value)));
          if (::mw::internal::robotics::gazebotransport::JointState_Joint_Type_IsValid(value)) {
            set_joint_type(static_cast< ::mw::internal::robotics::gazebotransport::JointState_Joint_Type >(value));
          } else {
            mutable_unknown_fields()->AddVarint(6, value);
          }
        } else {
          goto handle_unusual;
        }
        if (input->ExpectTag(58)) goto parse_parent_name;
        break;
      }

      // optional string parent_name = 7;
      case 7: {
        if (tag == 58) {
         parse_parent_name:
          DO_(::google::protobuf::internal::WireFormatLite::ReadString(
                input, this->mutable_parent_name()));
          ::google::protobuf::internal::WireFormat::VerifyUTF8StringNamedField(
            this->parent_name().data(), this->parent_name().length(),
            ::google::protobuf::internal::WireFormat::PARSE,
            "mw.internal.robotics.gazebotransport.JointState.parent_name");
        } else {
          goto handle_unusual;
        }
        if (input->ExpectTag(64)) goto parse_parent_id;
        break;
      }

      // optional uint32 parent_id = 8;
      case 8: {
        if (tag == 64) {
         parse_parent_id:
          DO_((::google::protobuf::internal::WireFormatLite::ReadPrimitive<
                   ::google::protobuf::uint32, ::google::protobuf::internal::WireFormatLite::TYPE_UINT32>(
                 input, &parent_id_)));
          set_has_parent_id();
        } else {
          goto handle_unusual;
        }
        if (input->ExpectTag(74)) goto parse_child_name;
        break;
      }

      // optional string child_name = 9;
      case 9: {
        if (tag == 74) {
         parse_child_name:
          DO_(::google::protobuf::internal::WireFormatLite::ReadString(
                input, this->mutable_child_name()));
          ::google::protobuf::internal::WireFormat::VerifyUTF8StringNamedField(
            this->child_name().data(), this->child_name().length(),
            ::google::protobuf::internal::WireFormat::PARSE,
            "mw.internal.robotics.gazebotransport.JointState.child_name");
        } else {
          goto handle_unusual;
        }
        if (input->ExpectTag(80)) goto parse_child_id;
        break;
      }

      // optional uint32 child_id = 10;
      case 10: {
        if (tag == 80) {
         parse_child_id:
          DO_((::google::protobuf::internal::WireFormatLite::ReadPrimitive<
                   ::google::protobuf::uint32, ::google::protobuf::internal::WireFormatLite::TYPE_UINT32>(
                 input, &child_id_)));
          set_has_child_id();
        } else {
          goto handle_unusual;
        }
        if (input->ExpectTag(90)) goto parse_initial_anchor_pose;
        break;
      }

      // optional .mw.internal.robotics.gazebotransport.Pose initial_anchor_pose = 11;
      case 11: {
        if (tag == 90) {
         parse_initial_anchor_pose:
          DO_(::google::protobuf::internal::WireFormatLite::ReadMessageNoVirtual(
               input, mutable_initial_anchor_pose()));
        } else {
          goto handle_unusual;
        }
        if (input->ExpectTag(98)) goto parse_world_pose;
        break;
      }

      // optional .mw.internal.robotics.gazebotransport.Pose world_pose = 12;
      case 12: {
        if (tag == 98) {
         parse_world_pose:
          DO_(::google::protobuf::internal::WireFormatLite::ReadMessageNoVirtual(
               input, mutable_world_pose()));
        } else {
          goto handle_unusual;
        }
        if (input->ExpectTag(106)) goto parse_parent_world_pose;
        break;
      }

      // optional .mw.internal.robotics.gazebotransport.Pose parent_world_pose = 13;
      case 13: {
        if (tag == 106) {
         parse_parent_world_pose:
          DO_(::google::protobuf::internal::WireFormatLite::ReadMessageNoVirtual(
               input, mutable_parent_world_pose()));
        } else {
          goto handle_unusual;
        }
        if (input->ExpectTag(114)) goto parse_axis;
        break;
      }

      // repeated .mw.internal.robotics.gazebotransport.Axis axis = 14;
      case 14: {
        if (tag == 114) {
         parse_axis:
          DO_(input->IncrementRecursionDepth());
         parse_loop_axis:
          DO_(::google::protobuf::internal::WireFormatLite::ReadMessageNoVirtualNoRecursionDepth(
                input, add_axis()));
        } else {
          goto handle_unusual;
        }
        if (input->ExpectTag(114)) goto parse_loop_axis;
        input->UnsafeDecrementRecursionDepth();
        if (input->ExpectAtEnd()) goto success;
        break;
      }

      default: {
      handle_unusual:
        if (tag == 0 ||
            ::google::protobuf::internal::WireFormatLite::GetTagWireType(tag) ==
            ::google::protobuf::internal::WireFormatLite::WIRETYPE_END_GROUP) {
          goto success;
        }
        DO_(::google::protobuf::internal::WireFormat::SkipField(
              input, tag, mutable_unknown_fields()));
        break;
      }
    }
  }
success:
  // @@protoc_insertion_point(parse_success:mw.internal.robotics.gazebotransport.JointState)
  return true;
failure:
  // @@protoc_insertion_point(parse_failure:mw.internal.robotics.gazebotransport.JointState)
  return false;
#undef DO_
}

void JointState::SerializeWithCachedSizes(
    ::google::protobuf::io::CodedOutputStream* output) const {
  // @@protoc_insertion_point(serialize_start:mw.internal.robotics.gazebotransport.JointState)
  // required string model_name = 1;
  if (has_model_name()) {
    ::google::protobuf::internal::WireFormat::VerifyUTF8StringNamedField(
      this->model_name().data(), this->model_name().length(),
      ::google::protobuf::internal::WireFormat::SERIALIZE,
      "mw.internal.robotics.gazebotransport.JointState.model_name");
    ::google::protobuf::internal::WireFormatLite::WriteStringMaybeAliased(
      1, this->model_name(), output);
  }

  // required string joint_name = 2;
  if (has_joint_name()) {
    ::google::protobuf::internal::WireFormat::VerifyUTF8StringNamedField(
      this->joint_name().data(), this->joint_name().length(),
      ::google::protobuf::internal::WireFormat::SERIALIZE,
      "mw.internal.robotics.gazebotransport.JointState.joint_name");
    ::google::protobuf::internal::WireFormatLite::WriteStringMaybeAliased(
      2, this->joint_name(), output);
  }

  // required uint32 joint_id = 3;
  if (has_joint_id()) {
    ::google::protobuf::internal::WireFormatLite::WriteUInt32(3, this->joint_id(), output);
  }

  // repeated double joint_position = 4;
  for (int i = 0; i < this->joint_position_size(); i++) {
    ::google::protobuf::internal::WireFormatLite::WriteDouble(
      4, this->joint_position(i), output);
  }

  // repeated double joint_velocity = 5;
  for (int i = 0; i < this->joint_velocity_size(); i++) {
    ::google::protobuf::internal::WireFormatLite::WriteDouble(
      5, this->joint_velocity(i), output);
  }

  // optional .mw.internal.robotics.gazebotransport.JointState.Joint_Type joint_type = 6;
  if (has_joint_type()) {
    ::google::protobuf::internal::WireFormatLite::WriteEnum(
      6, this->joint_type(), output);
  }

  // optional string parent_name = 7;
  if (has_parent_name()) {
    ::google::protobuf::internal::WireFormat::VerifyUTF8StringNamedField(
      this->parent_name().data(), this->parent_name().length(),
      ::google::protobuf::internal::WireFormat::SERIALIZE,
      "mw.internal.robotics.gazebotransport.JointState.parent_name");
    ::google::protobuf::internal::WireFormatLite::WriteStringMaybeAliased(
      7, this->parent_name(), output);
  }

  // optional uint32 parent_id = 8;
  if (has_parent_id()) {
    ::google::protobuf::internal::WireFormatLite::WriteUInt32(8, this->parent_id(), output);
  }

  // optional string child_name = 9;
  if (has_child_name()) {
    ::google::protobuf::internal::WireFormat::VerifyUTF8StringNamedField(
      this->child_name().data(), this->child_name().length(),
      ::google::protobuf::internal::WireFormat::SERIALIZE,
      "mw.internal.robotics.gazebotransport.JointState.child_name");
    ::google::protobuf::internal::WireFormatLite::WriteStringMaybeAliased(
      9, this->child_name(), output);
  }

  // optional uint32 child_id = 10;
  if (has_child_id()) {
    ::google::protobuf::internal::WireFormatLite::WriteUInt32(10, this->child_id(), output);
  }

  // optional .mw.internal.robotics.gazebotransport.Pose initial_anchor_pose = 11;
  if (has_initial_anchor_pose()) {
    ::google::protobuf::internal::WireFormatLite::WriteMessageMaybeToArray(
      11, *this->initial_anchor_pose_, output);
  }

  // optional .mw.internal.robotics.gazebotransport.Pose world_pose = 12;
  if (has_world_pose()) {
    ::google::protobuf::internal::WireFormatLite::WriteMessageMaybeToArray(
      12, *this->world_pose_, output);
  }

  // optional .mw.internal.robotics.gazebotransport.Pose parent_world_pose = 13;
  if (has_parent_world_pose()) {
    ::google::protobuf::internal::WireFormatLite::WriteMessageMaybeToArray(
      13, *this->parent_world_pose_, output);
  }

  // repeated .mw.internal.robotics.gazebotransport.Axis axis = 14;
  for (unsigned int i = 0, n = this->axis_size(); i < n; i++) {
    ::google::protobuf::internal::WireFormatLite::WriteMessageMaybeToArray(
      14, this->axis(i), output);
  }

  if (_internal_metadata_.have_unknown_fields()) {
    ::google::protobuf::internal::WireFormat::SerializeUnknownFields(
        unknown_fields(), output);
  }
  // @@protoc_insertion_point(serialize_end:mw.internal.robotics.gazebotransport.JointState)
}

::google::protobuf::uint8* JointState::InternalSerializeWithCachedSizesToArray(
    bool deterministic, ::google::protobuf::uint8* target) const {
  // @@protoc_insertion_point(serialize_to_array_start:mw.internal.robotics.gazebotransport.JointState)
  // required string model_name = 1;
  if (has_model_name()) {
    ::google::protobuf::internal::WireFormat::VerifyUTF8StringNamedField(
      this->model_name().data(), this->model_name().length(),
      ::google::protobuf::internal::WireFormat::SERIALIZE,
      "mw.internal.robotics.gazebotransport.JointState.model_name");
    target =
      ::google::protobuf::internal::WireFormatLite::WriteStringToArray(
        1, this->model_name(), target);
  }

  // required string joint_name = 2;
  if (has_joint_name()) {
    ::google::protobuf::internal::WireFormat::VerifyUTF8StringNamedField(
      this->joint_name().data(), this->joint_name().length(),
      ::google::protobuf::internal::WireFormat::SERIALIZE,
      "mw.internal.robotics.gazebotransport.JointState.joint_name");
    target =
      ::google::protobuf::internal::WireFormatLite::WriteStringToArray(
        2, this->joint_name(), target);
  }

  // required uint32 joint_id = 3;
  if (has_joint_id()) {
    target = ::google::protobuf::internal::WireFormatLite::WriteUInt32ToArray(3, this->joint_id(), target);
  }

  // repeated double joint_position = 4;
  for (int i = 0; i < this->joint_position_size(); i++) {
    target = ::google::protobuf::internal::WireFormatLite::
      WriteDoubleToArray(4, this->joint_position(i), target);
  }

  // repeated double joint_velocity = 5;
  for (int i = 0; i < this->joint_velocity_size(); i++) {
    target = ::google::protobuf::internal::WireFormatLite::
      WriteDoubleToArray(5, this->joint_velocity(i), target);
  }

  // optional .mw.internal.robotics.gazebotransport.JointState.Joint_Type joint_type = 6;
  if (has_joint_type()) {
    target = ::google::protobuf::internal::WireFormatLite::WriteEnumToArray(
      6, this->joint_type(), target);
  }

  // optional string parent_name = 7;
  if (has_parent_name()) {
    ::google::protobuf::internal::WireFormat::VerifyUTF8StringNamedField(
      this->parent_name().data(), this->parent_name().length(),
      ::google::protobuf::internal::WireFormat::SERIALIZE,
      "mw.internal.robotics.gazebotransport.JointState.parent_name");
    target =
      ::google::protobuf::internal::WireFormatLite::WriteStringToArray(
        7, this->parent_name(), target);
  }

  // optional uint32 parent_id = 8;
  if (has_parent_id()) {
    target = ::google::protobuf::internal::WireFormatLite::WriteUInt32ToArray(8, this->parent_id(), target);
  }

  // optional string child_name = 9;
  if (has_child_name()) {
    ::google::protobuf::internal::WireFormat::VerifyUTF8StringNamedField(
      this->child_name().data(), this->child_name().length(),
      ::google::protobuf::internal::WireFormat::SERIALIZE,
      "mw.internal.robotics.gazebotransport.JointState.child_name");
    target =
      ::google::protobuf::internal::WireFormatLite::WriteStringToArray(
        9, this->child_name(), target);
  }

  // optional uint32 child_id = 10;
  if (has_child_id()) {
    target = ::google::protobuf::internal::WireFormatLite::WriteUInt32ToArray(10, this->child_id(), target);
  }

  // optional .mw.internal.robotics.gazebotransport.Pose initial_anchor_pose = 11;
  if (has_initial_anchor_pose()) {
    target = ::google::protobuf::internal::WireFormatLite::
      InternalWriteMessageNoVirtualToArray(
        11, *this->initial_anchor_pose_, false, target);
  }

  // optional .mw.internal.robotics.gazebotransport.Pose world_pose = 12;
  if (has_world_pose()) {
    target = ::google::protobuf::internal::WireFormatLite::
      InternalWriteMessageNoVirtualToArray(
        12, *this->world_pose_, false, target);
  }

  // optional .mw.internal.robotics.gazebotransport.Pose parent_world_pose = 13;
  if (has_parent_world_pose()) {
    target = ::google::protobuf::internal::WireFormatLite::
      InternalWriteMessageNoVirtualToArray(
        13, *this->parent_world_pose_, false, target);
  }

  // repeated .mw.internal.robotics.gazebotransport.Axis axis = 14;
  for (unsigned int i = 0, n = this->axis_size(); i < n; i++) {
    target = ::google::protobuf::internal::WireFormatLite::
      InternalWriteMessageNoVirtualToArray(
        14, this->axis(i), false, target);
  }

  if (_internal_metadata_.have_unknown_fields()) {
    target = ::google::protobuf::internal::WireFormat::SerializeUnknownFieldsToArray(
        unknown_fields(), target);
  }
  // @@protoc_insertion_point(serialize_to_array_end:mw.internal.robotics.gazebotransport.JointState)
  return target;
}

int JointState::RequiredFieldsByteSizeFallback() const {
// @@protoc_insertion_point(required_fields_byte_size_fallback_start:mw.internal.robotics.gazebotransport.JointState)
  int total_size = 0;

  if (has_model_name()) {
    // required string model_name = 1;
    total_size += 1 +
      ::google::protobuf::internal::WireFormatLite::StringSize(
        this->model_name());
  }

  if (has_joint_name()) {
    // required string joint_name = 2;
    total_size += 1 +
      ::google::protobuf::internal::WireFormatLite::StringSize(
        this->joint_name());
  }

  if (has_joint_id()) {
    // required uint32 joint_id = 3;
    total_size += 1 +
      ::google::protobuf::internal::WireFormatLite::UInt32Size(
        this->joint_id());
  }

  return total_size;
}
int JointState::ByteSize() const {
// @@protoc_insertion_point(message_byte_size_start:mw.internal.robotics.gazebotransport.JointState)
  int total_size = 0;

  if (((_has_bits_[0] & 0x00000007) ^ 0x00000007) == 0) {  // All required fields are present.
    // required string model_name = 1;
    total_size += 1 +
      ::google::protobuf::internal::WireFormatLite::StringSize(
        this->model_name());

    // required string joint_name = 2;
    total_size += 1 +
      ::google::protobuf::internal::WireFormatLite::StringSize(
        this->joint_name());

    // required uint32 joint_id = 3;
    total_size += 1 +
      ::google::protobuf::internal::WireFormatLite::UInt32Size(
        this->joint_id());

  } else {
    total_size += RequiredFieldsByteSizeFallback();
  }
  if (_has_bits_[5 / 32] & 224u) {
    // optional .mw.internal.robotics.gazebotransport.JointState.Joint_Type joint_type = 6;
    if (has_joint_type()) {
      total_size += 1 +
        ::google::protobuf::internal::WireFormatLite::EnumSize(this->joint_type());
    }

    // optional string parent_name = 7;
    if (has_parent_name()) {
      total_size += 1 +
        ::google::protobuf::internal::WireFormatLite::StringSize(
          this->parent_name());
    }

    // optional uint32 parent_id = 8;
    if (has_parent_id()) {
      total_size += 1 +
        ::google::protobuf::internal::WireFormatLite::UInt32Size(
          this->parent_id());
    }

  }
  if (_has_bits_[8 / 32] & 7936u) {
    // optional string child_name = 9;
    if (has_child_name()) {
      total_size += 1 +
        ::google::protobuf::internal::WireFormatLite::StringSize(
          this->child_name());
    }

    // optional uint32 child_id = 10;
    if (has_child_id()) {
      total_size += 1 +
        ::google::protobuf::internal::WireFormatLite::UInt32Size(
          this->child_id());
    }

    // optional .mw.internal.robotics.gazebotransport.Pose initial_anchor_pose = 11;
    if (has_initial_anchor_pose()) {
      total_size += 1 +
        ::google::protobuf::internal::WireFormatLite::MessageSizeNoVirtual(
          *this->initial_anchor_pose_);
    }

    // optional .mw.internal.robotics.gazebotransport.Pose world_pose = 12;
    if (has_world_pose()) {
      total_size += 1 +
        ::google::protobuf::internal::WireFormatLite::MessageSizeNoVirtual(
          *this->world_pose_);
    }

    // optional .mw.internal.robotics.gazebotransport.Pose parent_world_pose = 13;
    if (has_parent_world_pose()) {
      total_size += 1 +
        ::google::protobuf::internal::WireFormatLite::MessageSizeNoVirtual(
          *this->parent_world_pose_);
    }

  }
  // repeated double joint_position = 4;
  {
    int data_size = 0;
    data_size = 8 * this->joint_position_size();
    total_size += 1 * this->joint_position_size() + data_size;
  }

  // repeated double joint_velocity = 5;
  {
    int data_size = 0;
    data_size = 8 * this->joint_velocity_size();
    total_size += 1 * this->joint_velocity_size() + data_size;
  }

  // repeated .mw.internal.robotics.gazebotransport.Axis axis = 14;
  total_size += 1 * this->axis_size();
  for (int i = 0; i < this->axis_size(); i++) {
    total_size +=
      ::google::protobuf::internal::WireFormatLite::MessageSizeNoVirtual(
        this->axis(i));
  }

  if (_internal_metadata_.have_unknown_fields()) {
    total_size +=
      ::google::protobuf::internal::WireFormat::ComputeUnknownFieldsSize(
        unknown_fields());
  }
  GOOGLE_SAFE_CONCURRENT_WRITES_BEGIN();
  _cached_size_ = total_size;
  GOOGLE_SAFE_CONCURRENT_WRITES_END();
  return total_size;
}

void JointState::MergeFrom(const ::google::protobuf::Message& from) {
// @@protoc_insertion_point(generalized_merge_from_start:mw.internal.robotics.gazebotransport.JointState)
  if (GOOGLE_PREDICT_FALSE(&from == this)) {
    ::google::protobuf::internal::MergeFromFail(__FILE__, __LINE__);
  }
  const JointState* source = 
      ::google::protobuf::internal::DynamicCastToGenerated<const JointState>(
          &from);
  if (source == NULL) {
  // @@protoc_insertion_point(generalized_merge_from_cast_fail:mw.internal.robotics.gazebotransport.JointState)
    ::google::protobuf::internal::ReflectionOps::Merge(from, this);
  } else {
  // @@protoc_insertion_point(generalized_merge_from_cast_success:mw.internal.robotics.gazebotransport.JointState)
    MergeFrom(*source);
  }
}

void JointState::MergeFrom(const JointState& from) {
// @@protoc_insertion_point(class_specific_merge_from_start:mw.internal.robotics.gazebotransport.JointState)
  if (GOOGLE_PREDICT_FALSE(&from == this)) {
    ::google::protobuf::internal::MergeFromFail(__FILE__, __LINE__);
  }
  joint_position_.MergeFrom(from.joint_position_);
  joint_velocity_.MergeFrom(from.joint_velocity_);
  axis_.MergeFrom(from.axis_);
  if (from._has_bits_[0 / 32] & (0xffu << (0 % 32))) {
    if (from.has_model_name()) {
      set_has_model_name();
      model_name_.AssignWithDefault(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), from.model_name_);
    }
    if (from.has_joint_name()) {
      set_has_joint_name();
      joint_name_.AssignWithDefault(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), from.joint_name_);
    }
    if (from.has_joint_id()) {
      set_joint_id(from.joint_id());
    }
    if (from.has_joint_type()) {
      set_joint_type(from.joint_type());
    }
    if (from.has_parent_name()) {
      set_has_parent_name();
      parent_name_.AssignWithDefault(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), from.parent_name_);
    }
    if (from.has_parent_id()) {
      set_parent_id(from.parent_id());
    }
  }
  if (from._has_bits_[8 / 32] & (0xffu << (8 % 32))) {
    if (from.has_child_name()) {
      set_has_child_name();
      child_name_.AssignWithDefault(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), from.child_name_);
    }
    if (from.has_child_id()) {
      set_child_id(from.child_id());
    }
    if (from.has_initial_anchor_pose()) {
      mutable_initial_anchor_pose()->::mw::internal::robotics::gazebotransport::Pose::MergeFrom(from.initial_anchor_pose());
    }
    if (from.has_world_pose()) {
      mutable_world_pose()->::mw::internal::robotics::gazebotransport::Pose::MergeFrom(from.world_pose());
    }
    if (from.has_parent_world_pose()) {
      mutable_parent_world_pose()->::mw::internal::robotics::gazebotransport::Pose::MergeFrom(from.parent_world_pose());
    }
  }
  if (from._internal_metadata_.have_unknown_fields()) {
    mutable_unknown_fields()->MergeFrom(from.unknown_fields());
  }
}

void JointState::CopyFrom(const ::google::protobuf::Message& from) {
// @@protoc_insertion_point(generalized_copy_from_start:mw.internal.robotics.gazebotransport.JointState)
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

void JointState::CopyFrom(const JointState& from) {
// @@protoc_insertion_point(class_specific_copy_from_start:mw.internal.robotics.gazebotransport.JointState)
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

bool JointState::IsInitialized() const {
  if ((_has_bits_[0] & 0x00000007) != 0x00000007) return false;

  if (has_initial_anchor_pose()) {
    if (!this->initial_anchor_pose_->IsInitialized()) return false;
  }
  if (has_world_pose()) {
    if (!this->world_pose_->IsInitialized()) return false;
  }
  if (has_parent_world_pose()) {
    if (!this->parent_world_pose_->IsInitialized()) return false;
  }
  if (!::google::protobuf::internal::AllAreInitialized(this->axis())) return false;
  return true;
}

void JointState::Swap(JointState* other) {
  if (other == this) return;
  InternalSwap(other);
}
void JointState::InternalSwap(JointState* other) {
  model_name_.Swap(&other->model_name_);
  joint_name_.Swap(&other->joint_name_);
  std::swap(joint_id_, other->joint_id_);
  joint_position_.UnsafeArenaSwap(&other->joint_position_);
  joint_velocity_.UnsafeArenaSwap(&other->joint_velocity_);
  std::swap(joint_type_, other->joint_type_);
  parent_name_.Swap(&other->parent_name_);
  std::swap(parent_id_, other->parent_id_);
  child_name_.Swap(&other->child_name_);
  std::swap(child_id_, other->child_id_);
  std::swap(initial_anchor_pose_, other->initial_anchor_pose_);
  std::swap(world_pose_, other->world_pose_);
  std::swap(parent_world_pose_, other->parent_world_pose_);
  axis_.UnsafeArenaSwap(&other->axis_);
  std::swap(_has_bits_[0], other->_has_bits_[0]);
  _internal_metadata_.Swap(&other->_internal_metadata_);
  std::swap(_cached_size_, other->_cached_size_);
}

::google::protobuf::Metadata JointState::GetMetadata() const {
  protobuf_AssignDescriptorsOnce();
  ::google::protobuf::Metadata metadata;
  metadata.descriptor = JointState_descriptor_;
  metadata.reflection = JointState_reflection_;
  return metadata;
}

#if PROTOBUF_INLINE_NOT_IN_HEADERS
// JointState

// required string model_name = 1;
bool JointState::has_model_name() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
void JointState::set_has_model_name() {
  _has_bits_[0] |= 0x00000001u;
}
void JointState::clear_has_model_name() {
  _has_bits_[0] &= ~0x00000001u;
}
void JointState::clear_model_name() {
  model_name_.ClearToEmptyNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
  clear_has_model_name();
}
 const ::std::string& JointState::model_name() const {
  // @@protoc_insertion_point(field_get:mw.internal.robotics.gazebotransport.JointState.model_name)
  return model_name_.GetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
 void JointState::set_model_name(const ::std::string& value) {
  set_has_model_name();
  model_name_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), value);
  // @@protoc_insertion_point(field_set:mw.internal.robotics.gazebotransport.JointState.model_name)
}
 void JointState::set_model_name(const char* value) {
  set_has_model_name();
  model_name_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::string(value));
  // @@protoc_insertion_point(field_set_char:mw.internal.robotics.gazebotransport.JointState.model_name)
}
 void JointState::set_model_name(const char* value, size_t size) {
  set_has_model_name();
  model_name_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(),
      ::std::string(reinterpret_cast<const char*>(value), size));
  // @@protoc_insertion_point(field_set_pointer:mw.internal.robotics.gazebotransport.JointState.model_name)
}
 ::std::string* JointState::mutable_model_name() {
  set_has_model_name();
  // @@protoc_insertion_point(field_mutable:mw.internal.robotics.gazebotransport.JointState.model_name)
  return model_name_.MutableNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
 ::std::string* JointState::release_model_name() {
  // @@protoc_insertion_point(field_release:mw.internal.robotics.gazebotransport.JointState.model_name)
  clear_has_model_name();
  return model_name_.ReleaseNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
 void JointState::set_allocated_model_name(::std::string* model_name) {
  if (model_name != NULL) {
    set_has_model_name();
  } else {
    clear_has_model_name();
  }
  model_name_.SetAllocatedNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), model_name);
  // @@protoc_insertion_point(field_set_allocated:mw.internal.robotics.gazebotransport.JointState.model_name)
}

// required string joint_name = 2;
bool JointState::has_joint_name() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
void JointState::set_has_joint_name() {
  _has_bits_[0] |= 0x00000002u;
}
void JointState::clear_has_joint_name() {
  _has_bits_[0] &= ~0x00000002u;
}
void JointState::clear_joint_name() {
  joint_name_.ClearToEmptyNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
  clear_has_joint_name();
}
 const ::std::string& JointState::joint_name() const {
  // @@protoc_insertion_point(field_get:mw.internal.robotics.gazebotransport.JointState.joint_name)
  return joint_name_.GetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
 void JointState::set_joint_name(const ::std::string& value) {
  set_has_joint_name();
  joint_name_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), value);
  // @@protoc_insertion_point(field_set:mw.internal.robotics.gazebotransport.JointState.joint_name)
}
 void JointState::set_joint_name(const char* value) {
  set_has_joint_name();
  joint_name_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::string(value));
  // @@protoc_insertion_point(field_set_char:mw.internal.robotics.gazebotransport.JointState.joint_name)
}
 void JointState::set_joint_name(const char* value, size_t size) {
  set_has_joint_name();
  joint_name_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(),
      ::std::string(reinterpret_cast<const char*>(value), size));
  // @@protoc_insertion_point(field_set_pointer:mw.internal.robotics.gazebotransport.JointState.joint_name)
}
 ::std::string* JointState::mutable_joint_name() {
  set_has_joint_name();
  // @@protoc_insertion_point(field_mutable:mw.internal.robotics.gazebotransport.JointState.joint_name)
  return joint_name_.MutableNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
 ::std::string* JointState::release_joint_name() {
  // @@protoc_insertion_point(field_release:mw.internal.robotics.gazebotransport.JointState.joint_name)
  clear_has_joint_name();
  return joint_name_.ReleaseNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
 void JointState::set_allocated_joint_name(::std::string* joint_name) {
  if (joint_name != NULL) {
    set_has_joint_name();
  } else {
    clear_has_joint_name();
  }
  joint_name_.SetAllocatedNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), joint_name);
  // @@protoc_insertion_point(field_set_allocated:mw.internal.robotics.gazebotransport.JointState.joint_name)
}

// required uint32 joint_id = 3;
bool JointState::has_joint_id() const {
  return (_has_bits_[0] & 0x00000004u) != 0;
}
void JointState::set_has_joint_id() {
  _has_bits_[0] |= 0x00000004u;
}
void JointState::clear_has_joint_id() {
  _has_bits_[0] &= ~0x00000004u;
}
void JointState::clear_joint_id() {
  joint_id_ = 0u;
  clear_has_joint_id();
}
 ::google::protobuf::uint32 JointState::joint_id() const {
  // @@protoc_insertion_point(field_get:mw.internal.robotics.gazebotransport.JointState.joint_id)
  return joint_id_;
}
 void JointState::set_joint_id(::google::protobuf::uint32 value) {
  set_has_joint_id();
  joint_id_ = value;
  // @@protoc_insertion_point(field_set:mw.internal.robotics.gazebotransport.JointState.joint_id)
}

// repeated double joint_position = 4;
int JointState::joint_position_size() const {
  return joint_position_.size();
}
void JointState::clear_joint_position() {
  joint_position_.Clear();
}
 double JointState::joint_position(int index) const {
  // @@protoc_insertion_point(field_get:mw.internal.robotics.gazebotransport.JointState.joint_position)
  return joint_position_.Get(index);
}
 void JointState::set_joint_position(int index, double value) {
  joint_position_.Set(index, value);
  // @@protoc_insertion_point(field_set:mw.internal.robotics.gazebotransport.JointState.joint_position)
}
 void JointState::add_joint_position(double value) {
  joint_position_.Add(value);
  // @@protoc_insertion_point(field_add:mw.internal.robotics.gazebotransport.JointState.joint_position)
}
 const ::google::protobuf::RepeatedField< double >&
JointState::joint_position() const {
  // @@protoc_insertion_point(field_list:mw.internal.robotics.gazebotransport.JointState.joint_position)
  return joint_position_;
}
 ::google::protobuf::RepeatedField< double >*
JointState::mutable_joint_position() {
  // @@protoc_insertion_point(field_mutable_list:mw.internal.robotics.gazebotransport.JointState.joint_position)
  return &joint_position_;
}

// repeated double joint_velocity = 5;
int JointState::joint_velocity_size() const {
  return joint_velocity_.size();
}
void JointState::clear_joint_velocity() {
  joint_velocity_.Clear();
}
 double JointState::joint_velocity(int index) const {
  // @@protoc_insertion_point(field_get:mw.internal.robotics.gazebotransport.JointState.joint_velocity)
  return joint_velocity_.Get(index);
}
 void JointState::set_joint_velocity(int index, double value) {
  joint_velocity_.Set(index, value);
  // @@protoc_insertion_point(field_set:mw.internal.robotics.gazebotransport.JointState.joint_velocity)
}
 void JointState::add_joint_velocity(double value) {
  joint_velocity_.Add(value);
  // @@protoc_insertion_point(field_add:mw.internal.robotics.gazebotransport.JointState.joint_velocity)
}
 const ::google::protobuf::RepeatedField< double >&
JointState::joint_velocity() const {
  // @@protoc_insertion_point(field_list:mw.internal.robotics.gazebotransport.JointState.joint_velocity)
  return joint_velocity_;
}
 ::google::protobuf::RepeatedField< double >*
JointState::mutable_joint_velocity() {
  // @@protoc_insertion_point(field_mutable_list:mw.internal.robotics.gazebotransport.JointState.joint_velocity)
  return &joint_velocity_;
}

// optional .mw.internal.robotics.gazebotransport.JointState.Joint_Type joint_type = 6;
bool JointState::has_joint_type() const {
  return (_has_bits_[0] & 0x00000020u) != 0;
}
void JointState::set_has_joint_type() {
  _has_bits_[0] |= 0x00000020u;
}
void JointState::clear_has_joint_type() {
  _has_bits_[0] &= ~0x00000020u;
}
void JointState::clear_joint_type() {
  joint_type_ = 1;
  clear_has_joint_type();
}
 ::mw::internal::robotics::gazebotransport::JointState_Joint_Type JointState::joint_type() const {
  // @@protoc_insertion_point(field_get:mw.internal.robotics.gazebotransport.JointState.joint_type)
  return static_cast< ::mw::internal::robotics::gazebotransport::JointState_Joint_Type >(joint_type_);
}
 void JointState::set_joint_type(::mw::internal::robotics::gazebotransport::JointState_Joint_Type value) {
  assert(::mw::internal::robotics::gazebotransport::JointState_Joint_Type_IsValid(value));
  set_has_joint_type();
  joint_type_ = value;
  // @@protoc_insertion_point(field_set:mw.internal.robotics.gazebotransport.JointState.joint_type)
}

// optional string parent_name = 7;
bool JointState::has_parent_name() const {
  return (_has_bits_[0] & 0x00000040u) != 0;
}
void JointState::set_has_parent_name() {
  _has_bits_[0] |= 0x00000040u;
}
void JointState::clear_has_parent_name() {
  _has_bits_[0] &= ~0x00000040u;
}
void JointState::clear_parent_name() {
  parent_name_.ClearToEmptyNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
  clear_has_parent_name();
}
 const ::std::string& JointState::parent_name() const {
  // @@protoc_insertion_point(field_get:mw.internal.robotics.gazebotransport.JointState.parent_name)
  return parent_name_.GetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
 void JointState::set_parent_name(const ::std::string& value) {
  set_has_parent_name();
  parent_name_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), value);
  // @@protoc_insertion_point(field_set:mw.internal.robotics.gazebotransport.JointState.parent_name)
}
 void JointState::set_parent_name(const char* value) {
  set_has_parent_name();
  parent_name_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::string(value));
  // @@protoc_insertion_point(field_set_char:mw.internal.robotics.gazebotransport.JointState.parent_name)
}
 void JointState::set_parent_name(const char* value, size_t size) {
  set_has_parent_name();
  parent_name_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(),
      ::std::string(reinterpret_cast<const char*>(value), size));
  // @@protoc_insertion_point(field_set_pointer:mw.internal.robotics.gazebotransport.JointState.parent_name)
}
 ::std::string* JointState::mutable_parent_name() {
  set_has_parent_name();
  // @@protoc_insertion_point(field_mutable:mw.internal.robotics.gazebotransport.JointState.parent_name)
  return parent_name_.MutableNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
 ::std::string* JointState::release_parent_name() {
  // @@protoc_insertion_point(field_release:mw.internal.robotics.gazebotransport.JointState.parent_name)
  clear_has_parent_name();
  return parent_name_.ReleaseNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
 void JointState::set_allocated_parent_name(::std::string* parent_name) {
  if (parent_name != NULL) {
    set_has_parent_name();
  } else {
    clear_has_parent_name();
  }
  parent_name_.SetAllocatedNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), parent_name);
  // @@protoc_insertion_point(field_set_allocated:mw.internal.robotics.gazebotransport.JointState.parent_name)
}

// optional uint32 parent_id = 8;
bool JointState::has_parent_id() const {
  return (_has_bits_[0] & 0x00000080u) != 0;
}
void JointState::set_has_parent_id() {
  _has_bits_[0] |= 0x00000080u;
}
void JointState::clear_has_parent_id() {
  _has_bits_[0] &= ~0x00000080u;
}
void JointState::clear_parent_id() {
  parent_id_ = 0u;
  clear_has_parent_id();
}
 ::google::protobuf::uint32 JointState::parent_id() const {
  // @@protoc_insertion_point(field_get:mw.internal.robotics.gazebotransport.JointState.parent_id)
  return parent_id_;
}
 void JointState::set_parent_id(::google::protobuf::uint32 value) {
  set_has_parent_id();
  parent_id_ = value;
  // @@protoc_insertion_point(field_set:mw.internal.robotics.gazebotransport.JointState.parent_id)
}

// optional string child_name = 9;
bool JointState::has_child_name() const {
  return (_has_bits_[0] & 0x00000100u) != 0;
}
void JointState::set_has_child_name() {
  _has_bits_[0] |= 0x00000100u;
}
void JointState::clear_has_child_name() {
  _has_bits_[0] &= ~0x00000100u;
}
void JointState::clear_child_name() {
  child_name_.ClearToEmptyNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
  clear_has_child_name();
}
 const ::std::string& JointState::child_name() const {
  // @@protoc_insertion_point(field_get:mw.internal.robotics.gazebotransport.JointState.child_name)
  return child_name_.GetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
 void JointState::set_child_name(const ::std::string& value) {
  set_has_child_name();
  child_name_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), value);
  // @@protoc_insertion_point(field_set:mw.internal.robotics.gazebotransport.JointState.child_name)
}
 void JointState::set_child_name(const char* value) {
  set_has_child_name();
  child_name_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::string(value));
  // @@protoc_insertion_point(field_set_char:mw.internal.robotics.gazebotransport.JointState.child_name)
}
 void JointState::set_child_name(const char* value, size_t size) {
  set_has_child_name();
  child_name_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(),
      ::std::string(reinterpret_cast<const char*>(value), size));
  // @@protoc_insertion_point(field_set_pointer:mw.internal.robotics.gazebotransport.JointState.child_name)
}
 ::std::string* JointState::mutable_child_name() {
  set_has_child_name();
  // @@protoc_insertion_point(field_mutable:mw.internal.robotics.gazebotransport.JointState.child_name)
  return child_name_.MutableNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
 ::std::string* JointState::release_child_name() {
  // @@protoc_insertion_point(field_release:mw.internal.robotics.gazebotransport.JointState.child_name)
  clear_has_child_name();
  return child_name_.ReleaseNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
 void JointState::set_allocated_child_name(::std::string* child_name) {
  if (child_name != NULL) {
    set_has_child_name();
  } else {
    clear_has_child_name();
  }
  child_name_.SetAllocatedNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), child_name);
  // @@protoc_insertion_point(field_set_allocated:mw.internal.robotics.gazebotransport.JointState.child_name)
}

// optional uint32 child_id = 10;
bool JointState::has_child_id() const {
  return (_has_bits_[0] & 0x00000200u) != 0;
}
void JointState::set_has_child_id() {
  _has_bits_[0] |= 0x00000200u;
}
void JointState::clear_has_child_id() {
  _has_bits_[0] &= ~0x00000200u;
}
void JointState::clear_child_id() {
  child_id_ = 0u;
  clear_has_child_id();
}
 ::google::protobuf::uint32 JointState::child_id() const {
  // @@protoc_insertion_point(field_get:mw.internal.robotics.gazebotransport.JointState.child_id)
  return child_id_;
}
 void JointState::set_child_id(::google::protobuf::uint32 value) {
  set_has_child_id();
  child_id_ = value;
  // @@protoc_insertion_point(field_set:mw.internal.robotics.gazebotransport.JointState.child_id)
}

// optional .mw.internal.robotics.gazebotransport.Pose initial_anchor_pose = 11;
bool JointState::has_initial_anchor_pose() const {
  return (_has_bits_[0] & 0x00000400u) != 0;
}
void JointState::set_has_initial_anchor_pose() {
  _has_bits_[0] |= 0x00000400u;
}
void JointState::clear_has_initial_anchor_pose() {
  _has_bits_[0] &= ~0x00000400u;
}
void JointState::clear_initial_anchor_pose() {
  if (initial_anchor_pose_ != NULL) initial_anchor_pose_->::mw::internal::robotics::gazebotransport::Pose::Clear();
  clear_has_initial_anchor_pose();
}
const ::mw::internal::robotics::gazebotransport::Pose& JointState::initial_anchor_pose() const {
  // @@protoc_insertion_point(field_get:mw.internal.robotics.gazebotransport.JointState.initial_anchor_pose)
  return initial_anchor_pose_ != NULL ? *initial_anchor_pose_ : *default_instance_->initial_anchor_pose_;
}
::mw::internal::robotics::gazebotransport::Pose* JointState::mutable_initial_anchor_pose() {
  set_has_initial_anchor_pose();
  if (initial_anchor_pose_ == NULL) {
    initial_anchor_pose_ = new ::mw::internal::robotics::gazebotransport::Pose;
  }
  // @@protoc_insertion_point(field_mutable:mw.internal.robotics.gazebotransport.JointState.initial_anchor_pose)
  return initial_anchor_pose_;
}
::mw::internal::robotics::gazebotransport::Pose* JointState::release_initial_anchor_pose() {
  // @@protoc_insertion_point(field_release:mw.internal.robotics.gazebotransport.JointState.initial_anchor_pose)
  clear_has_initial_anchor_pose();
  ::mw::internal::robotics::gazebotransport::Pose* temp = initial_anchor_pose_;
  initial_anchor_pose_ = NULL;
  return temp;
}
void JointState::set_allocated_initial_anchor_pose(::mw::internal::robotics::gazebotransport::Pose* initial_anchor_pose) {
  delete initial_anchor_pose_;
  initial_anchor_pose_ = initial_anchor_pose;
  if (initial_anchor_pose) {
    set_has_initial_anchor_pose();
  } else {
    clear_has_initial_anchor_pose();
  }
  // @@protoc_insertion_point(field_set_allocated:mw.internal.robotics.gazebotransport.JointState.initial_anchor_pose)
}

// optional .mw.internal.robotics.gazebotransport.Pose world_pose = 12;
bool JointState::has_world_pose() const {
  return (_has_bits_[0] & 0x00000800u) != 0;
}
void JointState::set_has_world_pose() {
  _has_bits_[0] |= 0x00000800u;
}
void JointState::clear_has_world_pose() {
  _has_bits_[0] &= ~0x00000800u;
}
void JointState::clear_world_pose() {
  if (world_pose_ != NULL) world_pose_->::mw::internal::robotics::gazebotransport::Pose::Clear();
  clear_has_world_pose();
}
const ::mw::internal::robotics::gazebotransport::Pose& JointState::world_pose() const {
  // @@protoc_insertion_point(field_get:mw.internal.robotics.gazebotransport.JointState.world_pose)
  return world_pose_ != NULL ? *world_pose_ : *default_instance_->world_pose_;
}
::mw::internal::robotics::gazebotransport::Pose* JointState::mutable_world_pose() {
  set_has_world_pose();
  if (world_pose_ == NULL) {
    world_pose_ = new ::mw::internal::robotics::gazebotransport::Pose;
  }
  // @@protoc_insertion_point(field_mutable:mw.internal.robotics.gazebotransport.JointState.world_pose)
  return world_pose_;
}
::mw::internal::robotics::gazebotransport::Pose* JointState::release_world_pose() {
  // @@protoc_insertion_point(field_release:mw.internal.robotics.gazebotransport.JointState.world_pose)
  clear_has_world_pose();
  ::mw::internal::robotics::gazebotransport::Pose* temp = world_pose_;
  world_pose_ = NULL;
  return temp;
}
void JointState::set_allocated_world_pose(::mw::internal::robotics::gazebotransport::Pose* world_pose) {
  delete world_pose_;
  world_pose_ = world_pose;
  if (world_pose) {
    set_has_world_pose();
  } else {
    clear_has_world_pose();
  }
  // @@protoc_insertion_point(field_set_allocated:mw.internal.robotics.gazebotransport.JointState.world_pose)
}

// optional .mw.internal.robotics.gazebotransport.Pose parent_world_pose = 13;
bool JointState::has_parent_world_pose() const {
  return (_has_bits_[0] & 0x00001000u) != 0;
}
void JointState::set_has_parent_world_pose() {
  _has_bits_[0] |= 0x00001000u;
}
void JointState::clear_has_parent_world_pose() {
  _has_bits_[0] &= ~0x00001000u;
}
void JointState::clear_parent_world_pose() {
  if (parent_world_pose_ != NULL) parent_world_pose_->::mw::internal::robotics::gazebotransport::Pose::Clear();
  clear_has_parent_world_pose();
}
const ::mw::internal::robotics::gazebotransport::Pose& JointState::parent_world_pose() const {
  // @@protoc_insertion_point(field_get:mw.internal.robotics.gazebotransport.JointState.parent_world_pose)
  return parent_world_pose_ != NULL ? *parent_world_pose_ : *default_instance_->parent_world_pose_;
}
::mw::internal::robotics::gazebotransport::Pose* JointState::mutable_parent_world_pose() {
  set_has_parent_world_pose();
  if (parent_world_pose_ == NULL) {
    parent_world_pose_ = new ::mw::internal::robotics::gazebotransport::Pose;
  }
  // @@protoc_insertion_point(field_mutable:mw.internal.robotics.gazebotransport.JointState.parent_world_pose)
  return parent_world_pose_;
}
::mw::internal::robotics::gazebotransport::Pose* JointState::release_parent_world_pose() {
  // @@protoc_insertion_point(field_release:mw.internal.robotics.gazebotransport.JointState.parent_world_pose)
  clear_has_parent_world_pose();
  ::mw::internal::robotics::gazebotransport::Pose* temp = parent_world_pose_;
  parent_world_pose_ = NULL;
  return temp;
}
void JointState::set_allocated_parent_world_pose(::mw::internal::robotics::gazebotransport::Pose* parent_world_pose) {
  delete parent_world_pose_;
  parent_world_pose_ = parent_world_pose;
  if (parent_world_pose) {
    set_has_parent_world_pose();
  } else {
    clear_has_parent_world_pose();
  }
  // @@protoc_insertion_point(field_set_allocated:mw.internal.robotics.gazebotransport.JointState.parent_world_pose)
}

// repeated .mw.internal.robotics.gazebotransport.Axis axis = 14;
int JointState::axis_size() const {
  return axis_.size();
}
void JointState::clear_axis() {
  axis_.Clear();
}
const ::mw::internal::robotics::gazebotransport::Axis& JointState::axis(int index) const {
  // @@protoc_insertion_point(field_get:mw.internal.robotics.gazebotransport.JointState.axis)
  return axis_.Get(index);
}
::mw::internal::robotics::gazebotransport::Axis* JointState::mutable_axis(int index) {
  // @@protoc_insertion_point(field_mutable:mw.internal.robotics.gazebotransport.JointState.axis)
  return axis_.Mutable(index);
}
::mw::internal::robotics::gazebotransport::Axis* JointState::add_axis() {
  // @@protoc_insertion_point(field_add:mw.internal.robotics.gazebotransport.JointState.axis)
  return axis_.Add();
}
::google::protobuf::RepeatedPtrField< ::mw::internal::robotics::gazebotransport::Axis >*
JointState::mutable_axis() {
  // @@protoc_insertion_point(field_mutable_list:mw.internal.robotics.gazebotransport.JointState.axis)
  return &axis_;
}
const ::google::protobuf::RepeatedPtrField< ::mw::internal::robotics::gazebotransport::Axis >&
JointState::axis() const {
  // @@protoc_insertion_point(field_list:mw.internal.robotics.gazebotransport.JointState.axis)
  return axis_;
}

#endif  // PROTOBUF_INLINE_NOT_IN_HEADERS

// ===================================================================

#if !defined(_MSC_VER) || _MSC_VER >= 1900
const int SetLinkWorldPose::kModelNameFieldNumber;
const int SetLinkWorldPose::kLinkNameFieldNumber;
const int SetLinkWorldPose::kPoseFieldNumber;
const int SetLinkWorldPose::kDurationFieldNumber;
#endif  // !defined(_MSC_VER) || _MSC_VER >= 1900

SetLinkWorldPose::SetLinkWorldPose()
  : ::google::protobuf::Message(), _internal_metadata_(NULL) {
  SharedCtor();
  // @@protoc_insertion_point(constructor:mw.internal.robotics.gazebotransport.SetLinkWorldPose)
}

void SetLinkWorldPose::InitAsDefaultInstance() {
  pose_ = const_cast< ::mw::internal::robotics::gazebotransport::Pose*>(&::mw::internal::robotics::gazebotransport::Pose::default_instance());
  duration_ = const_cast< ::mw::internal::robotics::gazebotransport::Time*>(&::mw::internal::robotics::gazebotransport::Time::default_instance());
}

SetLinkWorldPose::SetLinkWorldPose(const SetLinkWorldPose& from)
  : ::google::protobuf::Message(),
    _internal_metadata_(NULL) {
  SharedCtor();
  MergeFrom(from);
  // @@protoc_insertion_point(copy_constructor:mw.internal.robotics.gazebotransport.SetLinkWorldPose)
}

void SetLinkWorldPose::SharedCtor() {
  ::google::protobuf::internal::GetEmptyString();
  _cached_size_ = 0;
  model_name_.UnsafeSetDefault(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
  link_name_.UnsafeSetDefault(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
  pose_ = NULL;
  duration_ = NULL;
  ::memset(_has_bits_, 0, sizeof(_has_bits_));
}

SetLinkWorldPose::~SetLinkWorldPose() {
  // @@protoc_insertion_point(destructor:mw.internal.robotics.gazebotransport.SetLinkWorldPose)
  SharedDtor();
}

void SetLinkWorldPose::SharedDtor() {
  model_name_.DestroyNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
  link_name_.DestroyNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
  if (this != default_instance_) {
    delete pose_;
    delete duration_;
  }
}

void SetLinkWorldPose::SetCachedSize(int size) const {
  GOOGLE_SAFE_CONCURRENT_WRITES_BEGIN();
  _cached_size_ = size;
  GOOGLE_SAFE_CONCURRENT_WRITES_END();
}
const ::google::protobuf::Descriptor* SetLinkWorldPose::descriptor() {
  protobuf_AssignDescriptorsOnce();
  return SetLinkWorldPose_descriptor_;
}

const SetLinkWorldPose& SetLinkWorldPose::default_instance() {
  if (default_instance_ == NULL) protobuf_AddDesc_mw_2einternal_2erobotics_2egazebotransport_2eCoSimMsgs_2eproto();
  return *default_instance_;
}

SetLinkWorldPose* SetLinkWorldPose::default_instance_ = NULL;

SetLinkWorldPose* SetLinkWorldPose::New(::google::protobuf::Arena* arena) const {
  SetLinkWorldPose* n = new SetLinkWorldPose;
  if (arena != NULL) {
    arena->Own(n);
  }
  return n;
}

void SetLinkWorldPose::Clear() {
// @@protoc_insertion_point(message_clear_start:mw.internal.robotics.gazebotransport.SetLinkWorldPose)
  if (_has_bits_[0 / 32] & 15u) {
    if (has_model_name()) {
      model_name_.ClearToEmptyNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
    }
    if (has_link_name()) {
      link_name_.ClearToEmptyNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
    }
    if (has_pose()) {
      if (pose_ != NULL) pose_->::mw::internal::robotics::gazebotransport::Pose::Clear();
    }
    if (has_duration()) {
      if (duration_ != NULL) duration_->::mw::internal::robotics::gazebotransport::Time::Clear();
    }
  }
  ::memset(_has_bits_, 0, sizeof(_has_bits_));
  if (_internal_metadata_.have_unknown_fields()) {
    mutable_unknown_fields()->Clear();
  }
}

bool SetLinkWorldPose::MergePartialFromCodedStream(
    ::google::protobuf::io::CodedInputStream* input) {
#define DO_(EXPRESSION) if (!GOOGLE_PREDICT_TRUE(EXPRESSION)) goto failure
  ::google::protobuf::uint32 tag;
  // @@protoc_insertion_point(parse_start:mw.internal.robotics.gazebotransport.SetLinkWorldPose)
  for (;;) {
    ::std::pair< ::google::protobuf::uint32, bool> p = input->ReadTagWithCutoff(127);
    tag = p.first;
    if (!p.second) goto handle_unusual;
    switch (::google::protobuf::internal::WireFormatLite::GetTagFieldNumber(tag)) {
      // required string model_name = 1;
      case 1: {
        if (tag == 10) {
          DO_(::google::protobuf::internal::WireFormatLite::ReadString(
                input, this->mutable_model_name()));
          ::google::protobuf::internal::WireFormat::VerifyUTF8StringNamedField(
            this->model_name().data(), this->model_name().length(),
            ::google::protobuf::internal::WireFormat::PARSE,
            "mw.internal.robotics.gazebotransport.SetLinkWorldPose.model_name");
        } else {
          goto handle_unusual;
        }
        if (input->ExpectTag(18)) goto parse_link_name;
        break;
      }

      // required string link_name = 2;
      case 2: {
        if (tag == 18) {
         parse_link_name:
          DO_(::google::protobuf::internal::WireFormatLite::ReadString(
                input, this->mutable_link_name()));
          ::google::protobuf::internal::WireFormat::VerifyUTF8StringNamedField(
            this->link_name().data(), this->link_name().length(),
            ::google::protobuf::internal::WireFormat::PARSE,
            "mw.internal.robotics.gazebotransport.SetLinkWorldPose.link_name");
        } else {
          goto handle_unusual;
        }
        if (input->ExpectTag(26)) goto parse_pose;
        break;
      }

      // required .mw.internal.robotics.gazebotransport.Pose pose = 3;
      case 3: {
        if (tag == 26) {
         parse_pose:
          DO_(::google::protobuf::internal::WireFormatLite::ReadMessageNoVirtual(
               input, mutable_pose()));
        } else {
          goto handle_unusual;
        }
        if (input->ExpectTag(34)) goto parse_duration;
        break;
      }

      // required .mw.internal.robotics.gazebotransport.Time duration = 4;
      case 4: {
        if (tag == 34) {
         parse_duration:
          DO_(::google::protobuf::internal::WireFormatLite::ReadMessageNoVirtual(
               input, mutable_duration()));
        } else {
          goto handle_unusual;
        }
        if (input->ExpectAtEnd()) goto success;
        break;
      }

      default: {
      handle_unusual:
        if (tag == 0 ||
            ::google::protobuf::internal::WireFormatLite::GetTagWireType(tag) ==
            ::google::protobuf::internal::WireFormatLite::WIRETYPE_END_GROUP) {
          goto success;
        }
        DO_(::google::protobuf::internal::WireFormat::SkipField(
              input, tag, mutable_unknown_fields()));
        break;
      }
    }
  }
success:
  // @@protoc_insertion_point(parse_success:mw.internal.robotics.gazebotransport.SetLinkWorldPose)
  return true;
failure:
  // @@protoc_insertion_point(parse_failure:mw.internal.robotics.gazebotransport.SetLinkWorldPose)
  return false;
#undef DO_
}

void SetLinkWorldPose::SerializeWithCachedSizes(
    ::google::protobuf::io::CodedOutputStream* output) const {
  // @@protoc_insertion_point(serialize_start:mw.internal.robotics.gazebotransport.SetLinkWorldPose)
  // required string model_name = 1;
  if (has_model_name()) {
    ::google::protobuf::internal::WireFormat::VerifyUTF8StringNamedField(
      this->model_name().data(), this->model_name().length(),
      ::google::protobuf::internal::WireFormat::SERIALIZE,
      "mw.internal.robotics.gazebotransport.SetLinkWorldPose.model_name");
    ::google::protobuf::internal::WireFormatLite::WriteStringMaybeAliased(
      1, this->model_name(), output);
  }

  // required string link_name = 2;
  if (has_link_name()) {
    ::google::protobuf::internal::WireFormat::VerifyUTF8StringNamedField(
      this->link_name().data(), this->link_name().length(),
      ::google::protobuf::internal::WireFormat::SERIALIZE,
      "mw.internal.robotics.gazebotransport.SetLinkWorldPose.link_name");
    ::google::protobuf::internal::WireFormatLite::WriteStringMaybeAliased(
      2, this->link_name(), output);
  }

  // required .mw.internal.robotics.gazebotransport.Pose pose = 3;
  if (has_pose()) {
    ::google::protobuf::internal::WireFormatLite::WriteMessageMaybeToArray(
      3, *this->pose_, output);
  }

  // required .mw.internal.robotics.gazebotransport.Time duration = 4;
  if (has_duration()) {
    ::google::protobuf::internal::WireFormatLite::WriteMessageMaybeToArray(
      4, *this->duration_, output);
  }

  if (_internal_metadata_.have_unknown_fields()) {
    ::google::protobuf::internal::WireFormat::SerializeUnknownFields(
        unknown_fields(), output);
  }
  // @@protoc_insertion_point(serialize_end:mw.internal.robotics.gazebotransport.SetLinkWorldPose)
}

::google::protobuf::uint8* SetLinkWorldPose::InternalSerializeWithCachedSizesToArray(
    bool deterministic, ::google::protobuf::uint8* target) const {
  // @@protoc_insertion_point(serialize_to_array_start:mw.internal.robotics.gazebotransport.SetLinkWorldPose)
  // required string model_name = 1;
  if (has_model_name()) {
    ::google::protobuf::internal::WireFormat::VerifyUTF8StringNamedField(
      this->model_name().data(), this->model_name().length(),
      ::google::protobuf::internal::WireFormat::SERIALIZE,
      "mw.internal.robotics.gazebotransport.SetLinkWorldPose.model_name");
    target =
      ::google::protobuf::internal::WireFormatLite::WriteStringToArray(
        1, this->model_name(), target);
  }

  // required string link_name = 2;
  if (has_link_name()) {
    ::google::protobuf::internal::WireFormat::VerifyUTF8StringNamedField(
      this->link_name().data(), this->link_name().length(),
      ::google::protobuf::internal::WireFormat::SERIALIZE,
      "mw.internal.robotics.gazebotransport.SetLinkWorldPose.link_name");
    target =
      ::google::protobuf::internal::WireFormatLite::WriteStringToArray(
        2, this->link_name(), target);
  }

  // required .mw.internal.robotics.gazebotransport.Pose pose = 3;
  if (has_pose()) {
    target = ::google::protobuf::internal::WireFormatLite::
      InternalWriteMessageNoVirtualToArray(
        3, *this->pose_, false, target);
  }

  // required .mw.internal.robotics.gazebotransport.Time duration = 4;
  if (has_duration()) {
    target = ::google::protobuf::internal::WireFormatLite::
      InternalWriteMessageNoVirtualToArray(
        4, *this->duration_, false, target);
  }

  if (_internal_metadata_.have_unknown_fields()) {
    target = ::google::protobuf::internal::WireFormat::SerializeUnknownFieldsToArray(
        unknown_fields(), target);
  }
  // @@protoc_insertion_point(serialize_to_array_end:mw.internal.robotics.gazebotransport.SetLinkWorldPose)
  return target;
}

int SetLinkWorldPose::RequiredFieldsByteSizeFallback() const {
// @@protoc_insertion_point(required_fields_byte_size_fallback_start:mw.internal.robotics.gazebotransport.SetLinkWorldPose)
  int total_size = 0;

  if (has_model_name()) {
    // required string model_name = 1;
    total_size += 1 +
      ::google::protobuf::internal::WireFormatLite::StringSize(
        this->model_name());
  }

  if (has_link_name()) {
    // required string link_name = 2;
    total_size += 1 +
      ::google::protobuf::internal::WireFormatLite::StringSize(
        this->link_name());
  }

  if (has_pose()) {
    // required .mw.internal.robotics.gazebotransport.Pose pose = 3;
    total_size += 1 +
      ::google::protobuf::internal::WireFormatLite::MessageSizeNoVirtual(
        *this->pose_);
  }

  if (has_duration()) {
    // required .mw.internal.robotics.gazebotransport.Time duration = 4;
    total_size += 1 +
      ::google::protobuf::internal::WireFormatLite::MessageSizeNoVirtual(
        *this->duration_);
  }

  return total_size;
}
int SetLinkWorldPose::ByteSize() const {
// @@protoc_insertion_point(message_byte_size_start:mw.internal.robotics.gazebotransport.SetLinkWorldPose)
  int total_size = 0;

  if (((_has_bits_[0] & 0x0000000f) ^ 0x0000000f) == 0) {  // All required fields are present.
    // required string model_name = 1;
    total_size += 1 +
      ::google::protobuf::internal::WireFormatLite::StringSize(
        this->model_name());

    // required string link_name = 2;
    total_size += 1 +
      ::google::protobuf::internal::WireFormatLite::StringSize(
        this->link_name());

    // required .mw.internal.robotics.gazebotransport.Pose pose = 3;
    total_size += 1 +
      ::google::protobuf::internal::WireFormatLite::MessageSizeNoVirtual(
        *this->pose_);

    // required .mw.internal.robotics.gazebotransport.Time duration = 4;
    total_size += 1 +
      ::google::protobuf::internal::WireFormatLite::MessageSizeNoVirtual(
        *this->duration_);

  } else {
    total_size += RequiredFieldsByteSizeFallback();
  }
  if (_internal_metadata_.have_unknown_fields()) {
    total_size +=
      ::google::protobuf::internal::WireFormat::ComputeUnknownFieldsSize(
        unknown_fields());
  }
  GOOGLE_SAFE_CONCURRENT_WRITES_BEGIN();
  _cached_size_ = total_size;
  GOOGLE_SAFE_CONCURRENT_WRITES_END();
  return total_size;
}

void SetLinkWorldPose::MergeFrom(const ::google::protobuf::Message& from) {
// @@protoc_insertion_point(generalized_merge_from_start:mw.internal.robotics.gazebotransport.SetLinkWorldPose)
  if (GOOGLE_PREDICT_FALSE(&from == this)) {
    ::google::protobuf::internal::MergeFromFail(__FILE__, __LINE__);
  }
  const SetLinkWorldPose* source = 
      ::google::protobuf::internal::DynamicCastToGenerated<const SetLinkWorldPose>(
          &from);
  if (source == NULL) {
  // @@protoc_insertion_point(generalized_merge_from_cast_fail:mw.internal.robotics.gazebotransport.SetLinkWorldPose)
    ::google::protobuf::internal::ReflectionOps::Merge(from, this);
  } else {
  // @@protoc_insertion_point(generalized_merge_from_cast_success:mw.internal.robotics.gazebotransport.SetLinkWorldPose)
    MergeFrom(*source);
  }
}

void SetLinkWorldPose::MergeFrom(const SetLinkWorldPose& from) {
// @@protoc_insertion_point(class_specific_merge_from_start:mw.internal.robotics.gazebotransport.SetLinkWorldPose)
  if (GOOGLE_PREDICT_FALSE(&from == this)) {
    ::google::protobuf::internal::MergeFromFail(__FILE__, __LINE__);
  }
  if (from._has_bits_[0 / 32] & (0xffu << (0 % 32))) {
    if (from.has_model_name()) {
      set_has_model_name();
      model_name_.AssignWithDefault(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), from.model_name_);
    }
    if (from.has_link_name()) {
      set_has_link_name();
      link_name_.AssignWithDefault(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), from.link_name_);
    }
    if (from.has_pose()) {
      mutable_pose()->::mw::internal::robotics::gazebotransport::Pose::MergeFrom(from.pose());
    }
    if (from.has_duration()) {
      mutable_duration()->::mw::internal::robotics::gazebotransport::Time::MergeFrom(from.duration());
    }
  }
  if (from._internal_metadata_.have_unknown_fields()) {
    mutable_unknown_fields()->MergeFrom(from.unknown_fields());
  }
}

void SetLinkWorldPose::CopyFrom(const ::google::protobuf::Message& from) {
// @@protoc_insertion_point(generalized_copy_from_start:mw.internal.robotics.gazebotransport.SetLinkWorldPose)
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

void SetLinkWorldPose::CopyFrom(const SetLinkWorldPose& from) {
// @@protoc_insertion_point(class_specific_copy_from_start:mw.internal.robotics.gazebotransport.SetLinkWorldPose)
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

bool SetLinkWorldPose::IsInitialized() const {
  if ((_has_bits_[0] & 0x0000000f) != 0x0000000f) return false;

  if (has_pose()) {
    if (!this->pose_->IsInitialized()) return false;
  }
  if (has_duration()) {
    if (!this->duration_->IsInitialized()) return false;
  }
  return true;
}

void SetLinkWorldPose::Swap(SetLinkWorldPose* other) {
  if (other == this) return;
  InternalSwap(other);
}
void SetLinkWorldPose::InternalSwap(SetLinkWorldPose* other) {
  model_name_.Swap(&other->model_name_);
  link_name_.Swap(&other->link_name_);
  std::swap(pose_, other->pose_);
  std::swap(duration_, other->duration_);
  std::swap(_has_bits_[0], other->_has_bits_[0]);
  _internal_metadata_.Swap(&other->_internal_metadata_);
  std::swap(_cached_size_, other->_cached_size_);
}

::google::protobuf::Metadata SetLinkWorldPose::GetMetadata() const {
  protobuf_AssignDescriptorsOnce();
  ::google::protobuf::Metadata metadata;
  metadata.descriptor = SetLinkWorldPose_descriptor_;
  metadata.reflection = SetLinkWorldPose_reflection_;
  return metadata;
}

#if PROTOBUF_INLINE_NOT_IN_HEADERS
// SetLinkWorldPose

// required string model_name = 1;
bool SetLinkWorldPose::has_model_name() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
void SetLinkWorldPose::set_has_model_name() {
  _has_bits_[0] |= 0x00000001u;
}
void SetLinkWorldPose::clear_has_model_name() {
  _has_bits_[0] &= ~0x00000001u;
}
void SetLinkWorldPose::clear_model_name() {
  model_name_.ClearToEmptyNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
  clear_has_model_name();
}
 const ::std::string& SetLinkWorldPose::model_name() const {
  // @@protoc_insertion_point(field_get:mw.internal.robotics.gazebotransport.SetLinkWorldPose.model_name)
  return model_name_.GetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
 void SetLinkWorldPose::set_model_name(const ::std::string& value) {
  set_has_model_name();
  model_name_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), value);
  // @@protoc_insertion_point(field_set:mw.internal.robotics.gazebotransport.SetLinkWorldPose.model_name)
}
 void SetLinkWorldPose::set_model_name(const char* value) {
  set_has_model_name();
  model_name_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::string(value));
  // @@protoc_insertion_point(field_set_char:mw.internal.robotics.gazebotransport.SetLinkWorldPose.model_name)
}
 void SetLinkWorldPose::set_model_name(const char* value, size_t size) {
  set_has_model_name();
  model_name_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(),
      ::std::string(reinterpret_cast<const char*>(value), size));
  // @@protoc_insertion_point(field_set_pointer:mw.internal.robotics.gazebotransport.SetLinkWorldPose.model_name)
}
 ::std::string* SetLinkWorldPose::mutable_model_name() {
  set_has_model_name();
  // @@protoc_insertion_point(field_mutable:mw.internal.robotics.gazebotransport.SetLinkWorldPose.model_name)
  return model_name_.MutableNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
 ::std::string* SetLinkWorldPose::release_model_name() {
  // @@protoc_insertion_point(field_release:mw.internal.robotics.gazebotransport.SetLinkWorldPose.model_name)
  clear_has_model_name();
  return model_name_.ReleaseNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
 void SetLinkWorldPose::set_allocated_model_name(::std::string* model_name) {
  if (model_name != NULL) {
    set_has_model_name();
  } else {
    clear_has_model_name();
  }
  model_name_.SetAllocatedNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), model_name);
  // @@protoc_insertion_point(field_set_allocated:mw.internal.robotics.gazebotransport.SetLinkWorldPose.model_name)
}

// required string link_name = 2;
bool SetLinkWorldPose::has_link_name() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
void SetLinkWorldPose::set_has_link_name() {
  _has_bits_[0] |= 0x00000002u;
}
void SetLinkWorldPose::clear_has_link_name() {
  _has_bits_[0] &= ~0x00000002u;
}
void SetLinkWorldPose::clear_link_name() {
  link_name_.ClearToEmptyNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
  clear_has_link_name();
}
 const ::std::string& SetLinkWorldPose::link_name() const {
  // @@protoc_insertion_point(field_get:mw.internal.robotics.gazebotransport.SetLinkWorldPose.link_name)
  return link_name_.GetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
 void SetLinkWorldPose::set_link_name(const ::std::string& value) {
  set_has_link_name();
  link_name_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), value);
  // @@protoc_insertion_point(field_set:mw.internal.robotics.gazebotransport.SetLinkWorldPose.link_name)
}
 void SetLinkWorldPose::set_link_name(const char* value) {
  set_has_link_name();
  link_name_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::string(value));
  // @@protoc_insertion_point(field_set_char:mw.internal.robotics.gazebotransport.SetLinkWorldPose.link_name)
}
 void SetLinkWorldPose::set_link_name(const char* value, size_t size) {
  set_has_link_name();
  link_name_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(),
      ::std::string(reinterpret_cast<const char*>(value), size));
  // @@protoc_insertion_point(field_set_pointer:mw.internal.robotics.gazebotransport.SetLinkWorldPose.link_name)
}
 ::std::string* SetLinkWorldPose::mutable_link_name() {
  set_has_link_name();
  // @@protoc_insertion_point(field_mutable:mw.internal.robotics.gazebotransport.SetLinkWorldPose.link_name)
  return link_name_.MutableNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
 ::std::string* SetLinkWorldPose::release_link_name() {
  // @@protoc_insertion_point(field_release:mw.internal.robotics.gazebotransport.SetLinkWorldPose.link_name)
  clear_has_link_name();
  return link_name_.ReleaseNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
 void SetLinkWorldPose::set_allocated_link_name(::std::string* link_name) {
  if (link_name != NULL) {
    set_has_link_name();
  } else {
    clear_has_link_name();
  }
  link_name_.SetAllocatedNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), link_name);
  // @@protoc_insertion_point(field_set_allocated:mw.internal.robotics.gazebotransport.SetLinkWorldPose.link_name)
}

// required .mw.internal.robotics.gazebotransport.Pose pose = 3;
bool SetLinkWorldPose::has_pose() const {
  return (_has_bits_[0] & 0x00000004u) != 0;
}
void SetLinkWorldPose::set_has_pose() {
  _has_bits_[0] |= 0x00000004u;
}
void SetLinkWorldPose::clear_has_pose() {
  _has_bits_[0] &= ~0x00000004u;
}
void SetLinkWorldPose::clear_pose() {
  if (pose_ != NULL) pose_->::mw::internal::robotics::gazebotransport::Pose::Clear();
  clear_has_pose();
}
const ::mw::internal::robotics::gazebotransport::Pose& SetLinkWorldPose::pose() const {
  // @@protoc_insertion_point(field_get:mw.internal.robotics.gazebotransport.SetLinkWorldPose.pose)
  return pose_ != NULL ? *pose_ : *default_instance_->pose_;
}
::mw::internal::robotics::gazebotransport::Pose* SetLinkWorldPose::mutable_pose() {
  set_has_pose();
  if (pose_ == NULL) {
    pose_ = new ::mw::internal::robotics::gazebotransport::Pose;
  }
  // @@protoc_insertion_point(field_mutable:mw.internal.robotics.gazebotransport.SetLinkWorldPose.pose)
  return pose_;
}
::mw::internal::robotics::gazebotransport::Pose* SetLinkWorldPose::release_pose() {
  // @@protoc_insertion_point(field_release:mw.internal.robotics.gazebotransport.SetLinkWorldPose.pose)
  clear_has_pose();
  ::mw::internal::robotics::gazebotransport::Pose* temp = pose_;
  pose_ = NULL;
  return temp;
}
void SetLinkWorldPose::set_allocated_pose(::mw::internal::robotics::gazebotransport::Pose* pose) {
  delete pose_;
  pose_ = pose;
  if (pose) {
    set_has_pose();
  } else {
    clear_has_pose();
  }
  // @@protoc_insertion_point(field_set_allocated:mw.internal.robotics.gazebotransport.SetLinkWorldPose.pose)
}

// required .mw.internal.robotics.gazebotransport.Time duration = 4;
bool SetLinkWorldPose::has_duration() const {
  return (_has_bits_[0] & 0x00000008u) != 0;
}
void SetLinkWorldPose::set_has_duration() {
  _has_bits_[0] |= 0x00000008u;
}
void SetLinkWorldPose::clear_has_duration() {
  _has_bits_[0] &= ~0x00000008u;
}
void SetLinkWorldPose::clear_duration() {
  if (duration_ != NULL) duration_->::mw::internal::robotics::gazebotransport::Time::Clear();
  clear_has_duration();
}
const ::mw::internal::robotics::gazebotransport::Time& SetLinkWorldPose::duration() const {
  // @@protoc_insertion_point(field_get:mw.internal.robotics.gazebotransport.SetLinkWorldPose.duration)
  return duration_ != NULL ? *duration_ : *default_instance_->duration_;
}
::mw::internal::robotics::gazebotransport::Time* SetLinkWorldPose::mutable_duration() {
  set_has_duration();
  if (duration_ == NULL) {
    duration_ = new ::mw::internal::robotics::gazebotransport::Time;
  }
  // @@protoc_insertion_point(field_mutable:mw.internal.robotics.gazebotransport.SetLinkWorldPose.duration)
  return duration_;
}
::mw::internal::robotics::gazebotransport::Time* SetLinkWorldPose::release_duration() {
  // @@protoc_insertion_point(field_release:mw.internal.robotics.gazebotransport.SetLinkWorldPose.duration)
  clear_has_duration();
  ::mw::internal::robotics::gazebotransport::Time* temp = duration_;
  duration_ = NULL;
  return temp;
}
void SetLinkWorldPose::set_allocated_duration(::mw::internal::robotics::gazebotransport::Time* duration) {
  delete duration_;
  duration_ = duration;
  if (duration) {
    set_has_duration();
  } else {
    clear_has_duration();
  }
  // @@protoc_insertion_point(field_set_allocated:mw.internal.robotics.gazebotransport.SetLinkWorldPose.duration)
}

#endif  // PROTOBUF_INLINE_NOT_IN_HEADERS

// ===================================================================

#if !defined(_MSC_VER) || _MSC_VER >= 1900
const int SetLinkLinearVelocity::kModelNameFieldNumber;
const int SetLinkLinearVelocity::kLinkNameFieldNumber;
const int SetLinkLinearVelocity::kVelocityFieldNumber;
const int SetLinkLinearVelocity::kDurationFieldNumber;
#endif  // !defined(_MSC_VER) || _MSC_VER >= 1900

SetLinkLinearVelocity::SetLinkLinearVelocity()
  : ::google::protobuf::Message(), _internal_metadata_(NULL) {
  SharedCtor();
  // @@protoc_insertion_point(constructor:mw.internal.robotics.gazebotransport.SetLinkLinearVelocity)
}

void SetLinkLinearVelocity::InitAsDefaultInstance() {
  velocity_ = const_cast< ::mw::internal::robotics::gazebotransport::Point*>(&::mw::internal::robotics::gazebotransport::Point::default_instance());
  duration_ = const_cast< ::mw::internal::robotics::gazebotransport::Time*>(&::mw::internal::robotics::gazebotransport::Time::default_instance());
}

SetLinkLinearVelocity::SetLinkLinearVelocity(const SetLinkLinearVelocity& from)
  : ::google::protobuf::Message(),
    _internal_metadata_(NULL) {
  SharedCtor();
  MergeFrom(from);
  // @@protoc_insertion_point(copy_constructor:mw.internal.robotics.gazebotransport.SetLinkLinearVelocity)
}

void SetLinkLinearVelocity::SharedCtor() {
  ::google::protobuf::internal::GetEmptyString();
  _cached_size_ = 0;
  model_name_.UnsafeSetDefault(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
  link_name_.UnsafeSetDefault(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
  velocity_ = NULL;
  duration_ = NULL;
  ::memset(_has_bits_, 0, sizeof(_has_bits_));
}

SetLinkLinearVelocity::~SetLinkLinearVelocity() {
  // @@protoc_insertion_point(destructor:mw.internal.robotics.gazebotransport.SetLinkLinearVelocity)
  SharedDtor();
}

void SetLinkLinearVelocity::SharedDtor() {
  model_name_.DestroyNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
  link_name_.DestroyNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
  if (this != default_instance_) {
    delete velocity_;
    delete duration_;
  }
}

void SetLinkLinearVelocity::SetCachedSize(int size) const {
  GOOGLE_SAFE_CONCURRENT_WRITES_BEGIN();
  _cached_size_ = size;
  GOOGLE_SAFE_CONCURRENT_WRITES_END();
}
const ::google::protobuf::Descriptor* SetLinkLinearVelocity::descriptor() {
  protobuf_AssignDescriptorsOnce();
  return SetLinkLinearVelocity_descriptor_;
}

const SetLinkLinearVelocity& SetLinkLinearVelocity::default_instance() {
  if (default_instance_ == NULL) protobuf_AddDesc_mw_2einternal_2erobotics_2egazebotransport_2eCoSimMsgs_2eproto();
  return *default_instance_;
}

SetLinkLinearVelocity* SetLinkLinearVelocity::default_instance_ = NULL;

SetLinkLinearVelocity* SetLinkLinearVelocity::New(::google::protobuf::Arena* arena) const {
  SetLinkLinearVelocity* n = new SetLinkLinearVelocity;
  if (arena != NULL) {
    arena->Own(n);
  }
  return n;
}

void SetLinkLinearVelocity::Clear() {
// @@protoc_insertion_point(message_clear_start:mw.internal.robotics.gazebotransport.SetLinkLinearVelocity)
  if (_has_bits_[0 / 32] & 15u) {
    if (has_model_name()) {
      model_name_.ClearToEmptyNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
    }
    if (has_link_name()) {
      link_name_.ClearToEmptyNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
    }
    if (has_velocity()) {
      if (velocity_ != NULL) velocity_->::mw::internal::robotics::gazebotransport::Point::Clear();
    }
    if (has_duration()) {
      if (duration_ != NULL) duration_->::mw::internal::robotics::gazebotransport::Time::Clear();
    }
  }
  ::memset(_has_bits_, 0, sizeof(_has_bits_));
  if (_internal_metadata_.have_unknown_fields()) {
    mutable_unknown_fields()->Clear();
  }
}

bool SetLinkLinearVelocity::MergePartialFromCodedStream(
    ::google::protobuf::io::CodedInputStream* input) {
#define DO_(EXPRESSION) if (!GOOGLE_PREDICT_TRUE(EXPRESSION)) goto failure
  ::google::protobuf::uint32 tag;
  // @@protoc_insertion_point(parse_start:mw.internal.robotics.gazebotransport.SetLinkLinearVelocity)
  for (;;) {
    ::std::pair< ::google::protobuf::uint32, bool> p = input->ReadTagWithCutoff(127);
    tag = p.first;
    if (!p.second) goto handle_unusual;
    switch (::google::protobuf::internal::WireFormatLite::GetTagFieldNumber(tag)) {
      // required string model_name = 1;
      case 1: {
        if (tag == 10) {
          DO_(::google::protobuf::internal::WireFormatLite::ReadString(
                input, this->mutable_model_name()));
          ::google::protobuf::internal::WireFormat::VerifyUTF8StringNamedField(
            this->model_name().data(), this->model_name().length(),
            ::google::protobuf::internal::WireFormat::PARSE,
            "mw.internal.robotics.gazebotransport.SetLinkLinearVelocity.model_name");
        } else {
          goto handle_unusual;
        }
        if (input->ExpectTag(18)) goto parse_link_name;
        break;
      }

      // required string link_name = 2;
      case 2: {
        if (tag == 18) {
         parse_link_name:
          DO_(::google::protobuf::internal::WireFormatLite::ReadString(
                input, this->mutable_link_name()));
          ::google::protobuf::internal::WireFormat::VerifyUTF8StringNamedField(
            this->link_name().data(), this->link_name().length(),
            ::google::protobuf::internal::WireFormat::PARSE,
            "mw.internal.robotics.gazebotransport.SetLinkLinearVelocity.link_name");
        } else {
          goto handle_unusual;
        }
        if (input->ExpectTag(26)) goto parse_velocity;
        break;
      }

      // required .mw.internal.robotics.gazebotransport.Point velocity = 3;
      case 3: {
        if (tag == 26) {
         parse_velocity:
          DO_(::google::protobuf::internal::WireFormatLite::ReadMessageNoVirtual(
               input, mutable_velocity()));
        } else {
          goto handle_unusual;
        }
        if (input->ExpectTag(34)) goto parse_duration;
        break;
      }

      // required .mw.internal.robotics.gazebotransport.Time duration = 4;
      case 4: {
        if (tag == 34) {
         parse_duration:
          DO_(::google::protobuf::internal::WireFormatLite::ReadMessageNoVirtual(
               input, mutable_duration()));
        } else {
          goto handle_unusual;
        }
        if (input->ExpectAtEnd()) goto success;
        break;
      }

      default: {
      handle_unusual:
        if (tag == 0 ||
            ::google::protobuf::internal::WireFormatLite::GetTagWireType(tag) ==
            ::google::protobuf::internal::WireFormatLite::WIRETYPE_END_GROUP) {
          goto success;
        }
        DO_(::google::protobuf::internal::WireFormat::SkipField(
              input, tag, mutable_unknown_fields()));
        break;
      }
    }
  }
success:
  // @@protoc_insertion_point(parse_success:mw.internal.robotics.gazebotransport.SetLinkLinearVelocity)
  return true;
failure:
  // @@protoc_insertion_point(parse_failure:mw.internal.robotics.gazebotransport.SetLinkLinearVelocity)
  return false;
#undef DO_
}

void SetLinkLinearVelocity::SerializeWithCachedSizes(
    ::google::protobuf::io::CodedOutputStream* output) const {
  // @@protoc_insertion_point(serialize_start:mw.internal.robotics.gazebotransport.SetLinkLinearVelocity)
  // required string model_name = 1;
  if (has_model_name()) {
    ::google::protobuf::internal::WireFormat::VerifyUTF8StringNamedField(
      this->model_name().data(), this->model_name().length(),
      ::google::protobuf::internal::WireFormat::SERIALIZE,
      "mw.internal.robotics.gazebotransport.SetLinkLinearVelocity.model_name");
    ::google::protobuf::internal::WireFormatLite::WriteStringMaybeAliased(
      1, this->model_name(), output);
  }

  // required string link_name = 2;
  if (has_link_name()) {
    ::google::protobuf::internal::WireFormat::VerifyUTF8StringNamedField(
      this->link_name().data(), this->link_name().length(),
      ::google::protobuf::internal::WireFormat::SERIALIZE,
      "mw.internal.robotics.gazebotransport.SetLinkLinearVelocity.link_name");
    ::google::protobuf::internal::WireFormatLite::WriteStringMaybeAliased(
      2, this->link_name(), output);
  }

  // required .mw.internal.robotics.gazebotransport.Point velocity = 3;
  if (has_velocity()) {
    ::google::protobuf::internal::WireFormatLite::WriteMessageMaybeToArray(
      3, *this->velocity_, output);
  }

  // required .mw.internal.robotics.gazebotransport.Time duration = 4;
  if (has_duration()) {
    ::google::protobuf::internal::WireFormatLite::WriteMessageMaybeToArray(
      4, *this->duration_, output);
  }

  if (_internal_metadata_.have_unknown_fields()) {
    ::google::protobuf::internal::WireFormat::SerializeUnknownFields(
        unknown_fields(), output);
  }
  // @@protoc_insertion_point(serialize_end:mw.internal.robotics.gazebotransport.SetLinkLinearVelocity)
}

::google::protobuf::uint8* SetLinkLinearVelocity::InternalSerializeWithCachedSizesToArray(
    bool deterministic, ::google::protobuf::uint8* target) const {
  // @@protoc_insertion_point(serialize_to_array_start:mw.internal.robotics.gazebotransport.SetLinkLinearVelocity)
  // required string model_name = 1;
  if (has_model_name()) {
    ::google::protobuf::internal::WireFormat::VerifyUTF8StringNamedField(
      this->model_name().data(), this->model_name().length(),
      ::google::protobuf::internal::WireFormat::SERIALIZE,
      "mw.internal.robotics.gazebotransport.SetLinkLinearVelocity.model_name");
    target =
      ::google::protobuf::internal::WireFormatLite::WriteStringToArray(
        1, this->model_name(), target);
  }

  // required string link_name = 2;
  if (has_link_name()) {
    ::google::protobuf::internal::WireFormat::VerifyUTF8StringNamedField(
      this->link_name().data(), this->link_name().length(),
      ::google::protobuf::internal::WireFormat::SERIALIZE,
      "mw.internal.robotics.gazebotransport.SetLinkLinearVelocity.link_name");
    target =
      ::google::protobuf::internal::WireFormatLite::WriteStringToArray(
        2, this->link_name(), target);
  }

  // required .mw.internal.robotics.gazebotransport.Point velocity = 3;
  if (has_velocity()) {
    target = ::google::protobuf::internal::WireFormatLite::
      InternalWriteMessageNoVirtualToArray(
        3, *this->velocity_, false, target);
  }

  // required .mw.internal.robotics.gazebotransport.Time duration = 4;
  if (has_duration()) {
    target = ::google::protobuf::internal::WireFormatLite::
      InternalWriteMessageNoVirtualToArray(
        4, *this->duration_, false, target);
  }

  if (_internal_metadata_.have_unknown_fields()) {
    target = ::google::protobuf::internal::WireFormat::SerializeUnknownFieldsToArray(
        unknown_fields(), target);
  }
  // @@protoc_insertion_point(serialize_to_array_end:mw.internal.robotics.gazebotransport.SetLinkLinearVelocity)
  return target;
}

int SetLinkLinearVelocity::RequiredFieldsByteSizeFallback() const {
// @@protoc_insertion_point(required_fields_byte_size_fallback_start:mw.internal.robotics.gazebotransport.SetLinkLinearVelocity)
  int total_size = 0;

  if (has_model_name()) {
    // required string model_name = 1;
    total_size += 1 +
      ::google::protobuf::internal::WireFormatLite::StringSize(
        this->model_name());
  }

  if (has_link_name()) {
    // required string link_name = 2;
    total_size += 1 +
      ::google::protobuf::internal::WireFormatLite::StringSize(
        this->link_name());
  }

  if (has_velocity()) {
    // required .mw.internal.robotics.gazebotransport.Point velocity = 3;
    total_size += 1 +
      ::google::protobuf::internal::WireFormatLite::MessageSizeNoVirtual(
        *this->velocity_);
  }

  if (has_duration()) {
    // required .mw.internal.robotics.gazebotransport.Time duration = 4;
    total_size += 1 +
      ::google::protobuf::internal::WireFormatLite::MessageSizeNoVirtual(
        *this->duration_);
  }

  return total_size;
}
int SetLinkLinearVelocity::ByteSize() const {
// @@protoc_insertion_point(message_byte_size_start:mw.internal.robotics.gazebotransport.SetLinkLinearVelocity)
  int total_size = 0;

  if (((_has_bits_[0] & 0x0000000f) ^ 0x0000000f) == 0) {  // All required fields are present.
    // required string model_name = 1;
    total_size += 1 +
      ::google::protobuf::internal::WireFormatLite::StringSize(
        this->model_name());

    // required string link_name = 2;
    total_size += 1 +
      ::google::protobuf::internal::WireFormatLite::StringSize(
        this->link_name());

    // required .mw.internal.robotics.gazebotransport.Point velocity = 3;
    total_size += 1 +
      ::google::protobuf::internal::WireFormatLite::MessageSizeNoVirtual(
        *this->velocity_);

    // required .mw.internal.robotics.gazebotransport.Time duration = 4;
    total_size += 1 +
      ::google::protobuf::internal::WireFormatLite::MessageSizeNoVirtual(
        *this->duration_);

  } else {
    total_size += RequiredFieldsByteSizeFallback();
  }
  if (_internal_metadata_.have_unknown_fields()) {
    total_size +=
      ::google::protobuf::internal::WireFormat::ComputeUnknownFieldsSize(
        unknown_fields());
  }
  GOOGLE_SAFE_CONCURRENT_WRITES_BEGIN();
  _cached_size_ = total_size;
  GOOGLE_SAFE_CONCURRENT_WRITES_END();
  return total_size;
}

void SetLinkLinearVelocity::MergeFrom(const ::google::protobuf::Message& from) {
// @@protoc_insertion_point(generalized_merge_from_start:mw.internal.robotics.gazebotransport.SetLinkLinearVelocity)
  if (GOOGLE_PREDICT_FALSE(&from == this)) {
    ::google::protobuf::internal::MergeFromFail(__FILE__, __LINE__);
  }
  const SetLinkLinearVelocity* source = 
      ::google::protobuf::internal::DynamicCastToGenerated<const SetLinkLinearVelocity>(
          &from);
  if (source == NULL) {
  // @@protoc_insertion_point(generalized_merge_from_cast_fail:mw.internal.robotics.gazebotransport.SetLinkLinearVelocity)
    ::google::protobuf::internal::ReflectionOps::Merge(from, this);
  } else {
  // @@protoc_insertion_point(generalized_merge_from_cast_success:mw.internal.robotics.gazebotransport.SetLinkLinearVelocity)
    MergeFrom(*source);
  }
}

void SetLinkLinearVelocity::MergeFrom(const SetLinkLinearVelocity& from) {
// @@protoc_insertion_point(class_specific_merge_from_start:mw.internal.robotics.gazebotransport.SetLinkLinearVelocity)
  if (GOOGLE_PREDICT_FALSE(&from == this)) {
    ::google::protobuf::internal::MergeFromFail(__FILE__, __LINE__);
  }
  if (from._has_bits_[0 / 32] & (0xffu << (0 % 32))) {
    if (from.has_model_name()) {
      set_has_model_name();
      model_name_.AssignWithDefault(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), from.model_name_);
    }
    if (from.has_link_name()) {
      set_has_link_name();
      link_name_.AssignWithDefault(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), from.link_name_);
    }
    if (from.has_velocity()) {
      mutable_velocity()->::mw::internal::robotics::gazebotransport::Point::MergeFrom(from.velocity());
    }
    if (from.has_duration()) {
      mutable_duration()->::mw::internal::robotics::gazebotransport::Time::MergeFrom(from.duration());
    }
  }
  if (from._internal_metadata_.have_unknown_fields()) {
    mutable_unknown_fields()->MergeFrom(from.unknown_fields());
  }
}

void SetLinkLinearVelocity::CopyFrom(const ::google::protobuf::Message& from) {
// @@protoc_insertion_point(generalized_copy_from_start:mw.internal.robotics.gazebotransport.SetLinkLinearVelocity)
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

void SetLinkLinearVelocity::CopyFrom(const SetLinkLinearVelocity& from) {
// @@protoc_insertion_point(class_specific_copy_from_start:mw.internal.robotics.gazebotransport.SetLinkLinearVelocity)
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

bool SetLinkLinearVelocity::IsInitialized() const {
  if ((_has_bits_[0] & 0x0000000f) != 0x0000000f) return false;

  if (has_velocity()) {
    if (!this->velocity_->IsInitialized()) return false;
  }
  if (has_duration()) {
    if (!this->duration_->IsInitialized()) return false;
  }
  return true;
}

void SetLinkLinearVelocity::Swap(SetLinkLinearVelocity* other) {
  if (other == this) return;
  InternalSwap(other);
}
void SetLinkLinearVelocity::InternalSwap(SetLinkLinearVelocity* other) {
  model_name_.Swap(&other->model_name_);
  link_name_.Swap(&other->link_name_);
  std::swap(velocity_, other->velocity_);
  std::swap(duration_, other->duration_);
  std::swap(_has_bits_[0], other->_has_bits_[0]);
  _internal_metadata_.Swap(&other->_internal_metadata_);
  std::swap(_cached_size_, other->_cached_size_);
}

::google::protobuf::Metadata SetLinkLinearVelocity::GetMetadata() const {
  protobuf_AssignDescriptorsOnce();
  ::google::protobuf::Metadata metadata;
  metadata.descriptor = SetLinkLinearVelocity_descriptor_;
  metadata.reflection = SetLinkLinearVelocity_reflection_;
  return metadata;
}

#if PROTOBUF_INLINE_NOT_IN_HEADERS
// SetLinkLinearVelocity

// required string model_name = 1;
bool SetLinkLinearVelocity::has_model_name() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
void SetLinkLinearVelocity::set_has_model_name() {
  _has_bits_[0] |= 0x00000001u;
}
void SetLinkLinearVelocity::clear_has_model_name() {
  _has_bits_[0] &= ~0x00000001u;
}
void SetLinkLinearVelocity::clear_model_name() {
  model_name_.ClearToEmptyNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
  clear_has_model_name();
}
 const ::std::string& SetLinkLinearVelocity::model_name() const {
  // @@protoc_insertion_point(field_get:mw.internal.robotics.gazebotransport.SetLinkLinearVelocity.model_name)
  return model_name_.GetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
 void SetLinkLinearVelocity::set_model_name(const ::std::string& value) {
  set_has_model_name();
  model_name_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), value);
  // @@protoc_insertion_point(field_set:mw.internal.robotics.gazebotransport.SetLinkLinearVelocity.model_name)
}
 void SetLinkLinearVelocity::set_model_name(const char* value) {
  set_has_model_name();
  model_name_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::string(value));
  // @@protoc_insertion_point(field_set_char:mw.internal.robotics.gazebotransport.SetLinkLinearVelocity.model_name)
}
 void SetLinkLinearVelocity::set_model_name(const char* value, size_t size) {
  set_has_model_name();
  model_name_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(),
      ::std::string(reinterpret_cast<const char*>(value), size));
  // @@protoc_insertion_point(field_set_pointer:mw.internal.robotics.gazebotransport.SetLinkLinearVelocity.model_name)
}
 ::std::string* SetLinkLinearVelocity::mutable_model_name() {
  set_has_model_name();
  // @@protoc_insertion_point(field_mutable:mw.internal.robotics.gazebotransport.SetLinkLinearVelocity.model_name)
  return model_name_.MutableNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
 ::std::string* SetLinkLinearVelocity::release_model_name() {
  // @@protoc_insertion_point(field_release:mw.internal.robotics.gazebotransport.SetLinkLinearVelocity.model_name)
  clear_has_model_name();
  return model_name_.ReleaseNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
 void SetLinkLinearVelocity::set_allocated_model_name(::std::string* model_name) {
  if (model_name != NULL) {
    set_has_model_name();
  } else {
    clear_has_model_name();
  }
  model_name_.SetAllocatedNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), model_name);
  // @@protoc_insertion_point(field_set_allocated:mw.internal.robotics.gazebotransport.SetLinkLinearVelocity.model_name)
}

// required string link_name = 2;
bool SetLinkLinearVelocity::has_link_name() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
void SetLinkLinearVelocity::set_has_link_name() {
  _has_bits_[0] |= 0x00000002u;
}
void SetLinkLinearVelocity::clear_has_link_name() {
  _has_bits_[0] &= ~0x00000002u;
}
void SetLinkLinearVelocity::clear_link_name() {
  link_name_.ClearToEmptyNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
  clear_has_link_name();
}
 const ::std::string& SetLinkLinearVelocity::link_name() const {
  // @@protoc_insertion_point(field_get:mw.internal.robotics.gazebotransport.SetLinkLinearVelocity.link_name)
  return link_name_.GetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
 void SetLinkLinearVelocity::set_link_name(const ::std::string& value) {
  set_has_link_name();
  link_name_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), value);
  // @@protoc_insertion_point(field_set:mw.internal.robotics.gazebotransport.SetLinkLinearVelocity.link_name)
}
 void SetLinkLinearVelocity::set_link_name(const char* value) {
  set_has_link_name();
  link_name_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::string(value));
  // @@protoc_insertion_point(field_set_char:mw.internal.robotics.gazebotransport.SetLinkLinearVelocity.link_name)
}
 void SetLinkLinearVelocity::set_link_name(const char* value, size_t size) {
  set_has_link_name();
  link_name_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(),
      ::std::string(reinterpret_cast<const char*>(value), size));
  // @@protoc_insertion_point(field_set_pointer:mw.internal.robotics.gazebotransport.SetLinkLinearVelocity.link_name)
}
 ::std::string* SetLinkLinearVelocity::mutable_link_name() {
  set_has_link_name();
  // @@protoc_insertion_point(field_mutable:mw.internal.robotics.gazebotransport.SetLinkLinearVelocity.link_name)
  return link_name_.MutableNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
 ::std::string* SetLinkLinearVelocity::release_link_name() {
  // @@protoc_insertion_point(field_release:mw.internal.robotics.gazebotransport.SetLinkLinearVelocity.link_name)
  clear_has_link_name();
  return link_name_.ReleaseNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
 void SetLinkLinearVelocity::set_allocated_link_name(::std::string* link_name) {
  if (link_name != NULL) {
    set_has_link_name();
  } else {
    clear_has_link_name();
  }
  link_name_.SetAllocatedNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), link_name);
  // @@protoc_insertion_point(field_set_allocated:mw.internal.robotics.gazebotransport.SetLinkLinearVelocity.link_name)
}

// required .mw.internal.robotics.gazebotransport.Point velocity = 3;
bool SetLinkLinearVelocity::has_velocity() const {
  return (_has_bits_[0] & 0x00000004u) != 0;
}
void SetLinkLinearVelocity::set_has_velocity() {
  _has_bits_[0] |= 0x00000004u;
}
void SetLinkLinearVelocity::clear_has_velocity() {
  _has_bits_[0] &= ~0x00000004u;
}
void SetLinkLinearVelocity::clear_velocity() {
  if (velocity_ != NULL) velocity_->::mw::internal::robotics::gazebotransport::Point::Clear();
  clear_has_velocity();
}
const ::mw::internal::robotics::gazebotransport::Point& SetLinkLinearVelocity::velocity() const {
  // @@protoc_insertion_point(field_get:mw.internal.robotics.gazebotransport.SetLinkLinearVelocity.velocity)
  return velocity_ != NULL ? *velocity_ : *default_instance_->velocity_;
}
::mw::internal::robotics::gazebotransport::Point* SetLinkLinearVelocity::mutable_velocity() {
  set_has_velocity();
  if (velocity_ == NULL) {
    velocity_ = new ::mw::internal::robotics::gazebotransport::Point;
  }
  // @@protoc_insertion_point(field_mutable:mw.internal.robotics.gazebotransport.SetLinkLinearVelocity.velocity)
  return velocity_;
}
::mw::internal::robotics::gazebotransport::Point* SetLinkLinearVelocity::release_velocity() {
  // @@protoc_insertion_point(field_release:mw.internal.robotics.gazebotransport.SetLinkLinearVelocity.velocity)
  clear_has_velocity();
  ::mw::internal::robotics::gazebotransport::Point* temp = velocity_;
  velocity_ = NULL;
  return temp;
}
void SetLinkLinearVelocity::set_allocated_velocity(::mw::internal::robotics::gazebotransport::Point* velocity) {
  delete velocity_;
  velocity_ = velocity;
  if (velocity) {
    set_has_velocity();
  } else {
    clear_has_velocity();
  }
  // @@protoc_insertion_point(field_set_allocated:mw.internal.robotics.gazebotransport.SetLinkLinearVelocity.velocity)
}

// required .mw.internal.robotics.gazebotransport.Time duration = 4;
bool SetLinkLinearVelocity::has_duration() const {
  return (_has_bits_[0] & 0x00000008u) != 0;
}
void SetLinkLinearVelocity::set_has_duration() {
  _has_bits_[0] |= 0x00000008u;
}
void SetLinkLinearVelocity::clear_has_duration() {
  _has_bits_[0] &= ~0x00000008u;
}
void SetLinkLinearVelocity::clear_duration() {
  if (duration_ != NULL) duration_->::mw::internal::robotics::gazebotransport::Time::Clear();
  clear_has_duration();
}
const ::mw::internal::robotics::gazebotransport::Time& SetLinkLinearVelocity::duration() const {
  // @@protoc_insertion_point(field_get:mw.internal.robotics.gazebotransport.SetLinkLinearVelocity.duration)
  return duration_ != NULL ? *duration_ : *default_instance_->duration_;
}
::mw::internal::robotics::gazebotransport::Time* SetLinkLinearVelocity::mutable_duration() {
  set_has_duration();
  if (duration_ == NULL) {
    duration_ = new ::mw::internal::robotics::gazebotransport::Time;
  }
  // @@protoc_insertion_point(field_mutable:mw.internal.robotics.gazebotransport.SetLinkLinearVelocity.duration)
  return duration_;
}
::mw::internal::robotics::gazebotransport::Time* SetLinkLinearVelocity::release_duration() {
  // @@protoc_insertion_point(field_release:mw.internal.robotics.gazebotransport.SetLinkLinearVelocity.duration)
  clear_has_duration();
  ::mw::internal::robotics::gazebotransport::Time* temp = duration_;
  duration_ = NULL;
  return temp;
}
void SetLinkLinearVelocity::set_allocated_duration(::mw::internal::robotics::gazebotransport::Time* duration) {
  delete duration_;
  duration_ = duration;
  if (duration) {
    set_has_duration();
  } else {
    clear_has_duration();
  }
  // @@protoc_insertion_point(field_set_allocated:mw.internal.robotics.gazebotransport.SetLinkLinearVelocity.duration)
}

#endif  // PROTOBUF_INLINE_NOT_IN_HEADERS

// ===================================================================

#if !defined(_MSC_VER) || _MSC_VER >= 1900
const int SetLinkAngularVelocity::kModelNameFieldNumber;
const int SetLinkAngularVelocity::kLinkNameFieldNumber;
const int SetLinkAngularVelocity::kVelocityFieldNumber;
const int SetLinkAngularVelocity::kDurationFieldNumber;
#endif  // !defined(_MSC_VER) || _MSC_VER >= 1900

SetLinkAngularVelocity::SetLinkAngularVelocity()
  : ::google::protobuf::Message(), _internal_metadata_(NULL) {
  SharedCtor();
  // @@protoc_insertion_point(constructor:mw.internal.robotics.gazebotransport.SetLinkAngularVelocity)
}

void SetLinkAngularVelocity::InitAsDefaultInstance() {
  velocity_ = const_cast< ::mw::internal::robotics::gazebotransport::Point*>(&::mw::internal::robotics::gazebotransport::Point::default_instance());
  duration_ = const_cast< ::mw::internal::robotics::gazebotransport::Time*>(&::mw::internal::robotics::gazebotransport::Time::default_instance());
}

SetLinkAngularVelocity::SetLinkAngularVelocity(const SetLinkAngularVelocity& from)
  : ::google::protobuf::Message(),
    _internal_metadata_(NULL) {
  SharedCtor();
  MergeFrom(from);
  // @@protoc_insertion_point(copy_constructor:mw.internal.robotics.gazebotransport.SetLinkAngularVelocity)
}

void SetLinkAngularVelocity::SharedCtor() {
  ::google::protobuf::internal::GetEmptyString();
  _cached_size_ = 0;
  model_name_.UnsafeSetDefault(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
  link_name_.UnsafeSetDefault(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
  velocity_ = NULL;
  duration_ = NULL;
  ::memset(_has_bits_, 0, sizeof(_has_bits_));
}

SetLinkAngularVelocity::~SetLinkAngularVelocity() {
  // @@protoc_insertion_point(destructor:mw.internal.robotics.gazebotransport.SetLinkAngularVelocity)
  SharedDtor();
}

void SetLinkAngularVelocity::SharedDtor() {
  model_name_.DestroyNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
  link_name_.DestroyNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
  if (this != default_instance_) {
    delete velocity_;
    delete duration_;
  }
}

void SetLinkAngularVelocity::SetCachedSize(int size) const {
  GOOGLE_SAFE_CONCURRENT_WRITES_BEGIN();
  _cached_size_ = size;
  GOOGLE_SAFE_CONCURRENT_WRITES_END();
}
const ::google::protobuf::Descriptor* SetLinkAngularVelocity::descriptor() {
  protobuf_AssignDescriptorsOnce();
  return SetLinkAngularVelocity_descriptor_;
}

const SetLinkAngularVelocity& SetLinkAngularVelocity::default_instance() {
  if (default_instance_ == NULL) protobuf_AddDesc_mw_2einternal_2erobotics_2egazebotransport_2eCoSimMsgs_2eproto();
  return *default_instance_;
}

SetLinkAngularVelocity* SetLinkAngularVelocity::default_instance_ = NULL;

SetLinkAngularVelocity* SetLinkAngularVelocity::New(::google::protobuf::Arena* arena) const {
  SetLinkAngularVelocity* n = new SetLinkAngularVelocity;
  if (arena != NULL) {
    arena->Own(n);
  }
  return n;
}

void SetLinkAngularVelocity::Clear() {
// @@protoc_insertion_point(message_clear_start:mw.internal.robotics.gazebotransport.SetLinkAngularVelocity)
  if (_has_bits_[0 / 32] & 15u) {
    if (has_model_name()) {
      model_name_.ClearToEmptyNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
    }
    if (has_link_name()) {
      link_name_.ClearToEmptyNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
    }
    if (has_velocity()) {
      if (velocity_ != NULL) velocity_->::mw::internal::robotics::gazebotransport::Point::Clear();
    }
    if (has_duration()) {
      if (duration_ != NULL) duration_->::mw::internal::robotics::gazebotransport::Time::Clear();
    }
  }
  ::memset(_has_bits_, 0, sizeof(_has_bits_));
  if (_internal_metadata_.have_unknown_fields()) {
    mutable_unknown_fields()->Clear();
  }
}

bool SetLinkAngularVelocity::MergePartialFromCodedStream(
    ::google::protobuf::io::CodedInputStream* input) {
#define DO_(EXPRESSION) if (!GOOGLE_PREDICT_TRUE(EXPRESSION)) goto failure
  ::google::protobuf::uint32 tag;
  // @@protoc_insertion_point(parse_start:mw.internal.robotics.gazebotransport.SetLinkAngularVelocity)
  for (;;) {
    ::std::pair< ::google::protobuf::uint32, bool> p = input->ReadTagWithCutoff(127);
    tag = p.first;
    if (!p.second) goto handle_unusual;
    switch (::google::protobuf::internal::WireFormatLite::GetTagFieldNumber(tag)) {
      // required string model_name = 1;
      case 1: {
        if (tag == 10) {
          DO_(::google::protobuf::internal::WireFormatLite::ReadString(
                input, this->mutable_model_name()));
          ::google::protobuf::internal::WireFormat::VerifyUTF8StringNamedField(
            this->model_name().data(), this->model_name().length(),
            ::google::protobuf::internal::WireFormat::PARSE,
            "mw.internal.robotics.gazebotransport.SetLinkAngularVelocity.model_name");
        } else {
          goto handle_unusual;
        }
        if (input->ExpectTag(18)) goto parse_link_name;
        break;
      }

      // required string link_name = 2;
      case 2: {
        if (tag == 18) {
         parse_link_name:
          DO_(::google::protobuf::internal::WireFormatLite::ReadString(
                input, this->mutable_link_name()));
          ::google::protobuf::internal::WireFormat::VerifyUTF8StringNamedField(
            this->link_name().data(), this->link_name().length(),
            ::google::protobuf::internal::WireFormat::PARSE,
            "mw.internal.robotics.gazebotransport.SetLinkAngularVelocity.link_name");
        } else {
          goto handle_unusual;
        }
        if (input->ExpectTag(26)) goto parse_velocity;
        break;
      }

      // required .mw.internal.robotics.gazebotransport.Point velocity = 3;
      case 3: {
        if (tag == 26) {
         parse_velocity:
          DO_(::google::protobuf::internal::WireFormatLite::ReadMessageNoVirtual(
               input, mutable_velocity()));
        } else {
          goto handle_unusual;
        }
        if (input->ExpectTag(34)) goto parse_duration;
        break;
      }

      // required .mw.internal.robotics.gazebotransport.Time duration = 4;
      case 4: {
        if (tag == 34) {
         parse_duration:
          DO_(::google::protobuf::internal::WireFormatLite::ReadMessageNoVirtual(
               input, mutable_duration()));
        } else {
          goto handle_unusual;
        }
        if (input->ExpectAtEnd()) goto success;
        break;
      }

      default: {
      handle_unusual:
        if (tag == 0 ||
            ::google::protobuf::internal::WireFormatLite::GetTagWireType(tag) ==
            ::google::protobuf::internal::WireFormatLite::WIRETYPE_END_GROUP) {
          goto success;
        }
        DO_(::google::protobuf::internal::WireFormat::SkipField(
              input, tag, mutable_unknown_fields()));
        break;
      }
    }
  }
success:
  // @@protoc_insertion_point(parse_success:mw.internal.robotics.gazebotransport.SetLinkAngularVelocity)
  return true;
failure:
  // @@protoc_insertion_point(parse_failure:mw.internal.robotics.gazebotransport.SetLinkAngularVelocity)
  return false;
#undef DO_
}

void SetLinkAngularVelocity::SerializeWithCachedSizes(
    ::google::protobuf::io::CodedOutputStream* output) const {
  // @@protoc_insertion_point(serialize_start:mw.internal.robotics.gazebotransport.SetLinkAngularVelocity)
  // required string model_name = 1;
  if (has_model_name()) {
    ::google::protobuf::internal::WireFormat::VerifyUTF8StringNamedField(
      this->model_name().data(), this->model_name().length(),
      ::google::protobuf::internal::WireFormat::SERIALIZE,
      "mw.internal.robotics.gazebotransport.SetLinkAngularVelocity.model_name");
    ::google::protobuf::internal::WireFormatLite::WriteStringMaybeAliased(
      1, this->model_name(), output);
  }

  // required string link_name = 2;
  if (has_link_name()) {
    ::google::protobuf::internal::WireFormat::VerifyUTF8StringNamedField(
      this->link_name().data(), this->link_name().length(),
      ::google::protobuf::internal::WireFormat::SERIALIZE,
      "mw.internal.robotics.gazebotransport.SetLinkAngularVelocity.link_name");
    ::google::protobuf::internal::WireFormatLite::WriteStringMaybeAliased(
      2, this->link_name(), output);
  }

  // required .mw.internal.robotics.gazebotransport.Point velocity = 3;
  if (has_velocity()) {
    ::google::protobuf::internal::WireFormatLite::WriteMessageMaybeToArray(
      3, *this->velocity_, output);
  }

  // required .mw.internal.robotics.gazebotransport.Time duration = 4;
  if (has_duration()) {
    ::google::protobuf::internal::WireFormatLite::WriteMessageMaybeToArray(
      4, *this->duration_, output);
  }

  if (_internal_metadata_.have_unknown_fields()) {
    ::google::protobuf::internal::WireFormat::SerializeUnknownFields(
        unknown_fields(), output);
  }
  // @@protoc_insertion_point(serialize_end:mw.internal.robotics.gazebotransport.SetLinkAngularVelocity)
}

::google::protobuf::uint8* SetLinkAngularVelocity::InternalSerializeWithCachedSizesToArray(
    bool deterministic, ::google::protobuf::uint8* target) const {
  // @@protoc_insertion_point(serialize_to_array_start:mw.internal.robotics.gazebotransport.SetLinkAngularVelocity)
  // required string model_name = 1;
  if (has_model_name()) {
    ::google::protobuf::internal::WireFormat::VerifyUTF8StringNamedField(
      this->model_name().data(), this->model_name().length(),
      ::google::protobuf::internal::WireFormat::SERIALIZE,
      "mw.internal.robotics.gazebotransport.SetLinkAngularVelocity.model_name");
    target =
      ::google::protobuf::internal::WireFormatLite::WriteStringToArray(
        1, this->model_name(), target);
  }

  // required string link_name = 2;
  if (has_link_name()) {
    ::google::protobuf::internal::WireFormat::VerifyUTF8StringNamedField(
      this->link_name().data(), this->link_name().length(),
      ::google::protobuf::internal::WireFormat::SERIALIZE,
      "mw.internal.robotics.gazebotransport.SetLinkAngularVelocity.link_name");
    target =
      ::google::protobuf::internal::WireFormatLite::WriteStringToArray(
        2, this->link_name(), target);
  }

  // required .mw.internal.robotics.gazebotransport.Point velocity = 3;
  if (has_velocity()) {
    target = ::google::protobuf::internal::WireFormatLite::
      InternalWriteMessageNoVirtualToArray(
        3, *this->velocity_, false, target);
  }

  // required .mw.internal.robotics.gazebotransport.Time duration = 4;
  if (has_duration()) {
    target = ::google::protobuf::internal::WireFormatLite::
      InternalWriteMessageNoVirtualToArray(
        4, *this->duration_, false, target);
  }

  if (_internal_metadata_.have_unknown_fields()) {
    target = ::google::protobuf::internal::WireFormat::SerializeUnknownFieldsToArray(
        unknown_fields(), target);
  }
  // @@protoc_insertion_point(serialize_to_array_end:mw.internal.robotics.gazebotransport.SetLinkAngularVelocity)
  return target;
}

int SetLinkAngularVelocity::RequiredFieldsByteSizeFallback() const {
// @@protoc_insertion_point(required_fields_byte_size_fallback_start:mw.internal.robotics.gazebotransport.SetLinkAngularVelocity)
  int total_size = 0;

  if (has_model_name()) {
    // required string model_name = 1;
    total_size += 1 +
      ::google::protobuf::internal::WireFormatLite::StringSize(
        this->model_name());
  }

  if (has_link_name()) {
    // required string link_name = 2;
    total_size += 1 +
      ::google::protobuf::internal::WireFormatLite::StringSize(
        this->link_name());
  }

  if (has_velocity()) {
    // required .mw.internal.robotics.gazebotransport.Point velocity = 3;
    total_size += 1 +
      ::google::protobuf::internal::WireFormatLite::MessageSizeNoVirtual(
        *this->velocity_);
  }

  if (has_duration()) {
    // required .mw.internal.robotics.gazebotransport.Time duration = 4;
    total_size += 1 +
      ::google::protobuf::internal::WireFormatLite::MessageSizeNoVirtual(
        *this->duration_);
  }

  return total_size;
}
int SetLinkAngularVelocity::ByteSize() const {
// @@protoc_insertion_point(message_byte_size_start:mw.internal.robotics.gazebotransport.SetLinkAngularVelocity)
  int total_size = 0;

  if (((_has_bits_[0] & 0x0000000f) ^ 0x0000000f) == 0) {  // All required fields are present.
    // required string model_name = 1;
    total_size += 1 +
      ::google::protobuf::internal::WireFormatLite::StringSize(
        this->model_name());

    // required string link_name = 2;
    total_size += 1 +
      ::google::protobuf::internal::WireFormatLite::StringSize(
        this->link_name());

    // required .mw.internal.robotics.gazebotransport.Point velocity = 3;
    total_size += 1 +
      ::google::protobuf::internal::WireFormatLite::MessageSizeNoVirtual(
        *this->velocity_);

    // required .mw.internal.robotics.gazebotransport.Time duration = 4;
    total_size += 1 +
      ::google::protobuf::internal::WireFormatLite::MessageSizeNoVirtual(
        *this->duration_);

  } else {
    total_size += RequiredFieldsByteSizeFallback();
  }
  if (_internal_metadata_.have_unknown_fields()) {
    total_size +=
      ::google::protobuf::internal::WireFormat::ComputeUnknownFieldsSize(
        unknown_fields());
  }
  GOOGLE_SAFE_CONCURRENT_WRITES_BEGIN();
  _cached_size_ = total_size;
  GOOGLE_SAFE_CONCURRENT_WRITES_END();
  return total_size;
}

void SetLinkAngularVelocity::MergeFrom(const ::google::protobuf::Message& from) {
// @@protoc_insertion_point(generalized_merge_from_start:mw.internal.robotics.gazebotransport.SetLinkAngularVelocity)
  if (GOOGLE_PREDICT_FALSE(&from == this)) {
    ::google::protobuf::internal::MergeFromFail(__FILE__, __LINE__);
  }
  const SetLinkAngularVelocity* source = 
      ::google::protobuf::internal::DynamicCastToGenerated<const SetLinkAngularVelocity>(
          &from);
  if (source == NULL) {
  // @@protoc_insertion_point(generalized_merge_from_cast_fail:mw.internal.robotics.gazebotransport.SetLinkAngularVelocity)
    ::google::protobuf::internal::ReflectionOps::Merge(from, this);
  } else {
  // @@protoc_insertion_point(generalized_merge_from_cast_success:mw.internal.robotics.gazebotransport.SetLinkAngularVelocity)
    MergeFrom(*source);
  }
}

void SetLinkAngularVelocity::MergeFrom(const SetLinkAngularVelocity& from) {
// @@protoc_insertion_point(class_specific_merge_from_start:mw.internal.robotics.gazebotransport.SetLinkAngularVelocity)
  if (GOOGLE_PREDICT_FALSE(&from == this)) {
    ::google::protobuf::internal::MergeFromFail(__FILE__, __LINE__);
  }
  if (from._has_bits_[0 / 32] & (0xffu << (0 % 32))) {
    if (from.has_model_name()) {
      set_has_model_name();
      model_name_.AssignWithDefault(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), from.model_name_);
    }
    if (from.has_link_name()) {
      set_has_link_name();
      link_name_.AssignWithDefault(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), from.link_name_);
    }
    if (from.has_velocity()) {
      mutable_velocity()->::mw::internal::robotics::gazebotransport::Point::MergeFrom(from.velocity());
    }
    if (from.has_duration()) {
      mutable_duration()->::mw::internal::robotics::gazebotransport::Time::MergeFrom(from.duration());
    }
  }
  if (from._internal_metadata_.have_unknown_fields()) {
    mutable_unknown_fields()->MergeFrom(from.unknown_fields());
  }
}

void SetLinkAngularVelocity::CopyFrom(const ::google::protobuf::Message& from) {
// @@protoc_insertion_point(generalized_copy_from_start:mw.internal.robotics.gazebotransport.SetLinkAngularVelocity)
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

void SetLinkAngularVelocity::CopyFrom(const SetLinkAngularVelocity& from) {
// @@protoc_insertion_point(class_specific_copy_from_start:mw.internal.robotics.gazebotransport.SetLinkAngularVelocity)
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

bool SetLinkAngularVelocity::IsInitialized() const {
  if ((_has_bits_[0] & 0x0000000f) != 0x0000000f) return false;

  if (has_velocity()) {
    if (!this->velocity_->IsInitialized()) return false;
  }
  if (has_duration()) {
    if (!this->duration_->IsInitialized()) return false;
  }
  return true;
}

void SetLinkAngularVelocity::Swap(SetLinkAngularVelocity* other) {
  if (other == this) return;
  InternalSwap(other);
}
void SetLinkAngularVelocity::InternalSwap(SetLinkAngularVelocity* other) {
  model_name_.Swap(&other->model_name_);
  link_name_.Swap(&other->link_name_);
  std::swap(velocity_, other->velocity_);
  std::swap(duration_, other->duration_);
  std::swap(_has_bits_[0], other->_has_bits_[0]);
  _internal_metadata_.Swap(&other->_internal_metadata_);
  std::swap(_cached_size_, other->_cached_size_);
}

::google::protobuf::Metadata SetLinkAngularVelocity::GetMetadata() const {
  protobuf_AssignDescriptorsOnce();
  ::google::protobuf::Metadata metadata;
  metadata.descriptor = SetLinkAngularVelocity_descriptor_;
  metadata.reflection = SetLinkAngularVelocity_reflection_;
  return metadata;
}

#if PROTOBUF_INLINE_NOT_IN_HEADERS
// SetLinkAngularVelocity

// required string model_name = 1;
bool SetLinkAngularVelocity::has_model_name() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
void SetLinkAngularVelocity::set_has_model_name() {
  _has_bits_[0] |= 0x00000001u;
}
void SetLinkAngularVelocity::clear_has_model_name() {
  _has_bits_[0] &= ~0x00000001u;
}
void SetLinkAngularVelocity::clear_model_name() {
  model_name_.ClearToEmptyNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
  clear_has_model_name();
}
 const ::std::string& SetLinkAngularVelocity::model_name() const {
  // @@protoc_insertion_point(field_get:mw.internal.robotics.gazebotransport.SetLinkAngularVelocity.model_name)
  return model_name_.GetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
 void SetLinkAngularVelocity::set_model_name(const ::std::string& value) {
  set_has_model_name();
  model_name_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), value);
  // @@protoc_insertion_point(field_set:mw.internal.robotics.gazebotransport.SetLinkAngularVelocity.model_name)
}
 void SetLinkAngularVelocity::set_model_name(const char* value) {
  set_has_model_name();
  model_name_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::string(value));
  // @@protoc_insertion_point(field_set_char:mw.internal.robotics.gazebotransport.SetLinkAngularVelocity.model_name)
}
 void SetLinkAngularVelocity::set_model_name(const char* value, size_t size) {
  set_has_model_name();
  model_name_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(),
      ::std::string(reinterpret_cast<const char*>(value), size));
  // @@protoc_insertion_point(field_set_pointer:mw.internal.robotics.gazebotransport.SetLinkAngularVelocity.model_name)
}
 ::std::string* SetLinkAngularVelocity::mutable_model_name() {
  set_has_model_name();
  // @@protoc_insertion_point(field_mutable:mw.internal.robotics.gazebotransport.SetLinkAngularVelocity.model_name)
  return model_name_.MutableNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
 ::std::string* SetLinkAngularVelocity::release_model_name() {
  // @@protoc_insertion_point(field_release:mw.internal.robotics.gazebotransport.SetLinkAngularVelocity.model_name)
  clear_has_model_name();
  return model_name_.ReleaseNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
 void SetLinkAngularVelocity::set_allocated_model_name(::std::string* model_name) {
  if (model_name != NULL) {
    set_has_model_name();
  } else {
    clear_has_model_name();
  }
  model_name_.SetAllocatedNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), model_name);
  // @@protoc_insertion_point(field_set_allocated:mw.internal.robotics.gazebotransport.SetLinkAngularVelocity.model_name)
}

// required string link_name = 2;
bool SetLinkAngularVelocity::has_link_name() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
void SetLinkAngularVelocity::set_has_link_name() {
  _has_bits_[0] |= 0x00000002u;
}
void SetLinkAngularVelocity::clear_has_link_name() {
  _has_bits_[0] &= ~0x00000002u;
}
void SetLinkAngularVelocity::clear_link_name() {
  link_name_.ClearToEmptyNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
  clear_has_link_name();
}
 const ::std::string& SetLinkAngularVelocity::link_name() const {
  // @@protoc_insertion_point(field_get:mw.internal.robotics.gazebotransport.SetLinkAngularVelocity.link_name)
  return link_name_.GetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
 void SetLinkAngularVelocity::set_link_name(const ::std::string& value) {
  set_has_link_name();
  link_name_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), value);
  // @@protoc_insertion_point(field_set:mw.internal.robotics.gazebotransport.SetLinkAngularVelocity.link_name)
}
 void SetLinkAngularVelocity::set_link_name(const char* value) {
  set_has_link_name();
  link_name_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::string(value));
  // @@protoc_insertion_point(field_set_char:mw.internal.robotics.gazebotransport.SetLinkAngularVelocity.link_name)
}
 void SetLinkAngularVelocity::set_link_name(const char* value, size_t size) {
  set_has_link_name();
  link_name_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(),
      ::std::string(reinterpret_cast<const char*>(value), size));
  // @@protoc_insertion_point(field_set_pointer:mw.internal.robotics.gazebotransport.SetLinkAngularVelocity.link_name)
}
 ::std::string* SetLinkAngularVelocity::mutable_link_name() {
  set_has_link_name();
  // @@protoc_insertion_point(field_mutable:mw.internal.robotics.gazebotransport.SetLinkAngularVelocity.link_name)
  return link_name_.MutableNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
 ::std::string* SetLinkAngularVelocity::release_link_name() {
  // @@protoc_insertion_point(field_release:mw.internal.robotics.gazebotransport.SetLinkAngularVelocity.link_name)
  clear_has_link_name();
  return link_name_.ReleaseNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
 void SetLinkAngularVelocity::set_allocated_link_name(::std::string* link_name) {
  if (link_name != NULL) {
    set_has_link_name();
  } else {
    clear_has_link_name();
  }
  link_name_.SetAllocatedNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), link_name);
  // @@protoc_insertion_point(field_set_allocated:mw.internal.robotics.gazebotransport.SetLinkAngularVelocity.link_name)
}

// required .mw.internal.robotics.gazebotransport.Point velocity = 3;
bool SetLinkAngularVelocity::has_velocity() const {
  return (_has_bits_[0] & 0x00000004u) != 0;
}
void SetLinkAngularVelocity::set_has_velocity() {
  _has_bits_[0] |= 0x00000004u;
}
void SetLinkAngularVelocity::clear_has_velocity() {
  _has_bits_[0] &= ~0x00000004u;
}
void SetLinkAngularVelocity::clear_velocity() {
  if (velocity_ != NULL) velocity_->::mw::internal::robotics::gazebotransport::Point::Clear();
  clear_has_velocity();
}
const ::mw::internal::robotics::gazebotransport::Point& SetLinkAngularVelocity::velocity() const {
  // @@protoc_insertion_point(field_get:mw.internal.robotics.gazebotransport.SetLinkAngularVelocity.velocity)
  return velocity_ != NULL ? *velocity_ : *default_instance_->velocity_;
}
::mw::internal::robotics::gazebotransport::Point* SetLinkAngularVelocity::mutable_velocity() {
  set_has_velocity();
  if (velocity_ == NULL) {
    velocity_ = new ::mw::internal::robotics::gazebotransport::Point;
  }
  // @@protoc_insertion_point(field_mutable:mw.internal.robotics.gazebotransport.SetLinkAngularVelocity.velocity)
  return velocity_;
}
::mw::internal::robotics::gazebotransport::Point* SetLinkAngularVelocity::release_velocity() {
  // @@protoc_insertion_point(field_release:mw.internal.robotics.gazebotransport.SetLinkAngularVelocity.velocity)
  clear_has_velocity();
  ::mw::internal::robotics::gazebotransport::Point* temp = velocity_;
  velocity_ = NULL;
  return temp;
}
void SetLinkAngularVelocity::set_allocated_velocity(::mw::internal::robotics::gazebotransport::Point* velocity) {
  delete velocity_;
  velocity_ = velocity;
  if (velocity) {
    set_has_velocity();
  } else {
    clear_has_velocity();
  }
  // @@protoc_insertion_point(field_set_allocated:mw.internal.robotics.gazebotransport.SetLinkAngularVelocity.velocity)
}

// required .mw.internal.robotics.gazebotransport.Time duration = 4;
bool SetLinkAngularVelocity::has_duration() const {
  return (_has_bits_[0] & 0x00000008u) != 0;
}
void SetLinkAngularVelocity::set_has_duration() {
  _has_bits_[0] |= 0x00000008u;
}
void SetLinkAngularVelocity::clear_has_duration() {
  _has_bits_[0] &= ~0x00000008u;
}
void SetLinkAngularVelocity::clear_duration() {
  if (duration_ != NULL) duration_->::mw::internal::robotics::gazebotransport::Time::Clear();
  clear_has_duration();
}
const ::mw::internal::robotics::gazebotransport::Time& SetLinkAngularVelocity::duration() const {
  // @@protoc_insertion_point(field_get:mw.internal.robotics.gazebotransport.SetLinkAngularVelocity.duration)
  return duration_ != NULL ? *duration_ : *default_instance_->duration_;
}
::mw::internal::robotics::gazebotransport::Time* SetLinkAngularVelocity::mutable_duration() {
  set_has_duration();
  if (duration_ == NULL) {
    duration_ = new ::mw::internal::robotics::gazebotransport::Time;
  }
  // @@protoc_insertion_point(field_mutable:mw.internal.robotics.gazebotransport.SetLinkAngularVelocity.duration)
  return duration_;
}
::mw::internal::robotics::gazebotransport::Time* SetLinkAngularVelocity::release_duration() {
  // @@protoc_insertion_point(field_release:mw.internal.robotics.gazebotransport.SetLinkAngularVelocity.duration)
  clear_has_duration();
  ::mw::internal::robotics::gazebotransport::Time* temp = duration_;
  duration_ = NULL;
  return temp;
}
void SetLinkAngularVelocity::set_allocated_duration(::mw::internal::robotics::gazebotransport::Time* duration) {
  delete duration_;
  duration_ = duration;
  if (duration) {
    set_has_duration();
  } else {
    clear_has_duration();
  }
  // @@protoc_insertion_point(field_set_allocated:mw.internal.robotics.gazebotransport.SetLinkAngularVelocity.duration)
}

#endif  // PROTOBUF_INLINE_NOT_IN_HEADERS

// ===================================================================

#if !defined(_MSC_VER) || _MSC_VER >= 1900
const int GetLinkState::kModelNameFieldNumber;
const int GetLinkState::kLinkNameFieldNumber;
#endif  // !defined(_MSC_VER) || _MSC_VER >= 1900

GetLinkState::GetLinkState()
  : ::google::protobuf::Message(), _internal_metadata_(NULL) {
  SharedCtor();
  // @@protoc_insertion_point(constructor:mw.internal.robotics.gazebotransport.GetLinkState)
}

void GetLinkState::InitAsDefaultInstance() {
}

GetLinkState::GetLinkState(const GetLinkState& from)
  : ::google::protobuf::Message(),
    _internal_metadata_(NULL) {
  SharedCtor();
  MergeFrom(from);
  // @@protoc_insertion_point(copy_constructor:mw.internal.robotics.gazebotransport.GetLinkState)
}

void GetLinkState::SharedCtor() {
  ::google::protobuf::internal::GetEmptyString();
  _cached_size_ = 0;
  model_name_.UnsafeSetDefault(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
  link_name_.UnsafeSetDefault(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
  ::memset(_has_bits_, 0, sizeof(_has_bits_));
}

GetLinkState::~GetLinkState() {
  // @@protoc_insertion_point(destructor:mw.internal.robotics.gazebotransport.GetLinkState)
  SharedDtor();
}

void GetLinkState::SharedDtor() {
  model_name_.DestroyNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
  link_name_.DestroyNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
  if (this != default_instance_) {
  }
}

void GetLinkState::SetCachedSize(int size) const {
  GOOGLE_SAFE_CONCURRENT_WRITES_BEGIN();
  _cached_size_ = size;
  GOOGLE_SAFE_CONCURRENT_WRITES_END();
}
const ::google::protobuf::Descriptor* GetLinkState::descriptor() {
  protobuf_AssignDescriptorsOnce();
  return GetLinkState_descriptor_;
}

const GetLinkState& GetLinkState::default_instance() {
  if (default_instance_ == NULL) protobuf_AddDesc_mw_2einternal_2erobotics_2egazebotransport_2eCoSimMsgs_2eproto();
  return *default_instance_;
}

GetLinkState* GetLinkState::default_instance_ = NULL;

GetLinkState* GetLinkState::New(::google::protobuf::Arena* arena) const {
  GetLinkState* n = new GetLinkState;
  if (arena != NULL) {
    arena->Own(n);
  }
  return n;
}

void GetLinkState::Clear() {
// @@protoc_insertion_point(message_clear_start:mw.internal.robotics.gazebotransport.GetLinkState)
  if (_has_bits_[0 / 32] & 3u) {
    if (has_model_name()) {
      model_name_.ClearToEmptyNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
    }
    if (has_link_name()) {
      link_name_.ClearToEmptyNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
    }
  }
  ::memset(_has_bits_, 0, sizeof(_has_bits_));
  if (_internal_metadata_.have_unknown_fields()) {
    mutable_unknown_fields()->Clear();
  }
}

bool GetLinkState::MergePartialFromCodedStream(
    ::google::protobuf::io::CodedInputStream* input) {
#define DO_(EXPRESSION) if (!GOOGLE_PREDICT_TRUE(EXPRESSION)) goto failure
  ::google::protobuf::uint32 tag;
  // @@protoc_insertion_point(parse_start:mw.internal.robotics.gazebotransport.GetLinkState)
  for (;;) {
    ::std::pair< ::google::protobuf::uint32, bool> p = input->ReadTagWithCutoff(127);
    tag = p.first;
    if (!p.second) goto handle_unusual;
    switch (::google::protobuf::internal::WireFormatLite::GetTagFieldNumber(tag)) {
      // required string model_name = 1;
      case 1: {
        if (tag == 10) {
          DO_(::google::protobuf::internal::WireFormatLite::ReadString(
                input, this->mutable_model_name()));
          ::google::protobuf::internal::WireFormat::VerifyUTF8StringNamedField(
            this->model_name().data(), this->model_name().length(),
            ::google::protobuf::internal::WireFormat::PARSE,
            "mw.internal.robotics.gazebotransport.GetLinkState.model_name");
        } else {
          goto handle_unusual;
        }
        if (input->ExpectTag(18)) goto parse_link_name;
        break;
      }

      // required string link_name = 2;
      case 2: {
        if (tag == 18) {
         parse_link_name:
          DO_(::google::protobuf::internal::WireFormatLite::ReadString(
                input, this->mutable_link_name()));
          ::google::protobuf::internal::WireFormat::VerifyUTF8StringNamedField(
            this->link_name().data(), this->link_name().length(),
            ::google::protobuf::internal::WireFormat::PARSE,
            "mw.internal.robotics.gazebotransport.GetLinkState.link_name");
        } else {
          goto handle_unusual;
        }
        if (input->ExpectAtEnd()) goto success;
        break;
      }

      default: {
      handle_unusual:
        if (tag == 0 ||
            ::google::protobuf::internal::WireFormatLite::GetTagWireType(tag) ==
            ::google::protobuf::internal::WireFormatLite::WIRETYPE_END_GROUP) {
          goto success;
        }
        DO_(::google::protobuf::internal::WireFormat::SkipField(
              input, tag, mutable_unknown_fields()));
        break;
      }
    }
  }
success:
  // @@protoc_insertion_point(parse_success:mw.internal.robotics.gazebotransport.GetLinkState)
  return true;
failure:
  // @@protoc_insertion_point(parse_failure:mw.internal.robotics.gazebotransport.GetLinkState)
  return false;
#undef DO_
}

void GetLinkState::SerializeWithCachedSizes(
    ::google::protobuf::io::CodedOutputStream* output) const {
  // @@protoc_insertion_point(serialize_start:mw.internal.robotics.gazebotransport.GetLinkState)
  // required string model_name = 1;
  if (has_model_name()) {
    ::google::protobuf::internal::WireFormat::VerifyUTF8StringNamedField(
      this->model_name().data(), this->model_name().length(),
      ::google::protobuf::internal::WireFormat::SERIALIZE,
      "mw.internal.robotics.gazebotransport.GetLinkState.model_name");
    ::google::protobuf::internal::WireFormatLite::WriteStringMaybeAliased(
      1, this->model_name(), output);
  }

  // required string link_name = 2;
  if (has_link_name()) {
    ::google::protobuf::internal::WireFormat::VerifyUTF8StringNamedField(
      this->link_name().data(), this->link_name().length(),
      ::google::protobuf::internal::WireFormat::SERIALIZE,
      "mw.internal.robotics.gazebotransport.GetLinkState.link_name");
    ::google::protobuf::internal::WireFormatLite::WriteStringMaybeAliased(
      2, this->link_name(), output);
  }

  if (_internal_metadata_.have_unknown_fields()) {
    ::google::protobuf::internal::WireFormat::SerializeUnknownFields(
        unknown_fields(), output);
  }
  // @@protoc_insertion_point(serialize_end:mw.internal.robotics.gazebotransport.GetLinkState)
}

::google::protobuf::uint8* GetLinkState::InternalSerializeWithCachedSizesToArray(
    bool deterministic, ::google::protobuf::uint8* target) const {
  // @@protoc_insertion_point(serialize_to_array_start:mw.internal.robotics.gazebotransport.GetLinkState)
  // required string model_name = 1;
  if (has_model_name()) {
    ::google::protobuf::internal::WireFormat::VerifyUTF8StringNamedField(
      this->model_name().data(), this->model_name().length(),
      ::google::protobuf::internal::WireFormat::SERIALIZE,
      "mw.internal.robotics.gazebotransport.GetLinkState.model_name");
    target =
      ::google::protobuf::internal::WireFormatLite::WriteStringToArray(
        1, this->model_name(), target);
  }

  // required string link_name = 2;
  if (has_link_name()) {
    ::google::protobuf::internal::WireFormat::VerifyUTF8StringNamedField(
      this->link_name().data(), this->link_name().length(),
      ::google::protobuf::internal::WireFormat::SERIALIZE,
      "mw.internal.robotics.gazebotransport.GetLinkState.link_name");
    target =
      ::google::protobuf::internal::WireFormatLite::WriteStringToArray(
        2, this->link_name(), target);
  }

  if (_internal_metadata_.have_unknown_fields()) {
    target = ::google::protobuf::internal::WireFormat::SerializeUnknownFieldsToArray(
        unknown_fields(), target);
  }
  // @@protoc_insertion_point(serialize_to_array_end:mw.internal.robotics.gazebotransport.GetLinkState)
  return target;
}

int GetLinkState::RequiredFieldsByteSizeFallback() const {
// @@protoc_insertion_point(required_fields_byte_size_fallback_start:mw.internal.robotics.gazebotransport.GetLinkState)
  int total_size = 0;

  if (has_model_name()) {
    // required string model_name = 1;
    total_size += 1 +
      ::google::protobuf::internal::WireFormatLite::StringSize(
        this->model_name());
  }

  if (has_link_name()) {
    // required string link_name = 2;
    total_size += 1 +
      ::google::protobuf::internal::WireFormatLite::StringSize(
        this->link_name());
  }

  return total_size;
}
int GetLinkState::ByteSize() const {
// @@protoc_insertion_point(message_byte_size_start:mw.internal.robotics.gazebotransport.GetLinkState)
  int total_size = 0;

  if (((_has_bits_[0] & 0x00000003) ^ 0x00000003) == 0) {  // All required fields are present.
    // required string model_name = 1;
    total_size += 1 +
      ::google::protobuf::internal::WireFormatLite::StringSize(
        this->model_name());

    // required string link_name = 2;
    total_size += 1 +
      ::google::protobuf::internal::WireFormatLite::StringSize(
        this->link_name());

  } else {
    total_size += RequiredFieldsByteSizeFallback();
  }
  if (_internal_metadata_.have_unknown_fields()) {
    total_size +=
      ::google::protobuf::internal::WireFormat::ComputeUnknownFieldsSize(
        unknown_fields());
  }
  GOOGLE_SAFE_CONCURRENT_WRITES_BEGIN();
  _cached_size_ = total_size;
  GOOGLE_SAFE_CONCURRENT_WRITES_END();
  return total_size;
}

void GetLinkState::MergeFrom(const ::google::protobuf::Message& from) {
// @@protoc_insertion_point(generalized_merge_from_start:mw.internal.robotics.gazebotransport.GetLinkState)
  if (GOOGLE_PREDICT_FALSE(&from == this)) {
    ::google::protobuf::internal::MergeFromFail(__FILE__, __LINE__);
  }
  const GetLinkState* source = 
      ::google::protobuf::internal::DynamicCastToGenerated<const GetLinkState>(
          &from);
  if (source == NULL) {
  // @@protoc_insertion_point(generalized_merge_from_cast_fail:mw.internal.robotics.gazebotransport.GetLinkState)
    ::google::protobuf::internal::ReflectionOps::Merge(from, this);
  } else {
  // @@protoc_insertion_point(generalized_merge_from_cast_success:mw.internal.robotics.gazebotransport.GetLinkState)
    MergeFrom(*source);
  }
}

void GetLinkState::MergeFrom(const GetLinkState& from) {
// @@protoc_insertion_point(class_specific_merge_from_start:mw.internal.robotics.gazebotransport.GetLinkState)
  if (GOOGLE_PREDICT_FALSE(&from == this)) {
    ::google::protobuf::internal::MergeFromFail(__FILE__, __LINE__);
  }
  if (from._has_bits_[0 / 32] & (0xffu << (0 % 32))) {
    if (from.has_model_name()) {
      set_has_model_name();
      model_name_.AssignWithDefault(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), from.model_name_);
    }
    if (from.has_link_name()) {
      set_has_link_name();
      link_name_.AssignWithDefault(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), from.link_name_);
    }
  }
  if (from._internal_metadata_.have_unknown_fields()) {
    mutable_unknown_fields()->MergeFrom(from.unknown_fields());
  }
}

void GetLinkState::CopyFrom(const ::google::protobuf::Message& from) {
// @@protoc_insertion_point(generalized_copy_from_start:mw.internal.robotics.gazebotransport.GetLinkState)
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

void GetLinkState::CopyFrom(const GetLinkState& from) {
// @@protoc_insertion_point(class_specific_copy_from_start:mw.internal.robotics.gazebotransport.GetLinkState)
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

bool GetLinkState::IsInitialized() const {
  if ((_has_bits_[0] & 0x00000003) != 0x00000003) return false;

  return true;
}

void GetLinkState::Swap(GetLinkState* other) {
  if (other == this) return;
  InternalSwap(other);
}
void GetLinkState::InternalSwap(GetLinkState* other) {
  model_name_.Swap(&other->model_name_);
  link_name_.Swap(&other->link_name_);
  std::swap(_has_bits_[0], other->_has_bits_[0]);
  _internal_metadata_.Swap(&other->_internal_metadata_);
  std::swap(_cached_size_, other->_cached_size_);
}

::google::protobuf::Metadata GetLinkState::GetMetadata() const {
  protobuf_AssignDescriptorsOnce();
  ::google::protobuf::Metadata metadata;
  metadata.descriptor = GetLinkState_descriptor_;
  metadata.reflection = GetLinkState_reflection_;
  return metadata;
}

#if PROTOBUF_INLINE_NOT_IN_HEADERS
// GetLinkState

// required string model_name = 1;
bool GetLinkState::has_model_name() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
void GetLinkState::set_has_model_name() {
  _has_bits_[0] |= 0x00000001u;
}
void GetLinkState::clear_has_model_name() {
  _has_bits_[0] &= ~0x00000001u;
}
void GetLinkState::clear_model_name() {
  model_name_.ClearToEmptyNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
  clear_has_model_name();
}
 const ::std::string& GetLinkState::model_name() const {
  // @@protoc_insertion_point(field_get:mw.internal.robotics.gazebotransport.GetLinkState.model_name)
  return model_name_.GetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
 void GetLinkState::set_model_name(const ::std::string& value) {
  set_has_model_name();
  model_name_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), value);
  // @@protoc_insertion_point(field_set:mw.internal.robotics.gazebotransport.GetLinkState.model_name)
}
 void GetLinkState::set_model_name(const char* value) {
  set_has_model_name();
  model_name_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::string(value));
  // @@protoc_insertion_point(field_set_char:mw.internal.robotics.gazebotransport.GetLinkState.model_name)
}
 void GetLinkState::set_model_name(const char* value, size_t size) {
  set_has_model_name();
  model_name_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(),
      ::std::string(reinterpret_cast<const char*>(value), size));
  // @@protoc_insertion_point(field_set_pointer:mw.internal.robotics.gazebotransport.GetLinkState.model_name)
}
 ::std::string* GetLinkState::mutable_model_name() {
  set_has_model_name();
  // @@protoc_insertion_point(field_mutable:mw.internal.robotics.gazebotransport.GetLinkState.model_name)
  return model_name_.MutableNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
 ::std::string* GetLinkState::release_model_name() {
  // @@protoc_insertion_point(field_release:mw.internal.robotics.gazebotransport.GetLinkState.model_name)
  clear_has_model_name();
  return model_name_.ReleaseNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
 void GetLinkState::set_allocated_model_name(::std::string* model_name) {
  if (model_name != NULL) {
    set_has_model_name();
  } else {
    clear_has_model_name();
  }
  model_name_.SetAllocatedNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), model_name);
  // @@protoc_insertion_point(field_set_allocated:mw.internal.robotics.gazebotransport.GetLinkState.model_name)
}

// required string link_name = 2;
bool GetLinkState::has_link_name() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
void GetLinkState::set_has_link_name() {
  _has_bits_[0] |= 0x00000002u;
}
void GetLinkState::clear_has_link_name() {
  _has_bits_[0] &= ~0x00000002u;
}
void GetLinkState::clear_link_name() {
  link_name_.ClearToEmptyNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
  clear_has_link_name();
}
 const ::std::string& GetLinkState::link_name() const {
  // @@protoc_insertion_point(field_get:mw.internal.robotics.gazebotransport.GetLinkState.link_name)
  return link_name_.GetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
 void GetLinkState::set_link_name(const ::std::string& value) {
  set_has_link_name();
  link_name_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), value);
  // @@protoc_insertion_point(field_set:mw.internal.robotics.gazebotransport.GetLinkState.link_name)
}
 void GetLinkState::set_link_name(const char* value) {
  set_has_link_name();
  link_name_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::string(value));
  // @@protoc_insertion_point(field_set_char:mw.internal.robotics.gazebotransport.GetLinkState.link_name)
}
 void GetLinkState::set_link_name(const char* value, size_t size) {
  set_has_link_name();
  link_name_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(),
      ::std::string(reinterpret_cast<const char*>(value), size));
  // @@protoc_insertion_point(field_set_pointer:mw.internal.robotics.gazebotransport.GetLinkState.link_name)
}
 ::std::string* GetLinkState::mutable_link_name() {
  set_has_link_name();
  // @@protoc_insertion_point(field_mutable:mw.internal.robotics.gazebotransport.GetLinkState.link_name)
  return link_name_.MutableNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
 ::std::string* GetLinkState::release_link_name() {
  // @@protoc_insertion_point(field_release:mw.internal.robotics.gazebotransport.GetLinkState.link_name)
  clear_has_link_name();
  return link_name_.ReleaseNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
 void GetLinkState::set_allocated_link_name(::std::string* link_name) {
  if (link_name != NULL) {
    set_has_link_name();
  } else {
    clear_has_link_name();
  }
  link_name_.SetAllocatedNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), link_name);
  // @@protoc_insertion_point(field_set_allocated:mw.internal.robotics.gazebotransport.GetLinkState.link_name)
}

#endif  // PROTOBUF_INLINE_NOT_IN_HEADERS

// ===================================================================

#if !defined(_MSC_VER) || _MSC_VER >= 1900
const int LinkState::kModelNameFieldNumber;
const int LinkState::kLinkNameFieldNumber;
const int LinkState::kLinkIdFieldNumber;
const int LinkState::kWorldLinearVelocityFieldNumber;
const int LinkState::kWorldAngularVelocityFieldNumber;
const int LinkState::kRelativeLinearVelocityFieldNumber;
const int LinkState::kRelativeAngularVelocityFieldNumber;
const int LinkState::kWorldPoseFieldNumber;
const int LinkState::kRelativePoseFieldNumber;
const int LinkState::kSelfCollideFieldNumber;
const int LinkState::kGravityFieldNumber;
const int LinkState::kKinematicFieldNumber;
const int LinkState::kEnableWindFieldNumber;
const int LinkState::kCanonicalFieldNumber;
#endif  // !defined(_MSC_VER) || _MSC_VER >= 1900

LinkState::LinkState()
  : ::google::protobuf::Message(), _internal_metadata_(NULL) {
  SharedCtor();
  // @@protoc_insertion_point(constructor:mw.internal.robotics.gazebotransport.LinkState)
}

void LinkState::InitAsDefaultInstance() {
  world_linear_velocity_ = const_cast< ::mw::internal::robotics::gazebotransport::Point*>(&::mw::internal::robotics::gazebotransport::Point::default_instance());
  world_angular_velocity_ = const_cast< ::mw::internal::robotics::gazebotransport::Point*>(&::mw::internal::robotics::gazebotransport::Point::default_instance());
  relative_linear_velocity_ = const_cast< ::mw::internal::robotics::gazebotransport::Point*>(&::mw::internal::robotics::gazebotransport::Point::default_instance());
  relative_angular_velocity_ = const_cast< ::mw::internal::robotics::gazebotransport::Point*>(&::mw::internal::robotics::gazebotransport::Point::default_instance());
  world_pose_ = const_cast< ::mw::internal::robotics::gazebotransport::Pose*>(&::mw::internal::robotics::gazebotransport::Pose::default_instance());
  relative_pose_ = const_cast< ::mw::internal::robotics::gazebotransport::Pose*>(&::mw::internal::robotics::gazebotransport::Pose::default_instance());
}

LinkState::LinkState(const LinkState& from)
  : ::google::protobuf::Message(),
    _internal_metadata_(NULL) {
  SharedCtor();
  MergeFrom(from);
  // @@protoc_insertion_point(copy_constructor:mw.internal.robotics.gazebotransport.LinkState)
}

void LinkState::SharedCtor() {
  ::google::protobuf::internal::GetEmptyString();
  _cached_size_ = 0;
  model_name_.UnsafeSetDefault(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
  link_name_.UnsafeSetDefault(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
  link_id_ = 0u;
  world_linear_velocity_ = NULL;
  world_angular_velocity_ = NULL;
  relative_linear_velocity_ = NULL;
  relative_angular_velocity_ = NULL;
  world_pose_ = NULL;
  relative_pose_ = NULL;
  self_collide_ = false;
  gravity_ = false;
  kinematic_ = false;
  enable_wind_ = false;
  canonical_ = false;
  ::memset(_has_bits_, 0, sizeof(_has_bits_));
}

LinkState::~LinkState() {
  // @@protoc_insertion_point(destructor:mw.internal.robotics.gazebotransport.LinkState)
  SharedDtor();
}

void LinkState::SharedDtor() {
  model_name_.DestroyNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
  link_name_.DestroyNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
  if (this != default_instance_) {
    delete world_linear_velocity_;
    delete world_angular_velocity_;
    delete relative_linear_velocity_;
    delete relative_angular_velocity_;
    delete world_pose_;
    delete relative_pose_;
  }
}

void LinkState::SetCachedSize(int size) const {
  GOOGLE_SAFE_CONCURRENT_WRITES_BEGIN();
  _cached_size_ = size;
  GOOGLE_SAFE_CONCURRENT_WRITES_END();
}
const ::google::protobuf::Descriptor* LinkState::descriptor() {
  protobuf_AssignDescriptorsOnce();
  return LinkState_descriptor_;
}

const LinkState& LinkState::default_instance() {
  if (default_instance_ == NULL) protobuf_AddDesc_mw_2einternal_2erobotics_2egazebotransport_2eCoSimMsgs_2eproto();
  return *default_instance_;
}

LinkState* LinkState::default_instance_ = NULL;

LinkState* LinkState::New(::google::protobuf::Arena* arena) const {
  LinkState* n = new LinkState;
  if (arena != NULL) {
    arena->Own(n);
  }
  return n;
}

void LinkState::Clear() {
// @@protoc_insertion_point(message_clear_start:mw.internal.robotics.gazebotransport.LinkState)
#if defined(__clang__)
#define ZR_HELPER_(f) \
  _Pragma("clang diagnostic push") \
  _Pragma("clang diagnostic ignored \"-Winvalid-offsetof\"") \
  __builtin_offsetof(LinkState, f) \
  _Pragma("clang diagnostic pop")
#else
#define ZR_HELPER_(f) reinterpret_cast<char*>(\
  &reinterpret_cast<LinkState*>(16)->f)
#endif

#define ZR_(first, last) do {\
  ::memset(&first, 0,\
           ZR_HELPER_(last) - ZR_HELPER_(first) + sizeof(last));\
} while (0)

  if (_has_bits_[0 / 32] & 255u) {
    if (has_model_name()) {
      model_name_.ClearToEmptyNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
    }
    if (has_link_name()) {
      link_name_.ClearToEmptyNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
    }
    link_id_ = 0u;
    if (has_world_linear_velocity()) {
      if (world_linear_velocity_ != NULL) world_linear_velocity_->::mw::internal::robotics::gazebotransport::Point::Clear();
    }
    if (has_world_angular_velocity()) {
      if (world_angular_velocity_ != NULL) world_angular_velocity_->::mw::internal::robotics::gazebotransport::Point::Clear();
    }
    if (has_relative_linear_velocity()) {
      if (relative_linear_velocity_ != NULL) relative_linear_velocity_->::mw::internal::robotics::gazebotransport::Point::Clear();
    }
    if (has_relative_angular_velocity()) {
      if (relative_angular_velocity_ != NULL) relative_angular_velocity_->::mw::internal::robotics::gazebotransport::Point::Clear();
    }
    if (has_world_pose()) {
      if (world_pose_ != NULL) world_pose_->::mw::internal::robotics::gazebotransport::Pose::Clear();
    }
  }
  if (_has_bits_[8 / 32] & 16128u) {
    ZR_(self_collide_, canonical_);
    if (has_relative_pose()) {
      if (relative_pose_ != NULL) relative_pose_->::mw::internal::robotics::gazebotransport::Pose::Clear();
    }
  }

#undef ZR_HELPER_
#undef ZR_

  ::memset(_has_bits_, 0, sizeof(_has_bits_));
  if (_internal_metadata_.have_unknown_fields()) {
    mutable_unknown_fields()->Clear();
  }
}

bool LinkState::MergePartialFromCodedStream(
    ::google::protobuf::io::CodedInputStream* input) {
#define DO_(EXPRESSION) if (!GOOGLE_PREDICT_TRUE(EXPRESSION)) goto failure
  ::google::protobuf::uint32 tag;
  // @@protoc_insertion_point(parse_start:mw.internal.robotics.gazebotransport.LinkState)
  for (;;) {
    ::std::pair< ::google::protobuf::uint32, bool> p = input->ReadTagWithCutoff(127);
    tag = p.first;
    if (!p.second) goto handle_unusual;
    switch (::google::protobuf::internal::WireFormatLite::GetTagFieldNumber(tag)) {
      // required string model_name = 1;
      case 1: {
        if (tag == 10) {
          DO_(::google::protobuf::internal::WireFormatLite::ReadString(
                input, this->mutable_model_name()));
          ::google::protobuf::internal::WireFormat::VerifyUTF8StringNamedField(
            this->model_name().data(), this->model_name().length(),
            ::google::protobuf::internal::WireFormat::PARSE,
            "mw.internal.robotics.gazebotransport.LinkState.model_name");
        } else {
          goto handle_unusual;
        }
        if (input->ExpectTag(18)) goto parse_link_name;
        break;
      }

      // required string link_name = 2;
      case 2: {
        if (tag == 18) {
         parse_link_name:
          DO_(::google::protobuf::internal::WireFormatLite::ReadString(
                input, this->mutable_link_name()));
          ::google::protobuf::internal::WireFormat::VerifyUTF8StringNamedField(
            this->link_name().data(), this->link_name().length(),
            ::google::protobuf::internal::WireFormat::PARSE,
            "mw.internal.robotics.gazebotransport.LinkState.link_name");
        } else {
          goto handle_unusual;
        }
        if (input->ExpectTag(24)) goto parse_link_id;
        break;
      }

      // required uint32 link_id = 3;
      case 3: {
        if (tag == 24) {
         parse_link_id:
          DO_((::google::protobuf::internal::WireFormatLite::ReadPrimitive<
                   ::google::protobuf::uint32, ::google::protobuf::internal::WireFormatLite::TYPE_UINT32>(
                 input, &link_id_)));
          set_has_link_id();
        } else {
          goto handle_unusual;
        }
        if (input->ExpectTag(34)) goto parse_world_linear_velocity;
        break;
      }

      // required .mw.internal.robotics.gazebotransport.Point world_linear_velocity = 4;
      case 4: {
        if (tag == 34) {
         parse_world_linear_velocity:
          DO_(::google::protobuf::internal::WireFormatLite::ReadMessageNoVirtual(
               input, mutable_world_linear_velocity()));
        } else {
          goto handle_unusual;
        }
        if (input->ExpectTag(42)) goto parse_world_angular_velocity;
        break;
      }

      // required .mw.internal.robotics.gazebotransport.Point world_angular_velocity = 5;
      case 5: {
        if (tag == 42) {
         parse_world_angular_velocity:
          DO_(::google::protobuf::internal::WireFormatLite::ReadMessageNoVirtual(
               input, mutable_world_angular_velocity()));
        } else {
          goto handle_unusual;
        }
        if (input->ExpectTag(50)) goto parse_relative_linear_velocity;
        break;
      }

      // required .mw.internal.robotics.gazebotransport.Point relative_linear_velocity = 6;
      case 6: {
        if (tag == 50) {
         parse_relative_linear_velocity:
          DO_(::google::protobuf::internal::WireFormatLite::ReadMessageNoVirtual(
               input, mutable_relative_linear_velocity()));
        } else {
          goto handle_unusual;
        }
        if (input->ExpectTag(58)) goto parse_relative_angular_velocity;
        break;
      }

      // required .mw.internal.robotics.gazebotransport.Point relative_angular_velocity = 7;
      case 7: {
        if (tag == 58) {
         parse_relative_angular_velocity:
          DO_(::google::protobuf::internal::WireFormatLite::ReadMessageNoVirtual(
               input, mutable_relative_angular_velocity()));
        } else {
          goto handle_unusual;
        }
        if (input->ExpectTag(66)) goto parse_world_pose;
        break;
      }

      // optional .mw.internal.robotics.gazebotransport.Pose world_pose = 8;
      case 8: {
        if (tag == 66) {
         parse_world_pose:
          DO_(::google::protobuf::internal::WireFormatLite::ReadMessageNoVirtual(
               input, mutable_world_pose()));
        } else {
          goto handle_unusual;
        }
        if (input->ExpectTag(74)) goto parse_relative_pose;
        break;
      }

      // optional .mw.internal.robotics.gazebotransport.Pose relative_pose = 9;
      case 9: {
        if (tag == 74) {
         parse_relative_pose:
          DO_(::google::protobuf::internal::WireFormatLite::ReadMessageNoVirtual(
               input, mutable_relative_pose()));
        } else {
          goto handle_unusual;
        }
        if (input->ExpectTag(80)) goto parse_self_collide;
        break;
      }

      // optional bool self_collide = 10;
      case 10: {
        if (tag == 80) {
         parse_self_collide:
          DO_((::google::protobuf::internal::WireFormatLite::ReadPrimitive<
                   bool, ::google::protobuf::internal::WireFormatLite::TYPE_BOOL>(
                 input, &self_collide_)));
          set_has_self_collide();
        } else {
          goto handle_unusual;
        }
        if (input->ExpectTag(88)) goto parse_gravity;
        break;
      }

      // optional bool gravity = 11;
      case 11: {
        if (tag == 88) {
         parse_gravity:
          DO_((::google::protobuf::internal::WireFormatLite::ReadPrimitive<
                   bool, ::google::protobuf::internal::WireFormatLite::TYPE_BOOL>(
                 input, &gravity_)));
          set_has_gravity();
        } else {
          goto handle_unusual;
        }
        if (input->ExpectTag(96)) goto parse_kinematic;
        break;
      }

      // optional bool kinematic = 12;
      case 12: {
        if (tag == 96) {
         parse_kinematic:
          DO_((::google::protobuf::internal::WireFormatLite::ReadPrimitive<
                   bool, ::google::protobuf::internal::WireFormatLite::TYPE_BOOL>(
                 input, &kinematic_)));
          set_has_kinematic();
        } else {
          goto handle_unusual;
        }
        if (input->ExpectTag(104)) goto parse_enable_wind;
        break;
      }

      // optional bool enable_wind = 13;
      case 13: {
        if (tag == 104) {
         parse_enable_wind:
          DO_((::google::protobuf::internal::WireFormatLite::ReadPrimitive<
                   bool, ::google::protobuf::internal::WireFormatLite::TYPE_BOOL>(
                 input, &enable_wind_)));
          set_has_enable_wind();
        } else {
          goto handle_unusual;
        }
        if (input->ExpectTag(112)) goto parse_canonical;
        break;
      }

      // optional bool canonical = 14;
      case 14: {
        if (tag == 112) {
         parse_canonical:
          DO_((::google::protobuf::internal::WireFormatLite::ReadPrimitive<
                   bool, ::google::protobuf::internal::WireFormatLite::TYPE_BOOL>(
                 input, &canonical_)));
          set_has_canonical();
        } else {
          goto handle_unusual;
        }
        if (input->ExpectAtEnd()) goto success;
        break;
      }

      default: {
      handle_unusual:
        if (tag == 0 ||
            ::google::protobuf::internal::WireFormatLite::GetTagWireType(tag) ==
            ::google::protobuf::internal::WireFormatLite::WIRETYPE_END_GROUP) {
          goto success;
        }
        DO_(::google::protobuf::internal::WireFormat::SkipField(
              input, tag, mutable_unknown_fields()));
        break;
      }
    }
  }
success:
  // @@protoc_insertion_point(parse_success:mw.internal.robotics.gazebotransport.LinkState)
  return true;
failure:
  // @@protoc_insertion_point(parse_failure:mw.internal.robotics.gazebotransport.LinkState)
  return false;
#undef DO_
}

void LinkState::SerializeWithCachedSizes(
    ::google::protobuf::io::CodedOutputStream* output) const {
  // @@protoc_insertion_point(serialize_start:mw.internal.robotics.gazebotransport.LinkState)
  // required string model_name = 1;
  if (has_model_name()) {
    ::google::protobuf::internal::WireFormat::VerifyUTF8StringNamedField(
      this->model_name().data(), this->model_name().length(),
      ::google::protobuf::internal::WireFormat::SERIALIZE,
      "mw.internal.robotics.gazebotransport.LinkState.model_name");
    ::google::protobuf::internal::WireFormatLite::WriteStringMaybeAliased(
      1, this->model_name(), output);
  }

  // required string link_name = 2;
  if (has_link_name()) {
    ::google::protobuf::internal::WireFormat::VerifyUTF8StringNamedField(
      this->link_name().data(), this->link_name().length(),
      ::google::protobuf::internal::WireFormat::SERIALIZE,
      "mw.internal.robotics.gazebotransport.LinkState.link_name");
    ::google::protobuf::internal::WireFormatLite::WriteStringMaybeAliased(
      2, this->link_name(), output);
  }

  // required uint32 link_id = 3;
  if (has_link_id()) {
    ::google::protobuf::internal::WireFormatLite::WriteUInt32(3, this->link_id(), output);
  }

  // required .mw.internal.robotics.gazebotransport.Point world_linear_velocity = 4;
  if (has_world_linear_velocity()) {
    ::google::protobuf::internal::WireFormatLite::WriteMessageMaybeToArray(
      4, *this->world_linear_velocity_, output);
  }

  // required .mw.internal.robotics.gazebotransport.Point world_angular_velocity = 5;
  if (has_world_angular_velocity()) {
    ::google::protobuf::internal::WireFormatLite::WriteMessageMaybeToArray(
      5, *this->world_angular_velocity_, output);
  }

  // required .mw.internal.robotics.gazebotransport.Point relative_linear_velocity = 6;
  if (has_relative_linear_velocity()) {
    ::google::protobuf::internal::WireFormatLite::WriteMessageMaybeToArray(
      6, *this->relative_linear_velocity_, output);
  }

  // required .mw.internal.robotics.gazebotransport.Point relative_angular_velocity = 7;
  if (has_relative_angular_velocity()) {
    ::google::protobuf::internal::WireFormatLite::WriteMessageMaybeToArray(
      7, *this->relative_angular_velocity_, output);
  }

  // optional .mw.internal.robotics.gazebotransport.Pose world_pose = 8;
  if (has_world_pose()) {
    ::google::protobuf::internal::WireFormatLite::WriteMessageMaybeToArray(
      8, *this->world_pose_, output);
  }

  // optional .mw.internal.robotics.gazebotransport.Pose relative_pose = 9;
  if (has_relative_pose()) {
    ::google::protobuf::internal::WireFormatLite::WriteMessageMaybeToArray(
      9, *this->relative_pose_, output);
  }

  // optional bool self_collide = 10;
  if (has_self_collide()) {
    ::google::protobuf::internal::WireFormatLite::WriteBool(10, this->self_collide(), output);
  }

  // optional bool gravity = 11;
  if (has_gravity()) {
    ::google::protobuf::internal::WireFormatLite::WriteBool(11, this->gravity(), output);
  }

  // optional bool kinematic = 12;
  if (has_kinematic()) {
    ::google::protobuf::internal::WireFormatLite::WriteBool(12, this->kinematic(), output);
  }

  // optional bool enable_wind = 13;
  if (has_enable_wind()) {
    ::google::protobuf::internal::WireFormatLite::WriteBool(13, this->enable_wind(), output);
  }

  // optional bool canonical = 14;
  if (has_canonical()) {
    ::google::protobuf::internal::WireFormatLite::WriteBool(14, this->canonical(), output);
  }

  if (_internal_metadata_.have_unknown_fields()) {
    ::google::protobuf::internal::WireFormat::SerializeUnknownFields(
        unknown_fields(), output);
  }
  // @@protoc_insertion_point(serialize_end:mw.internal.robotics.gazebotransport.LinkState)
}

::google::protobuf::uint8* LinkState::InternalSerializeWithCachedSizesToArray(
    bool deterministic, ::google::protobuf::uint8* target) const {
  // @@protoc_insertion_point(serialize_to_array_start:mw.internal.robotics.gazebotransport.LinkState)
  // required string model_name = 1;
  if (has_model_name()) {
    ::google::protobuf::internal::WireFormat::VerifyUTF8StringNamedField(
      this->model_name().data(), this->model_name().length(),
      ::google::protobuf::internal::WireFormat::SERIALIZE,
      "mw.internal.robotics.gazebotransport.LinkState.model_name");
    target =
      ::google::protobuf::internal::WireFormatLite::WriteStringToArray(
        1, this->model_name(), target);
  }

  // required string link_name = 2;
  if (has_link_name()) {
    ::google::protobuf::internal::WireFormat::VerifyUTF8StringNamedField(
      this->link_name().data(), this->link_name().length(),
      ::google::protobuf::internal::WireFormat::SERIALIZE,
      "mw.internal.robotics.gazebotransport.LinkState.link_name");
    target =
      ::google::protobuf::internal::WireFormatLite::WriteStringToArray(
        2, this->link_name(), target);
  }

  // required uint32 link_id = 3;
  if (has_link_id()) {
    target = ::google::protobuf::internal::WireFormatLite::WriteUInt32ToArray(3, this->link_id(), target);
  }

  // required .mw.internal.robotics.gazebotransport.Point world_linear_velocity = 4;
  if (has_world_linear_velocity()) {
    target = ::google::protobuf::internal::WireFormatLite::
      InternalWriteMessageNoVirtualToArray(
        4, *this->world_linear_velocity_, false, target);
  }

  // required .mw.internal.robotics.gazebotransport.Point world_angular_velocity = 5;
  if (has_world_angular_velocity()) {
    target = ::google::protobuf::internal::WireFormatLite::
      InternalWriteMessageNoVirtualToArray(
        5, *this->world_angular_velocity_, false, target);
  }

  // required .mw.internal.robotics.gazebotransport.Point relative_linear_velocity = 6;
  if (has_relative_linear_velocity()) {
    target = ::google::protobuf::internal::WireFormatLite::
      InternalWriteMessageNoVirtualToArray(
        6, *this->relative_linear_velocity_, false, target);
  }

  // required .mw.internal.robotics.gazebotransport.Point relative_angular_velocity = 7;
  if (has_relative_angular_velocity()) {
    target = ::google::protobuf::internal::WireFormatLite::
      InternalWriteMessageNoVirtualToArray(
        7, *this->relative_angular_velocity_, false, target);
  }

  // optional .mw.internal.robotics.gazebotransport.Pose world_pose = 8;
  if (has_world_pose()) {
    target = ::google::protobuf::internal::WireFormatLite::
      InternalWriteMessageNoVirtualToArray(
        8, *this->world_pose_, false, target);
  }

  // optional .mw.internal.robotics.gazebotransport.Pose relative_pose = 9;
  if (has_relative_pose()) {
    target = ::google::protobuf::internal::WireFormatLite::
      InternalWriteMessageNoVirtualToArray(
        9, *this->relative_pose_, false, target);
  }

  // optional bool self_collide = 10;
  if (has_self_collide()) {
    target = ::google::protobuf::internal::WireFormatLite::WriteBoolToArray(10, this->self_collide(), target);
  }

  // optional bool gravity = 11;
  if (has_gravity()) {
    target = ::google::protobuf::internal::WireFormatLite::WriteBoolToArray(11, this->gravity(), target);
  }

  // optional bool kinematic = 12;
  if (has_kinematic()) {
    target = ::google::protobuf::internal::WireFormatLite::WriteBoolToArray(12, this->kinematic(), target);
  }

  // optional bool enable_wind = 13;
  if (has_enable_wind()) {
    target = ::google::protobuf::internal::WireFormatLite::WriteBoolToArray(13, this->enable_wind(), target);
  }

  // optional bool canonical = 14;
  if (has_canonical()) {
    target = ::google::protobuf::internal::WireFormatLite::WriteBoolToArray(14, this->canonical(), target);
  }

  if (_internal_metadata_.have_unknown_fields()) {
    target = ::google::protobuf::internal::WireFormat::SerializeUnknownFieldsToArray(
        unknown_fields(), target);
  }
  // @@protoc_insertion_point(serialize_to_array_end:mw.internal.robotics.gazebotransport.LinkState)
  return target;
}

int LinkState::RequiredFieldsByteSizeFallback() const {
// @@protoc_insertion_point(required_fields_byte_size_fallback_start:mw.internal.robotics.gazebotransport.LinkState)
  int total_size = 0;

  if (has_model_name()) {
    // required string model_name = 1;
    total_size += 1 +
      ::google::protobuf::internal::WireFormatLite::StringSize(
        this->model_name());
  }

  if (has_link_name()) {
    // required string link_name = 2;
    total_size += 1 +
      ::google::protobuf::internal::WireFormatLite::StringSize(
        this->link_name());
  }

  if (has_link_id()) {
    // required uint32 link_id = 3;
    total_size += 1 +
      ::google::protobuf::internal::WireFormatLite::UInt32Size(
        this->link_id());
  }

  if (has_world_linear_velocity()) {
    // required .mw.internal.robotics.gazebotransport.Point world_linear_velocity = 4;
    total_size += 1 +
      ::google::protobuf::internal::WireFormatLite::MessageSizeNoVirtual(
        *this->world_linear_velocity_);
  }

  if (has_world_angular_velocity()) {
    // required .mw.internal.robotics.gazebotransport.Point world_angular_velocity = 5;
    total_size += 1 +
      ::google::protobuf::internal::WireFormatLite::MessageSizeNoVirtual(
        *this->world_angular_velocity_);
  }

  if (has_relative_linear_velocity()) {
    // required .mw.internal.robotics.gazebotransport.Point relative_linear_velocity = 6;
    total_size += 1 +
      ::google::protobuf::internal::WireFormatLite::MessageSizeNoVirtual(
        *this->relative_linear_velocity_);
  }

  if (has_relative_angular_velocity()) {
    // required .mw.internal.robotics.gazebotransport.Point relative_angular_velocity = 7;
    total_size += 1 +
      ::google::protobuf::internal::WireFormatLite::MessageSizeNoVirtual(
        *this->relative_angular_velocity_);
  }

  return total_size;
}
int LinkState::ByteSize() const {
// @@protoc_insertion_point(message_byte_size_start:mw.internal.robotics.gazebotransport.LinkState)
  int total_size = 0;

  if (((_has_bits_[0] & 0x0000007f) ^ 0x0000007f) == 0) {  // All required fields are present.
    // required string model_name = 1;
    total_size += 1 +
      ::google::protobuf::internal::WireFormatLite::StringSize(
        this->model_name());

    // required string link_name = 2;
    total_size += 1 +
      ::google::protobuf::internal::WireFormatLite::StringSize(
        this->link_name());

    // required uint32 link_id = 3;
    total_size += 1 +
      ::google::protobuf::internal::WireFormatLite::UInt32Size(
        this->link_id());

    // required .mw.internal.robotics.gazebotransport.Point world_linear_velocity = 4;
    total_size += 1 +
      ::google::protobuf::internal::WireFormatLite::MessageSizeNoVirtual(
        *this->world_linear_velocity_);

    // required .mw.internal.robotics.gazebotransport.Point world_angular_velocity = 5;
    total_size += 1 +
      ::google::protobuf::internal::WireFormatLite::MessageSizeNoVirtual(
        *this->world_angular_velocity_);

    // required .mw.internal.robotics.gazebotransport.Point relative_linear_velocity = 6;
    total_size += 1 +
      ::google::protobuf::internal::WireFormatLite::MessageSizeNoVirtual(
        *this->relative_linear_velocity_);

    // required .mw.internal.robotics.gazebotransport.Point relative_angular_velocity = 7;
    total_size += 1 +
      ::google::protobuf::internal::WireFormatLite::MessageSizeNoVirtual(
        *this->relative_angular_velocity_);

  } else {
    total_size += RequiredFieldsByteSizeFallback();
  }
  // optional .mw.internal.robotics.gazebotransport.Pose world_pose = 8;
  if (has_world_pose()) {
    total_size += 1 +
      ::google::protobuf::internal::WireFormatLite::MessageSizeNoVirtual(
        *this->world_pose_);
  }

  if (_has_bits_[8 / 32] & 16128u) {
    // optional .mw.internal.robotics.gazebotransport.Pose relative_pose = 9;
    if (has_relative_pose()) {
      total_size += 1 +
        ::google::protobuf::internal::WireFormatLite::MessageSizeNoVirtual(
          *this->relative_pose_);
    }

    // optional bool self_collide = 10;
    if (has_self_collide()) {
      total_size += 1 + 1;
    }

    // optional bool gravity = 11;
    if (has_gravity()) {
      total_size += 1 + 1;
    }

    // optional bool kinematic = 12;
    if (has_kinematic()) {
      total_size += 1 + 1;
    }

    // optional bool enable_wind = 13;
    if (has_enable_wind()) {
      total_size += 1 + 1;
    }

    // optional bool canonical = 14;
    if (has_canonical()) {
      total_size += 1 + 1;
    }

  }
  if (_internal_metadata_.have_unknown_fields()) {
    total_size +=
      ::google::protobuf::internal::WireFormat::ComputeUnknownFieldsSize(
        unknown_fields());
  }
  GOOGLE_SAFE_CONCURRENT_WRITES_BEGIN();
  _cached_size_ = total_size;
  GOOGLE_SAFE_CONCURRENT_WRITES_END();
  return total_size;
}

void LinkState::MergeFrom(const ::google::protobuf::Message& from) {
// @@protoc_insertion_point(generalized_merge_from_start:mw.internal.robotics.gazebotransport.LinkState)
  if (GOOGLE_PREDICT_FALSE(&from == this)) {
    ::google::protobuf::internal::MergeFromFail(__FILE__, __LINE__);
  }
  const LinkState* source = 
      ::google::protobuf::internal::DynamicCastToGenerated<const LinkState>(
          &from);
  if (source == NULL) {
  // @@protoc_insertion_point(generalized_merge_from_cast_fail:mw.internal.robotics.gazebotransport.LinkState)
    ::google::protobuf::internal::ReflectionOps::Merge(from, this);
  } else {
  // @@protoc_insertion_point(generalized_merge_from_cast_success:mw.internal.robotics.gazebotransport.LinkState)
    MergeFrom(*source);
  }
}

void LinkState::MergeFrom(const LinkState& from) {
// @@protoc_insertion_point(class_specific_merge_from_start:mw.internal.robotics.gazebotransport.LinkState)
  if (GOOGLE_PREDICT_FALSE(&from == this)) {
    ::google::protobuf::internal::MergeFromFail(__FILE__, __LINE__);
  }
  if (from._has_bits_[0 / 32] & (0xffu << (0 % 32))) {
    if (from.has_model_name()) {
      set_has_model_name();
      model_name_.AssignWithDefault(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), from.model_name_);
    }
    if (from.has_link_name()) {
      set_has_link_name();
      link_name_.AssignWithDefault(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), from.link_name_);
    }
    if (from.has_link_id()) {
      set_link_id(from.link_id());
    }
    if (from.has_world_linear_velocity()) {
      mutable_world_linear_velocity()->::mw::internal::robotics::gazebotransport::Point::MergeFrom(from.world_linear_velocity());
    }
    if (from.has_world_angular_velocity()) {
      mutable_world_angular_velocity()->::mw::internal::robotics::gazebotransport::Point::MergeFrom(from.world_angular_velocity());
    }
    if (from.has_relative_linear_velocity()) {
      mutable_relative_linear_velocity()->::mw::internal::robotics::gazebotransport::Point::MergeFrom(from.relative_linear_velocity());
    }
    if (from.has_relative_angular_velocity()) {
      mutable_relative_angular_velocity()->::mw::internal::robotics::gazebotransport::Point::MergeFrom(from.relative_angular_velocity());
    }
    if (from.has_world_pose()) {
      mutable_world_pose()->::mw::internal::robotics::gazebotransport::Pose::MergeFrom(from.world_pose());
    }
  }
  if (from._has_bits_[8 / 32] & (0xffu << (8 % 32))) {
    if (from.has_relative_pose()) {
      mutable_relative_pose()->::mw::internal::robotics::gazebotransport::Pose::MergeFrom(from.relative_pose());
    }
    if (from.has_self_collide()) {
      set_self_collide(from.self_collide());
    }
    if (from.has_gravity()) {
      set_gravity(from.gravity());
    }
    if (from.has_kinematic()) {
      set_kinematic(from.kinematic());
    }
    if (from.has_enable_wind()) {
      set_enable_wind(from.enable_wind());
    }
    if (from.has_canonical()) {
      set_canonical(from.canonical());
    }
  }
  if (from._internal_metadata_.have_unknown_fields()) {
    mutable_unknown_fields()->MergeFrom(from.unknown_fields());
  }
}

void LinkState::CopyFrom(const ::google::protobuf::Message& from) {
// @@protoc_insertion_point(generalized_copy_from_start:mw.internal.robotics.gazebotransport.LinkState)
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

void LinkState::CopyFrom(const LinkState& from) {
// @@protoc_insertion_point(class_specific_copy_from_start:mw.internal.robotics.gazebotransport.LinkState)
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

bool LinkState::IsInitialized() const {
  if ((_has_bits_[0] & 0x0000007f) != 0x0000007f) return false;

  if (has_world_linear_velocity()) {
    if (!this->world_linear_velocity_->IsInitialized()) return false;
  }
  if (has_world_angular_velocity()) {
    if (!this->world_angular_velocity_->IsInitialized()) return false;
  }
  if (has_relative_linear_velocity()) {
    if (!this->relative_linear_velocity_->IsInitialized()) return false;
  }
  if (has_relative_angular_velocity()) {
    if (!this->relative_angular_velocity_->IsInitialized()) return false;
  }
  if (has_world_pose()) {
    if (!this->world_pose_->IsInitialized()) return false;
  }
  if (has_relative_pose()) {
    if (!this->relative_pose_->IsInitialized()) return false;
  }
  return true;
}

void LinkState::Swap(LinkState* other) {
  if (other == this) return;
  InternalSwap(other);
}
void LinkState::InternalSwap(LinkState* other) {
  model_name_.Swap(&other->model_name_);
  link_name_.Swap(&other->link_name_);
  std::swap(link_id_, other->link_id_);
  std::swap(world_linear_velocity_, other->world_linear_velocity_);
  std::swap(world_angular_velocity_, other->world_angular_velocity_);
  std::swap(relative_linear_velocity_, other->relative_linear_velocity_);
  std::swap(relative_angular_velocity_, other->relative_angular_velocity_);
  std::swap(world_pose_, other->world_pose_);
  std::swap(relative_pose_, other->relative_pose_);
  std::swap(self_collide_, other->self_collide_);
  std::swap(gravity_, other->gravity_);
  std::swap(kinematic_, other->kinematic_);
  std::swap(enable_wind_, other->enable_wind_);
  std::swap(canonical_, other->canonical_);
  std::swap(_has_bits_[0], other->_has_bits_[0]);
  _internal_metadata_.Swap(&other->_internal_metadata_);
  std::swap(_cached_size_, other->_cached_size_);
}

::google::protobuf::Metadata LinkState::GetMetadata() const {
  protobuf_AssignDescriptorsOnce();
  ::google::protobuf::Metadata metadata;
  metadata.descriptor = LinkState_descriptor_;
  metadata.reflection = LinkState_reflection_;
  return metadata;
}

#if PROTOBUF_INLINE_NOT_IN_HEADERS
// LinkState

// required string model_name = 1;
bool LinkState::has_model_name() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
void LinkState::set_has_model_name() {
  _has_bits_[0] |= 0x00000001u;
}
void LinkState::clear_has_model_name() {
  _has_bits_[0] &= ~0x00000001u;
}
void LinkState::clear_model_name() {
  model_name_.ClearToEmptyNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
  clear_has_model_name();
}
 const ::std::string& LinkState::model_name() const {
  // @@protoc_insertion_point(field_get:mw.internal.robotics.gazebotransport.LinkState.model_name)
  return model_name_.GetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
 void LinkState::set_model_name(const ::std::string& value) {
  set_has_model_name();
  model_name_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), value);
  // @@protoc_insertion_point(field_set:mw.internal.robotics.gazebotransport.LinkState.model_name)
}
 void LinkState::set_model_name(const char* value) {
  set_has_model_name();
  model_name_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::string(value));
  // @@protoc_insertion_point(field_set_char:mw.internal.robotics.gazebotransport.LinkState.model_name)
}
 void LinkState::set_model_name(const char* value, size_t size) {
  set_has_model_name();
  model_name_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(),
      ::std::string(reinterpret_cast<const char*>(value), size));
  // @@protoc_insertion_point(field_set_pointer:mw.internal.robotics.gazebotransport.LinkState.model_name)
}
 ::std::string* LinkState::mutable_model_name() {
  set_has_model_name();
  // @@protoc_insertion_point(field_mutable:mw.internal.robotics.gazebotransport.LinkState.model_name)
  return model_name_.MutableNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
 ::std::string* LinkState::release_model_name() {
  // @@protoc_insertion_point(field_release:mw.internal.robotics.gazebotransport.LinkState.model_name)
  clear_has_model_name();
  return model_name_.ReleaseNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
 void LinkState::set_allocated_model_name(::std::string* model_name) {
  if (model_name != NULL) {
    set_has_model_name();
  } else {
    clear_has_model_name();
  }
  model_name_.SetAllocatedNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), model_name);
  // @@protoc_insertion_point(field_set_allocated:mw.internal.robotics.gazebotransport.LinkState.model_name)
}

// required string link_name = 2;
bool LinkState::has_link_name() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
void LinkState::set_has_link_name() {
  _has_bits_[0] |= 0x00000002u;
}
void LinkState::clear_has_link_name() {
  _has_bits_[0] &= ~0x00000002u;
}
void LinkState::clear_link_name() {
  link_name_.ClearToEmptyNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
  clear_has_link_name();
}
 const ::std::string& LinkState::link_name() const {
  // @@protoc_insertion_point(field_get:mw.internal.robotics.gazebotransport.LinkState.link_name)
  return link_name_.GetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
 void LinkState::set_link_name(const ::std::string& value) {
  set_has_link_name();
  link_name_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), value);
  // @@protoc_insertion_point(field_set:mw.internal.robotics.gazebotransport.LinkState.link_name)
}
 void LinkState::set_link_name(const char* value) {
  set_has_link_name();
  link_name_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::string(value));
  // @@protoc_insertion_point(field_set_char:mw.internal.robotics.gazebotransport.LinkState.link_name)
}
 void LinkState::set_link_name(const char* value, size_t size) {
  set_has_link_name();
  link_name_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(),
      ::std::string(reinterpret_cast<const char*>(value), size));
  // @@protoc_insertion_point(field_set_pointer:mw.internal.robotics.gazebotransport.LinkState.link_name)
}
 ::std::string* LinkState::mutable_link_name() {
  set_has_link_name();
  // @@protoc_insertion_point(field_mutable:mw.internal.robotics.gazebotransport.LinkState.link_name)
  return link_name_.MutableNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
 ::std::string* LinkState::release_link_name() {
  // @@protoc_insertion_point(field_release:mw.internal.robotics.gazebotransport.LinkState.link_name)
  clear_has_link_name();
  return link_name_.ReleaseNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
 void LinkState::set_allocated_link_name(::std::string* link_name) {
  if (link_name != NULL) {
    set_has_link_name();
  } else {
    clear_has_link_name();
  }
  link_name_.SetAllocatedNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), link_name);
  // @@protoc_insertion_point(field_set_allocated:mw.internal.robotics.gazebotransport.LinkState.link_name)
}

// required uint32 link_id = 3;
bool LinkState::has_link_id() const {
  return (_has_bits_[0] & 0x00000004u) != 0;
}
void LinkState::set_has_link_id() {
  _has_bits_[0] |= 0x00000004u;
}
void LinkState::clear_has_link_id() {
  _has_bits_[0] &= ~0x00000004u;
}
void LinkState::clear_link_id() {
  link_id_ = 0u;
  clear_has_link_id();
}
 ::google::protobuf::uint32 LinkState::link_id() const {
  // @@protoc_insertion_point(field_get:mw.internal.robotics.gazebotransport.LinkState.link_id)
  return link_id_;
}
 void LinkState::set_link_id(::google::protobuf::uint32 value) {
  set_has_link_id();
  link_id_ = value;
  // @@protoc_insertion_point(field_set:mw.internal.robotics.gazebotransport.LinkState.link_id)
}

// required .mw.internal.robotics.gazebotransport.Point world_linear_velocity = 4;
bool LinkState::has_world_linear_velocity() const {
  return (_has_bits_[0] & 0x00000008u) != 0;
}
void LinkState::set_has_world_linear_velocity() {
  _has_bits_[0] |= 0x00000008u;
}
void LinkState::clear_has_world_linear_velocity() {
  _has_bits_[0] &= ~0x00000008u;
}
void LinkState::clear_world_linear_velocity() {
  if (world_linear_velocity_ != NULL) world_linear_velocity_->::mw::internal::robotics::gazebotransport::Point::Clear();
  clear_has_world_linear_velocity();
}
const ::mw::internal::robotics::gazebotransport::Point& LinkState::world_linear_velocity() const {
  // @@protoc_insertion_point(field_get:mw.internal.robotics.gazebotransport.LinkState.world_linear_velocity)
  return world_linear_velocity_ != NULL ? *world_linear_velocity_ : *default_instance_->world_linear_velocity_;
}
::mw::internal::robotics::gazebotransport::Point* LinkState::mutable_world_linear_velocity() {
  set_has_world_linear_velocity();
  if (world_linear_velocity_ == NULL) {
    world_linear_velocity_ = new ::mw::internal::robotics::gazebotransport::Point;
  }
  // @@protoc_insertion_point(field_mutable:mw.internal.robotics.gazebotransport.LinkState.world_linear_velocity)
  return world_linear_velocity_;
}
::mw::internal::robotics::gazebotransport::Point* LinkState::release_world_linear_velocity() {
  // @@protoc_insertion_point(field_release:mw.internal.robotics.gazebotransport.LinkState.world_linear_velocity)
  clear_has_world_linear_velocity();
  ::mw::internal::robotics::gazebotransport::Point* temp = world_linear_velocity_;
  world_linear_velocity_ = NULL;
  return temp;
}
void LinkState::set_allocated_world_linear_velocity(::mw::internal::robotics::gazebotransport::Point* world_linear_velocity) {
  delete world_linear_velocity_;
  world_linear_velocity_ = world_linear_velocity;
  if (world_linear_velocity) {
    set_has_world_linear_velocity();
  } else {
    clear_has_world_linear_velocity();
  }
  // @@protoc_insertion_point(field_set_allocated:mw.internal.robotics.gazebotransport.LinkState.world_linear_velocity)
}

// required .mw.internal.robotics.gazebotransport.Point world_angular_velocity = 5;
bool LinkState::has_world_angular_velocity() const {
  return (_has_bits_[0] & 0x00000010u) != 0;
}
void LinkState::set_has_world_angular_velocity() {
  _has_bits_[0] |= 0x00000010u;
}
void LinkState::clear_has_world_angular_velocity() {
  _has_bits_[0] &= ~0x00000010u;
}
void LinkState::clear_world_angular_velocity() {
  if (world_angular_velocity_ != NULL) world_angular_velocity_->::mw::internal::robotics::gazebotransport::Point::Clear();
  clear_has_world_angular_velocity();
}
const ::mw::internal::robotics::gazebotransport::Point& LinkState::world_angular_velocity() const {
  // @@protoc_insertion_point(field_get:mw.internal.robotics.gazebotransport.LinkState.world_angular_velocity)
  return world_angular_velocity_ != NULL ? *world_angular_velocity_ : *default_instance_->world_angular_velocity_;
}
::mw::internal::robotics::gazebotransport::Point* LinkState::mutable_world_angular_velocity() {
  set_has_world_angular_velocity();
  if (world_angular_velocity_ == NULL) {
    world_angular_velocity_ = new ::mw::internal::robotics::gazebotransport::Point;
  }
  // @@protoc_insertion_point(field_mutable:mw.internal.robotics.gazebotransport.LinkState.world_angular_velocity)
  return world_angular_velocity_;
}
::mw::internal::robotics::gazebotransport::Point* LinkState::release_world_angular_velocity() {
  // @@protoc_insertion_point(field_release:mw.internal.robotics.gazebotransport.LinkState.world_angular_velocity)
  clear_has_world_angular_velocity();
  ::mw::internal::robotics::gazebotransport::Point* temp = world_angular_velocity_;
  world_angular_velocity_ = NULL;
  return temp;
}
void LinkState::set_allocated_world_angular_velocity(::mw::internal::robotics::gazebotransport::Point* world_angular_velocity) {
  delete world_angular_velocity_;
  world_angular_velocity_ = world_angular_velocity;
  if (world_angular_velocity) {
    set_has_world_angular_velocity();
  } else {
    clear_has_world_angular_velocity();
  }
  // @@protoc_insertion_point(field_set_allocated:mw.internal.robotics.gazebotransport.LinkState.world_angular_velocity)
}

// required .mw.internal.robotics.gazebotransport.Point relative_linear_velocity = 6;
bool LinkState::has_relative_linear_velocity() const {
  return (_has_bits_[0] & 0x00000020u) != 0;
}
void LinkState::set_has_relative_linear_velocity() {
  _has_bits_[0] |= 0x00000020u;
}
void LinkState::clear_has_relative_linear_velocity() {
  _has_bits_[0] &= ~0x00000020u;
}
void LinkState::clear_relative_linear_velocity() {
  if (relative_linear_velocity_ != NULL) relative_linear_velocity_->::mw::internal::robotics::gazebotransport::Point::Clear();
  clear_has_relative_linear_velocity();
}
const ::mw::internal::robotics::gazebotransport::Point& LinkState::relative_linear_velocity() const {
  // @@protoc_insertion_point(field_get:mw.internal.robotics.gazebotransport.LinkState.relative_linear_velocity)
  return relative_linear_velocity_ != NULL ? *relative_linear_velocity_ : *default_instance_->relative_linear_velocity_;
}
::mw::internal::robotics::gazebotransport::Point* LinkState::mutable_relative_linear_velocity() {
  set_has_relative_linear_velocity();
  if (relative_linear_velocity_ == NULL) {
    relative_linear_velocity_ = new ::mw::internal::robotics::gazebotransport::Point;
  }
  // @@protoc_insertion_point(field_mutable:mw.internal.robotics.gazebotransport.LinkState.relative_linear_velocity)
  return relative_linear_velocity_;
}
::mw::internal::robotics::gazebotransport::Point* LinkState::release_relative_linear_velocity() {
  // @@protoc_insertion_point(field_release:mw.internal.robotics.gazebotransport.LinkState.relative_linear_velocity)
  clear_has_relative_linear_velocity();
  ::mw::internal::robotics::gazebotransport::Point* temp = relative_linear_velocity_;
  relative_linear_velocity_ = NULL;
  return temp;
}
void LinkState::set_allocated_relative_linear_velocity(::mw::internal::robotics::gazebotransport::Point* relative_linear_velocity) {
  delete relative_linear_velocity_;
  relative_linear_velocity_ = relative_linear_velocity;
  if (relative_linear_velocity) {
    set_has_relative_linear_velocity();
  } else {
    clear_has_relative_linear_velocity();
  }
  // @@protoc_insertion_point(field_set_allocated:mw.internal.robotics.gazebotransport.LinkState.relative_linear_velocity)
}

// required .mw.internal.robotics.gazebotransport.Point relative_angular_velocity = 7;
bool LinkState::has_relative_angular_velocity() const {
  return (_has_bits_[0] & 0x00000040u) != 0;
}
void LinkState::set_has_relative_angular_velocity() {
  _has_bits_[0] |= 0x00000040u;
}
void LinkState::clear_has_relative_angular_velocity() {
  _has_bits_[0] &= ~0x00000040u;
}
void LinkState::clear_relative_angular_velocity() {
  if (relative_angular_velocity_ != NULL) relative_angular_velocity_->::mw::internal::robotics::gazebotransport::Point::Clear();
  clear_has_relative_angular_velocity();
}
const ::mw::internal::robotics::gazebotransport::Point& LinkState::relative_angular_velocity() const {
  // @@protoc_insertion_point(field_get:mw.internal.robotics.gazebotransport.LinkState.relative_angular_velocity)
  return relative_angular_velocity_ != NULL ? *relative_angular_velocity_ : *default_instance_->relative_angular_velocity_;
}
::mw::internal::robotics::gazebotransport::Point* LinkState::mutable_relative_angular_velocity() {
  set_has_relative_angular_velocity();
  if (relative_angular_velocity_ == NULL) {
    relative_angular_velocity_ = new ::mw::internal::robotics::gazebotransport::Point;
  }
  // @@protoc_insertion_point(field_mutable:mw.internal.robotics.gazebotransport.LinkState.relative_angular_velocity)
  return relative_angular_velocity_;
}
::mw::internal::robotics::gazebotransport::Point* LinkState::release_relative_angular_velocity() {
  // @@protoc_insertion_point(field_release:mw.internal.robotics.gazebotransport.LinkState.relative_angular_velocity)
  clear_has_relative_angular_velocity();
  ::mw::internal::robotics::gazebotransport::Point* temp = relative_angular_velocity_;
  relative_angular_velocity_ = NULL;
  return temp;
}
void LinkState::set_allocated_relative_angular_velocity(::mw::internal::robotics::gazebotransport::Point* relative_angular_velocity) {
  delete relative_angular_velocity_;
  relative_angular_velocity_ = relative_angular_velocity;
  if (relative_angular_velocity) {
    set_has_relative_angular_velocity();
  } else {
    clear_has_relative_angular_velocity();
  }
  // @@protoc_insertion_point(field_set_allocated:mw.internal.robotics.gazebotransport.LinkState.relative_angular_velocity)
}

// optional .mw.internal.robotics.gazebotransport.Pose world_pose = 8;
bool LinkState::has_world_pose() const {
  return (_has_bits_[0] & 0x00000080u) != 0;
}
void LinkState::set_has_world_pose() {
  _has_bits_[0] |= 0x00000080u;
}
void LinkState::clear_has_world_pose() {
  _has_bits_[0] &= ~0x00000080u;
}
void LinkState::clear_world_pose() {
  if (world_pose_ != NULL) world_pose_->::mw::internal::robotics::gazebotransport::Pose::Clear();
  clear_has_world_pose();
}
const ::mw::internal::robotics::gazebotransport::Pose& LinkState::world_pose() const {
  // @@protoc_insertion_point(field_get:mw.internal.robotics.gazebotransport.LinkState.world_pose)
  return world_pose_ != NULL ? *world_pose_ : *default_instance_->world_pose_;
}
::mw::internal::robotics::gazebotransport::Pose* LinkState::mutable_world_pose() {
  set_has_world_pose();
  if (world_pose_ == NULL) {
    world_pose_ = new ::mw::internal::robotics::gazebotransport::Pose;
  }
  // @@protoc_insertion_point(field_mutable:mw.internal.robotics.gazebotransport.LinkState.world_pose)
  return world_pose_;
}
::mw::internal::robotics::gazebotransport::Pose* LinkState::release_world_pose() {
  // @@protoc_insertion_point(field_release:mw.internal.robotics.gazebotransport.LinkState.world_pose)
  clear_has_world_pose();
  ::mw::internal::robotics::gazebotransport::Pose* temp = world_pose_;
  world_pose_ = NULL;
  return temp;
}
void LinkState::set_allocated_world_pose(::mw::internal::robotics::gazebotransport::Pose* world_pose) {
  delete world_pose_;
  world_pose_ = world_pose;
  if (world_pose) {
    set_has_world_pose();
  } else {
    clear_has_world_pose();
  }
  // @@protoc_insertion_point(field_set_allocated:mw.internal.robotics.gazebotransport.LinkState.world_pose)
}

// optional .mw.internal.robotics.gazebotransport.Pose relative_pose = 9;
bool LinkState::has_relative_pose() const {
  return (_has_bits_[0] & 0x00000100u) != 0;
}
void LinkState::set_has_relative_pose() {
  _has_bits_[0] |= 0x00000100u;
}
void LinkState::clear_has_relative_pose() {
  _has_bits_[0] &= ~0x00000100u;
}
void LinkState::clear_relative_pose() {
  if (relative_pose_ != NULL) relative_pose_->::mw::internal::robotics::gazebotransport::Pose::Clear();
  clear_has_relative_pose();
}
const ::mw::internal::robotics::gazebotransport::Pose& LinkState::relative_pose() const {
  // @@protoc_insertion_point(field_get:mw.internal.robotics.gazebotransport.LinkState.relative_pose)
  return relative_pose_ != NULL ? *relative_pose_ : *default_instance_->relative_pose_;
}
::mw::internal::robotics::gazebotransport::Pose* LinkState::mutable_relative_pose() {
  set_has_relative_pose();
  if (relative_pose_ == NULL) {
    relative_pose_ = new ::mw::internal::robotics::gazebotransport::Pose;
  }
  // @@protoc_insertion_point(field_mutable:mw.internal.robotics.gazebotransport.LinkState.relative_pose)
  return relative_pose_;
}
::mw::internal::robotics::gazebotransport::Pose* LinkState::release_relative_pose() {
  // @@protoc_insertion_point(field_release:mw.internal.robotics.gazebotransport.LinkState.relative_pose)
  clear_has_relative_pose();
  ::mw::internal::robotics::gazebotransport::Pose* temp = relative_pose_;
  relative_pose_ = NULL;
  return temp;
}
void LinkState::set_allocated_relative_pose(::mw::internal::robotics::gazebotransport::Pose* relative_pose) {
  delete relative_pose_;
  relative_pose_ = relative_pose;
  if (relative_pose) {
    set_has_relative_pose();
  } else {
    clear_has_relative_pose();
  }
  // @@protoc_insertion_point(field_set_allocated:mw.internal.robotics.gazebotransport.LinkState.relative_pose)
}

// optional bool self_collide = 10;
bool LinkState::has_self_collide() const {
  return (_has_bits_[0] & 0x00000200u) != 0;
}
void LinkState::set_has_self_collide() {
  _has_bits_[0] |= 0x00000200u;
}
void LinkState::clear_has_self_collide() {
  _has_bits_[0] &= ~0x00000200u;
}
void LinkState::clear_self_collide() {
  self_collide_ = false;
  clear_has_self_collide();
}
 bool LinkState::self_collide() const {
  // @@protoc_insertion_point(field_get:mw.internal.robotics.gazebotransport.LinkState.self_collide)
  return self_collide_;
}
 void LinkState::set_self_collide(bool value) {
  set_has_self_collide();
  self_collide_ = value;
  // @@protoc_insertion_point(field_set:mw.internal.robotics.gazebotransport.LinkState.self_collide)
}

// optional bool gravity = 11;
bool LinkState::has_gravity() const {
  return (_has_bits_[0] & 0x00000400u) != 0;
}
void LinkState::set_has_gravity() {
  _has_bits_[0] |= 0x00000400u;
}
void LinkState::clear_has_gravity() {
  _has_bits_[0] &= ~0x00000400u;
}
void LinkState::clear_gravity() {
  gravity_ = false;
  clear_has_gravity();
}
 bool LinkState::gravity() const {
  // @@protoc_insertion_point(field_get:mw.internal.robotics.gazebotransport.LinkState.gravity)
  return gravity_;
}
 void LinkState::set_gravity(bool value) {
  set_has_gravity();
  gravity_ = value;
  // @@protoc_insertion_point(field_set:mw.internal.robotics.gazebotransport.LinkState.gravity)
}

// optional bool kinematic = 12;
bool LinkState::has_kinematic() const {
  return (_has_bits_[0] & 0x00000800u) != 0;
}
void LinkState::set_has_kinematic() {
  _has_bits_[0] |= 0x00000800u;
}
void LinkState::clear_has_kinematic() {
  _has_bits_[0] &= ~0x00000800u;
}
void LinkState::clear_kinematic() {
  kinematic_ = false;
  clear_has_kinematic();
}
 bool LinkState::kinematic() const {
  // @@protoc_insertion_point(field_get:mw.internal.robotics.gazebotransport.LinkState.kinematic)
  return kinematic_;
}
 void LinkState::set_kinematic(bool value) {
  set_has_kinematic();
  kinematic_ = value;
  // @@protoc_insertion_point(field_set:mw.internal.robotics.gazebotransport.LinkState.kinematic)
}

// optional bool enable_wind = 13;
bool LinkState::has_enable_wind() const {
  return (_has_bits_[0] & 0x00001000u) != 0;
}
void LinkState::set_has_enable_wind() {
  _has_bits_[0] |= 0x00001000u;
}
void LinkState::clear_has_enable_wind() {
  _has_bits_[0] &= ~0x00001000u;
}
void LinkState::clear_enable_wind() {
  enable_wind_ = false;
  clear_has_enable_wind();
}
 bool LinkState::enable_wind() const {
  // @@protoc_insertion_point(field_get:mw.internal.robotics.gazebotransport.LinkState.enable_wind)
  return enable_wind_;
}
 void LinkState::set_enable_wind(bool value) {
  set_has_enable_wind();
  enable_wind_ = value;
  // @@protoc_insertion_point(field_set:mw.internal.robotics.gazebotransport.LinkState.enable_wind)
}

// optional bool canonical = 14;
bool LinkState::has_canonical() const {
  return (_has_bits_[0] & 0x00002000u) != 0;
}
void LinkState::set_has_canonical() {
  _has_bits_[0] |= 0x00002000u;
}
void LinkState::clear_has_canonical() {
  _has_bits_[0] &= ~0x00002000u;
}
void LinkState::clear_canonical() {
  canonical_ = false;
  clear_has_canonical();
}
 bool LinkState::canonical() const {
  // @@protoc_insertion_point(field_get:mw.internal.robotics.gazebotransport.LinkState.canonical)
  return canonical_;
}
 void LinkState::set_canonical(bool value) {
  set_has_canonical();
  canonical_ = value;
  // @@protoc_insertion_point(field_set:mw.internal.robotics.gazebotransport.LinkState.canonical)
}

#endif  // PROTOBUF_INLINE_NOT_IN_HEADERS

// ===================================================================

#if !defined(_MSC_VER) || _MSC_VER >= 1900
const int ML_Cord::kXFieldNumber;
const int ML_Cord::kYFieldNumber;
#endif  // !defined(_MSC_VER) || _MSC_VER >= 1900

ML_Cord::ML_Cord()
  : ::google::protobuf::Message(), _internal_metadata_(NULL) {
  SharedCtor();
  // @@protoc_insertion_point(constructor:mw.internal.robotics.gazebotransport.ML_Cord)
}

void ML_Cord::InitAsDefaultInstance() {
}

ML_Cord::ML_Cord(const ML_Cord& from)
  : ::google::protobuf::Message(),
    _internal_metadata_(NULL) {
  SharedCtor();
  MergeFrom(from);
  // @@protoc_insertion_point(copy_constructor:mw.internal.robotics.gazebotransport.ML_Cord)
}

void ML_Cord::SharedCtor() {
  _cached_size_ = 0;
  x_ = 0;
  y_ = 0;
  ::memset(_has_bits_, 0, sizeof(_has_bits_));
}

ML_Cord::~ML_Cord() {
  // @@protoc_insertion_point(destructor:mw.internal.robotics.gazebotransport.ML_Cord)
  SharedDtor();
}

void ML_Cord::SharedDtor() {
  if (this != default_instance_) {
  }
}

void ML_Cord::SetCachedSize(int size) const {
  GOOGLE_SAFE_CONCURRENT_WRITES_BEGIN();
  _cached_size_ = size;
  GOOGLE_SAFE_CONCURRENT_WRITES_END();
}
const ::google::protobuf::Descriptor* ML_Cord::descriptor() {
  protobuf_AssignDescriptorsOnce();
  return ML_Cord_descriptor_;
}

const ML_Cord& ML_Cord::default_instance() {
  if (default_instance_ == NULL) protobuf_AddDesc_mw_2einternal_2erobotics_2egazebotransport_2eCoSimMsgs_2eproto();
  return *default_instance_;
}

ML_Cord* ML_Cord::default_instance_ = NULL;

ML_Cord* ML_Cord::New(::google::protobuf::Arena* arena) const {
  ML_Cord* n = new ML_Cord;
  if (arena != NULL) {
    arena->Own(n);
  }
  return n;
}

void ML_Cord::Clear() {
// @@protoc_insertion_point(message_clear_start:mw.internal.robotics.gazebotransport.ML_Cord)
#if defined(__clang__)
#define ZR_HELPER_(f) \
  _Pragma("clang diagnostic push") \
  _Pragma("clang diagnostic ignored \"-Winvalid-offsetof\"") \
  __builtin_offsetof(ML_Cord, f) \
  _Pragma("clang diagnostic pop")
#else
#define ZR_HELPER_(f) reinterpret_cast<char*>(\
  &reinterpret_cast<ML_Cord*>(16)->f)
#endif

#define ZR_(first, last) do {\
  ::memset(&first, 0,\
           ZR_HELPER_(last) - ZR_HELPER_(first) + sizeof(last));\
} while (0)

  ZR_(x_, y_);

#undef ZR_HELPER_
#undef ZR_

  ::memset(_has_bits_, 0, sizeof(_has_bits_));
  if (_internal_metadata_.have_unknown_fields()) {
    mutable_unknown_fields()->Clear();
  }
}

bool ML_Cord::MergePartialFromCodedStream(
    ::google::protobuf::io::CodedInputStream* input) {
#define DO_(EXPRESSION) if (!GOOGLE_PREDICT_TRUE(EXPRESSION)) goto failure
  ::google::protobuf::uint32 tag;
  // @@protoc_insertion_point(parse_start:mw.internal.robotics.gazebotransport.ML_Cord)
  for (;;) {
    ::std::pair< ::google::protobuf::uint32, bool> p = input->ReadTagWithCutoff(127);
    tag = p.first;
    if (!p.second) goto handle_unusual;
    switch (::google::protobuf::internal::WireFormatLite::GetTagFieldNumber(tag)) {
      // optional double x = 1;
      case 1: {
        if (tag == 9) {
          DO_((::google::protobuf::internal::WireFormatLite::ReadPrimitive<
                   double, ::google::protobuf::internal::WireFormatLite::TYPE_DOUBLE>(
                 input, &x_)));
          set_has_x();
        } else {
          goto handle_unusual;
        }
        if (input->ExpectTag(17)) goto parse_y;
        break;
      }

      // optional double y = 2;
      case 2: {
        if (tag == 17) {
         parse_y:
          DO_((::google::protobuf::internal::WireFormatLite::ReadPrimitive<
                   double, ::google::protobuf::internal::WireFormatLite::TYPE_DOUBLE>(
                 input, &y_)));
          set_has_y();
        } else {
          goto handle_unusual;
        }
        if (input->ExpectAtEnd()) goto success;
        break;
      }

      default: {
      handle_unusual:
        if (tag == 0 ||
            ::google::protobuf::internal::WireFormatLite::GetTagWireType(tag) ==
            ::google::protobuf::internal::WireFormatLite::WIRETYPE_END_GROUP) {
          goto success;
        }
        DO_(::google::protobuf::internal::WireFormat::SkipField(
              input, tag, mutable_unknown_fields()));
        break;
      }
    }
  }
success:
  // @@protoc_insertion_point(parse_success:mw.internal.robotics.gazebotransport.ML_Cord)
  return true;
failure:
  // @@protoc_insertion_point(parse_failure:mw.internal.robotics.gazebotransport.ML_Cord)
  return false;
#undef DO_
}

void ML_Cord::SerializeWithCachedSizes(
    ::google::protobuf::io::CodedOutputStream* output) const {
  // @@protoc_insertion_point(serialize_start:mw.internal.robotics.gazebotransport.ML_Cord)
  // optional double x = 1;
  if (has_x()) {
    ::google::protobuf::internal::WireFormatLite::WriteDouble(1, this->x(), output);
  }

  // optional double y = 2;
  if (has_y()) {
    ::google::protobuf::internal::WireFormatLite::WriteDouble(2, this->y(), output);
  }

  if (_internal_metadata_.have_unknown_fields()) {
    ::google::protobuf::internal::WireFormat::SerializeUnknownFields(
        unknown_fields(), output);
  }
  // @@protoc_insertion_point(serialize_end:mw.internal.robotics.gazebotransport.ML_Cord)
}

::google::protobuf::uint8* ML_Cord::InternalSerializeWithCachedSizesToArray(
    bool deterministic, ::google::protobuf::uint8* target) const {
  // @@protoc_insertion_point(serialize_to_array_start:mw.internal.robotics.gazebotransport.ML_Cord)
  // optional double x = 1;
  if (has_x()) {
    target = ::google::protobuf::internal::WireFormatLite::WriteDoubleToArray(1, this->x(), target);
  }

  // optional double y = 2;
  if (has_y()) {
    target = ::google::protobuf::internal::WireFormatLite::WriteDoubleToArray(2, this->y(), target);
  }

  if (_internal_metadata_.have_unknown_fields()) {
    target = ::google::protobuf::internal::WireFormat::SerializeUnknownFieldsToArray(
        unknown_fields(), target);
  }
  // @@protoc_insertion_point(serialize_to_array_end:mw.internal.robotics.gazebotransport.ML_Cord)
  return target;
}

int ML_Cord::ByteSize() const {
// @@protoc_insertion_point(message_byte_size_start:mw.internal.robotics.gazebotransport.ML_Cord)
  int total_size = 0;

  if (_has_bits_[0 / 32] & 3u) {
    // optional double x = 1;
    if (has_x()) {
      total_size += 1 + 8;
    }

    // optional double y = 2;
    if (has_y()) {
      total_size += 1 + 8;
    }

  }
  if (_internal_metadata_.have_unknown_fields()) {
    total_size +=
      ::google::protobuf::internal::WireFormat::ComputeUnknownFieldsSize(
        unknown_fields());
  }
  GOOGLE_SAFE_CONCURRENT_WRITES_BEGIN();
  _cached_size_ = total_size;
  GOOGLE_SAFE_CONCURRENT_WRITES_END();
  return total_size;
}

void ML_Cord::MergeFrom(const ::google::protobuf::Message& from) {
// @@protoc_insertion_point(generalized_merge_from_start:mw.internal.robotics.gazebotransport.ML_Cord)
  if (GOOGLE_PREDICT_FALSE(&from == this)) {
    ::google::protobuf::internal::MergeFromFail(__FILE__, __LINE__);
  }
  const ML_Cord* source = 
      ::google::protobuf::internal::DynamicCastToGenerated<const ML_Cord>(
          &from);
  if (source == NULL) {
  // @@protoc_insertion_point(generalized_merge_from_cast_fail:mw.internal.robotics.gazebotransport.ML_Cord)
    ::google::protobuf::internal::ReflectionOps::Merge(from, this);
  } else {
  // @@protoc_insertion_point(generalized_merge_from_cast_success:mw.internal.robotics.gazebotransport.ML_Cord)
    MergeFrom(*source);
  }
}

void ML_Cord::MergeFrom(const ML_Cord& from) {
// @@protoc_insertion_point(class_specific_merge_from_start:mw.internal.robotics.gazebotransport.ML_Cord)
  if (GOOGLE_PREDICT_FALSE(&from == this)) {
    ::google::protobuf::internal::MergeFromFail(__FILE__, __LINE__);
  }
  if (from._has_bits_[0 / 32] & (0xffu << (0 % 32))) {
    if (from.has_x()) {
      set_x(from.x());
    }
    if (from.has_y()) {
      set_y(from.y());
    }
  }
  if (from._internal_metadata_.have_unknown_fields()) {
    mutable_unknown_fields()->MergeFrom(from.unknown_fields());
  }
}

void ML_Cord::CopyFrom(const ::google::protobuf::Message& from) {
// @@protoc_insertion_point(generalized_copy_from_start:mw.internal.robotics.gazebotransport.ML_Cord)
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

void ML_Cord::CopyFrom(const ML_Cord& from) {
// @@protoc_insertion_point(class_specific_copy_from_start:mw.internal.robotics.gazebotransport.ML_Cord)
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

bool ML_Cord::IsInitialized() const {

  return true;
}

void ML_Cord::Swap(ML_Cord* other) {
  if (other == this) return;
  InternalSwap(other);
}
void ML_Cord::InternalSwap(ML_Cord* other) {
  std::swap(x_, other->x_);
  std::swap(y_, other->y_);
  std::swap(_has_bits_[0], other->_has_bits_[0]);
  _internal_metadata_.Swap(&other->_internal_metadata_);
  std::swap(_cached_size_, other->_cached_size_);
}

::google::protobuf::Metadata ML_Cord::GetMetadata() const {
  protobuf_AssignDescriptorsOnce();
  ::google::protobuf::Metadata metadata;
  metadata.descriptor = ML_Cord_descriptor_;
  metadata.reflection = ML_Cord_reflection_;
  return metadata;
}

#if PROTOBUF_INLINE_NOT_IN_HEADERS
// ML_Cord

// optional double x = 1;
bool ML_Cord::has_x() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
void ML_Cord::set_has_x() {
  _has_bits_[0] |= 0x00000001u;
}
void ML_Cord::clear_has_x() {
  _has_bits_[0] &= ~0x00000001u;
}
void ML_Cord::clear_x() {
  x_ = 0;
  clear_has_x();
}
 double ML_Cord::x() const {
  // @@protoc_insertion_point(field_get:mw.internal.robotics.gazebotransport.ML_Cord.x)
  return x_;
}
 void ML_Cord::set_x(double value) {
  set_has_x();
  x_ = value;
  // @@protoc_insertion_point(field_set:mw.internal.robotics.gazebotransport.ML_Cord.x)
}

// optional double y = 2;
bool ML_Cord::has_y() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
void ML_Cord::set_has_y() {
  _has_bits_[0] |= 0x00000002u;
}
void ML_Cord::clear_has_y() {
  _has_bits_[0] &= ~0x00000002u;
}
void ML_Cord::clear_y() {
  y_ = 0;
  clear_has_y();
}
 double ML_Cord::y() const {
  // @@protoc_insertion_point(field_get:mw.internal.robotics.gazebotransport.ML_Cord.y)
  return y_;
}
 void ML_Cord::set_y(double value) {
  set_has_y();
  y_ = value;
  // @@protoc_insertion_point(field_set:mw.internal.robotics.gazebotransport.ML_Cord.y)
}

#endif  // PROTOBUF_INLINE_NOT_IN_HEADERS

// ===================================================================

#if !defined(_MSC_VER) || _MSC_VER >= 1900
const int ML_Point::kXFieldNumber;
const int ML_Point::kYFieldNumber;
const int ML_Point::kZFieldNumber;
#endif  // !defined(_MSC_VER) || _MSC_VER >= 1900

ML_Point::ML_Point()
  : ::google::protobuf::Message(), _internal_metadata_(NULL) {
  SharedCtor();
  // @@protoc_insertion_point(constructor:mw.internal.robotics.gazebotransport.ML_Point)
}

void ML_Point::InitAsDefaultInstance() {
}

ML_Point::ML_Point(const ML_Point& from)
  : ::google::protobuf::Message(),
    _internal_metadata_(NULL) {
  SharedCtor();
  MergeFrom(from);
  // @@protoc_insertion_point(copy_constructor:mw.internal.robotics.gazebotransport.ML_Point)
}

void ML_Point::SharedCtor() {
  _cached_size_ = 0;
  x_ = 0;
  y_ = 0;
  z_ = 0;
  ::memset(_has_bits_, 0, sizeof(_has_bits_));
}

ML_Point::~ML_Point() {
  // @@protoc_insertion_point(destructor:mw.internal.robotics.gazebotransport.ML_Point)
  SharedDtor();
}

void ML_Point::SharedDtor() {
  if (this != default_instance_) {
  }
}

void ML_Point::SetCachedSize(int size) const {
  GOOGLE_SAFE_CONCURRENT_WRITES_BEGIN();
  _cached_size_ = size;
  GOOGLE_SAFE_CONCURRENT_WRITES_END();
}
const ::google::protobuf::Descriptor* ML_Point::descriptor() {
  protobuf_AssignDescriptorsOnce();
  return ML_Point_descriptor_;
}

const ML_Point& ML_Point::default_instance() {
  if (default_instance_ == NULL) protobuf_AddDesc_mw_2einternal_2erobotics_2egazebotransport_2eCoSimMsgs_2eproto();
  return *default_instance_;
}

ML_Point* ML_Point::default_instance_ = NULL;

ML_Point* ML_Point::New(::google::protobuf::Arena* arena) const {
  ML_Point* n = new ML_Point;
  if (arena != NULL) {
    arena->Own(n);
  }
  return n;
}

void ML_Point::Clear() {
// @@protoc_insertion_point(message_clear_start:mw.internal.robotics.gazebotransport.ML_Point)
#if defined(__clang__)
#define ZR_HELPER_(f) \
  _Pragma("clang diagnostic push") \
  _Pragma("clang diagnostic ignored \"-Winvalid-offsetof\"") \
  __builtin_offsetof(ML_Point, f) \
  _Pragma("clang diagnostic pop")
#else
#define ZR_HELPER_(f) reinterpret_cast<char*>(\
  &reinterpret_cast<ML_Point*>(16)->f)
#endif

#define ZR_(first, last) do {\
  ::memset(&first, 0,\
           ZR_HELPER_(last) - ZR_HELPER_(first) + sizeof(last));\
} while (0)

  ZR_(x_, z_);

#undef ZR_HELPER_
#undef ZR_

  ::memset(_has_bits_, 0, sizeof(_has_bits_));
  if (_internal_metadata_.have_unknown_fields()) {
    mutable_unknown_fields()->Clear();
  }
}

bool ML_Point::MergePartialFromCodedStream(
    ::google::protobuf::io::CodedInputStream* input) {
#define DO_(EXPRESSION) if (!GOOGLE_PREDICT_TRUE(EXPRESSION)) goto failure
  ::google::protobuf::uint32 tag;
  // @@protoc_insertion_point(parse_start:mw.internal.robotics.gazebotransport.ML_Point)
  for (;;) {
    ::std::pair< ::google::protobuf::uint32, bool> p = input->ReadTagWithCutoff(127);
    tag = p.first;
    if (!p.second) goto handle_unusual;
    switch (::google::protobuf::internal::WireFormatLite::GetTagFieldNumber(tag)) {
      // optional double x = 1;
      case 1: {
        if (tag == 9) {
          DO_((::google::protobuf::internal::WireFormatLite::ReadPrimitive<
                   double, ::google::protobuf::internal::WireFormatLite::TYPE_DOUBLE>(
                 input, &x_)));
          set_has_x();
        } else {
          goto handle_unusual;
        }
        if (input->ExpectTag(17)) goto parse_y;
        break;
      }

      // optional double y = 2;
      case 2: {
        if (tag == 17) {
         parse_y:
          DO_((::google::protobuf::internal::WireFormatLite::ReadPrimitive<
                   double, ::google::protobuf::internal::WireFormatLite::TYPE_DOUBLE>(
                 input, &y_)));
          set_has_y();
        } else {
          goto handle_unusual;
        }
        if (input->ExpectTag(25)) goto parse_z;
        break;
      }

      // optional double z = 3;
      case 3: {
        if (tag == 25) {
         parse_z:
          DO_((::google::protobuf::internal::WireFormatLite::ReadPrimitive<
                   double, ::google::protobuf::internal::WireFormatLite::TYPE_DOUBLE>(
                 input, &z_)));
          set_has_z();
        } else {
          goto handle_unusual;
        }
        if (input->ExpectAtEnd()) goto success;
        break;
      }

      default: {
      handle_unusual:
        if (tag == 0 ||
            ::google::protobuf::internal::WireFormatLite::GetTagWireType(tag) ==
            ::google::protobuf::internal::WireFormatLite::WIRETYPE_END_GROUP) {
          goto success;
        }
        DO_(::google::protobuf::internal::WireFormat::SkipField(
              input, tag, mutable_unknown_fields()));
        break;
      }
    }
  }
success:
  // @@protoc_insertion_point(parse_success:mw.internal.robotics.gazebotransport.ML_Point)
  return true;
failure:
  // @@protoc_insertion_point(parse_failure:mw.internal.robotics.gazebotransport.ML_Point)
  return false;
#undef DO_
}

void ML_Point::SerializeWithCachedSizes(
    ::google::protobuf::io::CodedOutputStream* output) const {
  // @@protoc_insertion_point(serialize_start:mw.internal.robotics.gazebotransport.ML_Point)
  // optional double x = 1;
  if (has_x()) {
    ::google::protobuf::internal::WireFormatLite::WriteDouble(1, this->x(), output);
  }

  // optional double y = 2;
  if (has_y()) {
    ::google::protobuf::internal::WireFormatLite::WriteDouble(2, this->y(), output);
  }

  // optional double z = 3;
  if (has_z()) {
    ::google::protobuf::internal::WireFormatLite::WriteDouble(3, this->z(), output);
  }

  if (_internal_metadata_.have_unknown_fields()) {
    ::google::protobuf::internal::WireFormat::SerializeUnknownFields(
        unknown_fields(), output);
  }
  // @@protoc_insertion_point(serialize_end:mw.internal.robotics.gazebotransport.ML_Point)
}

::google::protobuf::uint8* ML_Point::InternalSerializeWithCachedSizesToArray(
    bool deterministic, ::google::protobuf::uint8* target) const {
  // @@protoc_insertion_point(serialize_to_array_start:mw.internal.robotics.gazebotransport.ML_Point)
  // optional double x = 1;
  if (has_x()) {
    target = ::google::protobuf::internal::WireFormatLite::WriteDoubleToArray(1, this->x(), target);
  }

  // optional double y = 2;
  if (has_y()) {
    target = ::google::protobuf::internal::WireFormatLite::WriteDoubleToArray(2, this->y(), target);
  }

  // optional double z = 3;
  if (has_z()) {
    target = ::google::protobuf::internal::WireFormatLite::WriteDoubleToArray(3, this->z(), target);
  }

  if (_internal_metadata_.have_unknown_fields()) {
    target = ::google::protobuf::internal::WireFormat::SerializeUnknownFieldsToArray(
        unknown_fields(), target);
  }
  // @@protoc_insertion_point(serialize_to_array_end:mw.internal.robotics.gazebotransport.ML_Point)
  return target;
}

int ML_Point::ByteSize() const {
// @@protoc_insertion_point(message_byte_size_start:mw.internal.robotics.gazebotransport.ML_Point)
  int total_size = 0;

  if (_has_bits_[0 / 32] & 7u) {
    // optional double x = 1;
    if (has_x()) {
      total_size += 1 + 8;
    }

    // optional double y = 2;
    if (has_y()) {
      total_size += 1 + 8;
    }

    // optional double z = 3;
    if (has_z()) {
      total_size += 1 + 8;
    }

  }
  if (_internal_metadata_.have_unknown_fields()) {
    total_size +=
      ::google::protobuf::internal::WireFormat::ComputeUnknownFieldsSize(
        unknown_fields());
  }
  GOOGLE_SAFE_CONCURRENT_WRITES_BEGIN();
  _cached_size_ = total_size;
  GOOGLE_SAFE_CONCURRENT_WRITES_END();
  return total_size;
}

void ML_Point::MergeFrom(const ::google::protobuf::Message& from) {
// @@protoc_insertion_point(generalized_merge_from_start:mw.internal.robotics.gazebotransport.ML_Point)
  if (GOOGLE_PREDICT_FALSE(&from == this)) {
    ::google::protobuf::internal::MergeFromFail(__FILE__, __LINE__);
  }
  const ML_Point* source = 
      ::google::protobuf::internal::DynamicCastToGenerated<const ML_Point>(
          &from);
  if (source == NULL) {
  // @@protoc_insertion_point(generalized_merge_from_cast_fail:mw.internal.robotics.gazebotransport.ML_Point)
    ::google::protobuf::internal::ReflectionOps::Merge(from, this);
  } else {
  // @@protoc_insertion_point(generalized_merge_from_cast_success:mw.internal.robotics.gazebotransport.ML_Point)
    MergeFrom(*source);
  }
}

void ML_Point::MergeFrom(const ML_Point& from) {
// @@protoc_insertion_point(class_specific_merge_from_start:mw.internal.robotics.gazebotransport.ML_Point)
  if (GOOGLE_PREDICT_FALSE(&from == this)) {
    ::google::protobuf::internal::MergeFromFail(__FILE__, __LINE__);
  }
  if (from._has_bits_[0 / 32] & (0xffu << (0 % 32))) {
    if (from.has_x()) {
      set_x(from.x());
    }
    if (from.has_y()) {
      set_y(from.y());
    }
    if (from.has_z()) {
      set_z(from.z());
    }
  }
  if (from._internal_metadata_.have_unknown_fields()) {
    mutable_unknown_fields()->MergeFrom(from.unknown_fields());
  }
}

void ML_Point::CopyFrom(const ::google::protobuf::Message& from) {
// @@protoc_insertion_point(generalized_copy_from_start:mw.internal.robotics.gazebotransport.ML_Point)
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

void ML_Point::CopyFrom(const ML_Point& from) {
// @@protoc_insertion_point(class_specific_copy_from_start:mw.internal.robotics.gazebotransport.ML_Point)
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

bool ML_Point::IsInitialized() const {

  return true;
}

void ML_Point::Swap(ML_Point* other) {
  if (other == this) return;
  InternalSwap(other);
}
void ML_Point::InternalSwap(ML_Point* other) {
  std::swap(x_, other->x_);
  std::swap(y_, other->y_);
  std::swap(z_, other->z_);
  std::swap(_has_bits_[0], other->_has_bits_[0]);
  _internal_metadata_.Swap(&other->_internal_metadata_);
  std::swap(_cached_size_, other->_cached_size_);
}

::google::protobuf::Metadata ML_Point::GetMetadata() const {
  protobuf_AssignDescriptorsOnce();
  ::google::protobuf::Metadata metadata;
  metadata.descriptor = ML_Point_descriptor_;
  metadata.reflection = ML_Point_reflection_;
  return metadata;
}

#if PROTOBUF_INLINE_NOT_IN_HEADERS
// ML_Point

// optional double x = 1;
bool ML_Point::has_x() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
void ML_Point::set_has_x() {
  _has_bits_[0] |= 0x00000001u;
}
void ML_Point::clear_has_x() {
  _has_bits_[0] &= ~0x00000001u;
}
void ML_Point::clear_x() {
  x_ = 0;
  clear_has_x();
}
 double ML_Point::x() const {
  // @@protoc_insertion_point(field_get:mw.internal.robotics.gazebotransport.ML_Point.x)
  return x_;
}
 void ML_Point::set_x(double value) {
  set_has_x();
  x_ = value;
  // @@protoc_insertion_point(field_set:mw.internal.robotics.gazebotransport.ML_Point.x)
}

// optional double y = 2;
bool ML_Point::has_y() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
void ML_Point::set_has_y() {
  _has_bits_[0] |= 0x00000002u;
}
void ML_Point::clear_has_y() {
  _has_bits_[0] &= ~0x00000002u;
}
void ML_Point::clear_y() {
  y_ = 0;
  clear_has_y();
}
 double ML_Point::y() const {
  // @@protoc_insertion_point(field_get:mw.internal.robotics.gazebotransport.ML_Point.y)
  return y_;
}
 void ML_Point::set_y(double value) {
  set_has_y();
  y_ = value;
  // @@protoc_insertion_point(field_set:mw.internal.robotics.gazebotransport.ML_Point.y)
}

// optional double z = 3;
bool ML_Point::has_z() const {
  return (_has_bits_[0] & 0x00000004u) != 0;
}
void ML_Point::set_has_z() {
  _has_bits_[0] |= 0x00000004u;
}
void ML_Point::clear_has_z() {
  _has_bits_[0] &= ~0x00000004u;
}
void ML_Point::clear_z() {
  z_ = 0;
  clear_has_z();
}
 double ML_Point::z() const {
  // @@protoc_insertion_point(field_get:mw.internal.robotics.gazebotransport.ML_Point.z)
  return z_;
}
 void ML_Point::set_z(double value) {
  set_has_z();
  z_ = value;
  // @@protoc_insertion_point(field_set:mw.internal.robotics.gazebotransport.ML_Point.z)
}

#endif  // PROTOBUF_INLINE_NOT_IN_HEADERS

// ===================================================================

#if !defined(_MSC_VER) || _MSC_VER >= 1900
const int ML_Quat::kXFieldNumber;
const int ML_Quat::kYFieldNumber;
const int ML_Quat::kZFieldNumber;
const int ML_Quat::kWFieldNumber;
#endif  // !defined(_MSC_VER) || _MSC_VER >= 1900

ML_Quat::ML_Quat()
  : ::google::protobuf::Message(), _internal_metadata_(NULL) {
  SharedCtor();
  // @@protoc_insertion_point(constructor:mw.internal.robotics.gazebotransport.ML_Quat)
}

void ML_Quat::InitAsDefaultInstance() {
}

ML_Quat::ML_Quat(const ML_Quat& from)
  : ::google::protobuf::Message(),
    _internal_metadata_(NULL) {
  SharedCtor();
  MergeFrom(from);
  // @@protoc_insertion_point(copy_constructor:mw.internal.robotics.gazebotransport.ML_Quat)
}

void ML_Quat::SharedCtor() {
  _cached_size_ = 0;
  x_ = 0;
  y_ = 0;
  z_ = 0;
  w_ = 0;
  ::memset(_has_bits_, 0, sizeof(_has_bits_));
}

ML_Quat::~ML_Quat() {
  // @@protoc_insertion_point(destructor:mw.internal.robotics.gazebotransport.ML_Quat)
  SharedDtor();
}

void ML_Quat::SharedDtor() {
  if (this != default_instance_) {
  }
}

void ML_Quat::SetCachedSize(int size) const {
  GOOGLE_SAFE_CONCURRENT_WRITES_BEGIN();
  _cached_size_ = size;
  GOOGLE_SAFE_CONCURRENT_WRITES_END();
}
const ::google::protobuf::Descriptor* ML_Quat::descriptor() {
  protobuf_AssignDescriptorsOnce();
  return ML_Quat_descriptor_;
}

const ML_Quat& ML_Quat::default_instance() {
  if (default_instance_ == NULL) protobuf_AddDesc_mw_2einternal_2erobotics_2egazebotransport_2eCoSimMsgs_2eproto();
  return *default_instance_;
}

ML_Quat* ML_Quat::default_instance_ = NULL;

ML_Quat* ML_Quat::New(::google::protobuf::Arena* arena) const {
  ML_Quat* n = new ML_Quat;
  if (arena != NULL) {
    arena->Own(n);
  }
  return n;
}

void ML_Quat::Clear() {
// @@protoc_insertion_point(message_clear_start:mw.internal.robotics.gazebotransport.ML_Quat)
#if defined(__clang__)
#define ZR_HELPER_(f) \
  _Pragma("clang diagnostic push") \
  _Pragma("clang diagnostic ignored \"-Winvalid-offsetof\"") \
  __builtin_offsetof(ML_Quat, f) \
  _Pragma("clang diagnostic pop")
#else
#define ZR_HELPER_(f) reinterpret_cast<char*>(\
  &reinterpret_cast<ML_Quat*>(16)->f)
#endif

#define ZR_(first, last) do {\
  ::memset(&first, 0,\
           ZR_HELPER_(last) - ZR_HELPER_(first) + sizeof(last));\
} while (0)

  ZR_(x_, w_);

#undef ZR_HELPER_
#undef ZR_

  ::memset(_has_bits_, 0, sizeof(_has_bits_));
  if (_internal_metadata_.have_unknown_fields()) {
    mutable_unknown_fields()->Clear();
  }
}

bool ML_Quat::MergePartialFromCodedStream(
    ::google::protobuf::io::CodedInputStream* input) {
#define DO_(EXPRESSION) if (!GOOGLE_PREDICT_TRUE(EXPRESSION)) goto failure
  ::google::protobuf::uint32 tag;
  // @@protoc_insertion_point(parse_start:mw.internal.robotics.gazebotransport.ML_Quat)
  for (;;) {
    ::std::pair< ::google::protobuf::uint32, bool> p = input->ReadTagWithCutoff(127);
    tag = p.first;
    if (!p.second) goto handle_unusual;
    switch (::google::protobuf::internal::WireFormatLite::GetTagFieldNumber(tag)) {
      // optional double x = 1;
      case 1: {
        if (tag == 9) {
          DO_((::google::protobuf::internal::WireFormatLite::ReadPrimitive<
                   double, ::google::protobuf::internal::WireFormatLite::TYPE_DOUBLE>(
                 input, &x_)));
          set_has_x();
        } else {
          goto handle_unusual;
        }
        if (input->ExpectTag(17)) goto parse_y;
        break;
      }

      // optional double y = 2;
      case 2: {
        if (tag == 17) {
         parse_y:
          DO_((::google::protobuf::internal::WireFormatLite::ReadPrimitive<
                   double, ::google::protobuf::internal::WireFormatLite::TYPE_DOUBLE>(
                 input, &y_)));
          set_has_y();
        } else {
          goto handle_unusual;
        }
        if (input->ExpectTag(25)) goto parse_z;
        break;
      }

      // optional double z = 3;
      case 3: {
        if (tag == 25) {
         parse_z:
          DO_((::google::protobuf::internal::WireFormatLite::ReadPrimitive<
                   double, ::google::protobuf::internal::WireFormatLite::TYPE_DOUBLE>(
                 input, &z_)));
          set_has_z();
        } else {
          goto handle_unusual;
        }
        if (input->ExpectTag(33)) goto parse_w;
        break;
      }

      // optional double w = 4;
      case 4: {
        if (tag == 33) {
         parse_w:
          DO_((::google::protobuf::internal::WireFormatLite::ReadPrimitive<
                   double, ::google::protobuf::internal::WireFormatLite::TYPE_DOUBLE>(
                 input, &w_)));
          set_has_w();
        } else {
          goto handle_unusual;
        }
        if (input->ExpectAtEnd()) goto success;
        break;
      }

      default: {
      handle_unusual:
        if (tag == 0 ||
            ::google::protobuf::internal::WireFormatLite::GetTagWireType(tag) ==
            ::google::protobuf::internal::WireFormatLite::WIRETYPE_END_GROUP) {
          goto success;
        }
        DO_(::google::protobuf::internal::WireFormat::SkipField(
              input, tag, mutable_unknown_fields()));
        break;
      }
    }
  }
success:
  // @@protoc_insertion_point(parse_success:mw.internal.robotics.gazebotransport.ML_Quat)
  return true;
failure:
  // @@protoc_insertion_point(parse_failure:mw.internal.robotics.gazebotransport.ML_Quat)
  return false;
#undef DO_
}

void ML_Quat::SerializeWithCachedSizes(
    ::google::protobuf::io::CodedOutputStream* output) const {
  // @@protoc_insertion_point(serialize_start:mw.internal.robotics.gazebotransport.ML_Quat)
  // optional double x = 1;
  if (has_x()) {
    ::google::protobuf::internal::WireFormatLite::WriteDouble(1, this->x(), output);
  }

  // optional double y = 2;
  if (has_y()) {
    ::google::protobuf::internal::WireFormatLite::WriteDouble(2, this->y(), output);
  }

  // optional double z = 3;
  if (has_z()) {
    ::google::protobuf::internal::WireFormatLite::WriteDouble(3, this->z(), output);
  }

  // optional double w = 4;
  if (has_w()) {
    ::google::protobuf::internal::WireFormatLite::WriteDouble(4, this->w(), output);
  }

  if (_internal_metadata_.have_unknown_fields()) {
    ::google::protobuf::internal::WireFormat::SerializeUnknownFields(
        unknown_fields(), output);
  }
  // @@protoc_insertion_point(serialize_end:mw.internal.robotics.gazebotransport.ML_Quat)
}

::google::protobuf::uint8* ML_Quat::InternalSerializeWithCachedSizesToArray(
    bool deterministic, ::google::protobuf::uint8* target) const {
  // @@protoc_insertion_point(serialize_to_array_start:mw.internal.robotics.gazebotransport.ML_Quat)
  // optional double x = 1;
  if (has_x()) {
    target = ::google::protobuf::internal::WireFormatLite::WriteDoubleToArray(1, this->x(), target);
  }

  // optional double y = 2;
  if (has_y()) {
    target = ::google::protobuf::internal::WireFormatLite::WriteDoubleToArray(2, this->y(), target);
  }

  // optional double z = 3;
  if (has_z()) {
    target = ::google::protobuf::internal::WireFormatLite::WriteDoubleToArray(3, this->z(), target);
  }

  // optional double w = 4;
  if (has_w()) {
    target = ::google::protobuf::internal::WireFormatLite::WriteDoubleToArray(4, this->w(), target);
  }

  if (_internal_metadata_.have_unknown_fields()) {
    target = ::google::protobuf::internal::WireFormat::SerializeUnknownFieldsToArray(
        unknown_fields(), target);
  }
  // @@protoc_insertion_point(serialize_to_array_end:mw.internal.robotics.gazebotransport.ML_Quat)
  return target;
}

int ML_Quat::ByteSize() const {
// @@protoc_insertion_point(message_byte_size_start:mw.internal.robotics.gazebotransport.ML_Quat)
  int total_size = 0;

  if (_has_bits_[0 / 32] & 15u) {
    // optional double x = 1;
    if (has_x()) {
      total_size += 1 + 8;
    }

    // optional double y = 2;
    if (has_y()) {
      total_size += 1 + 8;
    }

    // optional double z = 3;
    if (has_z()) {
      total_size += 1 + 8;
    }

    // optional double w = 4;
    if (has_w()) {
      total_size += 1 + 8;
    }

  }
  if (_internal_metadata_.have_unknown_fields()) {
    total_size +=
      ::google::protobuf::internal::WireFormat::ComputeUnknownFieldsSize(
        unknown_fields());
  }
  GOOGLE_SAFE_CONCURRENT_WRITES_BEGIN();
  _cached_size_ = total_size;
  GOOGLE_SAFE_CONCURRENT_WRITES_END();
  return total_size;
}

void ML_Quat::MergeFrom(const ::google::protobuf::Message& from) {
// @@protoc_insertion_point(generalized_merge_from_start:mw.internal.robotics.gazebotransport.ML_Quat)
  if (GOOGLE_PREDICT_FALSE(&from == this)) {
    ::google::protobuf::internal::MergeFromFail(__FILE__, __LINE__);
  }
  const ML_Quat* source = 
      ::google::protobuf::internal::DynamicCastToGenerated<const ML_Quat>(
          &from);
  if (source == NULL) {
  // @@protoc_insertion_point(generalized_merge_from_cast_fail:mw.internal.robotics.gazebotransport.ML_Quat)
    ::google::protobuf::internal::ReflectionOps::Merge(from, this);
  } else {
  // @@protoc_insertion_point(generalized_merge_from_cast_success:mw.internal.robotics.gazebotransport.ML_Quat)
    MergeFrom(*source);
  }
}

void ML_Quat::MergeFrom(const ML_Quat& from) {
// @@protoc_insertion_point(class_specific_merge_from_start:mw.internal.robotics.gazebotransport.ML_Quat)
  if (GOOGLE_PREDICT_FALSE(&from == this)) {
    ::google::protobuf::internal::MergeFromFail(__FILE__, __LINE__);
  }
  if (from._has_bits_[0 / 32] & (0xffu << (0 % 32))) {
    if (from.has_x()) {
      set_x(from.x());
    }
    if (from.has_y()) {
      set_y(from.y());
    }
    if (from.has_z()) {
      set_z(from.z());
    }
    if (from.has_w()) {
      set_w(from.w());
    }
  }
  if (from._internal_metadata_.have_unknown_fields()) {
    mutable_unknown_fields()->MergeFrom(from.unknown_fields());
  }
}

void ML_Quat::CopyFrom(const ::google::protobuf::Message& from) {
// @@protoc_insertion_point(generalized_copy_from_start:mw.internal.robotics.gazebotransport.ML_Quat)
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

void ML_Quat::CopyFrom(const ML_Quat& from) {
// @@protoc_insertion_point(class_specific_copy_from_start:mw.internal.robotics.gazebotransport.ML_Quat)
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

bool ML_Quat::IsInitialized() const {

  return true;
}

void ML_Quat::Swap(ML_Quat* other) {
  if (other == this) return;
  InternalSwap(other);
}
void ML_Quat::InternalSwap(ML_Quat* other) {
  std::swap(x_, other->x_);
  std::swap(y_, other->y_);
  std::swap(z_, other->z_);
  std::swap(w_, other->w_);
  std::swap(_has_bits_[0], other->_has_bits_[0]);
  _internal_metadata_.Swap(&other->_internal_metadata_);
  std::swap(_cached_size_, other->_cached_size_);
}

::google::protobuf::Metadata ML_Quat::GetMetadata() const {
  protobuf_AssignDescriptorsOnce();
  ::google::protobuf::Metadata metadata;
  metadata.descriptor = ML_Quat_descriptor_;
  metadata.reflection = ML_Quat_reflection_;
  return metadata;
}

#if PROTOBUF_INLINE_NOT_IN_HEADERS
// ML_Quat

// optional double x = 1;
bool ML_Quat::has_x() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
void ML_Quat::set_has_x() {
  _has_bits_[0] |= 0x00000001u;
}
void ML_Quat::clear_has_x() {
  _has_bits_[0] &= ~0x00000001u;
}
void ML_Quat::clear_x() {
  x_ = 0;
  clear_has_x();
}
 double ML_Quat::x() const {
  // @@protoc_insertion_point(field_get:mw.internal.robotics.gazebotransport.ML_Quat.x)
  return x_;
}
 void ML_Quat::set_x(double value) {
  set_has_x();
  x_ = value;
  // @@protoc_insertion_point(field_set:mw.internal.robotics.gazebotransport.ML_Quat.x)
}

// optional double y = 2;
bool ML_Quat::has_y() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
void ML_Quat::set_has_y() {
  _has_bits_[0] |= 0x00000002u;
}
void ML_Quat::clear_has_y() {
  _has_bits_[0] &= ~0x00000002u;
}
void ML_Quat::clear_y() {
  y_ = 0;
  clear_has_y();
}
 double ML_Quat::y() const {
  // @@protoc_insertion_point(field_get:mw.internal.robotics.gazebotransport.ML_Quat.y)
  return y_;
}
 void ML_Quat::set_y(double value) {
  set_has_y();
  y_ = value;
  // @@protoc_insertion_point(field_set:mw.internal.robotics.gazebotransport.ML_Quat.y)
}

// optional double z = 3;
bool ML_Quat::has_z() const {
  return (_has_bits_[0] & 0x00000004u) != 0;
}
void ML_Quat::set_has_z() {
  _has_bits_[0] |= 0x00000004u;
}
void ML_Quat::clear_has_z() {
  _has_bits_[0] &= ~0x00000004u;
}
void ML_Quat::clear_z() {
  z_ = 0;
  clear_has_z();
}
 double ML_Quat::z() const {
  // @@protoc_insertion_point(field_get:mw.internal.robotics.gazebotransport.ML_Quat.z)
  return z_;
}
 void ML_Quat::set_z(double value) {
  set_has_z();
  z_ = value;
  // @@protoc_insertion_point(field_set:mw.internal.robotics.gazebotransport.ML_Quat.z)
}

// optional double w = 4;
bool ML_Quat::has_w() const {
  return (_has_bits_[0] & 0x00000008u) != 0;
}
void ML_Quat::set_has_w() {
  _has_bits_[0] |= 0x00000008u;
}
void ML_Quat::clear_has_w() {
  _has_bits_[0] &= ~0x00000008u;
}
void ML_Quat::clear_w() {
  w_ = 0;
  clear_has_w();
}
 double ML_Quat::w() const {
  // @@protoc_insertion_point(field_get:mw.internal.robotics.gazebotransport.ML_Quat.w)
  return w_;
}
 void ML_Quat::set_w(double value) {
  set_has_w();
  w_ = value;
  // @@protoc_insertion_point(field_set:mw.internal.robotics.gazebotransport.ML_Quat.w)
}

#endif  // PROTOBUF_INLINE_NOT_IN_HEADERS

// ===================================================================

#if !defined(_MSC_VER) || _MSC_VER >= 1900
const int ML_Pose::kPositionFieldNumber;
const int ML_Pose::kOrientationFieldNumber;
#endif  // !defined(_MSC_VER) || _MSC_VER >= 1900

ML_Pose::ML_Pose()
  : ::google::protobuf::Message(), _internal_metadata_(NULL) {
  SharedCtor();
  // @@protoc_insertion_point(constructor:mw.internal.robotics.gazebotransport.ML_Pose)
}

void ML_Pose::InitAsDefaultInstance() {
  position_ = const_cast< ::mw::internal::robotics::gazebotransport::ML_Point*>(&::mw::internal::robotics::gazebotransport::ML_Point::default_instance());
  orientation_ = const_cast< ::mw::internal::robotics::gazebotransport::ML_Quat*>(&::mw::internal::robotics::gazebotransport::ML_Quat::default_instance());
}

ML_Pose::ML_Pose(const ML_Pose& from)
  : ::google::protobuf::Message(),
    _internal_metadata_(NULL) {
  SharedCtor();
  MergeFrom(from);
  // @@protoc_insertion_point(copy_constructor:mw.internal.robotics.gazebotransport.ML_Pose)
}

void ML_Pose::SharedCtor() {
  _cached_size_ = 0;
  position_ = NULL;
  orientation_ = NULL;
  ::memset(_has_bits_, 0, sizeof(_has_bits_));
}

ML_Pose::~ML_Pose() {
  // @@protoc_insertion_point(destructor:mw.internal.robotics.gazebotransport.ML_Pose)
  SharedDtor();
}

void ML_Pose::SharedDtor() {
  if (this != default_instance_) {
    delete position_;
    delete orientation_;
  }
}

void ML_Pose::SetCachedSize(int size) const {
  GOOGLE_SAFE_CONCURRENT_WRITES_BEGIN();
  _cached_size_ = size;
  GOOGLE_SAFE_CONCURRENT_WRITES_END();
}
const ::google::protobuf::Descriptor* ML_Pose::descriptor() {
  protobuf_AssignDescriptorsOnce();
  return ML_Pose_descriptor_;
}

const ML_Pose& ML_Pose::default_instance() {
  if (default_instance_ == NULL) protobuf_AddDesc_mw_2einternal_2erobotics_2egazebotransport_2eCoSimMsgs_2eproto();
  return *default_instance_;
}

ML_Pose* ML_Pose::default_instance_ = NULL;

ML_Pose* ML_Pose::New(::google::protobuf::Arena* arena) const {
  ML_Pose* n = new ML_Pose;
  if (arena != NULL) {
    arena->Own(n);
  }
  return n;
}

void ML_Pose::Clear() {
// @@protoc_insertion_point(message_clear_start:mw.internal.robotics.gazebotransport.ML_Pose)
  if (_has_bits_[0 / 32] & 3u) {
    if (has_position()) {
      if (position_ != NULL) position_->::mw::internal::robotics::gazebotransport::ML_Point::Clear();
    }
    if (has_orientation()) {
      if (orientation_ != NULL) orientation_->::mw::internal::robotics::gazebotransport::ML_Quat::Clear();
    }
  }
  ::memset(_has_bits_, 0, sizeof(_has_bits_));
  if (_internal_metadata_.have_unknown_fields()) {
    mutable_unknown_fields()->Clear();
  }
}

bool ML_Pose::MergePartialFromCodedStream(
    ::google::protobuf::io::CodedInputStream* input) {
#define DO_(EXPRESSION) if (!GOOGLE_PREDICT_TRUE(EXPRESSION)) goto failure
  ::google::protobuf::uint32 tag;
  // @@protoc_insertion_point(parse_start:mw.internal.robotics.gazebotransport.ML_Pose)
  for (;;) {
    ::std::pair< ::google::protobuf::uint32, bool> p = input->ReadTagWithCutoff(127);
    tag = p.first;
    if (!p.second) goto handle_unusual;
    switch (::google::protobuf::internal::WireFormatLite::GetTagFieldNumber(tag)) {
      // optional .mw.internal.robotics.gazebotransport.ML_Point position = 1;
      case 1: {
        if (tag == 10) {
          DO_(::google::protobuf::internal::WireFormatLite::ReadMessageNoVirtual(
               input, mutable_position()));
        } else {
          goto handle_unusual;
        }
        if (input->ExpectTag(18)) goto parse_orientation;
        break;
      }

      // optional .mw.internal.robotics.gazebotransport.ML_Quat orientation = 2;
      case 2: {
        if (tag == 18) {
         parse_orientation:
          DO_(::google::protobuf::internal::WireFormatLite::ReadMessageNoVirtual(
               input, mutable_orientation()));
        } else {
          goto handle_unusual;
        }
        if (input->ExpectAtEnd()) goto success;
        break;
      }

      default: {
      handle_unusual:
        if (tag == 0 ||
            ::google::protobuf::internal::WireFormatLite::GetTagWireType(tag) ==
            ::google::protobuf::internal::WireFormatLite::WIRETYPE_END_GROUP) {
          goto success;
        }
        DO_(::google::protobuf::internal::WireFormat::SkipField(
              input, tag, mutable_unknown_fields()));
        break;
      }
    }
  }
success:
  // @@protoc_insertion_point(parse_success:mw.internal.robotics.gazebotransport.ML_Pose)
  return true;
failure:
  // @@protoc_insertion_point(parse_failure:mw.internal.robotics.gazebotransport.ML_Pose)
  return false;
#undef DO_
}

void ML_Pose::SerializeWithCachedSizes(
    ::google::protobuf::io::CodedOutputStream* output) const {
  // @@protoc_insertion_point(serialize_start:mw.internal.robotics.gazebotransport.ML_Pose)
  // optional .mw.internal.robotics.gazebotransport.ML_Point position = 1;
  if (has_position()) {
    ::google::protobuf::internal::WireFormatLite::WriteMessageMaybeToArray(
      1, *this->position_, output);
  }

  // optional .mw.internal.robotics.gazebotransport.ML_Quat orientation = 2;
  if (has_orientation()) {
    ::google::protobuf::internal::WireFormatLite::WriteMessageMaybeToArray(
      2, *this->orientation_, output);
  }

  if (_internal_metadata_.have_unknown_fields()) {
    ::google::protobuf::internal::WireFormat::SerializeUnknownFields(
        unknown_fields(), output);
  }
  // @@protoc_insertion_point(serialize_end:mw.internal.robotics.gazebotransport.ML_Pose)
}

::google::protobuf::uint8* ML_Pose::InternalSerializeWithCachedSizesToArray(
    bool deterministic, ::google::protobuf::uint8* target) const {
  // @@protoc_insertion_point(serialize_to_array_start:mw.internal.robotics.gazebotransport.ML_Pose)
  // optional .mw.internal.robotics.gazebotransport.ML_Point position = 1;
  if (has_position()) {
    target = ::google::protobuf::internal::WireFormatLite::
      InternalWriteMessageNoVirtualToArray(
        1, *this->position_, false, target);
  }

  // optional .mw.internal.robotics.gazebotransport.ML_Quat orientation = 2;
  if (has_orientation()) {
    target = ::google::protobuf::internal::WireFormatLite::
      InternalWriteMessageNoVirtualToArray(
        2, *this->orientation_, false, target);
  }

  if (_internal_metadata_.have_unknown_fields()) {
    target = ::google::protobuf::internal::WireFormat::SerializeUnknownFieldsToArray(
        unknown_fields(), target);
  }
  // @@protoc_insertion_point(serialize_to_array_end:mw.internal.robotics.gazebotransport.ML_Pose)
  return target;
}

int ML_Pose::ByteSize() const {
// @@protoc_insertion_point(message_byte_size_start:mw.internal.robotics.gazebotransport.ML_Pose)
  int total_size = 0;

  if (_has_bits_[0 / 32] & 3u) {
    // optional .mw.internal.robotics.gazebotransport.ML_Point position = 1;
    if (has_position()) {
      total_size += 1 +
        ::google::protobuf::internal::WireFormatLite::MessageSizeNoVirtual(
          *this->position_);
    }

    // optional .mw.internal.robotics.gazebotransport.ML_Quat orientation = 2;
    if (has_orientation()) {
      total_size += 1 +
        ::google::protobuf::internal::WireFormatLite::MessageSizeNoVirtual(
          *this->orientation_);
    }

  }
  if (_internal_metadata_.have_unknown_fields()) {
    total_size +=
      ::google::protobuf::internal::WireFormat::ComputeUnknownFieldsSize(
        unknown_fields());
  }
  GOOGLE_SAFE_CONCURRENT_WRITES_BEGIN();
  _cached_size_ = total_size;
  GOOGLE_SAFE_CONCURRENT_WRITES_END();
  return total_size;
}

void ML_Pose::MergeFrom(const ::google::protobuf::Message& from) {
// @@protoc_insertion_point(generalized_merge_from_start:mw.internal.robotics.gazebotransport.ML_Pose)
  if (GOOGLE_PREDICT_FALSE(&from == this)) {
    ::google::protobuf::internal::MergeFromFail(__FILE__, __LINE__);
  }
  const ML_Pose* source = 
      ::google::protobuf::internal::DynamicCastToGenerated<const ML_Pose>(
          &from);
  if (source == NULL) {
  // @@protoc_insertion_point(generalized_merge_from_cast_fail:mw.internal.robotics.gazebotransport.ML_Pose)
    ::google::protobuf::internal::ReflectionOps::Merge(from, this);
  } else {
  // @@protoc_insertion_point(generalized_merge_from_cast_success:mw.internal.robotics.gazebotransport.ML_Pose)
    MergeFrom(*source);
  }
}

void ML_Pose::MergeFrom(const ML_Pose& from) {
// @@protoc_insertion_point(class_specific_merge_from_start:mw.internal.robotics.gazebotransport.ML_Pose)
  if (GOOGLE_PREDICT_FALSE(&from == this)) {
    ::google::protobuf::internal::MergeFromFail(__FILE__, __LINE__);
  }
  if (from._has_bits_[0 / 32] & (0xffu << (0 % 32))) {
    if (from.has_position()) {
      mutable_position()->::mw::internal::robotics::gazebotransport::ML_Point::MergeFrom(from.position());
    }
    if (from.has_orientation()) {
      mutable_orientation()->::mw::internal::robotics::gazebotransport::ML_Quat::MergeFrom(from.orientation());
    }
  }
  if (from._internal_metadata_.have_unknown_fields()) {
    mutable_unknown_fields()->MergeFrom(from.unknown_fields());
  }
}

void ML_Pose::CopyFrom(const ::google::protobuf::Message& from) {
// @@protoc_insertion_point(generalized_copy_from_start:mw.internal.robotics.gazebotransport.ML_Pose)
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

void ML_Pose::CopyFrom(const ML_Pose& from) {
// @@protoc_insertion_point(class_specific_copy_from_start:mw.internal.robotics.gazebotransport.ML_Pose)
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

bool ML_Pose::IsInitialized() const {

  return true;
}

void ML_Pose::Swap(ML_Pose* other) {
  if (other == this) return;
  InternalSwap(other);
}
void ML_Pose::InternalSwap(ML_Pose* other) {
  std::swap(position_, other->position_);
  std::swap(orientation_, other->orientation_);
  std::swap(_has_bits_[0], other->_has_bits_[0]);
  _internal_metadata_.Swap(&other->_internal_metadata_);
  std::swap(_cached_size_, other->_cached_size_);
}

::google::protobuf::Metadata ML_Pose::GetMetadata() const {
  protobuf_AssignDescriptorsOnce();
  ::google::protobuf::Metadata metadata;
  metadata.descriptor = ML_Pose_descriptor_;
  metadata.reflection = ML_Pose_reflection_;
  return metadata;
}

#if PROTOBUF_INLINE_NOT_IN_HEADERS
// ML_Pose

// optional .mw.internal.robotics.gazebotransport.ML_Point position = 1;
bool ML_Pose::has_position() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
void ML_Pose::set_has_position() {
  _has_bits_[0] |= 0x00000001u;
}
void ML_Pose::clear_has_position() {
  _has_bits_[0] &= ~0x00000001u;
}
void ML_Pose::clear_position() {
  if (position_ != NULL) position_->::mw::internal::robotics::gazebotransport::ML_Point::Clear();
  clear_has_position();
}
const ::mw::internal::robotics::gazebotransport::ML_Point& ML_Pose::position() const {
  // @@protoc_insertion_point(field_get:mw.internal.robotics.gazebotransport.ML_Pose.position)
  return position_ != NULL ? *position_ : *default_instance_->position_;
}
::mw::internal::robotics::gazebotransport::ML_Point* ML_Pose::mutable_position() {
  set_has_position();
  if (position_ == NULL) {
    position_ = new ::mw::internal::robotics::gazebotransport::ML_Point;
  }
  // @@protoc_insertion_point(field_mutable:mw.internal.robotics.gazebotransport.ML_Pose.position)
  return position_;
}
::mw::internal::robotics::gazebotransport::ML_Point* ML_Pose::release_position() {
  // @@protoc_insertion_point(field_release:mw.internal.robotics.gazebotransport.ML_Pose.position)
  clear_has_position();
  ::mw::internal::robotics::gazebotransport::ML_Point* temp = position_;
  position_ = NULL;
  return temp;
}
void ML_Pose::set_allocated_position(::mw::internal::robotics::gazebotransport::ML_Point* position) {
  delete position_;
  position_ = position;
  if (position) {
    set_has_position();
  } else {
    clear_has_position();
  }
  // @@protoc_insertion_point(field_set_allocated:mw.internal.robotics.gazebotransport.ML_Pose.position)
}

// optional .mw.internal.robotics.gazebotransport.ML_Quat orientation = 2;
bool ML_Pose::has_orientation() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
void ML_Pose::set_has_orientation() {
  _has_bits_[0] |= 0x00000002u;
}
void ML_Pose::clear_has_orientation() {
  _has_bits_[0] &= ~0x00000002u;
}
void ML_Pose::clear_orientation() {
  if (orientation_ != NULL) orientation_->::mw::internal::robotics::gazebotransport::ML_Quat::Clear();
  clear_has_orientation();
}
const ::mw::internal::robotics::gazebotransport::ML_Quat& ML_Pose::orientation() const {
  // @@protoc_insertion_point(field_get:mw.internal.robotics.gazebotransport.ML_Pose.orientation)
  return orientation_ != NULL ? *orientation_ : *default_instance_->orientation_;
}
::mw::internal::robotics::gazebotransport::ML_Quat* ML_Pose::mutable_orientation() {
  set_has_orientation();
  if (orientation_ == NULL) {
    orientation_ = new ::mw::internal::robotics::gazebotransport::ML_Quat;
  }
  // @@protoc_insertion_point(field_mutable:mw.internal.robotics.gazebotransport.ML_Pose.orientation)
  return orientation_;
}
::mw::internal::robotics::gazebotransport::ML_Quat* ML_Pose::release_orientation() {
  // @@protoc_insertion_point(field_release:mw.internal.robotics.gazebotransport.ML_Pose.orientation)
  clear_has_orientation();
  ::mw::internal::robotics::gazebotransport::ML_Quat* temp = orientation_;
  orientation_ = NULL;
  return temp;
}
void ML_Pose::set_allocated_orientation(::mw::internal::robotics::gazebotransport::ML_Quat* orientation) {
  delete orientation_;
  orientation_ = orientation;
  if (orientation) {
    set_has_orientation();
  } else {
    clear_has_orientation();
  }
  // @@protoc_insertion_point(field_set_allocated:mw.internal.robotics.gazebotransport.ML_Pose.orientation)
}

#endif  // PROTOBUF_INLINE_NOT_IN_HEADERS

// ===================================================================

#if !defined(_MSC_VER) || _MSC_VER >= 1900
const int ML_Inertial::kMassFieldNumber;
const int ML_Inertial::kIxxFieldNumber;
const int ML_Inertial::kIxyFieldNumber;
const int ML_Inertial::kIxzFieldNumber;
const int ML_Inertial::kIyyFieldNumber;
const int ML_Inertial::kIyzFieldNumber;
const int ML_Inertial::kIzzFieldNumber;
#endif  // !defined(_MSC_VER) || _MSC_VER >= 1900

ML_Inertial::ML_Inertial()
  : ::google::protobuf::Message(), _internal_metadata_(NULL) {
  SharedCtor();
  // @@protoc_insertion_point(constructor:mw.internal.robotics.gazebotransport.ML_Inertial)
}

void ML_Inertial::InitAsDefaultInstance() {
}

ML_Inertial::ML_Inertial(const ML_Inertial& from)
  : ::google::protobuf::Message(),
    _internal_metadata_(NULL) {
  SharedCtor();
  MergeFrom(from);
  // @@protoc_insertion_point(copy_constructor:mw.internal.robotics.gazebotransport.ML_Inertial)
}

void ML_Inertial::SharedCtor() {
  _cached_size_ = 0;
  mass_ = 0;
  ixx_ = 0;
  ixy_ = 0;
  ixz_ = 0;
  iyy_ = 0;
  iyz_ = 0;
  izz_ = 0;
  ::memset(_has_bits_, 0, sizeof(_has_bits_));
}

ML_Inertial::~ML_Inertial() {
  // @@protoc_insertion_point(destructor:mw.internal.robotics.gazebotransport.ML_Inertial)
  SharedDtor();
}

void ML_Inertial::SharedDtor() {
  if (this != default_instance_) {
  }
}

void ML_Inertial::SetCachedSize(int size) const {
  GOOGLE_SAFE_CONCURRENT_WRITES_BEGIN();
  _cached_size_ = size;
  GOOGLE_SAFE_CONCURRENT_WRITES_END();
}
const ::google::protobuf::Descriptor* ML_Inertial::descriptor() {
  protobuf_AssignDescriptorsOnce();
  return ML_Inertial_descriptor_;
}

const ML_Inertial& ML_Inertial::default_instance() {
  if (default_instance_ == NULL) protobuf_AddDesc_mw_2einternal_2erobotics_2egazebotransport_2eCoSimMsgs_2eproto();
  return *default_instance_;
}

ML_Inertial* ML_Inertial::default_instance_ = NULL;

ML_Inertial* ML_Inertial::New(::google::protobuf::Arena* arena) const {
  ML_Inertial* n = new ML_Inertial;
  if (arena != NULL) {
    arena->Own(n);
  }
  return n;
}

void ML_Inertial::Clear() {
// @@protoc_insertion_point(message_clear_start:mw.internal.robotics.gazebotransport.ML_Inertial)
#if defined(__clang__)
#define ZR_HELPER_(f) \
  _Pragma("clang diagnostic push") \
  _Pragma("clang diagnostic ignored \"-Winvalid-offsetof\"") \
  __builtin_offsetof(ML_Inertial, f) \
  _Pragma("clang diagnostic pop")
#else
#define ZR_HELPER_(f) reinterpret_cast<char*>(\
  &reinterpret_cast<ML_Inertial*>(16)->f)
#endif

#define ZR_(first, last) do {\
  ::memset(&first, 0,\
           ZR_HELPER_(last) - ZR_HELPER_(first) + sizeof(last));\
} while (0)

  if (_has_bits_[0 / 32] & 127u) {
    ZR_(mass_, izz_);
  }

#undef ZR_HELPER_
#undef ZR_

  ::memset(_has_bits_, 0, sizeof(_has_bits_));
  if (_internal_metadata_.have_unknown_fields()) {
    mutable_unknown_fields()->Clear();
  }
}

bool ML_Inertial::MergePartialFromCodedStream(
    ::google::protobuf::io::CodedInputStream* input) {
#define DO_(EXPRESSION) if (!GOOGLE_PREDICT_TRUE(EXPRESSION)) goto failure
  ::google::protobuf::uint32 tag;
  // @@protoc_insertion_point(parse_start:mw.internal.robotics.gazebotransport.ML_Inertial)
  for (;;) {
    ::std::pair< ::google::protobuf::uint32, bool> p = input->ReadTagWithCutoff(127);
    tag = p.first;
    if (!p.second) goto handle_unusual;
    switch (::google::protobuf::internal::WireFormatLite::GetTagFieldNumber(tag)) {
      // optional double mass = 1;
      case 1: {
        if (tag == 9) {
          DO_((::google::protobuf::internal::WireFormatLite::ReadPrimitive<
                   double, ::google::protobuf::internal::WireFormatLite::TYPE_DOUBLE>(
                 input, &mass_)));
          set_has_mass();
        } else {
          goto handle_unusual;
        }
        if (input->ExpectTag(17)) goto parse_ixx;
        break;
      }

      // optional double ixx = 2;
      case 2: {
        if (tag == 17) {
         parse_ixx:
          DO_((::google::protobuf::internal::WireFormatLite::ReadPrimitive<
                   double, ::google::protobuf::internal::WireFormatLite::TYPE_DOUBLE>(
                 input, &ixx_)));
          set_has_ixx();
        } else {
          goto handle_unusual;
        }
        if (input->ExpectTag(25)) goto parse_ixy;
        break;
      }

      // optional double ixy = 3;
      case 3: {
        if (tag == 25) {
         parse_ixy:
          DO_((::google::protobuf::internal::WireFormatLite::ReadPrimitive<
                   double, ::google::protobuf::internal::WireFormatLite::TYPE_DOUBLE>(
                 input, &ixy_)));
          set_has_ixy();
        } else {
          goto handle_unusual;
        }
        if (input->ExpectTag(33)) goto parse_ixz;
        break;
      }

      // optional double ixz = 4;
      case 4: {
        if (tag == 33) {
         parse_ixz:
          DO_((::google::protobuf::internal::WireFormatLite::ReadPrimitive<
                   double, ::google::protobuf::internal::WireFormatLite::TYPE_DOUBLE>(
                 input, &ixz_)));
          set_has_ixz();
        } else {
          goto handle_unusual;
        }
        if (input->ExpectTag(41)) goto parse_iyy;
        break;
      }

      // optional double iyy = 5;
      case 5: {
        if (tag == 41) {
         parse_iyy:
          DO_((::google::protobuf::internal::WireFormatLite::ReadPrimitive<
                   double, ::google::protobuf::internal::WireFormatLite::TYPE_DOUBLE>(
                 input, &iyy_)));
          set_has_iyy();
        } else {
          goto handle_unusual;
        }
        if (input->ExpectTag(49)) goto parse_iyz;
        break;
      }

      // optional double iyz = 6;
      case 6: {
        if (tag == 49) {
         parse_iyz:
          DO_((::google::protobuf::internal::WireFormatLite::ReadPrimitive<
                   double, ::google::protobuf::internal::WireFormatLite::TYPE_DOUBLE>(
                 input, &iyz_)));
          set_has_iyz();
        } else {
          goto handle_unusual;
        }
        if (input->ExpectTag(57)) goto parse_izz;
        break;
      }

      // optional double izz = 7;
      case 7: {
        if (tag == 57) {
         parse_izz:
          DO_((::google::protobuf::internal::WireFormatLite::ReadPrimitive<
                   double, ::google::protobuf::internal::WireFormatLite::TYPE_DOUBLE>(
                 input, &izz_)));
          set_has_izz();
        } else {
          goto handle_unusual;
        }
        if (input->ExpectAtEnd()) goto success;
        break;
      }

      default: {
      handle_unusual:
        if (tag == 0 ||
            ::google::protobuf::internal::WireFormatLite::GetTagWireType(tag) ==
            ::google::protobuf::internal::WireFormatLite::WIRETYPE_END_GROUP) {
          goto success;
        }
        DO_(::google::protobuf::internal::WireFormat::SkipField(
              input, tag, mutable_unknown_fields()));
        break;
      }
    }
  }
success:
  // @@protoc_insertion_point(parse_success:mw.internal.robotics.gazebotransport.ML_Inertial)
  return true;
failure:
  // @@protoc_insertion_point(parse_failure:mw.internal.robotics.gazebotransport.ML_Inertial)
  return false;
#undef DO_
}

void ML_Inertial::SerializeWithCachedSizes(
    ::google::protobuf::io::CodedOutputStream* output) const {
  // @@protoc_insertion_point(serialize_start:mw.internal.robotics.gazebotransport.ML_Inertial)
  // optional double mass = 1;
  if (has_mass()) {
    ::google::protobuf::internal::WireFormatLite::WriteDouble(1, this->mass(), output);
  }

  // optional double ixx = 2;
  if (has_ixx()) {
    ::google::protobuf::internal::WireFormatLite::WriteDouble(2, this->ixx(), output);
  }

  // optional double ixy = 3;
  if (has_ixy()) {
    ::google::protobuf::internal::WireFormatLite::WriteDouble(3, this->ixy(), output);
  }

  // optional double ixz = 4;
  if (has_ixz()) {
    ::google::protobuf::internal::WireFormatLite::WriteDouble(4, this->ixz(), output);
  }

  // optional double iyy = 5;
  if (has_iyy()) {
    ::google::protobuf::internal::WireFormatLite::WriteDouble(5, this->iyy(), output);
  }

  // optional double iyz = 6;
  if (has_iyz()) {
    ::google::protobuf::internal::WireFormatLite::WriteDouble(6, this->iyz(), output);
  }

  // optional double izz = 7;
  if (has_izz()) {
    ::google::protobuf::internal::WireFormatLite::WriteDouble(7, this->izz(), output);
  }

  if (_internal_metadata_.have_unknown_fields()) {
    ::google::protobuf::internal::WireFormat::SerializeUnknownFields(
        unknown_fields(), output);
  }
  // @@protoc_insertion_point(serialize_end:mw.internal.robotics.gazebotransport.ML_Inertial)
}

::google::protobuf::uint8* ML_Inertial::InternalSerializeWithCachedSizesToArray(
    bool deterministic, ::google::protobuf::uint8* target) const {
  // @@protoc_insertion_point(serialize_to_array_start:mw.internal.robotics.gazebotransport.ML_Inertial)
  // optional double mass = 1;
  if (has_mass()) {
    target = ::google::protobuf::internal::WireFormatLite::WriteDoubleToArray(1, this->mass(), target);
  }

  // optional double ixx = 2;
  if (has_ixx()) {
    target = ::google::protobuf::internal::WireFormatLite::WriteDoubleToArray(2, this->ixx(), target);
  }

  // optional double ixy = 3;
  if (has_ixy()) {
    target = ::google::protobuf::internal::WireFormatLite::WriteDoubleToArray(3, this->ixy(), target);
  }

  // optional double ixz = 4;
  if (has_ixz()) {
    target = ::google::protobuf::internal::WireFormatLite::WriteDoubleToArray(4, this->ixz(), target);
  }

  // optional double iyy = 5;
  if (has_iyy()) {
    target = ::google::protobuf::internal::WireFormatLite::WriteDoubleToArray(5, this->iyy(), target);
  }

  // optional double iyz = 6;
  if (has_iyz()) {
    target = ::google::protobuf::internal::WireFormatLite::WriteDoubleToArray(6, this->iyz(), target);
  }

  // optional double izz = 7;
  if (has_izz()) {
    target = ::google::protobuf::internal::WireFormatLite::WriteDoubleToArray(7, this->izz(), target);
  }

  if (_internal_metadata_.have_unknown_fields()) {
    target = ::google::protobuf::internal::WireFormat::SerializeUnknownFieldsToArray(
        unknown_fields(), target);
  }
  // @@protoc_insertion_point(serialize_to_array_end:mw.internal.robotics.gazebotransport.ML_Inertial)
  return target;
}

int ML_Inertial::ByteSize() const {
// @@protoc_insertion_point(message_byte_size_start:mw.internal.robotics.gazebotransport.ML_Inertial)
  int total_size = 0;

  if (_has_bits_[0 / 32] & 127u) {
    // optional double mass = 1;
    if (has_mass()) {
      total_size += 1 + 8;
    }

    // optional double ixx = 2;
    if (has_ixx()) {
      total_size += 1 + 8;
    }

    // optional double ixy = 3;
    if (has_ixy()) {
      total_size += 1 + 8;
    }

    // optional double ixz = 4;
    if (has_ixz()) {
      total_size += 1 + 8;
    }

    // optional double iyy = 5;
    if (has_iyy()) {
      total_size += 1 + 8;
    }

    // optional double iyz = 6;
    if (has_iyz()) {
      total_size += 1 + 8;
    }

    // optional double izz = 7;
    if (has_izz()) {
      total_size += 1 + 8;
    }

  }
  if (_internal_metadata_.have_unknown_fields()) {
    total_size +=
      ::google::protobuf::internal::WireFormat::ComputeUnknownFieldsSize(
        unknown_fields());
  }
  GOOGLE_SAFE_CONCURRENT_WRITES_BEGIN();
  _cached_size_ = total_size;
  GOOGLE_SAFE_CONCURRENT_WRITES_END();
  return total_size;
}

void ML_Inertial::MergeFrom(const ::google::protobuf::Message& from) {
// @@protoc_insertion_point(generalized_merge_from_start:mw.internal.robotics.gazebotransport.ML_Inertial)
  if (GOOGLE_PREDICT_FALSE(&from == this)) {
    ::google::protobuf::internal::MergeFromFail(__FILE__, __LINE__);
  }
  const ML_Inertial* source = 
      ::google::protobuf::internal::DynamicCastToGenerated<const ML_Inertial>(
          &from);
  if (source == NULL) {
  // @@protoc_insertion_point(generalized_merge_from_cast_fail:mw.internal.robotics.gazebotransport.ML_Inertial)
    ::google::protobuf::internal::ReflectionOps::Merge(from, this);
  } else {
  // @@protoc_insertion_point(generalized_merge_from_cast_success:mw.internal.robotics.gazebotransport.ML_Inertial)
    MergeFrom(*source);
  }
}

void ML_Inertial::MergeFrom(const ML_Inertial& from) {
// @@protoc_insertion_point(class_specific_merge_from_start:mw.internal.robotics.gazebotransport.ML_Inertial)
  if (GOOGLE_PREDICT_FALSE(&from == this)) {
    ::google::protobuf::internal::MergeFromFail(__FILE__, __LINE__);
  }
  if (from._has_bits_[0 / 32] & (0xffu << (0 % 32))) {
    if (from.has_mass()) {
      set_mass(from.mass());
    }
    if (from.has_ixx()) {
      set_ixx(from.ixx());
    }
    if (from.has_ixy()) {
      set_ixy(from.ixy());
    }
    if (from.has_ixz()) {
      set_ixz(from.ixz());
    }
    if (from.has_iyy()) {
      set_iyy(from.iyy());
    }
    if (from.has_iyz()) {
      set_iyz(from.iyz());
    }
    if (from.has_izz()) {
      set_izz(from.izz());
    }
  }
  if (from._internal_metadata_.have_unknown_fields()) {
    mutable_unknown_fields()->MergeFrom(from.unknown_fields());
  }
}

void ML_Inertial::CopyFrom(const ::google::protobuf::Message& from) {
// @@protoc_insertion_point(generalized_copy_from_start:mw.internal.robotics.gazebotransport.ML_Inertial)
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

void ML_Inertial::CopyFrom(const ML_Inertial& from) {
// @@protoc_insertion_point(class_specific_copy_from_start:mw.internal.robotics.gazebotransport.ML_Inertial)
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

bool ML_Inertial::IsInitialized() const {

  return true;
}

void ML_Inertial::Swap(ML_Inertial* other) {
  if (other == this) return;
  InternalSwap(other);
}
void ML_Inertial::InternalSwap(ML_Inertial* other) {
  std::swap(mass_, other->mass_);
  std::swap(ixx_, other->ixx_);
  std::swap(ixy_, other->ixy_);
  std::swap(ixz_, other->ixz_);
  std::swap(iyy_, other->iyy_);
  std::swap(iyz_, other->iyz_);
  std::swap(izz_, other->izz_);
  std::swap(_has_bits_[0], other->_has_bits_[0]);
  _internal_metadata_.Swap(&other->_internal_metadata_);
  std::swap(_cached_size_, other->_cached_size_);
}

::google::protobuf::Metadata ML_Inertial::GetMetadata() const {
  protobuf_AssignDescriptorsOnce();
  ::google::protobuf::Metadata metadata;
  metadata.descriptor = ML_Inertial_descriptor_;
  metadata.reflection = ML_Inertial_reflection_;
  return metadata;
}

#if PROTOBUF_INLINE_NOT_IN_HEADERS
// ML_Inertial

// optional double mass = 1;
bool ML_Inertial::has_mass() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
void ML_Inertial::set_has_mass() {
  _has_bits_[0] |= 0x00000001u;
}
void ML_Inertial::clear_has_mass() {
  _has_bits_[0] &= ~0x00000001u;
}
void ML_Inertial::clear_mass() {
  mass_ = 0;
  clear_has_mass();
}
 double ML_Inertial::mass() const {
  // @@protoc_insertion_point(field_get:mw.internal.robotics.gazebotransport.ML_Inertial.mass)
  return mass_;
}
 void ML_Inertial::set_mass(double value) {
  set_has_mass();
  mass_ = value;
  // @@protoc_insertion_point(field_set:mw.internal.robotics.gazebotransport.ML_Inertial.mass)
}

// optional double ixx = 2;
bool ML_Inertial::has_ixx() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
void ML_Inertial::set_has_ixx() {
  _has_bits_[0] |= 0x00000002u;
}
void ML_Inertial::clear_has_ixx() {
  _has_bits_[0] &= ~0x00000002u;
}
void ML_Inertial::clear_ixx() {
  ixx_ = 0;
  clear_has_ixx();
}
 double ML_Inertial::ixx() const {
  // @@protoc_insertion_point(field_get:mw.internal.robotics.gazebotransport.ML_Inertial.ixx)
  return ixx_;
}
 void ML_Inertial::set_ixx(double value) {
  set_has_ixx();
  ixx_ = value;
  // @@protoc_insertion_point(field_set:mw.internal.robotics.gazebotransport.ML_Inertial.ixx)
}

// optional double ixy = 3;
bool ML_Inertial::has_ixy() const {
  return (_has_bits_[0] & 0x00000004u) != 0;
}
void ML_Inertial::set_has_ixy() {
  _has_bits_[0] |= 0x00000004u;
}
void ML_Inertial::clear_has_ixy() {
  _has_bits_[0] &= ~0x00000004u;
}
void ML_Inertial::clear_ixy() {
  ixy_ = 0;
  clear_has_ixy();
}
 double ML_Inertial::ixy() const {
  // @@protoc_insertion_point(field_get:mw.internal.robotics.gazebotransport.ML_Inertial.ixy)
  return ixy_;
}
 void ML_Inertial::set_ixy(double value) {
  set_has_ixy();
  ixy_ = value;
  // @@protoc_insertion_point(field_set:mw.internal.robotics.gazebotransport.ML_Inertial.ixy)
}

// optional double ixz = 4;
bool ML_Inertial::has_ixz() const {
  return (_has_bits_[0] & 0x00000008u) != 0;
}
void ML_Inertial::set_has_ixz() {
  _has_bits_[0] |= 0x00000008u;
}
void ML_Inertial::clear_has_ixz() {
  _has_bits_[0] &= ~0x00000008u;
}
void ML_Inertial::clear_ixz() {
  ixz_ = 0;
  clear_has_ixz();
}
 double ML_Inertial::ixz() const {
  // @@protoc_insertion_point(field_get:mw.internal.robotics.gazebotransport.ML_Inertial.ixz)
  return ixz_;
}
 void ML_Inertial::set_ixz(double value) {
  set_has_ixz();
  ixz_ = value;
  // @@protoc_insertion_point(field_set:mw.internal.robotics.gazebotransport.ML_Inertial.ixz)
}

// optional double iyy = 5;
bool ML_Inertial::has_iyy() const {
  return (_has_bits_[0] & 0x00000010u) != 0;
}
void ML_Inertial::set_has_iyy() {
  _has_bits_[0] |= 0x00000010u;
}
void ML_Inertial::clear_has_iyy() {
  _has_bits_[0] &= ~0x00000010u;
}
void ML_Inertial::clear_iyy() {
  iyy_ = 0;
  clear_has_iyy();
}
 double ML_Inertial::iyy() const {
  // @@protoc_insertion_point(field_get:mw.internal.robotics.gazebotransport.ML_Inertial.iyy)
  return iyy_;
}
 void ML_Inertial::set_iyy(double value) {
  set_has_iyy();
  iyy_ = value;
  // @@protoc_insertion_point(field_set:mw.internal.robotics.gazebotransport.ML_Inertial.iyy)
}

// optional double iyz = 6;
bool ML_Inertial::has_iyz() const {
  return (_has_bits_[0] & 0x00000020u) != 0;
}
void ML_Inertial::set_has_iyz() {
  _has_bits_[0] |= 0x00000020u;
}
void ML_Inertial::clear_has_iyz() {
  _has_bits_[0] &= ~0x00000020u;
}
void ML_Inertial::clear_iyz() {
  iyz_ = 0;
  clear_has_iyz();
}
 double ML_Inertial::iyz() const {
  // @@protoc_insertion_point(field_get:mw.internal.robotics.gazebotransport.ML_Inertial.iyz)
  return iyz_;
}
 void ML_Inertial::set_iyz(double value) {
  set_has_iyz();
  iyz_ = value;
  // @@protoc_insertion_point(field_set:mw.internal.robotics.gazebotransport.ML_Inertial.iyz)
}

// optional double izz = 7;
bool ML_Inertial::has_izz() const {
  return (_has_bits_[0] & 0x00000040u) != 0;
}
void ML_Inertial::set_has_izz() {
  _has_bits_[0] |= 0x00000040u;
}
void ML_Inertial::clear_has_izz() {
  _has_bits_[0] &= ~0x00000040u;
}
void ML_Inertial::clear_izz() {
  izz_ = 0;
  clear_has_izz();
}
 double ML_Inertial::izz() const {
  // @@protoc_insertion_point(field_get:mw.internal.robotics.gazebotransport.ML_Inertial.izz)
  return izz_;
}
 void ML_Inertial::set_izz(double value) {
  set_has_izz();
  izz_ = value;
  // @@protoc_insertion_point(field_set:mw.internal.robotics.gazebotransport.ML_Inertial.izz)
}

#endif  // PROTOBUF_INLINE_NOT_IN_HEADERS

// ===================================================================

#if !defined(_MSC_VER) || _MSC_VER >= 1900
const int ML_Links::kNameFieldNumber;
const int ML_Links::kPoseFieldNumber;
const int ML_Links::kInertialFieldNumber;
const int ML_Links::kSelfCollideFieldNumber;
const int ML_Links::kGravityFieldNumber;
const int ML_Links::kKinematicFieldNumber;
const int ML_Links::kEnabledWindFieldNumber;
const int ML_Links::kIsStaticFieldNumber;
const int ML_Links::kCanonicalFieldNumber;
#endif  // !defined(_MSC_VER) || _MSC_VER >= 1900

ML_Links::ML_Links()
  : ::google::protobuf::Message(), _internal_metadata_(NULL) {
  SharedCtor();
  // @@protoc_insertion_point(constructor:mw.internal.robotics.gazebotransport.ML_Links)
}

void ML_Links::InitAsDefaultInstance() {
  pose_ = const_cast< ::mw::internal::robotics::gazebotransport::ML_Pose*>(&::mw::internal::robotics::gazebotransport::ML_Pose::default_instance());
  inertial_ = const_cast< ::mw::internal::robotics::gazebotransport::ML_Inertial*>(&::mw::internal::robotics::gazebotransport::ML_Inertial::default_instance());
}

ML_Links::ML_Links(const ML_Links& from)
  : ::google::protobuf::Message(),
    _internal_metadata_(NULL) {
  SharedCtor();
  MergeFrom(from);
  // @@protoc_insertion_point(copy_constructor:mw.internal.robotics.gazebotransport.ML_Links)
}

void ML_Links::SharedCtor() {
  ::google::protobuf::internal::GetEmptyString();
  _cached_size_ = 0;
  name_.UnsafeSetDefault(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
  pose_ = NULL;
  inertial_ = NULL;
  self_collide_ = false;
  gravity_ = false;
  kinematic_ = false;
  enabled_wind_ = false;
  is_static_ = false;
  canonical_ = false;
  ::memset(_has_bits_, 0, sizeof(_has_bits_));
}

ML_Links::~ML_Links() {
  // @@protoc_insertion_point(destructor:mw.internal.robotics.gazebotransport.ML_Links)
  SharedDtor();
}

void ML_Links::SharedDtor() {
  name_.DestroyNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
  if (this != default_instance_) {
    delete pose_;
    delete inertial_;
  }
}

void ML_Links::SetCachedSize(int size) const {
  GOOGLE_SAFE_CONCURRENT_WRITES_BEGIN();
  _cached_size_ = size;
  GOOGLE_SAFE_CONCURRENT_WRITES_END();
}
const ::google::protobuf::Descriptor* ML_Links::descriptor() {
  protobuf_AssignDescriptorsOnce();
  return ML_Links_descriptor_;
}

const ML_Links& ML_Links::default_instance() {
  if (default_instance_ == NULL) protobuf_AddDesc_mw_2einternal_2erobotics_2egazebotransport_2eCoSimMsgs_2eproto();
  return *default_instance_;
}

ML_Links* ML_Links::default_instance_ = NULL;

ML_Links* ML_Links::New(::google::protobuf::Arena* arena) const {
  ML_Links* n = new ML_Links;
  if (arena != NULL) {
    arena->Own(n);
  }
  return n;
}

void ML_Links::Clear() {
// @@protoc_insertion_point(message_clear_start:mw.internal.robotics.gazebotransport.ML_Links)
#if defined(__clang__)
#define ZR_HELPER_(f) \
  _Pragma("clang diagnostic push") \
  _Pragma("clang diagnostic ignored \"-Winvalid-offsetof\"") \
  __builtin_offsetof(ML_Links, f) \
  _Pragma("clang diagnostic pop")
#else
#define ZR_HELPER_(f) reinterpret_cast<char*>(\
  &reinterpret_cast<ML_Links*>(16)->f)
#endif

#define ZR_(first, last) do {\
  ::memset(&first, 0,\
           ZR_HELPER_(last) - ZR_HELPER_(first) + sizeof(last));\
} while (0)

  if (_has_bits_[0 / 32] & 255u) {
    ZR_(self_collide_, is_static_);
    if (has_name()) {
      name_.ClearToEmptyNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
    }
    if (has_pose()) {
      if (pose_ != NULL) pose_->::mw::internal::robotics::gazebotransport::ML_Pose::Clear();
    }
    if (has_inertial()) {
      if (inertial_ != NULL) inertial_->::mw::internal::robotics::gazebotransport::ML_Inertial::Clear();
    }
  }
  canonical_ = false;

#undef ZR_HELPER_
#undef ZR_

  ::memset(_has_bits_, 0, sizeof(_has_bits_));
  if (_internal_metadata_.have_unknown_fields()) {
    mutable_unknown_fields()->Clear();
  }
}

bool ML_Links::MergePartialFromCodedStream(
    ::google::protobuf::io::CodedInputStream* input) {
#define DO_(EXPRESSION) if (!GOOGLE_PREDICT_TRUE(EXPRESSION)) goto failure
  ::google::protobuf::uint32 tag;
  // @@protoc_insertion_point(parse_start:mw.internal.robotics.gazebotransport.ML_Links)
  for (;;) {
    ::std::pair< ::google::protobuf::uint32, bool> p = input->ReadTagWithCutoff(127);
    tag = p.first;
    if (!p.second) goto handle_unusual;
    switch (::google::protobuf::internal::WireFormatLite::GetTagFieldNumber(tag)) {
      // optional string name = 1;
      case 1: {
        if (tag == 10) {
          DO_(::google::protobuf::internal::WireFormatLite::ReadString(
                input, this->mutable_name()));
          ::google::protobuf::internal::WireFormat::VerifyUTF8StringNamedField(
            this->name().data(), this->name().length(),
            ::google::protobuf::internal::WireFormat::PARSE,
            "mw.internal.robotics.gazebotransport.ML_Links.name");
        } else {
          goto handle_unusual;
        }
        if (input->ExpectTag(18)) goto parse_pose;
        break;
      }

      // optional .mw.internal.robotics.gazebotransport.ML_Pose pose = 2;
      case 2: {
        if (tag == 18) {
         parse_pose:
          DO_(::google::protobuf::internal::WireFormatLite::ReadMessageNoVirtual(
               input, mutable_pose()));
        } else {
          goto handle_unusual;
        }
        if (input->ExpectTag(26)) goto parse_inertial;
        break;
      }

      // optional .mw.internal.robotics.gazebotransport.ML_Inertial inertial = 3;
      case 3: {
        if (tag == 26) {
         parse_inertial:
          DO_(::google::protobuf::internal::WireFormatLite::ReadMessageNoVirtual(
               input, mutable_inertial()));
        } else {
          goto handle_unusual;
        }
        if (input->ExpectTag(32)) goto parse_self_collide;
        break;
      }

      // optional bool self_collide = 4;
      case 4: {
        if (tag == 32) {
         parse_self_collide:
          DO_((::google::protobuf::internal::WireFormatLite::ReadPrimitive<
                   bool, ::google::protobuf::internal::WireFormatLite::TYPE_BOOL>(
                 input, &self_collide_)));
          set_has_self_collide();
        } else {
          goto handle_unusual;
        }
        if (input->ExpectTag(40)) goto parse_gravity;
        break;
      }

      // optional bool gravity = 5;
      case 5: {
        if (tag == 40) {
         parse_gravity:
          DO_((::google::protobuf::internal::WireFormatLite::ReadPrimitive<
                   bool, ::google::protobuf::internal::WireFormatLite::TYPE_BOOL>(
                 input, &gravity_)));
          set_has_gravity();
        } else {
          goto handle_unusual;
        }
        if (input->ExpectTag(48)) goto parse_kinematic;
        break;
      }

      // optional bool kinematic = 6;
      case 6: {
        if (tag == 48) {
         parse_kinematic:
          DO_((::google::protobuf::internal::WireFormatLite::ReadPrimitive<
                   bool, ::google::protobuf::internal::WireFormatLite::TYPE_BOOL>(
                 input, &kinematic_)));
          set_has_kinematic();
        } else {
          goto handle_unusual;
        }
        if (input->ExpectTag(56)) goto parse_enabled_wind;
        break;
      }

      // optional bool enabled_wind = 7;
      case 7: {
        if (tag == 56) {
         parse_enabled_wind:
          DO_((::google::protobuf::internal::WireFormatLite::ReadPrimitive<
                   bool, ::google::protobuf::internal::WireFormatLite::TYPE_BOOL>(
                 input, &enabled_wind_)));
          set_has_enabled_wind();
        } else {
          goto handle_unusual;
        }
        if (input->ExpectTag(64)) goto parse_is_static;
        break;
      }

      // optional bool is_static = 8;
      case 8: {
        if (tag == 64) {
         parse_is_static:
          DO_((::google::protobuf::internal::WireFormatLite::ReadPrimitive<
                   bool, ::google::protobuf::internal::WireFormatLite::TYPE_BOOL>(
                 input, &is_static_)));
          set_has_is_static();
        } else {
          goto handle_unusual;
        }
        if (input->ExpectTag(72)) goto parse_canonical;
        break;
      }

      // optional bool canonical = 9;
      case 9: {
        if (tag == 72) {
         parse_canonical:
          DO_((::google::protobuf::internal::WireFormatLite::ReadPrimitive<
                   bool, ::google::protobuf::internal::WireFormatLite::TYPE_BOOL>(
                 input, &canonical_)));
          set_has_canonical();
        } else {
          goto handle_unusual;
        }
        if (input->ExpectAtEnd()) goto success;
        break;
      }

      default: {
      handle_unusual:
        if (tag == 0 ||
            ::google::protobuf::internal::WireFormatLite::GetTagWireType(tag) ==
            ::google::protobuf::internal::WireFormatLite::WIRETYPE_END_GROUP) {
          goto success;
        }
        DO_(::google::protobuf::internal::WireFormat::SkipField(
              input, tag, mutable_unknown_fields()));
        break;
      }
    }
  }
success:
  // @@protoc_insertion_point(parse_success:mw.internal.robotics.gazebotransport.ML_Links)
  return true;
failure:
  // @@protoc_insertion_point(parse_failure:mw.internal.robotics.gazebotransport.ML_Links)
  return false;
#undef DO_
}

void ML_Links::SerializeWithCachedSizes(
    ::google::protobuf::io::CodedOutputStream* output) const {
  // @@protoc_insertion_point(serialize_start:mw.internal.robotics.gazebotransport.ML_Links)
  // optional string name = 1;
  if (has_name()) {
    ::google::protobuf::internal::WireFormat::VerifyUTF8StringNamedField(
      this->name().data(), this->name().length(),
      ::google::protobuf::internal::WireFormat::SERIALIZE,
      "mw.internal.robotics.gazebotransport.ML_Links.name");
    ::google::protobuf::internal::WireFormatLite::WriteStringMaybeAliased(
      1, this->name(), output);
  }

  // optional .mw.internal.robotics.gazebotransport.ML_Pose pose = 2;
  if (has_pose()) {
    ::google::protobuf::internal::WireFormatLite::WriteMessageMaybeToArray(
      2, *this->pose_, output);
  }

  // optional .mw.internal.robotics.gazebotransport.ML_Inertial inertial = 3;
  if (has_inertial()) {
    ::google::protobuf::internal::WireFormatLite::WriteMessageMaybeToArray(
      3, *this->inertial_, output);
  }

  // optional bool self_collide = 4;
  if (has_self_collide()) {
    ::google::protobuf::internal::WireFormatLite::WriteBool(4, this->self_collide(), output);
  }

  // optional bool gravity = 5;
  if (has_gravity()) {
    ::google::protobuf::internal::WireFormatLite::WriteBool(5, this->gravity(), output);
  }

  // optional bool kinematic = 6;
  if (has_kinematic()) {
    ::google::protobuf::internal::WireFormatLite::WriteBool(6, this->kinematic(), output);
  }

  // optional bool enabled_wind = 7;
  if (has_enabled_wind()) {
    ::google::protobuf::internal::WireFormatLite::WriteBool(7, this->enabled_wind(), output);
  }

  // optional bool is_static = 8;
  if (has_is_static()) {
    ::google::protobuf::internal::WireFormatLite::WriteBool(8, this->is_static(), output);
  }

  // optional bool canonical = 9;
  if (has_canonical()) {
    ::google::protobuf::internal::WireFormatLite::WriteBool(9, this->canonical(), output);
  }

  if (_internal_metadata_.have_unknown_fields()) {
    ::google::protobuf::internal::WireFormat::SerializeUnknownFields(
        unknown_fields(), output);
  }
  // @@protoc_insertion_point(serialize_end:mw.internal.robotics.gazebotransport.ML_Links)
}

::google::protobuf::uint8* ML_Links::InternalSerializeWithCachedSizesToArray(
    bool deterministic, ::google::protobuf::uint8* target) const {
  // @@protoc_insertion_point(serialize_to_array_start:mw.internal.robotics.gazebotransport.ML_Links)
  // optional string name = 1;
  if (has_name()) {
    ::google::protobuf::internal::WireFormat::VerifyUTF8StringNamedField(
      this->name().data(), this->name().length(),
      ::google::protobuf::internal::WireFormat::SERIALIZE,
      "mw.internal.robotics.gazebotransport.ML_Links.name");
    target =
      ::google::protobuf::internal::WireFormatLite::WriteStringToArray(
        1, this->name(), target);
  }

  // optional .mw.internal.robotics.gazebotransport.ML_Pose pose = 2;
  if (has_pose()) {
    target = ::google::protobuf::internal::WireFormatLite::
      InternalWriteMessageNoVirtualToArray(
        2, *this->pose_, false, target);
  }

  // optional .mw.internal.robotics.gazebotransport.ML_Inertial inertial = 3;
  if (has_inertial()) {
    target = ::google::protobuf::internal::WireFormatLite::
      InternalWriteMessageNoVirtualToArray(
        3, *this->inertial_, false, target);
  }

  // optional bool self_collide = 4;
  if (has_self_collide()) {
    target = ::google::protobuf::internal::WireFormatLite::WriteBoolToArray(4, this->self_collide(), target);
  }

  // optional bool gravity = 5;
  if (has_gravity()) {
    target = ::google::protobuf::internal::WireFormatLite::WriteBoolToArray(5, this->gravity(), target);
  }

  // optional bool kinematic = 6;
  if (has_kinematic()) {
    target = ::google::protobuf::internal::WireFormatLite::WriteBoolToArray(6, this->kinematic(), target);
  }

  // optional bool enabled_wind = 7;
  if (has_enabled_wind()) {
    target = ::google::protobuf::internal::WireFormatLite::WriteBoolToArray(7, this->enabled_wind(), target);
  }

  // optional bool is_static = 8;
  if (has_is_static()) {
    target = ::google::protobuf::internal::WireFormatLite::WriteBoolToArray(8, this->is_static(), target);
  }

  // optional bool canonical = 9;
  if (has_canonical()) {
    target = ::google::protobuf::internal::WireFormatLite::WriteBoolToArray(9, this->canonical(), target);
  }

  if (_internal_metadata_.have_unknown_fields()) {
    target = ::google::protobuf::internal::WireFormat::SerializeUnknownFieldsToArray(
        unknown_fields(), target);
  }
  // @@protoc_insertion_point(serialize_to_array_end:mw.internal.robotics.gazebotransport.ML_Links)
  return target;
}

int ML_Links::ByteSize() const {
// @@protoc_insertion_point(message_byte_size_start:mw.internal.robotics.gazebotransport.ML_Links)
  int total_size = 0;

  if (_has_bits_[0 / 32] & 255u) {
    // optional string name = 1;
    if (has_name()) {
      total_size += 1 +
        ::google::protobuf::internal::WireFormatLite::StringSize(
          this->name());
    }

    // optional .mw.internal.robotics.gazebotransport.ML_Pose pose = 2;
    if (has_pose()) {
      total_size += 1 +
        ::google::protobuf::internal::WireFormatLite::MessageSizeNoVirtual(
          *this->pose_);
    }

    // optional .mw.internal.robotics.gazebotransport.ML_Inertial inertial = 3;
    if (has_inertial()) {
      total_size += 1 +
        ::google::protobuf::internal::WireFormatLite::MessageSizeNoVirtual(
          *this->inertial_);
    }

    // optional bool self_collide = 4;
    if (has_self_collide()) {
      total_size += 1 + 1;
    }

    // optional bool gravity = 5;
    if (has_gravity()) {
      total_size += 1 + 1;
    }

    // optional bool kinematic = 6;
    if (has_kinematic()) {
      total_size += 1 + 1;
    }

    // optional bool enabled_wind = 7;
    if (has_enabled_wind()) {
      total_size += 1 + 1;
    }

    // optional bool is_static = 8;
    if (has_is_static()) {
      total_size += 1 + 1;
    }

  }
  // optional bool canonical = 9;
  if (has_canonical()) {
    total_size += 1 + 1;
  }

  if (_internal_metadata_.have_unknown_fields()) {
    total_size +=
      ::google::protobuf::internal::WireFormat::ComputeUnknownFieldsSize(
        unknown_fields());
  }
  GOOGLE_SAFE_CONCURRENT_WRITES_BEGIN();
  _cached_size_ = total_size;
  GOOGLE_SAFE_CONCURRENT_WRITES_END();
  return total_size;
}

void ML_Links::MergeFrom(const ::google::protobuf::Message& from) {
// @@protoc_insertion_point(generalized_merge_from_start:mw.internal.robotics.gazebotransport.ML_Links)
  if (GOOGLE_PREDICT_FALSE(&from == this)) {
    ::google::protobuf::internal::MergeFromFail(__FILE__, __LINE__);
  }
  const ML_Links* source = 
      ::google::protobuf::internal::DynamicCastToGenerated<const ML_Links>(
          &from);
  if (source == NULL) {
  // @@protoc_insertion_point(generalized_merge_from_cast_fail:mw.internal.robotics.gazebotransport.ML_Links)
    ::google::protobuf::internal::ReflectionOps::Merge(from, this);
  } else {
  // @@protoc_insertion_point(generalized_merge_from_cast_success:mw.internal.robotics.gazebotransport.ML_Links)
    MergeFrom(*source);
  }
}

void ML_Links::MergeFrom(const ML_Links& from) {
// @@protoc_insertion_point(class_specific_merge_from_start:mw.internal.robotics.gazebotransport.ML_Links)
  if (GOOGLE_PREDICT_FALSE(&from == this)) {
    ::google::protobuf::internal::MergeFromFail(__FILE__, __LINE__);
  }
  if (from._has_bits_[0 / 32] & (0xffu << (0 % 32))) {
    if (from.has_name()) {
      set_has_name();
      name_.AssignWithDefault(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), from.name_);
    }
    if (from.has_pose()) {
      mutable_pose()->::mw::internal::robotics::gazebotransport::ML_Pose::MergeFrom(from.pose());
    }
    if (from.has_inertial()) {
      mutable_inertial()->::mw::internal::robotics::gazebotransport::ML_Inertial::MergeFrom(from.inertial());
    }
    if (from.has_self_collide()) {
      set_self_collide(from.self_collide());
    }
    if (from.has_gravity()) {
      set_gravity(from.gravity());
    }
    if (from.has_kinematic()) {
      set_kinematic(from.kinematic());
    }
    if (from.has_enabled_wind()) {
      set_enabled_wind(from.enabled_wind());
    }
    if (from.has_is_static()) {
      set_is_static(from.is_static());
    }
  }
  if (from._has_bits_[8 / 32] & (0xffu << (8 % 32))) {
    if (from.has_canonical()) {
      set_canonical(from.canonical());
    }
  }
  if (from._internal_metadata_.have_unknown_fields()) {
    mutable_unknown_fields()->MergeFrom(from.unknown_fields());
  }
}

void ML_Links::CopyFrom(const ::google::protobuf::Message& from) {
// @@protoc_insertion_point(generalized_copy_from_start:mw.internal.robotics.gazebotransport.ML_Links)
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

void ML_Links::CopyFrom(const ML_Links& from) {
// @@protoc_insertion_point(class_specific_copy_from_start:mw.internal.robotics.gazebotransport.ML_Links)
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

bool ML_Links::IsInitialized() const {

  return true;
}

void ML_Links::Swap(ML_Links* other) {
  if (other == this) return;
  InternalSwap(other);
}
void ML_Links::InternalSwap(ML_Links* other) {
  name_.Swap(&other->name_);
  std::swap(pose_, other->pose_);
  std::swap(inertial_, other->inertial_);
  std::swap(self_collide_, other->self_collide_);
  std::swap(gravity_, other->gravity_);
  std::swap(kinematic_, other->kinematic_);
  std::swap(enabled_wind_, other->enabled_wind_);
  std::swap(is_static_, other->is_static_);
  std::swap(canonical_, other->canonical_);
  std::swap(_has_bits_[0], other->_has_bits_[0]);
  _internal_metadata_.Swap(&other->_internal_metadata_);
  std::swap(_cached_size_, other->_cached_size_);
}

::google::protobuf::Metadata ML_Links::GetMetadata() const {
  protobuf_AssignDescriptorsOnce();
  ::google::protobuf::Metadata metadata;
  metadata.descriptor = ML_Links_descriptor_;
  metadata.reflection = ML_Links_reflection_;
  return metadata;
}

#if PROTOBUF_INLINE_NOT_IN_HEADERS
// ML_Links

// optional string name = 1;
bool ML_Links::has_name() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
void ML_Links::set_has_name() {
  _has_bits_[0] |= 0x00000001u;
}
void ML_Links::clear_has_name() {
  _has_bits_[0] &= ~0x00000001u;
}
void ML_Links::clear_name() {
  name_.ClearToEmptyNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
  clear_has_name();
}
 const ::std::string& ML_Links::name() const {
  // @@protoc_insertion_point(field_get:mw.internal.robotics.gazebotransport.ML_Links.name)
  return name_.GetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
 void ML_Links::set_name(const ::std::string& value) {
  set_has_name();
  name_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), value);
  // @@protoc_insertion_point(field_set:mw.internal.robotics.gazebotransport.ML_Links.name)
}
 void ML_Links::set_name(const char* value) {
  set_has_name();
  name_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::string(value));
  // @@protoc_insertion_point(field_set_char:mw.internal.robotics.gazebotransport.ML_Links.name)
}
 void ML_Links::set_name(const char* value, size_t size) {
  set_has_name();
  name_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(),
      ::std::string(reinterpret_cast<const char*>(value), size));
  // @@protoc_insertion_point(field_set_pointer:mw.internal.robotics.gazebotransport.ML_Links.name)
}
 ::std::string* ML_Links::mutable_name() {
  set_has_name();
  // @@protoc_insertion_point(field_mutable:mw.internal.robotics.gazebotransport.ML_Links.name)
  return name_.MutableNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
 ::std::string* ML_Links::release_name() {
  // @@protoc_insertion_point(field_release:mw.internal.robotics.gazebotransport.ML_Links.name)
  clear_has_name();
  return name_.ReleaseNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
 void ML_Links::set_allocated_name(::std::string* name) {
  if (name != NULL) {
    set_has_name();
  } else {
    clear_has_name();
  }
  name_.SetAllocatedNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), name);
  // @@protoc_insertion_point(field_set_allocated:mw.internal.robotics.gazebotransport.ML_Links.name)
}

// optional .mw.internal.robotics.gazebotransport.ML_Pose pose = 2;
bool ML_Links::has_pose() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
void ML_Links::set_has_pose() {
  _has_bits_[0] |= 0x00000002u;
}
void ML_Links::clear_has_pose() {
  _has_bits_[0] &= ~0x00000002u;
}
void ML_Links::clear_pose() {
  if (pose_ != NULL) pose_->::mw::internal::robotics::gazebotransport::ML_Pose::Clear();
  clear_has_pose();
}
const ::mw::internal::robotics::gazebotransport::ML_Pose& ML_Links::pose() const {
  // @@protoc_insertion_point(field_get:mw.internal.robotics.gazebotransport.ML_Links.pose)
  return pose_ != NULL ? *pose_ : *default_instance_->pose_;
}
::mw::internal::robotics::gazebotransport::ML_Pose* ML_Links::mutable_pose() {
  set_has_pose();
  if (pose_ == NULL) {
    pose_ = new ::mw::internal::robotics::gazebotransport::ML_Pose;
  }
  // @@protoc_insertion_point(field_mutable:mw.internal.robotics.gazebotransport.ML_Links.pose)
  return pose_;
}
::mw::internal::robotics::gazebotransport::ML_Pose* ML_Links::release_pose() {
  // @@protoc_insertion_point(field_release:mw.internal.robotics.gazebotransport.ML_Links.pose)
  clear_has_pose();
  ::mw::internal::robotics::gazebotransport::ML_Pose* temp = pose_;
  pose_ = NULL;
  return temp;
}
void ML_Links::set_allocated_pose(::mw::internal::robotics::gazebotransport::ML_Pose* pose) {
  delete pose_;
  pose_ = pose;
  if (pose) {
    set_has_pose();
  } else {
    clear_has_pose();
  }
  // @@protoc_insertion_point(field_set_allocated:mw.internal.robotics.gazebotransport.ML_Links.pose)
}

// optional .mw.internal.robotics.gazebotransport.ML_Inertial inertial = 3;
bool ML_Links::has_inertial() const {
  return (_has_bits_[0] & 0x00000004u) != 0;
}
void ML_Links::set_has_inertial() {
  _has_bits_[0] |= 0x00000004u;
}
void ML_Links::clear_has_inertial() {
  _has_bits_[0] &= ~0x00000004u;
}
void ML_Links::clear_inertial() {
  if (inertial_ != NULL) inertial_->::mw::internal::robotics::gazebotransport::ML_Inertial::Clear();
  clear_has_inertial();
}
const ::mw::internal::robotics::gazebotransport::ML_Inertial& ML_Links::inertial() const {
  // @@protoc_insertion_point(field_get:mw.internal.robotics.gazebotransport.ML_Links.inertial)
  return inertial_ != NULL ? *inertial_ : *default_instance_->inertial_;
}
::mw::internal::robotics::gazebotransport::ML_Inertial* ML_Links::mutable_inertial() {
  set_has_inertial();
  if (inertial_ == NULL) {
    inertial_ = new ::mw::internal::robotics::gazebotransport::ML_Inertial;
  }
  // @@protoc_insertion_point(field_mutable:mw.internal.robotics.gazebotransport.ML_Links.inertial)
  return inertial_;
}
::mw::internal::robotics::gazebotransport::ML_Inertial* ML_Links::release_inertial() {
  // @@protoc_insertion_point(field_release:mw.internal.robotics.gazebotransport.ML_Links.inertial)
  clear_has_inertial();
  ::mw::internal::robotics::gazebotransport::ML_Inertial* temp = inertial_;
  inertial_ = NULL;
  return temp;
}
void ML_Links::set_allocated_inertial(::mw::internal::robotics::gazebotransport::ML_Inertial* inertial) {
  delete inertial_;
  inertial_ = inertial;
  if (inertial) {
    set_has_inertial();
  } else {
    clear_has_inertial();
  }
  // @@protoc_insertion_point(field_set_allocated:mw.internal.robotics.gazebotransport.ML_Links.inertial)
}

// optional bool self_collide = 4;
bool ML_Links::has_self_collide() const {
  return (_has_bits_[0] & 0x00000008u) != 0;
}
void ML_Links::set_has_self_collide() {
  _has_bits_[0] |= 0x00000008u;
}
void ML_Links::clear_has_self_collide() {
  _has_bits_[0] &= ~0x00000008u;
}
void ML_Links::clear_self_collide() {
  self_collide_ = false;
  clear_has_self_collide();
}
 bool ML_Links::self_collide() const {
  // @@protoc_insertion_point(field_get:mw.internal.robotics.gazebotransport.ML_Links.self_collide)
  return self_collide_;
}
 void ML_Links::set_self_collide(bool value) {
  set_has_self_collide();
  self_collide_ = value;
  // @@protoc_insertion_point(field_set:mw.internal.robotics.gazebotransport.ML_Links.self_collide)
}

// optional bool gravity = 5;
bool ML_Links::has_gravity() const {
  return (_has_bits_[0] & 0x00000010u) != 0;
}
void ML_Links::set_has_gravity() {
  _has_bits_[0] |= 0x00000010u;
}
void ML_Links::clear_has_gravity() {
  _has_bits_[0] &= ~0x00000010u;
}
void ML_Links::clear_gravity() {
  gravity_ = false;
  clear_has_gravity();
}
 bool ML_Links::gravity() const {
  // @@protoc_insertion_point(field_get:mw.internal.robotics.gazebotransport.ML_Links.gravity)
  return gravity_;
}
 void ML_Links::set_gravity(bool value) {
  set_has_gravity();
  gravity_ = value;
  // @@protoc_insertion_point(field_set:mw.internal.robotics.gazebotransport.ML_Links.gravity)
}

// optional bool kinematic = 6;
bool ML_Links::has_kinematic() const {
  return (_has_bits_[0] & 0x00000020u) != 0;
}
void ML_Links::set_has_kinematic() {
  _has_bits_[0] |= 0x00000020u;
}
void ML_Links::clear_has_kinematic() {
  _has_bits_[0] &= ~0x00000020u;
}
void ML_Links::clear_kinematic() {
  kinematic_ = false;
  clear_has_kinematic();
}
 bool ML_Links::kinematic() const {
  // @@protoc_insertion_point(field_get:mw.internal.robotics.gazebotransport.ML_Links.kinematic)
  return kinematic_;
}
 void ML_Links::set_kinematic(bool value) {
  set_has_kinematic();
  kinematic_ = value;
  // @@protoc_insertion_point(field_set:mw.internal.robotics.gazebotransport.ML_Links.kinematic)
}

// optional bool enabled_wind = 7;
bool ML_Links::has_enabled_wind() const {
  return (_has_bits_[0] & 0x00000040u) != 0;
}
void ML_Links::set_has_enabled_wind() {
  _has_bits_[0] |= 0x00000040u;
}
void ML_Links::clear_has_enabled_wind() {
  _has_bits_[0] &= ~0x00000040u;
}
void ML_Links::clear_enabled_wind() {
  enabled_wind_ = false;
  clear_has_enabled_wind();
}
 bool ML_Links::enabled_wind() const {
  // @@protoc_insertion_point(field_get:mw.internal.robotics.gazebotransport.ML_Links.enabled_wind)
  return enabled_wind_;
}
 void ML_Links::set_enabled_wind(bool value) {
  set_has_enabled_wind();
  enabled_wind_ = value;
  // @@protoc_insertion_point(field_set:mw.internal.robotics.gazebotransport.ML_Links.enabled_wind)
}

// optional bool is_static = 8;
bool ML_Links::has_is_static() const {
  return (_has_bits_[0] & 0x00000080u) != 0;
}
void ML_Links::set_has_is_static() {
  _has_bits_[0] |= 0x00000080u;
}
void ML_Links::clear_has_is_static() {
  _has_bits_[0] &= ~0x00000080u;
}
void ML_Links::clear_is_static() {
  is_static_ = false;
  clear_has_is_static();
}
 bool ML_Links::is_static() const {
  // @@protoc_insertion_point(field_get:mw.internal.robotics.gazebotransport.ML_Links.is_static)
  return is_static_;
}
 void ML_Links::set_is_static(bool value) {
  set_has_is_static();
  is_static_ = value;
  // @@protoc_insertion_point(field_set:mw.internal.robotics.gazebotransport.ML_Links.is_static)
}

// optional bool canonical = 9;
bool ML_Links::has_canonical() const {
  return (_has_bits_[0] & 0x00000100u) != 0;
}
void ML_Links::set_has_canonical() {
  _has_bits_[0] |= 0x00000100u;
}
void ML_Links::clear_has_canonical() {
  _has_bits_[0] &= ~0x00000100u;
}
void ML_Links::clear_canonical() {
  canonical_ = false;
  clear_has_canonical();
}
 bool ML_Links::canonical() const {
  // @@protoc_insertion_point(field_get:mw.internal.robotics.gazebotransport.ML_Links.canonical)
  return canonical_;
}
 void ML_Links::set_canonical(bool value) {
  set_has_canonical();
  canonical_ = value;
  // @@protoc_insertion_point(field_set:mw.internal.robotics.gazebotransport.ML_Links.canonical)
}

#endif  // PROTOBUF_INLINE_NOT_IN_HEADERS

// ===================================================================

#if !defined(_MSC_VER) || _MSC_VER >= 1900
const int ML_Axis::kXyzFieldNumber;
const int ML_Axis::kDampingFieldNumber;
const int ML_Axis::kFrictionFieldNumber;
const int ML_Axis::kAngleFieldNumber;
#endif  // !defined(_MSC_VER) || _MSC_VER >= 1900

ML_Axis::ML_Axis()
  : ::google::protobuf::Message(), _internal_metadata_(NULL) {
  SharedCtor();
  // @@protoc_insertion_point(constructor:mw.internal.robotics.gazebotransport.ML_Axis)
}

void ML_Axis::InitAsDefaultInstance() {
  xyz_ = const_cast< ::mw::internal::robotics::gazebotransport::ML_Point*>(&::mw::internal::robotics::gazebotransport::ML_Point::default_instance());
}

ML_Axis::ML_Axis(const ML_Axis& from)
  : ::google::protobuf::Message(),
    _internal_metadata_(NULL) {
  SharedCtor();
  MergeFrom(from);
  // @@protoc_insertion_point(copy_constructor:mw.internal.robotics.gazebotransport.ML_Axis)
}

void ML_Axis::SharedCtor() {
  _cached_size_ = 0;
  xyz_ = NULL;
  damping_ = 0;
  friction_ = 0;
  angle_ = 0;
  ::memset(_has_bits_, 0, sizeof(_has_bits_));
}

ML_Axis::~ML_Axis() {
  // @@protoc_insertion_point(destructor:mw.internal.robotics.gazebotransport.ML_Axis)
  SharedDtor();
}

void ML_Axis::SharedDtor() {
  if (this != default_instance_) {
    delete xyz_;
  }
}

void ML_Axis::SetCachedSize(int size) const {
  GOOGLE_SAFE_CONCURRENT_WRITES_BEGIN();
  _cached_size_ = size;
  GOOGLE_SAFE_CONCURRENT_WRITES_END();
}
const ::google::protobuf::Descriptor* ML_Axis::descriptor() {
  protobuf_AssignDescriptorsOnce();
  return ML_Axis_descriptor_;
}

const ML_Axis& ML_Axis::default_instance() {
  if (default_instance_ == NULL) protobuf_AddDesc_mw_2einternal_2erobotics_2egazebotransport_2eCoSimMsgs_2eproto();
  return *default_instance_;
}

ML_Axis* ML_Axis::default_instance_ = NULL;

ML_Axis* ML_Axis::New(::google::protobuf::Arena* arena) const {
  ML_Axis* n = new ML_Axis;
  if (arena != NULL) {
    arena->Own(n);
  }
  return n;
}

void ML_Axis::Clear() {
// @@protoc_insertion_point(message_clear_start:mw.internal.robotics.gazebotransport.ML_Axis)
#if defined(__clang__)
#define ZR_HELPER_(f) \
  _Pragma("clang diagnostic push") \
  _Pragma("clang diagnostic ignored \"-Winvalid-offsetof\"") \
  __builtin_offsetof(ML_Axis, f) \
  _Pragma("clang diagnostic pop")
#else
#define ZR_HELPER_(f) reinterpret_cast<char*>(\
  &reinterpret_cast<ML_Axis*>(16)->f)
#endif

#define ZR_(first, last) do {\
  ::memset(&first, 0,\
           ZR_HELPER_(last) - ZR_HELPER_(first) + sizeof(last));\
} while (0)

  if (_has_bits_[0 / 32] & 15u) {
    ZR_(damping_, angle_);
    if (has_xyz()) {
      if (xyz_ != NULL) xyz_->::mw::internal::robotics::gazebotransport::ML_Point::Clear();
    }
  }

#undef ZR_HELPER_
#undef ZR_

  ::memset(_has_bits_, 0, sizeof(_has_bits_));
  if (_internal_metadata_.have_unknown_fields()) {
    mutable_unknown_fields()->Clear();
  }
}

bool ML_Axis::MergePartialFromCodedStream(
    ::google::protobuf::io::CodedInputStream* input) {
#define DO_(EXPRESSION) if (!GOOGLE_PREDICT_TRUE(EXPRESSION)) goto failure
  ::google::protobuf::uint32 tag;
  // @@protoc_insertion_point(parse_start:mw.internal.robotics.gazebotransport.ML_Axis)
  for (;;) {
    ::std::pair< ::google::protobuf::uint32, bool> p = input->ReadTagWithCutoff(127);
    tag = p.first;
    if (!p.second) goto handle_unusual;
    switch (::google::protobuf::internal::WireFormatLite::GetTagFieldNumber(tag)) {
      // optional .mw.internal.robotics.gazebotransport.ML_Point xyz = 1;
      case 1: {
        if (tag == 10) {
          DO_(::google::protobuf::internal::WireFormatLite::ReadMessageNoVirtual(
               input, mutable_xyz()));
        } else {
          goto handle_unusual;
        }
        if (input->ExpectTag(17)) goto parse_damping;
        break;
      }

      // optional double damping = 2;
      case 2: {
        if (tag == 17) {
         parse_damping:
          DO_((::google::protobuf::internal::WireFormatLite::ReadPrimitive<
                   double, ::google::protobuf::internal::WireFormatLite::TYPE_DOUBLE>(
                 input, &damping_)));
          set_has_damping();
        } else {
          goto handle_unusual;
        }
        if (input->ExpectTag(25)) goto parse_friction;
        break;
      }

      // optional double friction = 3;
      case 3: {
        if (tag == 25) {
         parse_friction:
          DO_((::google::protobuf::internal::WireFormatLite::ReadPrimitive<
                   double, ::google::protobuf::internal::WireFormatLite::TYPE_DOUBLE>(
                 input, &friction_)));
          set_has_friction();
        } else {
          goto handle_unusual;
        }
        if (input->ExpectTag(33)) goto parse_angle;
        break;
      }

      // optional double angle = 4;
      case 4: {
        if (tag == 33) {
         parse_angle:
          DO_((::google::protobuf::internal::WireFormatLite::ReadPrimitive<
                   double, ::google::protobuf::internal::WireFormatLite::TYPE_DOUBLE>(
                 input, &angle_)));
          set_has_angle();
        } else {
          goto handle_unusual;
        }
        if (input->ExpectAtEnd()) goto success;
        break;
      }

      default: {
      handle_unusual:
        if (tag == 0 ||
            ::google::protobuf::internal::WireFormatLite::GetTagWireType(tag) ==
            ::google::protobuf::internal::WireFormatLite::WIRETYPE_END_GROUP) {
          goto success;
        }
        DO_(::google::protobuf::internal::WireFormat::SkipField(
              input, tag, mutable_unknown_fields()));
        break;
      }
    }
  }
success:
  // @@protoc_insertion_point(parse_success:mw.internal.robotics.gazebotransport.ML_Axis)
  return true;
failure:
  // @@protoc_insertion_point(parse_failure:mw.internal.robotics.gazebotransport.ML_Axis)
  return false;
#undef DO_
}

void ML_Axis::SerializeWithCachedSizes(
    ::google::protobuf::io::CodedOutputStream* output) const {
  // @@protoc_insertion_point(serialize_start:mw.internal.robotics.gazebotransport.ML_Axis)
  // optional .mw.internal.robotics.gazebotransport.ML_Point xyz = 1;
  if (has_xyz()) {
    ::google::protobuf::internal::WireFormatLite::WriteMessageMaybeToArray(
      1, *this->xyz_, output);
  }

  // optional double damping = 2;
  if (has_damping()) {
    ::google::protobuf::internal::WireFormatLite::WriteDouble(2, this->damping(), output);
  }

  // optional double friction = 3;
  if (has_friction()) {
    ::google::protobuf::internal::WireFormatLite::WriteDouble(3, this->friction(), output);
  }

  // optional double angle = 4;
  if (has_angle()) {
    ::google::protobuf::internal::WireFormatLite::WriteDouble(4, this->angle(), output);
  }

  if (_internal_metadata_.have_unknown_fields()) {
    ::google::protobuf::internal::WireFormat::SerializeUnknownFields(
        unknown_fields(), output);
  }
  // @@protoc_insertion_point(serialize_end:mw.internal.robotics.gazebotransport.ML_Axis)
}

::google::protobuf::uint8* ML_Axis::InternalSerializeWithCachedSizesToArray(
    bool deterministic, ::google::protobuf::uint8* target) const {
  // @@protoc_insertion_point(serialize_to_array_start:mw.internal.robotics.gazebotransport.ML_Axis)
  // optional .mw.internal.robotics.gazebotransport.ML_Point xyz = 1;
  if (has_xyz()) {
    target = ::google::protobuf::internal::WireFormatLite::
      InternalWriteMessageNoVirtualToArray(
        1, *this->xyz_, false, target);
  }

  // optional double damping = 2;
  if (has_damping()) {
    target = ::google::protobuf::internal::WireFormatLite::WriteDoubleToArray(2, this->damping(), target);
  }

  // optional double friction = 3;
  if (has_friction()) {
    target = ::google::protobuf::internal::WireFormatLite::WriteDoubleToArray(3, this->friction(), target);
  }

  // optional double angle = 4;
  if (has_angle()) {
    target = ::google::protobuf::internal::WireFormatLite::WriteDoubleToArray(4, this->angle(), target);
  }

  if (_internal_metadata_.have_unknown_fields()) {
    target = ::google::protobuf::internal::WireFormat::SerializeUnknownFieldsToArray(
        unknown_fields(), target);
  }
  // @@protoc_insertion_point(serialize_to_array_end:mw.internal.robotics.gazebotransport.ML_Axis)
  return target;
}

int ML_Axis::ByteSize() const {
// @@protoc_insertion_point(message_byte_size_start:mw.internal.robotics.gazebotransport.ML_Axis)
  int total_size = 0;

  if (_has_bits_[0 / 32] & 15u) {
    // optional .mw.internal.robotics.gazebotransport.ML_Point xyz = 1;
    if (has_xyz()) {
      total_size += 1 +
        ::google::protobuf::internal::WireFormatLite::MessageSizeNoVirtual(
          *this->xyz_);
    }

    // optional double damping = 2;
    if (has_damping()) {
      total_size += 1 + 8;
    }

    // optional double friction = 3;
    if (has_friction()) {
      total_size += 1 + 8;
    }

    // optional double angle = 4;
    if (has_angle()) {
      total_size += 1 + 8;
    }

  }
  if (_internal_metadata_.have_unknown_fields()) {
    total_size +=
      ::google::protobuf::internal::WireFormat::ComputeUnknownFieldsSize(
        unknown_fields());
  }
  GOOGLE_SAFE_CONCURRENT_WRITES_BEGIN();
  _cached_size_ = total_size;
  GOOGLE_SAFE_CONCURRENT_WRITES_END();
  return total_size;
}

void ML_Axis::MergeFrom(const ::google::protobuf::Message& from) {
// @@protoc_insertion_point(generalized_merge_from_start:mw.internal.robotics.gazebotransport.ML_Axis)
  if (GOOGLE_PREDICT_FALSE(&from == this)) {
    ::google::protobuf::internal::MergeFromFail(__FILE__, __LINE__);
  }
  const ML_Axis* source = 
      ::google::protobuf::internal::DynamicCastToGenerated<const ML_Axis>(
          &from);
  if (source == NULL) {
  // @@protoc_insertion_point(generalized_merge_from_cast_fail:mw.internal.robotics.gazebotransport.ML_Axis)
    ::google::protobuf::internal::ReflectionOps::Merge(from, this);
  } else {
  // @@protoc_insertion_point(generalized_merge_from_cast_success:mw.internal.robotics.gazebotransport.ML_Axis)
    MergeFrom(*source);
  }
}

void ML_Axis::MergeFrom(const ML_Axis& from) {
// @@protoc_insertion_point(class_specific_merge_from_start:mw.internal.robotics.gazebotransport.ML_Axis)
  if (GOOGLE_PREDICT_FALSE(&from == this)) {
    ::google::protobuf::internal::MergeFromFail(__FILE__, __LINE__);
  }
  if (from._has_bits_[0 / 32] & (0xffu << (0 % 32))) {
    if (from.has_xyz()) {
      mutable_xyz()->::mw::internal::robotics::gazebotransport::ML_Point::MergeFrom(from.xyz());
    }
    if (from.has_damping()) {
      set_damping(from.damping());
    }
    if (from.has_friction()) {
      set_friction(from.friction());
    }
    if (from.has_angle()) {
      set_angle(from.angle());
    }
  }
  if (from._internal_metadata_.have_unknown_fields()) {
    mutable_unknown_fields()->MergeFrom(from.unknown_fields());
  }
}

void ML_Axis::CopyFrom(const ::google::protobuf::Message& from) {
// @@protoc_insertion_point(generalized_copy_from_start:mw.internal.robotics.gazebotransport.ML_Axis)
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

void ML_Axis::CopyFrom(const ML_Axis& from) {
// @@protoc_insertion_point(class_specific_copy_from_start:mw.internal.robotics.gazebotransport.ML_Axis)
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

bool ML_Axis::IsInitialized() const {

  return true;
}

void ML_Axis::Swap(ML_Axis* other) {
  if (other == this) return;
  InternalSwap(other);
}
void ML_Axis::InternalSwap(ML_Axis* other) {
  std::swap(xyz_, other->xyz_);
  std::swap(damping_, other->damping_);
  std::swap(friction_, other->friction_);
  std::swap(angle_, other->angle_);
  std::swap(_has_bits_[0], other->_has_bits_[0]);
  _internal_metadata_.Swap(&other->_internal_metadata_);
  std::swap(_cached_size_, other->_cached_size_);
}

::google::protobuf::Metadata ML_Axis::GetMetadata() const {
  protobuf_AssignDescriptorsOnce();
  ::google::protobuf::Metadata metadata;
  metadata.descriptor = ML_Axis_descriptor_;
  metadata.reflection = ML_Axis_reflection_;
  return metadata;
}

#if PROTOBUF_INLINE_NOT_IN_HEADERS
// ML_Axis

// optional .mw.internal.robotics.gazebotransport.ML_Point xyz = 1;
bool ML_Axis::has_xyz() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
void ML_Axis::set_has_xyz() {
  _has_bits_[0] |= 0x00000001u;
}
void ML_Axis::clear_has_xyz() {
  _has_bits_[0] &= ~0x00000001u;
}
void ML_Axis::clear_xyz() {
  if (xyz_ != NULL) xyz_->::mw::internal::robotics::gazebotransport::ML_Point::Clear();
  clear_has_xyz();
}
const ::mw::internal::robotics::gazebotransport::ML_Point& ML_Axis::xyz() const {
  // @@protoc_insertion_point(field_get:mw.internal.robotics.gazebotransport.ML_Axis.xyz)
  return xyz_ != NULL ? *xyz_ : *default_instance_->xyz_;
}
::mw::internal::robotics::gazebotransport::ML_Point* ML_Axis::mutable_xyz() {
  set_has_xyz();
  if (xyz_ == NULL) {
    xyz_ = new ::mw::internal::robotics::gazebotransport::ML_Point;
  }
  // @@protoc_insertion_point(field_mutable:mw.internal.robotics.gazebotransport.ML_Axis.xyz)
  return xyz_;
}
::mw::internal::robotics::gazebotransport::ML_Point* ML_Axis::release_xyz() {
  // @@protoc_insertion_point(field_release:mw.internal.robotics.gazebotransport.ML_Axis.xyz)
  clear_has_xyz();
  ::mw::internal::robotics::gazebotransport::ML_Point* temp = xyz_;
  xyz_ = NULL;
  return temp;
}
void ML_Axis::set_allocated_xyz(::mw::internal::robotics::gazebotransport::ML_Point* xyz) {
  delete xyz_;
  xyz_ = xyz;
  if (xyz) {
    set_has_xyz();
  } else {
    clear_has_xyz();
  }
  // @@protoc_insertion_point(field_set_allocated:mw.internal.robotics.gazebotransport.ML_Axis.xyz)
}

// optional double damping = 2;
bool ML_Axis::has_damping() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
void ML_Axis::set_has_damping() {
  _has_bits_[0] |= 0x00000002u;
}
void ML_Axis::clear_has_damping() {
  _has_bits_[0] &= ~0x00000002u;
}
void ML_Axis::clear_damping() {
  damping_ = 0;
  clear_has_damping();
}
 double ML_Axis::damping() const {
  // @@protoc_insertion_point(field_get:mw.internal.robotics.gazebotransport.ML_Axis.damping)
  return damping_;
}
 void ML_Axis::set_damping(double value) {
  set_has_damping();
  damping_ = value;
  // @@protoc_insertion_point(field_set:mw.internal.robotics.gazebotransport.ML_Axis.damping)
}

// optional double friction = 3;
bool ML_Axis::has_friction() const {
  return (_has_bits_[0] & 0x00000004u) != 0;
}
void ML_Axis::set_has_friction() {
  _has_bits_[0] |= 0x00000004u;
}
void ML_Axis::clear_has_friction() {
  _has_bits_[0] &= ~0x00000004u;
}
void ML_Axis::clear_friction() {
  friction_ = 0;
  clear_has_friction();
}
 double ML_Axis::friction() const {
  // @@protoc_insertion_point(field_get:mw.internal.robotics.gazebotransport.ML_Axis.friction)
  return friction_;
}
 void ML_Axis::set_friction(double value) {
  set_has_friction();
  friction_ = value;
  // @@protoc_insertion_point(field_set:mw.internal.robotics.gazebotransport.ML_Axis.friction)
}

// optional double angle = 4;
bool ML_Axis::has_angle() const {
  return (_has_bits_[0] & 0x00000008u) != 0;
}
void ML_Axis::set_has_angle() {
  _has_bits_[0] |= 0x00000008u;
}
void ML_Axis::clear_has_angle() {
  _has_bits_[0] &= ~0x00000008u;
}
void ML_Axis::clear_angle() {
  angle_ = 0;
  clear_has_angle();
}
 double ML_Axis::angle() const {
  // @@protoc_insertion_point(field_get:mw.internal.robotics.gazebotransport.ML_Axis.angle)
  return angle_;
}
 void ML_Axis::set_angle(double value) {
  set_has_angle();
  angle_ = value;
  // @@protoc_insertion_point(field_set:mw.internal.robotics.gazebotransport.ML_Axis.angle)
}

#endif  // PROTOBUF_INLINE_NOT_IN_HEADERS

// ===================================================================

#if !defined(_MSC_VER) || _MSC_VER >= 1900
const int ML_Joints::kNameFieldNumber;
const int ML_Joints::kPoseFieldNumber;
const int ML_Joints::kAxis1FieldNumber;
const int ML_Joints::kAxis2FieldNumber;
const int ML_Joints::kCfmFieldNumber;
const int ML_Joints::kFudgeFactorFieldNumber;
const int ML_Joints::kSuspensionCfmFieldNumber;
const int ML_Joints::kSuspensionErpFieldNumber;
const int ML_Joints::kDofFieldNumber;
#endif  // !defined(_MSC_VER) || _MSC_VER >= 1900

ML_Joints::ML_Joints()
  : ::google::protobuf::Message(), _internal_metadata_(NULL) {
  SharedCtor();
  // @@protoc_insertion_point(constructor:mw.internal.robotics.gazebotransport.ML_Joints)
}

void ML_Joints::InitAsDefaultInstance() {
  pose_ = const_cast< ::mw::internal::robotics::gazebotransport::ML_Pose*>(&::mw::internal::robotics::gazebotransport::ML_Pose::default_instance());
  axis1_ = const_cast< ::mw::internal::robotics::gazebotransport::ML_Axis*>(&::mw::internal::robotics::gazebotransport::ML_Axis::default_instance());
  axis2_ = const_cast< ::mw::internal::robotics::gazebotransport::ML_Axis*>(&::mw::internal::robotics::gazebotransport::ML_Axis::default_instance());
}

ML_Joints::ML_Joints(const ML_Joints& from)
  : ::google::protobuf::Message(),
    _internal_metadata_(NULL) {
  SharedCtor();
  MergeFrom(from);
  // @@protoc_insertion_point(copy_constructor:mw.internal.robotics.gazebotransport.ML_Joints)
}

void ML_Joints::SharedCtor() {
  ::google::protobuf::internal::GetEmptyString();
  _cached_size_ = 0;
  name_.UnsafeSetDefault(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
  pose_ = NULL;
  axis1_ = NULL;
  axis2_ = NULL;
  cfm_ = 0;
  fudge_factor_ = 0;
  suspension_cfm_ = 0;
  suspension_erp_ = 0;
  dof_ = 0u;
  ::memset(_has_bits_, 0, sizeof(_has_bits_));
}

ML_Joints::~ML_Joints() {
  // @@protoc_insertion_point(destructor:mw.internal.robotics.gazebotransport.ML_Joints)
  SharedDtor();
}

void ML_Joints::SharedDtor() {
  name_.DestroyNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
  if (this != default_instance_) {
    delete pose_;
    delete axis1_;
    delete axis2_;
  }
}

void ML_Joints::SetCachedSize(int size) const {
  GOOGLE_SAFE_CONCURRENT_WRITES_BEGIN();
  _cached_size_ = size;
  GOOGLE_SAFE_CONCURRENT_WRITES_END();
}
const ::google::protobuf::Descriptor* ML_Joints::descriptor() {
  protobuf_AssignDescriptorsOnce();
  return ML_Joints_descriptor_;
}

const ML_Joints& ML_Joints::default_instance() {
  if (default_instance_ == NULL) protobuf_AddDesc_mw_2einternal_2erobotics_2egazebotransport_2eCoSimMsgs_2eproto();
  return *default_instance_;
}

ML_Joints* ML_Joints::default_instance_ = NULL;

ML_Joints* ML_Joints::New(::google::protobuf::Arena* arena) const {
  ML_Joints* n = new ML_Joints;
  if (arena != NULL) {
    arena->Own(n);
  }
  return n;
}

void ML_Joints::Clear() {
// @@protoc_insertion_point(message_clear_start:mw.internal.robotics.gazebotransport.ML_Joints)
#if defined(__clang__)
#define ZR_HELPER_(f) \
  _Pragma("clang diagnostic push") \
  _Pragma("clang diagnostic ignored \"-Winvalid-offsetof\"") \
  __builtin_offsetof(ML_Joints, f) \
  _Pragma("clang diagnostic pop")
#else
#define ZR_HELPER_(f) reinterpret_cast<char*>(\
  &reinterpret_cast<ML_Joints*>(16)->f)
#endif

#define ZR_(first, last) do {\
  ::memset(&first, 0,\
           ZR_HELPER_(last) - ZR_HELPER_(first) + sizeof(last));\
} while (0)

  if (_has_bits_[0 / 32] & 255u) {
    ZR_(cfm_, suspension_erp_);
    if (has_name()) {
      name_.ClearToEmptyNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
    }
    if (has_pose()) {
      if (pose_ != NULL) pose_->::mw::internal::robotics::gazebotransport::ML_Pose::Clear();
    }
    if (has_axis1()) {
      if (axis1_ != NULL) axis1_->::mw::internal::robotics::gazebotransport::ML_Axis::Clear();
    }
    if (has_axis2()) {
      if (axis2_ != NULL) axis2_->::mw::internal::robotics::gazebotransport::ML_Axis::Clear();
    }
  }
  dof_ = 0u;

#undef ZR_HELPER_
#undef ZR_

  ::memset(_has_bits_, 0, sizeof(_has_bits_));
  if (_internal_metadata_.have_unknown_fields()) {
    mutable_unknown_fields()->Clear();
  }
}

bool ML_Joints::MergePartialFromCodedStream(
    ::google::protobuf::io::CodedInputStream* input) {
#define DO_(EXPRESSION) if (!GOOGLE_PREDICT_TRUE(EXPRESSION)) goto failure
  ::google::protobuf::uint32 tag;
  // @@protoc_insertion_point(parse_start:mw.internal.robotics.gazebotransport.ML_Joints)
  for (;;) {
    ::std::pair< ::google::protobuf::uint32, bool> p = input->ReadTagWithCutoff(127);
    tag = p.first;
    if (!p.second) goto handle_unusual;
    switch (::google::protobuf::internal::WireFormatLite::GetTagFieldNumber(tag)) {
      // optional string name = 1;
      case 1: {
        if (tag == 10) {
          DO_(::google::protobuf::internal::WireFormatLite::ReadString(
                input, this->mutable_name()));
          ::google::protobuf::internal::WireFormat::VerifyUTF8StringNamedField(
            this->name().data(), this->name().length(),
            ::google::protobuf::internal::WireFormat::PARSE,
            "mw.internal.robotics.gazebotransport.ML_Joints.name");
        } else {
          goto handle_unusual;
        }
        if (input->ExpectTag(18)) goto parse_pose;
        break;
      }

      // optional .mw.internal.robotics.gazebotransport.ML_Pose pose = 2;
      case 2: {
        if (tag == 18) {
         parse_pose:
          DO_(::google::protobuf::internal::WireFormatLite::ReadMessageNoVirtual(
               input, mutable_pose()));
        } else {
          goto handle_unusual;
        }
        if (input->ExpectTag(26)) goto parse_axis1;
        break;
      }

      // optional .mw.internal.robotics.gazebotransport.ML_Axis axis1 = 3;
      case 3: {
        if (tag == 26) {
         parse_axis1:
          DO_(::google::protobuf::internal::WireFormatLite::ReadMessageNoVirtual(
               input, mutable_axis1()));
        } else {
          goto handle_unusual;
        }
        if (input->ExpectTag(34)) goto parse_axis2;
        break;
      }

      // optional .mw.internal.robotics.gazebotransport.ML_Axis axis2 = 4;
      case 4: {
        if (tag == 34) {
         parse_axis2:
          DO_(::google::protobuf::internal::WireFormatLite::ReadMessageNoVirtual(
               input, mutable_axis2()));
        } else {
          goto handle_unusual;
        }
        if (input->ExpectTag(41)) goto parse_cfm;
        break;
      }

      // optional double cfm = 5;
      case 5: {
        if (tag == 41) {
         parse_cfm:
          DO_((::google::protobuf::internal::WireFormatLite::ReadPrimitive<
                   double, ::google::protobuf::internal::WireFormatLite::TYPE_DOUBLE>(
                 input, &cfm_)));
          set_has_cfm();
        } else {
          goto handle_unusual;
        }
        if (input->ExpectTag(49)) goto parse_fudge_factor;
        break;
      }

      // optional double fudge_factor = 6;
      case 6: {
        if (tag == 49) {
         parse_fudge_factor:
          DO_((::google::protobuf::internal::WireFormatLite::ReadPrimitive<
                   double, ::google::protobuf::internal::WireFormatLite::TYPE_DOUBLE>(
                 input, &fudge_factor_)));
          set_has_fudge_factor();
        } else {
          goto handle_unusual;
        }
        if (input->ExpectTag(57)) goto parse_suspension_cfm;
        break;
      }

      // optional double suspension_cfm = 7;
      case 7: {
        if (tag == 57) {
         parse_suspension_cfm:
          DO_((::google::protobuf::internal::WireFormatLite::ReadPrimitive<
                   double, ::google::protobuf::internal::WireFormatLite::TYPE_DOUBLE>(
                 input, &suspension_cfm_)));
          set_has_suspension_cfm();
        } else {
          goto handle_unusual;
        }
        if (input->ExpectTag(65)) goto parse_suspension_erp;
        break;
      }

      // optional double suspension_erp = 8;
      case 8: {
        if (tag == 65) {
         parse_suspension_erp:
          DO_((::google::protobuf::internal::WireFormatLite::ReadPrimitive<
                   double, ::google::protobuf::internal::WireFormatLite::TYPE_DOUBLE>(
                 input, &suspension_erp_)));
          set_has_suspension_erp();
        } else {
          goto handle_unusual;
        }
        if (input->ExpectTag(72)) goto parse_dof;
        break;
      }

      // optional uint32 dof = 9;
      case 9: {
        if (tag == 72) {
         parse_dof:
          DO_((::google::protobuf::internal::WireFormatLite::ReadPrimitive<
                   ::google::protobuf::uint32, ::google::protobuf::internal::WireFormatLite::TYPE_UINT32>(
                 input, &dof_)));
          set_has_dof();
        } else {
          goto handle_unusual;
        }
        if (input->ExpectAtEnd()) goto success;
        break;
      }

      default: {
      handle_unusual:
        if (tag == 0 ||
            ::google::protobuf::internal::WireFormatLite::GetTagWireType(tag) ==
            ::google::protobuf::internal::WireFormatLite::WIRETYPE_END_GROUP) {
          goto success;
        }
        DO_(::google::protobuf::internal::WireFormat::SkipField(
              input, tag, mutable_unknown_fields()));
        break;
      }
    }
  }
success:
  // @@protoc_insertion_point(parse_success:mw.internal.robotics.gazebotransport.ML_Joints)
  return true;
failure:
  // @@protoc_insertion_point(parse_failure:mw.internal.robotics.gazebotransport.ML_Joints)
  return false;
#undef DO_
}

void ML_Joints::SerializeWithCachedSizes(
    ::google::protobuf::io::CodedOutputStream* output) const {
  // @@protoc_insertion_point(serialize_start:mw.internal.robotics.gazebotransport.ML_Joints)
  // optional string name = 1;
  if (has_name()) {
    ::google::protobuf::internal::WireFormat::VerifyUTF8StringNamedField(
      this->name().data(), this->name().length(),
      ::google::protobuf::internal::WireFormat::SERIALIZE,
      "mw.internal.robotics.gazebotransport.ML_Joints.name");
    ::google::protobuf::internal::WireFormatLite::WriteStringMaybeAliased(
      1, this->name(), output);
  }

  // optional .mw.internal.robotics.gazebotransport.ML_Pose pose = 2;
  if (has_pose()) {
    ::google::protobuf::internal::WireFormatLite::WriteMessageMaybeToArray(
      2, *this->pose_, output);
  }

  // optional .mw.internal.robotics.gazebotransport.ML_Axis axis1 = 3;
  if (has_axis1()) {
    ::google::protobuf::internal::WireFormatLite::WriteMessageMaybeToArray(
      3, *this->axis1_, output);
  }

  // optional .mw.internal.robotics.gazebotransport.ML_Axis axis2 = 4;
  if (has_axis2()) {
    ::google::protobuf::internal::WireFormatLite::WriteMessageMaybeToArray(
      4, *this->axis2_, output);
  }

  // optional double cfm = 5;
  if (has_cfm()) {
    ::google::protobuf::internal::WireFormatLite::WriteDouble(5, this->cfm(), output);
  }

  // optional double fudge_factor = 6;
  if (has_fudge_factor()) {
    ::google::protobuf::internal::WireFormatLite::WriteDouble(6, this->fudge_factor(), output);
  }

  // optional double suspension_cfm = 7;
  if (has_suspension_cfm()) {
    ::google::protobuf::internal::WireFormatLite::WriteDouble(7, this->suspension_cfm(), output);
  }

  // optional double suspension_erp = 8;
  if (has_suspension_erp()) {
    ::google::protobuf::internal::WireFormatLite::WriteDouble(8, this->suspension_erp(), output);
  }

  // optional uint32 dof = 9;
  if (has_dof()) {
    ::google::protobuf::internal::WireFormatLite::WriteUInt32(9, this->dof(), output);
  }

  if (_internal_metadata_.have_unknown_fields()) {
    ::google::protobuf::internal::WireFormat::SerializeUnknownFields(
        unknown_fields(), output);
  }
  // @@protoc_insertion_point(serialize_end:mw.internal.robotics.gazebotransport.ML_Joints)
}

::google::protobuf::uint8* ML_Joints::InternalSerializeWithCachedSizesToArray(
    bool deterministic, ::google::protobuf::uint8* target) const {
  // @@protoc_insertion_point(serialize_to_array_start:mw.internal.robotics.gazebotransport.ML_Joints)
  // optional string name = 1;
  if (has_name()) {
    ::google::protobuf::internal::WireFormat::VerifyUTF8StringNamedField(
      this->name().data(), this->name().length(),
      ::google::protobuf::internal::WireFormat::SERIALIZE,
      "mw.internal.robotics.gazebotransport.ML_Joints.name");
    target =
      ::google::protobuf::internal::WireFormatLite::WriteStringToArray(
        1, this->name(), target);
  }

  // optional .mw.internal.robotics.gazebotransport.ML_Pose pose = 2;
  if (has_pose()) {
    target = ::google::protobuf::internal::WireFormatLite::
      InternalWriteMessageNoVirtualToArray(
        2, *this->pose_, false, target);
  }

  // optional .mw.internal.robotics.gazebotransport.ML_Axis axis1 = 3;
  if (has_axis1()) {
    target = ::google::protobuf::internal::WireFormatLite::
      InternalWriteMessageNoVirtualToArray(
        3, *this->axis1_, false, target);
  }

  // optional .mw.internal.robotics.gazebotransport.ML_Axis axis2 = 4;
  if (has_axis2()) {
    target = ::google::protobuf::internal::WireFormatLite::
      InternalWriteMessageNoVirtualToArray(
        4, *this->axis2_, false, target);
  }

  // optional double cfm = 5;
  if (has_cfm()) {
    target = ::google::protobuf::internal::WireFormatLite::WriteDoubleToArray(5, this->cfm(), target);
  }

  // optional double fudge_factor = 6;
  if (has_fudge_factor()) {
    target = ::google::protobuf::internal::WireFormatLite::WriteDoubleToArray(6, this->fudge_factor(), target);
  }

  // optional double suspension_cfm = 7;
  if (has_suspension_cfm()) {
    target = ::google::protobuf::internal::WireFormatLite::WriteDoubleToArray(7, this->suspension_cfm(), target);
  }

  // optional double suspension_erp = 8;
  if (has_suspension_erp()) {
    target = ::google::protobuf::internal::WireFormatLite::WriteDoubleToArray(8, this->suspension_erp(), target);
  }

  // optional uint32 dof = 9;
  if (has_dof()) {
    target = ::google::protobuf::internal::WireFormatLite::WriteUInt32ToArray(9, this->dof(), target);
  }

  if (_internal_metadata_.have_unknown_fields()) {
    target = ::google::protobuf::internal::WireFormat::SerializeUnknownFieldsToArray(
        unknown_fields(), target);
  }
  // @@protoc_insertion_point(serialize_to_array_end:mw.internal.robotics.gazebotransport.ML_Joints)
  return target;
}

int ML_Joints::ByteSize() const {
// @@protoc_insertion_point(message_byte_size_start:mw.internal.robotics.gazebotransport.ML_Joints)
  int total_size = 0;

  if (_has_bits_[0 / 32] & 255u) {
    // optional string name = 1;
    if (has_name()) {
      total_size += 1 +
        ::google::protobuf::internal::WireFormatLite::StringSize(
          this->name());
    }

    // optional .mw.internal.robotics.gazebotransport.ML_Pose pose = 2;
    if (has_pose()) {
      total_size += 1 +
        ::google::protobuf::internal::WireFormatLite::MessageSizeNoVirtual(
          *this->pose_);
    }

    // optional .mw.internal.robotics.gazebotransport.ML_Axis axis1 = 3;
    if (has_axis1()) {
      total_size += 1 +
        ::google::protobuf::internal::WireFormatLite::MessageSizeNoVirtual(
          *this->axis1_);
    }

    // optional .mw.internal.robotics.gazebotransport.ML_Axis axis2 = 4;
    if (has_axis2()) {
      total_size += 1 +
        ::google::protobuf::internal::WireFormatLite::MessageSizeNoVirtual(
          *this->axis2_);
    }

    // optional double cfm = 5;
    if (has_cfm()) {
      total_size += 1 + 8;
    }

    // optional double fudge_factor = 6;
    if (has_fudge_factor()) {
      total_size += 1 + 8;
    }

    // optional double suspension_cfm = 7;
    if (has_suspension_cfm()) {
      total_size += 1 + 8;
    }

    // optional double suspension_erp = 8;
    if (has_suspension_erp()) {
      total_size += 1 + 8;
    }

  }
  // optional uint32 dof = 9;
  if (has_dof()) {
    total_size += 1 +
      ::google::protobuf::internal::WireFormatLite::UInt32Size(
        this->dof());
  }

  if (_internal_metadata_.have_unknown_fields()) {
    total_size +=
      ::google::protobuf::internal::WireFormat::ComputeUnknownFieldsSize(
        unknown_fields());
  }
  GOOGLE_SAFE_CONCURRENT_WRITES_BEGIN();
  _cached_size_ = total_size;
  GOOGLE_SAFE_CONCURRENT_WRITES_END();
  return total_size;
}

void ML_Joints::MergeFrom(const ::google::protobuf::Message& from) {
// @@protoc_insertion_point(generalized_merge_from_start:mw.internal.robotics.gazebotransport.ML_Joints)
  if (GOOGLE_PREDICT_FALSE(&from == this)) {
    ::google::protobuf::internal::MergeFromFail(__FILE__, __LINE__);
  }
  const ML_Joints* source = 
      ::google::protobuf::internal::DynamicCastToGenerated<const ML_Joints>(
          &from);
  if (source == NULL) {
  // @@protoc_insertion_point(generalized_merge_from_cast_fail:mw.internal.robotics.gazebotransport.ML_Joints)
    ::google::protobuf::internal::ReflectionOps::Merge(from, this);
  } else {
  // @@protoc_insertion_point(generalized_merge_from_cast_success:mw.internal.robotics.gazebotransport.ML_Joints)
    MergeFrom(*source);
  }
}

void ML_Joints::MergeFrom(const ML_Joints& from) {
// @@protoc_insertion_point(class_specific_merge_from_start:mw.internal.robotics.gazebotransport.ML_Joints)
  if (GOOGLE_PREDICT_FALSE(&from == this)) {
    ::google::protobuf::internal::MergeFromFail(__FILE__, __LINE__);
  }
  if (from._has_bits_[0 / 32] & (0xffu << (0 % 32))) {
    if (from.has_name()) {
      set_has_name();
      name_.AssignWithDefault(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), from.name_);
    }
    if (from.has_pose()) {
      mutable_pose()->::mw::internal::robotics::gazebotransport::ML_Pose::MergeFrom(from.pose());
    }
    if (from.has_axis1()) {
      mutable_axis1()->::mw::internal::robotics::gazebotransport::ML_Axis::MergeFrom(from.axis1());
    }
    if (from.has_axis2()) {
      mutable_axis2()->::mw::internal::robotics::gazebotransport::ML_Axis::MergeFrom(from.axis2());
    }
    if (from.has_cfm()) {
      set_cfm(from.cfm());
    }
    if (from.has_fudge_factor()) {
      set_fudge_factor(from.fudge_factor());
    }
    if (from.has_suspension_cfm()) {
      set_suspension_cfm(from.suspension_cfm());
    }
    if (from.has_suspension_erp()) {
      set_suspension_erp(from.suspension_erp());
    }
  }
  if (from._has_bits_[8 / 32] & (0xffu << (8 % 32))) {
    if (from.has_dof()) {
      set_dof(from.dof());
    }
  }
  if (from._internal_metadata_.have_unknown_fields()) {
    mutable_unknown_fields()->MergeFrom(from.unknown_fields());
  }
}

void ML_Joints::CopyFrom(const ::google::protobuf::Message& from) {
// @@protoc_insertion_point(generalized_copy_from_start:mw.internal.robotics.gazebotransport.ML_Joints)
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

void ML_Joints::CopyFrom(const ML_Joints& from) {
// @@protoc_insertion_point(class_specific_copy_from_start:mw.internal.robotics.gazebotransport.ML_Joints)
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

bool ML_Joints::IsInitialized() const {

  return true;
}

void ML_Joints::Swap(ML_Joints* other) {
  if (other == this) return;
  InternalSwap(other);
}
void ML_Joints::InternalSwap(ML_Joints* other) {
  name_.Swap(&other->name_);
  std::swap(pose_, other->pose_);
  std::swap(axis1_, other->axis1_);
  std::swap(axis2_, other->axis2_);
  std::swap(cfm_, other->cfm_);
  std::swap(fudge_factor_, other->fudge_factor_);
  std::swap(suspension_cfm_, other->suspension_cfm_);
  std::swap(suspension_erp_, other->suspension_erp_);
  std::swap(dof_, other->dof_);
  std::swap(_has_bits_[0], other->_has_bits_[0]);
  _internal_metadata_.Swap(&other->_internal_metadata_);
  std::swap(_cached_size_, other->_cached_size_);
}

::google::protobuf::Metadata ML_Joints::GetMetadata() const {
  protobuf_AssignDescriptorsOnce();
  ::google::protobuf::Metadata metadata;
  metadata.descriptor = ML_Joints_descriptor_;
  metadata.reflection = ML_Joints_reflection_;
  return metadata;
}

#if PROTOBUF_INLINE_NOT_IN_HEADERS
// ML_Joints

// optional string name = 1;
bool ML_Joints::has_name() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
void ML_Joints::set_has_name() {
  _has_bits_[0] |= 0x00000001u;
}
void ML_Joints::clear_has_name() {
  _has_bits_[0] &= ~0x00000001u;
}
void ML_Joints::clear_name() {
  name_.ClearToEmptyNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
  clear_has_name();
}
 const ::std::string& ML_Joints::name() const {
  // @@protoc_insertion_point(field_get:mw.internal.robotics.gazebotransport.ML_Joints.name)
  return name_.GetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
 void ML_Joints::set_name(const ::std::string& value) {
  set_has_name();
  name_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), value);
  // @@protoc_insertion_point(field_set:mw.internal.robotics.gazebotransport.ML_Joints.name)
}
 void ML_Joints::set_name(const char* value) {
  set_has_name();
  name_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::string(value));
  // @@protoc_insertion_point(field_set_char:mw.internal.robotics.gazebotransport.ML_Joints.name)
}
 void ML_Joints::set_name(const char* value, size_t size) {
  set_has_name();
  name_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(),
      ::std::string(reinterpret_cast<const char*>(value), size));
  // @@protoc_insertion_point(field_set_pointer:mw.internal.robotics.gazebotransport.ML_Joints.name)
}
 ::std::string* ML_Joints::mutable_name() {
  set_has_name();
  // @@protoc_insertion_point(field_mutable:mw.internal.robotics.gazebotransport.ML_Joints.name)
  return name_.MutableNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
 ::std::string* ML_Joints::release_name() {
  // @@protoc_insertion_point(field_release:mw.internal.robotics.gazebotransport.ML_Joints.name)
  clear_has_name();
  return name_.ReleaseNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
 void ML_Joints::set_allocated_name(::std::string* name) {
  if (name != NULL) {
    set_has_name();
  } else {
    clear_has_name();
  }
  name_.SetAllocatedNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), name);
  // @@protoc_insertion_point(field_set_allocated:mw.internal.robotics.gazebotransport.ML_Joints.name)
}

// optional .mw.internal.robotics.gazebotransport.ML_Pose pose = 2;
bool ML_Joints::has_pose() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
void ML_Joints::set_has_pose() {
  _has_bits_[0] |= 0x00000002u;
}
void ML_Joints::clear_has_pose() {
  _has_bits_[0] &= ~0x00000002u;
}
void ML_Joints::clear_pose() {
  if (pose_ != NULL) pose_->::mw::internal::robotics::gazebotransport::ML_Pose::Clear();
  clear_has_pose();
}
const ::mw::internal::robotics::gazebotransport::ML_Pose& ML_Joints::pose() const {
  // @@protoc_insertion_point(field_get:mw.internal.robotics.gazebotransport.ML_Joints.pose)
  return pose_ != NULL ? *pose_ : *default_instance_->pose_;
}
::mw::internal::robotics::gazebotransport::ML_Pose* ML_Joints::mutable_pose() {
  set_has_pose();
  if (pose_ == NULL) {
    pose_ = new ::mw::internal::robotics::gazebotransport::ML_Pose;
  }
  // @@protoc_insertion_point(field_mutable:mw.internal.robotics.gazebotransport.ML_Joints.pose)
  return pose_;
}
::mw::internal::robotics::gazebotransport::ML_Pose* ML_Joints::release_pose() {
  // @@protoc_insertion_point(field_release:mw.internal.robotics.gazebotransport.ML_Joints.pose)
  clear_has_pose();
  ::mw::internal::robotics::gazebotransport::ML_Pose* temp = pose_;
  pose_ = NULL;
  return temp;
}
void ML_Joints::set_allocated_pose(::mw::internal::robotics::gazebotransport::ML_Pose* pose) {
  delete pose_;
  pose_ = pose;
  if (pose) {
    set_has_pose();
  } else {
    clear_has_pose();
  }
  // @@protoc_insertion_point(field_set_allocated:mw.internal.robotics.gazebotransport.ML_Joints.pose)
}

// optional .mw.internal.robotics.gazebotransport.ML_Axis axis1 = 3;
bool ML_Joints::has_axis1() const {
  return (_has_bits_[0] & 0x00000004u) != 0;
}
void ML_Joints::set_has_axis1() {
  _has_bits_[0] |= 0x00000004u;
}
void ML_Joints::clear_has_axis1() {
  _has_bits_[0] &= ~0x00000004u;
}
void ML_Joints::clear_axis1() {
  if (axis1_ != NULL) axis1_->::mw::internal::robotics::gazebotransport::ML_Axis::Clear();
  clear_has_axis1();
}
const ::mw::internal::robotics::gazebotransport::ML_Axis& ML_Joints::axis1() const {
  // @@protoc_insertion_point(field_get:mw.internal.robotics.gazebotransport.ML_Joints.axis1)
  return axis1_ != NULL ? *axis1_ : *default_instance_->axis1_;
}
::mw::internal::robotics::gazebotransport::ML_Axis* ML_Joints::mutable_axis1() {
  set_has_axis1();
  if (axis1_ == NULL) {
    axis1_ = new ::mw::internal::robotics::gazebotransport::ML_Axis;
  }
  // @@protoc_insertion_point(field_mutable:mw.internal.robotics.gazebotransport.ML_Joints.axis1)
  return axis1_;
}
::mw::internal::robotics::gazebotransport::ML_Axis* ML_Joints::release_axis1() {
  // @@protoc_insertion_point(field_release:mw.internal.robotics.gazebotransport.ML_Joints.axis1)
  clear_has_axis1();
  ::mw::internal::robotics::gazebotransport::ML_Axis* temp = axis1_;
  axis1_ = NULL;
  return temp;
}
void ML_Joints::set_allocated_axis1(::mw::internal::robotics::gazebotransport::ML_Axis* axis1) {
  delete axis1_;
  axis1_ = axis1;
  if (axis1) {
    set_has_axis1();
  } else {
    clear_has_axis1();
  }
  // @@protoc_insertion_point(field_set_allocated:mw.internal.robotics.gazebotransport.ML_Joints.axis1)
}

// optional .mw.internal.robotics.gazebotransport.ML_Axis axis2 = 4;
bool ML_Joints::has_axis2() const {
  return (_has_bits_[0] & 0x00000008u) != 0;
}
void ML_Joints::set_has_axis2() {
  _has_bits_[0] |= 0x00000008u;
}
void ML_Joints::clear_has_axis2() {
  _has_bits_[0] &= ~0x00000008u;
}
void ML_Joints::clear_axis2() {
  if (axis2_ != NULL) axis2_->::mw::internal::robotics::gazebotransport::ML_Axis::Clear();
  clear_has_axis2();
}
const ::mw::internal::robotics::gazebotransport::ML_Axis& ML_Joints::axis2() const {
  // @@protoc_insertion_point(field_get:mw.internal.robotics.gazebotransport.ML_Joints.axis2)
  return axis2_ != NULL ? *axis2_ : *default_instance_->axis2_;
}
::mw::internal::robotics::gazebotransport::ML_Axis* ML_Joints::mutable_axis2() {
  set_has_axis2();
  if (axis2_ == NULL) {
    axis2_ = new ::mw::internal::robotics::gazebotransport::ML_Axis;
  }
  // @@protoc_insertion_point(field_mutable:mw.internal.robotics.gazebotransport.ML_Joints.axis2)
  return axis2_;
}
::mw::internal::robotics::gazebotransport::ML_Axis* ML_Joints::release_axis2() {
  // @@protoc_insertion_point(field_release:mw.internal.robotics.gazebotransport.ML_Joints.axis2)
  clear_has_axis2();
  ::mw::internal::robotics::gazebotransport::ML_Axis* temp = axis2_;
  axis2_ = NULL;
  return temp;
}
void ML_Joints::set_allocated_axis2(::mw::internal::robotics::gazebotransport::ML_Axis* axis2) {
  delete axis2_;
  axis2_ = axis2;
  if (axis2) {
    set_has_axis2();
  } else {
    clear_has_axis2();
  }
  // @@protoc_insertion_point(field_set_allocated:mw.internal.robotics.gazebotransport.ML_Joints.axis2)
}

// optional double cfm = 5;
bool ML_Joints::has_cfm() const {
  return (_has_bits_[0] & 0x00000010u) != 0;
}
void ML_Joints::set_has_cfm() {
  _has_bits_[0] |= 0x00000010u;
}
void ML_Joints::clear_has_cfm() {
  _has_bits_[0] &= ~0x00000010u;
}
void ML_Joints::clear_cfm() {
  cfm_ = 0;
  clear_has_cfm();
}
 double ML_Joints::cfm() const {
  // @@protoc_insertion_point(field_get:mw.internal.robotics.gazebotransport.ML_Joints.cfm)
  return cfm_;
}
 void ML_Joints::set_cfm(double value) {
  set_has_cfm();
  cfm_ = value;
  // @@protoc_insertion_point(field_set:mw.internal.robotics.gazebotransport.ML_Joints.cfm)
}

// optional double fudge_factor = 6;
bool ML_Joints::has_fudge_factor() const {
  return (_has_bits_[0] & 0x00000020u) != 0;
}
void ML_Joints::set_has_fudge_factor() {
  _has_bits_[0] |= 0x00000020u;
}
void ML_Joints::clear_has_fudge_factor() {
  _has_bits_[0] &= ~0x00000020u;
}
void ML_Joints::clear_fudge_factor() {
  fudge_factor_ = 0;
  clear_has_fudge_factor();
}
 double ML_Joints::fudge_factor() const {
  // @@protoc_insertion_point(field_get:mw.internal.robotics.gazebotransport.ML_Joints.fudge_factor)
  return fudge_factor_;
}
 void ML_Joints::set_fudge_factor(double value) {
  set_has_fudge_factor();
  fudge_factor_ = value;
  // @@protoc_insertion_point(field_set:mw.internal.robotics.gazebotransport.ML_Joints.fudge_factor)
}

// optional double suspension_cfm = 7;
bool ML_Joints::has_suspension_cfm() const {
  return (_has_bits_[0] & 0x00000040u) != 0;
}
void ML_Joints::set_has_suspension_cfm() {
  _has_bits_[0] |= 0x00000040u;
}
void ML_Joints::clear_has_suspension_cfm() {
  _has_bits_[0] &= ~0x00000040u;
}
void ML_Joints::clear_suspension_cfm() {
  suspension_cfm_ = 0;
  clear_has_suspension_cfm();
}
 double ML_Joints::suspension_cfm() const {
  // @@protoc_insertion_point(field_get:mw.internal.robotics.gazebotransport.ML_Joints.suspension_cfm)
  return suspension_cfm_;
}
 void ML_Joints::set_suspension_cfm(double value) {
  set_has_suspension_cfm();
  suspension_cfm_ = value;
  // @@protoc_insertion_point(field_set:mw.internal.robotics.gazebotransport.ML_Joints.suspension_cfm)
}

// optional double suspension_erp = 8;
bool ML_Joints::has_suspension_erp() const {
  return (_has_bits_[0] & 0x00000080u) != 0;
}
void ML_Joints::set_has_suspension_erp() {
  _has_bits_[0] |= 0x00000080u;
}
void ML_Joints::clear_has_suspension_erp() {
  _has_bits_[0] &= ~0x00000080u;
}
void ML_Joints::clear_suspension_erp() {
  suspension_erp_ = 0;
  clear_has_suspension_erp();
}
 double ML_Joints::suspension_erp() const {
  // @@protoc_insertion_point(field_get:mw.internal.robotics.gazebotransport.ML_Joints.suspension_erp)
  return suspension_erp_;
}
 void ML_Joints::set_suspension_erp(double value) {
  set_has_suspension_erp();
  suspension_erp_ = value;
  // @@protoc_insertion_point(field_set:mw.internal.robotics.gazebotransport.ML_Joints.suspension_erp)
}

// optional uint32 dof = 9;
bool ML_Joints::has_dof() const {
  return (_has_bits_[0] & 0x00000100u) != 0;
}
void ML_Joints::set_has_dof() {
  _has_bits_[0] |= 0x00000100u;
}
void ML_Joints::clear_has_dof() {
  _has_bits_[0] &= ~0x00000100u;
}
void ML_Joints::clear_dof() {
  dof_ = 0u;
  clear_has_dof();
}
 ::google::protobuf::uint32 ML_Joints::dof() const {
  // @@protoc_insertion_point(field_get:mw.internal.robotics.gazebotransport.ML_Joints.dof)
  return dof_;
}
 void ML_Joints::set_dof(::google::protobuf::uint32 value) {
  set_has_dof();
  dof_ = value;
  // @@protoc_insertion_point(field_set:mw.internal.robotics.gazebotransport.ML_Joints.dof)
}

#endif  // PROTOBUF_INLINE_NOT_IN_HEADERS

// ===================================================================

#if !defined(_MSC_VER) || _MSC_VER >= 1900
const int Gazebomodel::kNameFieldNumber;
const int Gazebomodel::kLinksFieldNumber;
const int Gazebomodel::kJointsFieldNumber;
const int Gazebomodel::kPoseFieldNumber;
const int Gazebomodel::kEnableWindFieldNumber;
const int Gazebomodel::kSelfCollideFieldNumber;
const int Gazebomodel::kIsStaticFieldNumber;
#endif  // !defined(_MSC_VER) || _MSC_VER >= 1900

Gazebomodel::Gazebomodel()
  : ::google::protobuf::Message(), _internal_metadata_(NULL) {
  SharedCtor();
  // @@protoc_insertion_point(constructor:mw.internal.robotics.gazebotransport.Gazebomodel)
}

void Gazebomodel::InitAsDefaultInstance() {
  pose_ = const_cast< ::mw::internal::robotics::gazebotransport::ML_Pose*>(&::mw::internal::robotics::gazebotransport::ML_Pose::default_instance());
}

Gazebomodel::Gazebomodel(const Gazebomodel& from)
  : ::google::protobuf::Message(),
    _internal_metadata_(NULL) {
  SharedCtor();
  MergeFrom(from);
  // @@protoc_insertion_point(copy_constructor:mw.internal.robotics.gazebotransport.Gazebomodel)
}

void Gazebomodel::SharedCtor() {
  ::google::protobuf::internal::GetEmptyString();
  _cached_size_ = 0;
  name_.UnsafeSetDefault(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
  pose_ = NULL;
  enable_wind_ = false;
  self_collide_ = false;
  is_static_ = false;
  ::memset(_has_bits_, 0, sizeof(_has_bits_));
}

Gazebomodel::~Gazebomodel() {
  // @@protoc_insertion_point(destructor:mw.internal.robotics.gazebotransport.Gazebomodel)
  SharedDtor();
}

void Gazebomodel::SharedDtor() {
  name_.DestroyNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
  if (this != default_instance_) {
    delete pose_;
  }
}

void Gazebomodel::SetCachedSize(int size) const {
  GOOGLE_SAFE_CONCURRENT_WRITES_BEGIN();
  _cached_size_ = size;
  GOOGLE_SAFE_CONCURRENT_WRITES_END();
}
const ::google::protobuf::Descriptor* Gazebomodel::descriptor() {
  protobuf_AssignDescriptorsOnce();
  return Gazebomodel_descriptor_;
}

const Gazebomodel& Gazebomodel::default_instance() {
  if (default_instance_ == NULL) protobuf_AddDesc_mw_2einternal_2erobotics_2egazebotransport_2eCoSimMsgs_2eproto();
  return *default_instance_;
}

Gazebomodel* Gazebomodel::default_instance_ = NULL;

Gazebomodel* Gazebomodel::New(::google::protobuf::Arena* arena) const {
  Gazebomodel* n = new Gazebomodel;
  if (arena != NULL) {
    arena->Own(n);
  }
  return n;
}

void Gazebomodel::Clear() {
// @@protoc_insertion_point(message_clear_start:mw.internal.robotics.gazebotransport.Gazebomodel)
#if defined(__clang__)
#define ZR_HELPER_(f) \
  _Pragma("clang diagnostic push") \
  _Pragma("clang diagnostic ignored \"-Winvalid-offsetof\"") \
  __builtin_offsetof(Gazebomodel, f) \
  _Pragma("clang diagnostic pop")
#else
#define ZR_HELPER_(f) reinterpret_cast<char*>(\
  &reinterpret_cast<Gazebomodel*>(16)->f)
#endif

#define ZR_(first, last) do {\
  ::memset(&first, 0,\
           ZR_HELPER_(last) - ZR_HELPER_(first) + sizeof(last));\
} while (0)

  if (_has_bits_[0 / 32] & 121u) {
    ZR_(enable_wind_, is_static_);
    if (has_name()) {
      name_.ClearToEmptyNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
    }
    if (has_pose()) {
      if (pose_ != NULL) pose_->::mw::internal::robotics::gazebotransport::ML_Pose::Clear();
    }
  }

#undef ZR_HELPER_
#undef ZR_

  links_.Clear();
  joints_.Clear();
  ::memset(_has_bits_, 0, sizeof(_has_bits_));
  if (_internal_metadata_.have_unknown_fields()) {
    mutable_unknown_fields()->Clear();
  }
}

bool Gazebomodel::MergePartialFromCodedStream(
    ::google::protobuf::io::CodedInputStream* input) {
#define DO_(EXPRESSION) if (!GOOGLE_PREDICT_TRUE(EXPRESSION)) goto failure
  ::google::protobuf::uint32 tag;
  // @@protoc_insertion_point(parse_start:mw.internal.robotics.gazebotransport.Gazebomodel)
  for (;;) {
    ::std::pair< ::google::protobuf::uint32, bool> p = input->ReadTagWithCutoff(127);
    tag = p.first;
    if (!p.second) goto handle_unusual;
    switch (::google::protobuf::internal::WireFormatLite::GetTagFieldNumber(tag)) {
      // required string name = 1;
      case 1: {
        if (tag == 10) {
          DO_(::google::protobuf::internal::WireFormatLite::ReadString(
                input, this->mutable_name()));
          ::google::protobuf::internal::WireFormat::VerifyUTF8StringNamedField(
            this->name().data(), this->name().length(),
            ::google::protobuf::internal::WireFormat::PARSE,
            "mw.internal.robotics.gazebotransport.Gazebomodel.name");
        } else {
          goto handle_unusual;
        }
        if (input->ExpectTag(18)) goto parse_links;
        break;
      }

      // repeated .mw.internal.robotics.gazebotransport.ML_Links links = 2;
      case 2: {
        if (tag == 18) {
         parse_links:
          DO_(input->IncrementRecursionDepth());
         parse_loop_links:
          DO_(::google::protobuf::internal::WireFormatLite::ReadMessageNoVirtualNoRecursionDepth(
                input, add_links()));
        } else {
          goto handle_unusual;
        }
        if (input->ExpectTag(18)) goto parse_loop_links;
        if (input->ExpectTag(26)) goto parse_loop_joints;
        input->UnsafeDecrementRecursionDepth();
        break;
      }

      // repeated .mw.internal.robotics.gazebotransport.ML_Joints joints = 3;
      case 3: {
        if (tag == 26) {
          DO_(input->IncrementRecursionDepth());
         parse_loop_joints:
          DO_(::google::protobuf::internal::WireFormatLite::ReadMessageNoVirtualNoRecursionDepth(
                input, add_joints()));
        } else {
          goto handle_unusual;
        }
        if (input->ExpectTag(26)) goto parse_loop_joints;
        input->UnsafeDecrementRecursionDepth();
        if (input->ExpectTag(34)) goto parse_pose;
        break;
      }

      // optional .mw.internal.robotics.gazebotransport.ML_Pose pose = 4;
      case 4: {
        if (tag == 34) {
         parse_pose:
          DO_(::google::protobuf::internal::WireFormatLite::ReadMessageNoVirtual(
               input, mutable_pose()));
        } else {
          goto handle_unusual;
        }
        if (input->ExpectTag(40)) goto parse_enable_wind;
        break;
      }

      // optional bool enable_wind = 5;
      case 5: {
        if (tag == 40) {
         parse_enable_wind:
          DO_((::google::protobuf::internal::WireFormatLite::ReadPrimitive<
                   bool, ::google::protobuf::internal::WireFormatLite::TYPE_BOOL>(
                 input, &enable_wind_)));
          set_has_enable_wind();
        } else {
          goto handle_unusual;
        }
        if (input->ExpectTag(48)) goto parse_self_collide;
        break;
      }

      // optional bool self_collide = 6;
      case 6: {
        if (tag == 48) {
         parse_self_collide:
          DO_((::google::protobuf::internal::WireFormatLite::ReadPrimitive<
                   bool, ::google::protobuf::internal::WireFormatLite::TYPE_BOOL>(
                 input, &self_collide_)));
          set_has_self_collide();
        } else {
          goto handle_unusual;
        }
        if (input->ExpectTag(56)) goto parse_is_static;
        break;
      }

      // optional bool is_static = 7;
      case 7: {
        if (tag == 56) {
         parse_is_static:
          DO_((::google::protobuf::internal::WireFormatLite::ReadPrimitive<
                   bool, ::google::protobuf::internal::WireFormatLite::TYPE_BOOL>(
                 input, &is_static_)));
          set_has_is_static();
        } else {
          goto handle_unusual;
        }
        if (input->ExpectAtEnd()) goto success;
        break;
      }

      default: {
      handle_unusual:
        if (tag == 0 ||
            ::google::protobuf::internal::WireFormatLite::GetTagWireType(tag) ==
            ::google::protobuf::internal::WireFormatLite::WIRETYPE_END_GROUP) {
          goto success;
        }
        DO_(::google::protobuf::internal::WireFormat::SkipField(
              input, tag, mutable_unknown_fields()));
        break;
      }
    }
  }
success:
  // @@protoc_insertion_point(parse_success:mw.internal.robotics.gazebotransport.Gazebomodel)
  return true;
failure:
  // @@protoc_insertion_point(parse_failure:mw.internal.robotics.gazebotransport.Gazebomodel)
  return false;
#undef DO_
}

void Gazebomodel::SerializeWithCachedSizes(
    ::google::protobuf::io::CodedOutputStream* output) const {
  // @@protoc_insertion_point(serialize_start:mw.internal.robotics.gazebotransport.Gazebomodel)
  // required string name = 1;
  if (has_name()) {
    ::google::protobuf::internal::WireFormat::VerifyUTF8StringNamedField(
      this->name().data(), this->name().length(),
      ::google::protobuf::internal::WireFormat::SERIALIZE,
      "mw.internal.robotics.gazebotransport.Gazebomodel.name");
    ::google::protobuf::internal::WireFormatLite::WriteStringMaybeAliased(
      1, this->name(), output);
  }

  // repeated .mw.internal.robotics.gazebotransport.ML_Links links = 2;
  for (unsigned int i = 0, n = this->links_size(); i < n; i++) {
    ::google::protobuf::internal::WireFormatLite::WriteMessageMaybeToArray(
      2, this->links(i), output);
  }

  // repeated .mw.internal.robotics.gazebotransport.ML_Joints joints = 3;
  for (unsigned int i = 0, n = this->joints_size(); i < n; i++) {
    ::google::protobuf::internal::WireFormatLite::WriteMessageMaybeToArray(
      3, this->joints(i), output);
  }

  // optional .mw.internal.robotics.gazebotransport.ML_Pose pose = 4;
  if (has_pose()) {
    ::google::protobuf::internal::WireFormatLite::WriteMessageMaybeToArray(
      4, *this->pose_, output);
  }

  // optional bool enable_wind = 5;
  if (has_enable_wind()) {
    ::google::protobuf::internal::WireFormatLite::WriteBool(5, this->enable_wind(), output);
  }

  // optional bool self_collide = 6;
  if (has_self_collide()) {
    ::google::protobuf::internal::WireFormatLite::WriteBool(6, this->self_collide(), output);
  }

  // optional bool is_static = 7;
  if (has_is_static()) {
    ::google::protobuf::internal::WireFormatLite::WriteBool(7, this->is_static(), output);
  }

  if (_internal_metadata_.have_unknown_fields()) {
    ::google::protobuf::internal::WireFormat::SerializeUnknownFields(
        unknown_fields(), output);
  }
  // @@protoc_insertion_point(serialize_end:mw.internal.robotics.gazebotransport.Gazebomodel)
}

::google::protobuf::uint8* Gazebomodel::InternalSerializeWithCachedSizesToArray(
    bool deterministic, ::google::protobuf::uint8* target) const {
  // @@protoc_insertion_point(serialize_to_array_start:mw.internal.robotics.gazebotransport.Gazebomodel)
  // required string name = 1;
  if (has_name()) {
    ::google::protobuf::internal::WireFormat::VerifyUTF8StringNamedField(
      this->name().data(), this->name().length(),
      ::google::protobuf::internal::WireFormat::SERIALIZE,
      "mw.internal.robotics.gazebotransport.Gazebomodel.name");
    target =
      ::google::protobuf::internal::WireFormatLite::WriteStringToArray(
        1, this->name(), target);
  }

  // repeated .mw.internal.robotics.gazebotransport.ML_Links links = 2;
  for (unsigned int i = 0, n = this->links_size(); i < n; i++) {
    target = ::google::protobuf::internal::WireFormatLite::
      InternalWriteMessageNoVirtualToArray(
        2, this->links(i), false, target);
  }

  // repeated .mw.internal.robotics.gazebotransport.ML_Joints joints = 3;
  for (unsigned int i = 0, n = this->joints_size(); i < n; i++) {
    target = ::google::protobuf::internal::WireFormatLite::
      InternalWriteMessageNoVirtualToArray(
        3, this->joints(i), false, target);
  }

  // optional .mw.internal.robotics.gazebotransport.ML_Pose pose = 4;
  if (has_pose()) {
    target = ::google::protobuf::internal::WireFormatLite::
      InternalWriteMessageNoVirtualToArray(
        4, *this->pose_, false, target);
  }

  // optional bool enable_wind = 5;
  if (has_enable_wind()) {
    target = ::google::protobuf::internal::WireFormatLite::WriteBoolToArray(5, this->enable_wind(), target);
  }

  // optional bool self_collide = 6;
  if (has_self_collide()) {
    target = ::google::protobuf::internal::WireFormatLite::WriteBoolToArray(6, this->self_collide(), target);
  }

  // optional bool is_static = 7;
  if (has_is_static()) {
    target = ::google::protobuf::internal::WireFormatLite::WriteBoolToArray(7, this->is_static(), target);
  }

  if (_internal_metadata_.have_unknown_fields()) {
    target = ::google::protobuf::internal::WireFormat::SerializeUnknownFieldsToArray(
        unknown_fields(), target);
  }
  // @@protoc_insertion_point(serialize_to_array_end:mw.internal.robotics.gazebotransport.Gazebomodel)
  return target;
}

int Gazebomodel::ByteSize() const {
// @@protoc_insertion_point(message_byte_size_start:mw.internal.robotics.gazebotransport.Gazebomodel)
  int total_size = 0;

  // required string name = 1;
  if (has_name()) {
    total_size += 1 +
      ::google::protobuf::internal::WireFormatLite::StringSize(
        this->name());
  }
  if (_has_bits_[3 / 32] & 120u) {
    // optional .mw.internal.robotics.gazebotransport.ML_Pose pose = 4;
    if (has_pose()) {
      total_size += 1 +
        ::google::protobuf::internal::WireFormatLite::MessageSizeNoVirtual(
          *this->pose_);
    }

    // optional bool enable_wind = 5;
    if (has_enable_wind()) {
      total_size += 1 + 1;
    }

    // optional bool self_collide = 6;
    if (has_self_collide()) {
      total_size += 1 + 1;
    }

    // optional bool is_static = 7;
    if (has_is_static()) {
      total_size += 1 + 1;
    }

  }
  // repeated .mw.internal.robotics.gazebotransport.ML_Links links = 2;
  total_size += 1 * this->links_size();
  for (int i = 0; i < this->links_size(); i++) {
    total_size +=
      ::google::protobuf::internal::WireFormatLite::MessageSizeNoVirtual(
        this->links(i));
  }

  // repeated .mw.internal.robotics.gazebotransport.ML_Joints joints = 3;
  total_size += 1 * this->joints_size();
  for (int i = 0; i < this->joints_size(); i++) {
    total_size +=
      ::google::protobuf::internal::WireFormatLite::MessageSizeNoVirtual(
        this->joints(i));
  }

  if (_internal_metadata_.have_unknown_fields()) {
    total_size +=
      ::google::protobuf::internal::WireFormat::ComputeUnknownFieldsSize(
        unknown_fields());
  }
  GOOGLE_SAFE_CONCURRENT_WRITES_BEGIN();
  _cached_size_ = total_size;
  GOOGLE_SAFE_CONCURRENT_WRITES_END();
  return total_size;
}

void Gazebomodel::MergeFrom(const ::google::protobuf::Message& from) {
// @@protoc_insertion_point(generalized_merge_from_start:mw.internal.robotics.gazebotransport.Gazebomodel)
  if (GOOGLE_PREDICT_FALSE(&from == this)) {
    ::google::protobuf::internal::MergeFromFail(__FILE__, __LINE__);
  }
  const Gazebomodel* source = 
      ::google::protobuf::internal::DynamicCastToGenerated<const Gazebomodel>(
          &from);
  if (source == NULL) {
  // @@protoc_insertion_point(generalized_merge_from_cast_fail:mw.internal.robotics.gazebotransport.Gazebomodel)
    ::google::protobuf::internal::ReflectionOps::Merge(from, this);
  } else {
  // @@protoc_insertion_point(generalized_merge_from_cast_success:mw.internal.robotics.gazebotransport.Gazebomodel)
    MergeFrom(*source);
  }
}

void Gazebomodel::MergeFrom(const Gazebomodel& from) {
// @@protoc_insertion_point(class_specific_merge_from_start:mw.internal.robotics.gazebotransport.Gazebomodel)
  if (GOOGLE_PREDICT_FALSE(&from == this)) {
    ::google::protobuf::internal::MergeFromFail(__FILE__, __LINE__);
  }
  links_.MergeFrom(from.links_);
  joints_.MergeFrom(from.joints_);
  if (from._has_bits_[0 / 32] & (0xffu << (0 % 32))) {
    if (from.has_name()) {
      set_has_name();
      name_.AssignWithDefault(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), from.name_);
    }
    if (from.has_pose()) {
      mutable_pose()->::mw::internal::robotics::gazebotransport::ML_Pose::MergeFrom(from.pose());
    }
    if (from.has_enable_wind()) {
      set_enable_wind(from.enable_wind());
    }
    if (from.has_self_collide()) {
      set_self_collide(from.self_collide());
    }
    if (from.has_is_static()) {
      set_is_static(from.is_static());
    }
  }
  if (from._internal_metadata_.have_unknown_fields()) {
    mutable_unknown_fields()->MergeFrom(from.unknown_fields());
  }
}

void Gazebomodel::CopyFrom(const ::google::protobuf::Message& from) {
// @@protoc_insertion_point(generalized_copy_from_start:mw.internal.robotics.gazebotransport.Gazebomodel)
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

void Gazebomodel::CopyFrom(const Gazebomodel& from) {
// @@protoc_insertion_point(class_specific_copy_from_start:mw.internal.robotics.gazebotransport.Gazebomodel)
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

bool Gazebomodel::IsInitialized() const {
  if ((_has_bits_[0] & 0x00000001) != 0x00000001) return false;

  return true;
}

void Gazebomodel::Swap(Gazebomodel* other) {
  if (other == this) return;
  InternalSwap(other);
}
void Gazebomodel::InternalSwap(Gazebomodel* other) {
  name_.Swap(&other->name_);
  links_.UnsafeArenaSwap(&other->links_);
  joints_.UnsafeArenaSwap(&other->joints_);
  std::swap(pose_, other->pose_);
  std::swap(enable_wind_, other->enable_wind_);
  std::swap(self_collide_, other->self_collide_);
  std::swap(is_static_, other->is_static_);
  std::swap(_has_bits_[0], other->_has_bits_[0]);
  _internal_metadata_.Swap(&other->_internal_metadata_);
  std::swap(_cached_size_, other->_cached_size_);
}

::google::protobuf::Metadata Gazebomodel::GetMetadata() const {
  protobuf_AssignDescriptorsOnce();
  ::google::protobuf::Metadata metadata;
  metadata.descriptor = Gazebomodel_descriptor_;
  metadata.reflection = Gazebomodel_reflection_;
  return metadata;
}

#if PROTOBUF_INLINE_NOT_IN_HEADERS
// Gazebomodel

// required string name = 1;
bool Gazebomodel::has_name() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
void Gazebomodel::set_has_name() {
  _has_bits_[0] |= 0x00000001u;
}
void Gazebomodel::clear_has_name() {
  _has_bits_[0] &= ~0x00000001u;
}
void Gazebomodel::clear_name() {
  name_.ClearToEmptyNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
  clear_has_name();
}
 const ::std::string& Gazebomodel::name() const {
  // @@protoc_insertion_point(field_get:mw.internal.robotics.gazebotransport.Gazebomodel.name)
  return name_.GetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
 void Gazebomodel::set_name(const ::std::string& value) {
  set_has_name();
  name_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), value);
  // @@protoc_insertion_point(field_set:mw.internal.robotics.gazebotransport.Gazebomodel.name)
}
 void Gazebomodel::set_name(const char* value) {
  set_has_name();
  name_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::string(value));
  // @@protoc_insertion_point(field_set_char:mw.internal.robotics.gazebotransport.Gazebomodel.name)
}
 void Gazebomodel::set_name(const char* value, size_t size) {
  set_has_name();
  name_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(),
      ::std::string(reinterpret_cast<const char*>(value), size));
  // @@protoc_insertion_point(field_set_pointer:mw.internal.robotics.gazebotransport.Gazebomodel.name)
}
 ::std::string* Gazebomodel::mutable_name() {
  set_has_name();
  // @@protoc_insertion_point(field_mutable:mw.internal.robotics.gazebotransport.Gazebomodel.name)
  return name_.MutableNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
 ::std::string* Gazebomodel::release_name() {
  // @@protoc_insertion_point(field_release:mw.internal.robotics.gazebotransport.Gazebomodel.name)
  clear_has_name();
  return name_.ReleaseNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
 void Gazebomodel::set_allocated_name(::std::string* name) {
  if (name != NULL) {
    set_has_name();
  } else {
    clear_has_name();
  }
  name_.SetAllocatedNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), name);
  // @@protoc_insertion_point(field_set_allocated:mw.internal.robotics.gazebotransport.Gazebomodel.name)
}

// repeated .mw.internal.robotics.gazebotransport.ML_Links links = 2;
int Gazebomodel::links_size() const {
  return links_.size();
}
void Gazebomodel::clear_links() {
  links_.Clear();
}
const ::mw::internal::robotics::gazebotransport::ML_Links& Gazebomodel::links(int index) const {
  // @@protoc_insertion_point(field_get:mw.internal.robotics.gazebotransport.Gazebomodel.links)
  return links_.Get(index);
}
::mw::internal::robotics::gazebotransport::ML_Links* Gazebomodel::mutable_links(int index) {
  // @@protoc_insertion_point(field_mutable:mw.internal.robotics.gazebotransport.Gazebomodel.links)
  return links_.Mutable(index);
}
::mw::internal::robotics::gazebotransport::ML_Links* Gazebomodel::add_links() {
  // @@protoc_insertion_point(field_add:mw.internal.robotics.gazebotransport.Gazebomodel.links)
  return links_.Add();
}
::google::protobuf::RepeatedPtrField< ::mw::internal::robotics::gazebotransport::ML_Links >*
Gazebomodel::mutable_links() {
  // @@protoc_insertion_point(field_mutable_list:mw.internal.robotics.gazebotransport.Gazebomodel.links)
  return &links_;
}
const ::google::protobuf::RepeatedPtrField< ::mw::internal::robotics::gazebotransport::ML_Links >&
Gazebomodel::links() const {
  // @@protoc_insertion_point(field_list:mw.internal.robotics.gazebotransport.Gazebomodel.links)
  return links_;
}

// repeated .mw.internal.robotics.gazebotransport.ML_Joints joints = 3;
int Gazebomodel::joints_size() const {
  return joints_.size();
}
void Gazebomodel::clear_joints() {
  joints_.Clear();
}
const ::mw::internal::robotics::gazebotransport::ML_Joints& Gazebomodel::joints(int index) const {
  // @@protoc_insertion_point(field_get:mw.internal.robotics.gazebotransport.Gazebomodel.joints)
  return joints_.Get(index);
}
::mw::internal::robotics::gazebotransport::ML_Joints* Gazebomodel::mutable_joints(int index) {
  // @@protoc_insertion_point(field_mutable:mw.internal.robotics.gazebotransport.Gazebomodel.joints)
  return joints_.Mutable(index);
}
::mw::internal::robotics::gazebotransport::ML_Joints* Gazebomodel::add_joints() {
  // @@protoc_insertion_point(field_add:mw.internal.robotics.gazebotransport.Gazebomodel.joints)
  return joints_.Add();
}
::google::protobuf::RepeatedPtrField< ::mw::internal::robotics::gazebotransport::ML_Joints >*
Gazebomodel::mutable_joints() {
  // @@protoc_insertion_point(field_mutable_list:mw.internal.robotics.gazebotransport.Gazebomodel.joints)
  return &joints_;
}
const ::google::protobuf::RepeatedPtrField< ::mw::internal::robotics::gazebotransport::ML_Joints >&
Gazebomodel::joints() const {
  // @@protoc_insertion_point(field_list:mw.internal.robotics.gazebotransport.Gazebomodel.joints)
  return joints_;
}

// optional .mw.internal.robotics.gazebotransport.ML_Pose pose = 4;
bool Gazebomodel::has_pose() const {
  return (_has_bits_[0] & 0x00000008u) != 0;
}
void Gazebomodel::set_has_pose() {
  _has_bits_[0] |= 0x00000008u;
}
void Gazebomodel::clear_has_pose() {
  _has_bits_[0] &= ~0x00000008u;
}
void Gazebomodel::clear_pose() {
  if (pose_ != NULL) pose_->::mw::internal::robotics::gazebotransport::ML_Pose::Clear();
  clear_has_pose();
}
const ::mw::internal::robotics::gazebotransport::ML_Pose& Gazebomodel::pose() const {
  // @@protoc_insertion_point(field_get:mw.internal.robotics.gazebotransport.Gazebomodel.pose)
  return pose_ != NULL ? *pose_ : *default_instance_->pose_;
}
::mw::internal::robotics::gazebotransport::ML_Pose* Gazebomodel::mutable_pose() {
  set_has_pose();
  if (pose_ == NULL) {
    pose_ = new ::mw::internal::robotics::gazebotransport::ML_Pose;
  }
  // @@protoc_insertion_point(field_mutable:mw.internal.robotics.gazebotransport.Gazebomodel.pose)
  return pose_;
}
::mw::internal::robotics::gazebotransport::ML_Pose* Gazebomodel::release_pose() {
  // @@protoc_insertion_point(field_release:mw.internal.robotics.gazebotransport.Gazebomodel.pose)
  clear_has_pose();
  ::mw::internal::robotics::gazebotransport::ML_Pose* temp = pose_;
  pose_ = NULL;
  return temp;
}
void Gazebomodel::set_allocated_pose(::mw::internal::robotics::gazebotransport::ML_Pose* pose) {
  delete pose_;
  pose_ = pose;
  if (pose) {
    set_has_pose();
  } else {
    clear_has_pose();
  }
  // @@protoc_insertion_point(field_set_allocated:mw.internal.robotics.gazebotransport.Gazebomodel.pose)
}

// optional bool enable_wind = 5;
bool Gazebomodel::has_enable_wind() const {
  return (_has_bits_[0] & 0x00000010u) != 0;
}
void Gazebomodel::set_has_enable_wind() {
  _has_bits_[0] |= 0x00000010u;
}
void Gazebomodel::clear_has_enable_wind() {
  _has_bits_[0] &= ~0x00000010u;
}
void Gazebomodel::clear_enable_wind() {
  enable_wind_ = false;
  clear_has_enable_wind();
}
 bool Gazebomodel::enable_wind() const {
  // @@protoc_insertion_point(field_get:mw.internal.robotics.gazebotransport.Gazebomodel.enable_wind)
  return enable_wind_;
}
 void Gazebomodel::set_enable_wind(bool value) {
  set_has_enable_wind();
  enable_wind_ = value;
  // @@protoc_insertion_point(field_set:mw.internal.robotics.gazebotransport.Gazebomodel.enable_wind)
}

// optional bool self_collide = 6;
bool Gazebomodel::has_self_collide() const {
  return (_has_bits_[0] & 0x00000020u) != 0;
}
void Gazebomodel::set_has_self_collide() {
  _has_bits_[0] |= 0x00000020u;
}
void Gazebomodel::clear_has_self_collide() {
  _has_bits_[0] &= ~0x00000020u;
}
void Gazebomodel::clear_self_collide() {
  self_collide_ = false;
  clear_has_self_collide();
}
 bool Gazebomodel::self_collide() const {
  // @@protoc_insertion_point(field_get:mw.internal.robotics.gazebotransport.Gazebomodel.self_collide)
  return self_collide_;
}
 void Gazebomodel::set_self_collide(bool value) {
  set_has_self_collide();
  self_collide_ = value;
  // @@protoc_insertion_point(field_set:mw.internal.robotics.gazebotransport.Gazebomodel.self_collide)
}

// optional bool is_static = 7;
bool Gazebomodel::has_is_static() const {
  return (_has_bits_[0] & 0x00000040u) != 0;
}
void Gazebomodel::set_has_is_static() {
  _has_bits_[0] |= 0x00000040u;
}
void Gazebomodel::clear_has_is_static() {
  _has_bits_[0] &= ~0x00000040u;
}
void Gazebomodel::clear_is_static() {
  is_static_ = false;
  clear_has_is_static();
}
 bool Gazebomodel::is_static() const {
  // @@protoc_insertion_point(field_get:mw.internal.robotics.gazebotransport.Gazebomodel.is_static)
  return is_static_;
}
 void Gazebomodel::set_is_static(bool value) {
  set_has_is_static();
  is_static_ = value;
  // @@protoc_insertion_point(field_set:mw.internal.robotics.gazebotransport.Gazebomodel.is_static)
}

#endif  // PROTOBUF_INLINE_NOT_IN_HEADERS

// ===================================================================

#if !defined(_MSC_VER) || _MSC_VER >= 1900
const int GetGazeboModelParam::kModelNameFieldNumber;
const int GetGazeboModelParam::kIsLinkFieldNumber;
const int GetGazeboModelParam::kLinkJointNameFieldNumber;
#endif  // !defined(_MSC_VER) || _MSC_VER >= 1900

GetGazeboModelParam::GetGazeboModelParam()
  : ::google::protobuf::Message(), _internal_metadata_(NULL) {
  SharedCtor();
  // @@protoc_insertion_point(constructor:mw.internal.robotics.gazebotransport.GetGazeboModelParam)
}

void GetGazeboModelParam::InitAsDefaultInstance() {
}

GetGazeboModelParam::GetGazeboModelParam(const GetGazeboModelParam& from)
  : ::google::protobuf::Message(),
    _internal_metadata_(NULL) {
  SharedCtor();
  MergeFrom(from);
  // @@protoc_insertion_point(copy_constructor:mw.internal.robotics.gazebotransport.GetGazeboModelParam)
}

void GetGazeboModelParam::SharedCtor() {
  ::google::protobuf::internal::GetEmptyString();
  _cached_size_ = 0;
  model_name_.UnsafeSetDefault(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
  is_link_ = false;
  link_joint_name_.UnsafeSetDefault(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
  ::memset(_has_bits_, 0, sizeof(_has_bits_));
}

GetGazeboModelParam::~GetGazeboModelParam() {
  // @@protoc_insertion_point(destructor:mw.internal.robotics.gazebotransport.GetGazeboModelParam)
  SharedDtor();
}

void GetGazeboModelParam::SharedDtor() {
  model_name_.DestroyNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
  link_joint_name_.DestroyNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
  if (this != default_instance_) {
  }
}

void GetGazeboModelParam::SetCachedSize(int size) const {
  GOOGLE_SAFE_CONCURRENT_WRITES_BEGIN();
  _cached_size_ = size;
  GOOGLE_SAFE_CONCURRENT_WRITES_END();
}
const ::google::protobuf::Descriptor* GetGazeboModelParam::descriptor() {
  protobuf_AssignDescriptorsOnce();
  return GetGazeboModelParam_descriptor_;
}

const GetGazeboModelParam& GetGazeboModelParam::default_instance() {
  if (default_instance_ == NULL) protobuf_AddDesc_mw_2einternal_2erobotics_2egazebotransport_2eCoSimMsgs_2eproto();
  return *default_instance_;
}

GetGazeboModelParam* GetGazeboModelParam::default_instance_ = NULL;

GetGazeboModelParam* GetGazeboModelParam::New(::google::protobuf::Arena* arena) const {
  GetGazeboModelParam* n = new GetGazeboModelParam;
  if (arena != NULL) {
    arena->Own(n);
  }
  return n;
}

void GetGazeboModelParam::Clear() {
// @@protoc_insertion_point(message_clear_start:mw.internal.robotics.gazebotransport.GetGazeboModelParam)
  if (_has_bits_[0 / 32] & 7u) {
    if (has_model_name()) {
      model_name_.ClearToEmptyNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
    }
    is_link_ = false;
    if (has_link_joint_name()) {
      link_joint_name_.ClearToEmptyNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
    }
  }
  ::memset(_has_bits_, 0, sizeof(_has_bits_));
  if (_internal_metadata_.have_unknown_fields()) {
    mutable_unknown_fields()->Clear();
  }
}

bool GetGazeboModelParam::MergePartialFromCodedStream(
    ::google::protobuf::io::CodedInputStream* input) {
#define DO_(EXPRESSION) if (!GOOGLE_PREDICT_TRUE(EXPRESSION)) goto failure
  ::google::protobuf::uint32 tag;
  // @@protoc_insertion_point(parse_start:mw.internal.robotics.gazebotransport.GetGazeboModelParam)
  for (;;) {
    ::std::pair< ::google::protobuf::uint32, bool> p = input->ReadTagWithCutoff(127);
    tag = p.first;
    if (!p.second) goto handle_unusual;
    switch (::google::protobuf::internal::WireFormatLite::GetTagFieldNumber(tag)) {
      // required string model_name = 1;
      case 1: {
        if (tag == 10) {
          DO_(::google::protobuf::internal::WireFormatLite::ReadString(
                input, this->mutable_model_name()));
          ::google::protobuf::internal::WireFormat::VerifyUTF8StringNamedField(
            this->model_name().data(), this->model_name().length(),
            ::google::protobuf::internal::WireFormat::PARSE,
            "mw.internal.robotics.gazebotransport.GetGazeboModelParam.model_name");
        } else {
          goto handle_unusual;
        }
        if (input->ExpectTag(16)) goto parse_is_link;
        break;
      }

      // optional bool is_link = 2;
      case 2: {
        if (tag == 16) {
         parse_is_link:
          DO_((::google::protobuf::internal::WireFormatLite::ReadPrimitive<
                   bool, ::google::protobuf::internal::WireFormatLite::TYPE_BOOL>(
                 input, &is_link_)));
          set_has_is_link();
        } else {
          goto handle_unusual;
        }
        if (input->ExpectTag(26)) goto parse_link_joint_name;
        break;
      }

      // optional string link_joint_name = 3;
      case 3: {
        if (tag == 26) {
         parse_link_joint_name:
          DO_(::google::protobuf::internal::WireFormatLite::ReadString(
                input, this->mutable_link_joint_name()));
          ::google::protobuf::internal::WireFormat::VerifyUTF8StringNamedField(
            this->link_joint_name().data(), this->link_joint_name().length(),
            ::google::protobuf::internal::WireFormat::PARSE,
            "mw.internal.robotics.gazebotransport.GetGazeboModelParam.link_joint_name");
        } else {
          goto handle_unusual;
        }
        if (input->ExpectAtEnd()) goto success;
        break;
      }

      default: {
      handle_unusual:
        if (tag == 0 ||
            ::google::protobuf::internal::WireFormatLite::GetTagWireType(tag) ==
            ::google::protobuf::internal::WireFormatLite::WIRETYPE_END_GROUP) {
          goto success;
        }
        DO_(::google::protobuf::internal::WireFormat::SkipField(
              input, tag, mutable_unknown_fields()));
        break;
      }
    }
  }
success:
  // @@protoc_insertion_point(parse_success:mw.internal.robotics.gazebotransport.GetGazeboModelParam)
  return true;
failure:
  // @@protoc_insertion_point(parse_failure:mw.internal.robotics.gazebotransport.GetGazeboModelParam)
  return false;
#undef DO_
}

void GetGazeboModelParam::SerializeWithCachedSizes(
    ::google::protobuf::io::CodedOutputStream* output) const {
  // @@protoc_insertion_point(serialize_start:mw.internal.robotics.gazebotransport.GetGazeboModelParam)
  // required string model_name = 1;
  if (has_model_name()) {
    ::google::protobuf::internal::WireFormat::VerifyUTF8StringNamedField(
      this->model_name().data(), this->model_name().length(),
      ::google::protobuf::internal::WireFormat::SERIALIZE,
      "mw.internal.robotics.gazebotransport.GetGazeboModelParam.model_name");
    ::google::protobuf::internal::WireFormatLite::WriteStringMaybeAliased(
      1, this->model_name(), output);
  }

  // optional bool is_link = 2;
  if (has_is_link()) {
    ::google::protobuf::internal::WireFormatLite::WriteBool(2, this->is_link(), output);
  }

  // optional string link_joint_name = 3;
  if (has_link_joint_name()) {
    ::google::protobuf::internal::WireFormat::VerifyUTF8StringNamedField(
      this->link_joint_name().data(), this->link_joint_name().length(),
      ::google::protobuf::internal::WireFormat::SERIALIZE,
      "mw.internal.robotics.gazebotransport.GetGazeboModelParam.link_joint_name");
    ::google::protobuf::internal::WireFormatLite::WriteStringMaybeAliased(
      3, this->link_joint_name(), output);
  }

  if (_internal_metadata_.have_unknown_fields()) {
    ::google::protobuf::internal::WireFormat::SerializeUnknownFields(
        unknown_fields(), output);
  }
  // @@protoc_insertion_point(serialize_end:mw.internal.robotics.gazebotransport.GetGazeboModelParam)
}

::google::protobuf::uint8* GetGazeboModelParam::InternalSerializeWithCachedSizesToArray(
    bool deterministic, ::google::protobuf::uint8* target) const {
  // @@protoc_insertion_point(serialize_to_array_start:mw.internal.robotics.gazebotransport.GetGazeboModelParam)
  // required string model_name = 1;
  if (has_model_name()) {
    ::google::protobuf::internal::WireFormat::VerifyUTF8StringNamedField(
      this->model_name().data(), this->model_name().length(),
      ::google::protobuf::internal::WireFormat::SERIALIZE,
      "mw.internal.robotics.gazebotransport.GetGazeboModelParam.model_name");
    target =
      ::google::protobuf::internal::WireFormatLite::WriteStringToArray(
        1, this->model_name(), target);
  }

  // optional bool is_link = 2;
  if (has_is_link()) {
    target = ::google::protobuf::internal::WireFormatLite::WriteBoolToArray(2, this->is_link(), target);
  }

  // optional string link_joint_name = 3;
  if (has_link_joint_name()) {
    ::google::protobuf::internal::WireFormat::VerifyUTF8StringNamedField(
      this->link_joint_name().data(), this->link_joint_name().length(),
      ::google::protobuf::internal::WireFormat::SERIALIZE,
      "mw.internal.robotics.gazebotransport.GetGazeboModelParam.link_joint_name");
    target =
      ::google::protobuf::internal::WireFormatLite::WriteStringToArray(
        3, this->link_joint_name(), target);
  }

  if (_internal_metadata_.have_unknown_fields()) {
    target = ::google::protobuf::internal::WireFormat::SerializeUnknownFieldsToArray(
        unknown_fields(), target);
  }
  // @@protoc_insertion_point(serialize_to_array_end:mw.internal.robotics.gazebotransport.GetGazeboModelParam)
  return target;
}

int GetGazeboModelParam::ByteSize() const {
// @@protoc_insertion_point(message_byte_size_start:mw.internal.robotics.gazebotransport.GetGazeboModelParam)
  int total_size = 0;

  // required string model_name = 1;
  if (has_model_name()) {
    total_size += 1 +
      ::google::protobuf::internal::WireFormatLite::StringSize(
        this->model_name());
  }
  if (_has_bits_[1 / 32] & 6u) {
    // optional bool is_link = 2;
    if (has_is_link()) {
      total_size += 1 + 1;
    }

    // optional string link_joint_name = 3;
    if (has_link_joint_name()) {
      total_size += 1 +
        ::google::protobuf::internal::WireFormatLite::StringSize(
          this->link_joint_name());
    }

  }
  if (_internal_metadata_.have_unknown_fields()) {
    total_size +=
      ::google::protobuf::internal::WireFormat::ComputeUnknownFieldsSize(
        unknown_fields());
  }
  GOOGLE_SAFE_CONCURRENT_WRITES_BEGIN();
  _cached_size_ = total_size;
  GOOGLE_SAFE_CONCURRENT_WRITES_END();
  return total_size;
}

void GetGazeboModelParam::MergeFrom(const ::google::protobuf::Message& from) {
// @@protoc_insertion_point(generalized_merge_from_start:mw.internal.robotics.gazebotransport.GetGazeboModelParam)
  if (GOOGLE_PREDICT_FALSE(&from == this)) {
    ::google::protobuf::internal::MergeFromFail(__FILE__, __LINE__);
  }
  const GetGazeboModelParam* source = 
      ::google::protobuf::internal::DynamicCastToGenerated<const GetGazeboModelParam>(
          &from);
  if (source == NULL) {
  // @@protoc_insertion_point(generalized_merge_from_cast_fail:mw.internal.robotics.gazebotransport.GetGazeboModelParam)
    ::google::protobuf::internal::ReflectionOps::Merge(from, this);
  } else {
  // @@protoc_insertion_point(generalized_merge_from_cast_success:mw.internal.robotics.gazebotransport.GetGazeboModelParam)
    MergeFrom(*source);
  }
}

void GetGazeboModelParam::MergeFrom(const GetGazeboModelParam& from) {
// @@protoc_insertion_point(class_specific_merge_from_start:mw.internal.robotics.gazebotransport.GetGazeboModelParam)
  if (GOOGLE_PREDICT_FALSE(&from == this)) {
    ::google::protobuf::internal::MergeFromFail(__FILE__, __LINE__);
  }
  if (from._has_bits_[0 / 32] & (0xffu << (0 % 32))) {
    if (from.has_model_name()) {
      set_has_model_name();
      model_name_.AssignWithDefault(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), from.model_name_);
    }
    if (from.has_is_link()) {
      set_is_link(from.is_link());
    }
    if (from.has_link_joint_name()) {
      set_has_link_joint_name();
      link_joint_name_.AssignWithDefault(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), from.link_joint_name_);
    }
  }
  if (from._internal_metadata_.have_unknown_fields()) {
    mutable_unknown_fields()->MergeFrom(from.unknown_fields());
  }
}

void GetGazeboModelParam::CopyFrom(const ::google::protobuf::Message& from) {
// @@protoc_insertion_point(generalized_copy_from_start:mw.internal.robotics.gazebotransport.GetGazeboModelParam)
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

void GetGazeboModelParam::CopyFrom(const GetGazeboModelParam& from) {
// @@protoc_insertion_point(class_specific_copy_from_start:mw.internal.robotics.gazebotransport.GetGazeboModelParam)
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

bool GetGazeboModelParam::IsInitialized() const {
  if ((_has_bits_[0] & 0x00000001) != 0x00000001) return false;

  return true;
}

void GetGazeboModelParam::Swap(GetGazeboModelParam* other) {
  if (other == this) return;
  InternalSwap(other);
}
void GetGazeboModelParam::InternalSwap(GetGazeboModelParam* other) {
  model_name_.Swap(&other->model_name_);
  std::swap(is_link_, other->is_link_);
  link_joint_name_.Swap(&other->link_joint_name_);
  std::swap(_has_bits_[0], other->_has_bits_[0]);
  _internal_metadata_.Swap(&other->_internal_metadata_);
  std::swap(_cached_size_, other->_cached_size_);
}

::google::protobuf::Metadata GetGazeboModelParam::GetMetadata() const {
  protobuf_AssignDescriptorsOnce();
  ::google::protobuf::Metadata metadata;
  metadata.descriptor = GetGazeboModelParam_descriptor_;
  metadata.reflection = GetGazeboModelParam_reflection_;
  return metadata;
}

#if PROTOBUF_INLINE_NOT_IN_HEADERS
// GetGazeboModelParam

// required string model_name = 1;
bool GetGazeboModelParam::has_model_name() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
void GetGazeboModelParam::set_has_model_name() {
  _has_bits_[0] |= 0x00000001u;
}
void GetGazeboModelParam::clear_has_model_name() {
  _has_bits_[0] &= ~0x00000001u;
}
void GetGazeboModelParam::clear_model_name() {
  model_name_.ClearToEmptyNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
  clear_has_model_name();
}
 const ::std::string& GetGazeboModelParam::model_name() const {
  // @@protoc_insertion_point(field_get:mw.internal.robotics.gazebotransport.GetGazeboModelParam.model_name)
  return model_name_.GetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
 void GetGazeboModelParam::set_model_name(const ::std::string& value) {
  set_has_model_name();
  model_name_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), value);
  // @@protoc_insertion_point(field_set:mw.internal.robotics.gazebotransport.GetGazeboModelParam.model_name)
}
 void GetGazeboModelParam::set_model_name(const char* value) {
  set_has_model_name();
  model_name_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::string(value));
  // @@protoc_insertion_point(field_set_char:mw.internal.robotics.gazebotransport.GetGazeboModelParam.model_name)
}
 void GetGazeboModelParam::set_model_name(const char* value, size_t size) {
  set_has_model_name();
  model_name_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(),
      ::std::string(reinterpret_cast<const char*>(value), size));
  // @@protoc_insertion_point(field_set_pointer:mw.internal.robotics.gazebotransport.GetGazeboModelParam.model_name)
}
 ::std::string* GetGazeboModelParam::mutable_model_name() {
  set_has_model_name();
  // @@protoc_insertion_point(field_mutable:mw.internal.robotics.gazebotransport.GetGazeboModelParam.model_name)
  return model_name_.MutableNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
 ::std::string* GetGazeboModelParam::release_model_name() {
  // @@protoc_insertion_point(field_release:mw.internal.robotics.gazebotransport.GetGazeboModelParam.model_name)
  clear_has_model_name();
  return model_name_.ReleaseNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
 void GetGazeboModelParam::set_allocated_model_name(::std::string* model_name) {
  if (model_name != NULL) {
    set_has_model_name();
  } else {
    clear_has_model_name();
  }
  model_name_.SetAllocatedNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), model_name);
  // @@protoc_insertion_point(field_set_allocated:mw.internal.robotics.gazebotransport.GetGazeboModelParam.model_name)
}

// optional bool is_link = 2;
bool GetGazeboModelParam::has_is_link() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
void GetGazeboModelParam::set_has_is_link() {
  _has_bits_[0] |= 0x00000002u;
}
void GetGazeboModelParam::clear_has_is_link() {
  _has_bits_[0] &= ~0x00000002u;
}
void GetGazeboModelParam::clear_is_link() {
  is_link_ = false;
  clear_has_is_link();
}
 bool GetGazeboModelParam::is_link() const {
  // @@protoc_insertion_point(field_get:mw.internal.robotics.gazebotransport.GetGazeboModelParam.is_link)
  return is_link_;
}
 void GetGazeboModelParam::set_is_link(bool value) {
  set_has_is_link();
  is_link_ = value;
  // @@protoc_insertion_point(field_set:mw.internal.robotics.gazebotransport.GetGazeboModelParam.is_link)
}

// optional string link_joint_name = 3;
bool GetGazeboModelParam::has_link_joint_name() const {
  return (_has_bits_[0] & 0x00000004u) != 0;
}
void GetGazeboModelParam::set_has_link_joint_name() {
  _has_bits_[0] |= 0x00000004u;
}
void GetGazeboModelParam::clear_has_link_joint_name() {
  _has_bits_[0] &= ~0x00000004u;
}
void GetGazeboModelParam::clear_link_joint_name() {
  link_joint_name_.ClearToEmptyNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
  clear_has_link_joint_name();
}
 const ::std::string& GetGazeboModelParam::link_joint_name() const {
  // @@protoc_insertion_point(field_get:mw.internal.robotics.gazebotransport.GetGazeboModelParam.link_joint_name)
  return link_joint_name_.GetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
 void GetGazeboModelParam::set_link_joint_name(const ::std::string& value) {
  set_has_link_joint_name();
  link_joint_name_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), value);
  // @@protoc_insertion_point(field_set:mw.internal.robotics.gazebotransport.GetGazeboModelParam.link_joint_name)
}
 void GetGazeboModelParam::set_link_joint_name(const char* value) {
  set_has_link_joint_name();
  link_joint_name_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::string(value));
  // @@protoc_insertion_point(field_set_char:mw.internal.robotics.gazebotransport.GetGazeboModelParam.link_joint_name)
}
 void GetGazeboModelParam::set_link_joint_name(const char* value, size_t size) {
  set_has_link_joint_name();
  link_joint_name_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(),
      ::std::string(reinterpret_cast<const char*>(value), size));
  // @@protoc_insertion_point(field_set_pointer:mw.internal.robotics.gazebotransport.GetGazeboModelParam.link_joint_name)
}
 ::std::string* GetGazeboModelParam::mutable_link_joint_name() {
  set_has_link_joint_name();
  // @@protoc_insertion_point(field_mutable:mw.internal.robotics.gazebotransport.GetGazeboModelParam.link_joint_name)
  return link_joint_name_.MutableNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
 ::std::string* GetGazeboModelParam::release_link_joint_name() {
  // @@protoc_insertion_point(field_release:mw.internal.robotics.gazebotransport.GetGazeboModelParam.link_joint_name)
  clear_has_link_joint_name();
  return link_joint_name_.ReleaseNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
 void GetGazeboModelParam::set_allocated_link_joint_name(::std::string* link_joint_name) {
  if (link_joint_name != NULL) {
    set_has_link_joint_name();
  } else {
    clear_has_link_joint_name();
  }
  link_joint_name_.SetAllocatedNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), link_joint_name);
  // @@protoc_insertion_point(field_set_allocated:mw.internal.robotics.gazebotransport.GetGazeboModelParam.link_joint_name)
}

#endif  // PROTOBUF_INLINE_NOT_IN_HEADERS

// ===================================================================

#if !defined(_MSC_VER) || _MSC_VER >= 1900
const int GazeboModelSDF::kModelNameFieldNumber;
const int GazeboModelSDF::kSdfStringFieldNumber;
#endif  // !defined(_MSC_VER) || _MSC_VER >= 1900

GazeboModelSDF::GazeboModelSDF()
  : ::google::protobuf::Message(), _internal_metadata_(NULL) {
  SharedCtor();
  // @@protoc_insertion_point(constructor:mw.internal.robotics.gazebotransport.GazeboModelSDF)
}

void GazeboModelSDF::InitAsDefaultInstance() {
}

GazeboModelSDF::GazeboModelSDF(const GazeboModelSDF& from)
  : ::google::protobuf::Message(),
    _internal_metadata_(NULL) {
  SharedCtor();
  MergeFrom(from);
  // @@protoc_insertion_point(copy_constructor:mw.internal.robotics.gazebotransport.GazeboModelSDF)
}

void GazeboModelSDF::SharedCtor() {
  ::google::protobuf::internal::GetEmptyString();
  _cached_size_ = 0;
  model_name_.UnsafeSetDefault(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
  sdf_string_.UnsafeSetDefault(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
  ::memset(_has_bits_, 0, sizeof(_has_bits_));
}

GazeboModelSDF::~GazeboModelSDF() {
  // @@protoc_insertion_point(destructor:mw.internal.robotics.gazebotransport.GazeboModelSDF)
  SharedDtor();
}

void GazeboModelSDF::SharedDtor() {
  model_name_.DestroyNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
  sdf_string_.DestroyNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
  if (this != default_instance_) {
  }
}

void GazeboModelSDF::SetCachedSize(int size) const {
  GOOGLE_SAFE_CONCURRENT_WRITES_BEGIN();
  _cached_size_ = size;
  GOOGLE_SAFE_CONCURRENT_WRITES_END();
}
const ::google::protobuf::Descriptor* GazeboModelSDF::descriptor() {
  protobuf_AssignDescriptorsOnce();
  return GazeboModelSDF_descriptor_;
}

const GazeboModelSDF& GazeboModelSDF::default_instance() {
  if (default_instance_ == NULL) protobuf_AddDesc_mw_2einternal_2erobotics_2egazebotransport_2eCoSimMsgs_2eproto();
  return *default_instance_;
}

GazeboModelSDF* GazeboModelSDF::default_instance_ = NULL;

GazeboModelSDF* GazeboModelSDF::New(::google::protobuf::Arena* arena) const {
  GazeboModelSDF* n = new GazeboModelSDF;
  if (arena != NULL) {
    arena->Own(n);
  }
  return n;
}

void GazeboModelSDF::Clear() {
// @@protoc_insertion_point(message_clear_start:mw.internal.robotics.gazebotransport.GazeboModelSDF)
  if (_has_bits_[0 / 32] & 3u) {
    if (has_model_name()) {
      model_name_.ClearToEmptyNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
    }
    if (has_sdf_string()) {
      sdf_string_.ClearToEmptyNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
    }
  }
  ::memset(_has_bits_, 0, sizeof(_has_bits_));
  if (_internal_metadata_.have_unknown_fields()) {
    mutable_unknown_fields()->Clear();
  }
}

bool GazeboModelSDF::MergePartialFromCodedStream(
    ::google::protobuf::io::CodedInputStream* input) {
#define DO_(EXPRESSION) if (!GOOGLE_PREDICT_TRUE(EXPRESSION)) goto failure
  ::google::protobuf::uint32 tag;
  // @@protoc_insertion_point(parse_start:mw.internal.robotics.gazebotransport.GazeboModelSDF)
  for (;;) {
    ::std::pair< ::google::protobuf::uint32, bool> p = input->ReadTagWithCutoff(127);
    tag = p.first;
    if (!p.second) goto handle_unusual;
    switch (::google::protobuf::internal::WireFormatLite::GetTagFieldNumber(tag)) {
      // required string model_name = 1;
      case 1: {
        if (tag == 10) {
          DO_(::google::protobuf::internal::WireFormatLite::ReadString(
                input, this->mutable_model_name()));
          ::google::protobuf::internal::WireFormat::VerifyUTF8StringNamedField(
            this->model_name().data(), this->model_name().length(),
            ::google::protobuf::internal::WireFormat::PARSE,
            "mw.internal.robotics.gazebotransport.GazeboModelSDF.model_name");
        } else {
          goto handle_unusual;
        }
        if (input->ExpectTag(18)) goto parse_sdf_string;
        break;
      }

      // required string sdf_string = 2;
      case 2: {
        if (tag == 18) {
         parse_sdf_string:
          DO_(::google::protobuf::internal::WireFormatLite::ReadString(
                input, this->mutable_sdf_string()));
          ::google::protobuf::internal::WireFormat::VerifyUTF8StringNamedField(
            this->sdf_string().data(), this->sdf_string().length(),
            ::google::protobuf::internal::WireFormat::PARSE,
            "mw.internal.robotics.gazebotransport.GazeboModelSDF.sdf_string");
        } else {
          goto handle_unusual;
        }
        if (input->ExpectAtEnd()) goto success;
        break;
      }

      default: {
      handle_unusual:
        if (tag == 0 ||
            ::google::protobuf::internal::WireFormatLite::GetTagWireType(tag) ==
            ::google::protobuf::internal::WireFormatLite::WIRETYPE_END_GROUP) {
          goto success;
        }
        DO_(::google::protobuf::internal::WireFormat::SkipField(
              input, tag, mutable_unknown_fields()));
        break;
      }
    }
  }
success:
  // @@protoc_insertion_point(parse_success:mw.internal.robotics.gazebotransport.GazeboModelSDF)
  return true;
failure:
  // @@protoc_insertion_point(parse_failure:mw.internal.robotics.gazebotransport.GazeboModelSDF)
  return false;
#undef DO_
}

void GazeboModelSDF::SerializeWithCachedSizes(
    ::google::protobuf::io::CodedOutputStream* output) const {
  // @@protoc_insertion_point(serialize_start:mw.internal.robotics.gazebotransport.GazeboModelSDF)
  // required string model_name = 1;
  if (has_model_name()) {
    ::google::protobuf::internal::WireFormat::VerifyUTF8StringNamedField(
      this->model_name().data(), this->model_name().length(),
      ::google::protobuf::internal::WireFormat::SERIALIZE,
      "mw.internal.robotics.gazebotransport.GazeboModelSDF.model_name");
    ::google::protobuf::internal::WireFormatLite::WriteStringMaybeAliased(
      1, this->model_name(), output);
  }

  // required string sdf_string = 2;
  if (has_sdf_string()) {
    ::google::protobuf::internal::WireFormat::VerifyUTF8StringNamedField(
      this->sdf_string().data(), this->sdf_string().length(),
      ::google::protobuf::internal::WireFormat::SERIALIZE,
      "mw.internal.robotics.gazebotransport.GazeboModelSDF.sdf_string");
    ::google::protobuf::internal::WireFormatLite::WriteStringMaybeAliased(
      2, this->sdf_string(), output);
  }

  if (_internal_metadata_.have_unknown_fields()) {
    ::google::protobuf::internal::WireFormat::SerializeUnknownFields(
        unknown_fields(), output);
  }
  // @@protoc_insertion_point(serialize_end:mw.internal.robotics.gazebotransport.GazeboModelSDF)
}

::google::protobuf::uint8* GazeboModelSDF::InternalSerializeWithCachedSizesToArray(
    bool deterministic, ::google::protobuf::uint8* target) const {
  // @@protoc_insertion_point(serialize_to_array_start:mw.internal.robotics.gazebotransport.GazeboModelSDF)
  // required string model_name = 1;
  if (has_model_name()) {
    ::google::protobuf::internal::WireFormat::VerifyUTF8StringNamedField(
      this->model_name().data(), this->model_name().length(),
      ::google::protobuf::internal::WireFormat::SERIALIZE,
      "mw.internal.robotics.gazebotransport.GazeboModelSDF.model_name");
    target =
      ::google::protobuf::internal::WireFormatLite::WriteStringToArray(
        1, this->model_name(), target);
  }

  // required string sdf_string = 2;
  if (has_sdf_string()) {
    ::google::protobuf::internal::WireFormat::VerifyUTF8StringNamedField(
      this->sdf_string().data(), this->sdf_string().length(),
      ::google::protobuf::internal::WireFormat::SERIALIZE,
      "mw.internal.robotics.gazebotransport.GazeboModelSDF.sdf_string");
    target =
      ::google::protobuf::internal::WireFormatLite::WriteStringToArray(
        2, this->sdf_string(), target);
  }

  if (_internal_metadata_.have_unknown_fields()) {
    target = ::google::protobuf::internal::WireFormat::SerializeUnknownFieldsToArray(
        unknown_fields(), target);
  }
  // @@protoc_insertion_point(serialize_to_array_end:mw.internal.robotics.gazebotransport.GazeboModelSDF)
  return target;
}

int GazeboModelSDF::RequiredFieldsByteSizeFallback() const {
// @@protoc_insertion_point(required_fields_byte_size_fallback_start:mw.internal.robotics.gazebotransport.GazeboModelSDF)
  int total_size = 0;

  if (has_model_name()) {
    // required string model_name = 1;
    total_size += 1 +
      ::google::protobuf::internal::WireFormatLite::StringSize(
        this->model_name());
  }

  if (has_sdf_string()) {
    // required string sdf_string = 2;
    total_size += 1 +
      ::google::protobuf::internal::WireFormatLite::StringSize(
        this->sdf_string());
  }

  return total_size;
}
int GazeboModelSDF::ByteSize() const {
// @@protoc_insertion_point(message_byte_size_start:mw.internal.robotics.gazebotransport.GazeboModelSDF)
  int total_size = 0;

  if (((_has_bits_[0] & 0x00000003) ^ 0x00000003) == 0) {  // All required fields are present.
    // required string model_name = 1;
    total_size += 1 +
      ::google::protobuf::internal::WireFormatLite::StringSize(
        this->model_name());

    // required string sdf_string = 2;
    total_size += 1 +
      ::google::protobuf::internal::WireFormatLite::StringSize(
        this->sdf_string());

  } else {
    total_size += RequiredFieldsByteSizeFallback();
  }
  if (_internal_metadata_.have_unknown_fields()) {
    total_size +=
      ::google::protobuf::internal::WireFormat::ComputeUnknownFieldsSize(
        unknown_fields());
  }
  GOOGLE_SAFE_CONCURRENT_WRITES_BEGIN();
  _cached_size_ = total_size;
  GOOGLE_SAFE_CONCURRENT_WRITES_END();
  return total_size;
}

void GazeboModelSDF::MergeFrom(const ::google::protobuf::Message& from) {
// @@protoc_insertion_point(generalized_merge_from_start:mw.internal.robotics.gazebotransport.GazeboModelSDF)
  if (GOOGLE_PREDICT_FALSE(&from == this)) {
    ::google::protobuf::internal::MergeFromFail(__FILE__, __LINE__);
  }
  const GazeboModelSDF* source = 
      ::google::protobuf::internal::DynamicCastToGenerated<const GazeboModelSDF>(
          &from);
  if (source == NULL) {
  // @@protoc_insertion_point(generalized_merge_from_cast_fail:mw.internal.robotics.gazebotransport.GazeboModelSDF)
    ::google::protobuf::internal::ReflectionOps::Merge(from, this);
  } else {
  // @@protoc_insertion_point(generalized_merge_from_cast_success:mw.internal.robotics.gazebotransport.GazeboModelSDF)
    MergeFrom(*source);
  }
}

void GazeboModelSDF::MergeFrom(const GazeboModelSDF& from) {
// @@protoc_insertion_point(class_specific_merge_from_start:mw.internal.robotics.gazebotransport.GazeboModelSDF)
  if (GOOGLE_PREDICT_FALSE(&from == this)) {
    ::google::protobuf::internal::MergeFromFail(__FILE__, __LINE__);
  }
  if (from._has_bits_[0 / 32] & (0xffu << (0 % 32))) {
    if (from.has_model_name()) {
      set_has_model_name();
      model_name_.AssignWithDefault(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), from.model_name_);
    }
    if (from.has_sdf_string()) {
      set_has_sdf_string();
      sdf_string_.AssignWithDefault(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), from.sdf_string_);
    }
  }
  if (from._internal_metadata_.have_unknown_fields()) {
    mutable_unknown_fields()->MergeFrom(from.unknown_fields());
  }
}

void GazeboModelSDF::CopyFrom(const ::google::protobuf::Message& from) {
// @@protoc_insertion_point(generalized_copy_from_start:mw.internal.robotics.gazebotransport.GazeboModelSDF)
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

void GazeboModelSDF::CopyFrom(const GazeboModelSDF& from) {
// @@protoc_insertion_point(class_specific_copy_from_start:mw.internal.robotics.gazebotransport.GazeboModelSDF)
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

bool GazeboModelSDF::IsInitialized() const {
  if ((_has_bits_[0] & 0x00000003) != 0x00000003) return false;

  return true;
}

void GazeboModelSDF::Swap(GazeboModelSDF* other) {
  if (other == this) return;
  InternalSwap(other);
}
void GazeboModelSDF::InternalSwap(GazeboModelSDF* other) {
  model_name_.Swap(&other->model_name_);
  sdf_string_.Swap(&other->sdf_string_);
  std::swap(_has_bits_[0], other->_has_bits_[0]);
  _internal_metadata_.Swap(&other->_internal_metadata_);
  std::swap(_cached_size_, other->_cached_size_);
}

::google::protobuf::Metadata GazeboModelSDF::GetMetadata() const {
  protobuf_AssignDescriptorsOnce();
  ::google::protobuf::Metadata metadata;
  metadata.descriptor = GazeboModelSDF_descriptor_;
  metadata.reflection = GazeboModelSDF_reflection_;
  return metadata;
}

#if PROTOBUF_INLINE_NOT_IN_HEADERS
// GazeboModelSDF

// required string model_name = 1;
bool GazeboModelSDF::has_model_name() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
void GazeboModelSDF::set_has_model_name() {
  _has_bits_[0] |= 0x00000001u;
}
void GazeboModelSDF::clear_has_model_name() {
  _has_bits_[0] &= ~0x00000001u;
}
void GazeboModelSDF::clear_model_name() {
  model_name_.ClearToEmptyNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
  clear_has_model_name();
}
 const ::std::string& GazeboModelSDF::model_name() const {
  // @@protoc_insertion_point(field_get:mw.internal.robotics.gazebotransport.GazeboModelSDF.model_name)
  return model_name_.GetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
 void GazeboModelSDF::set_model_name(const ::std::string& value) {
  set_has_model_name();
  model_name_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), value);
  // @@protoc_insertion_point(field_set:mw.internal.robotics.gazebotransport.GazeboModelSDF.model_name)
}
 void GazeboModelSDF::set_model_name(const char* value) {
  set_has_model_name();
  model_name_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::string(value));
  // @@protoc_insertion_point(field_set_char:mw.internal.robotics.gazebotransport.GazeboModelSDF.model_name)
}
 void GazeboModelSDF::set_model_name(const char* value, size_t size) {
  set_has_model_name();
  model_name_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(),
      ::std::string(reinterpret_cast<const char*>(value), size));
  // @@protoc_insertion_point(field_set_pointer:mw.internal.robotics.gazebotransport.GazeboModelSDF.model_name)
}
 ::std::string* GazeboModelSDF::mutable_model_name() {
  set_has_model_name();
  // @@protoc_insertion_point(field_mutable:mw.internal.robotics.gazebotransport.GazeboModelSDF.model_name)
  return model_name_.MutableNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
 ::std::string* GazeboModelSDF::release_model_name() {
  // @@protoc_insertion_point(field_release:mw.internal.robotics.gazebotransport.GazeboModelSDF.model_name)
  clear_has_model_name();
  return model_name_.ReleaseNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
 void GazeboModelSDF::set_allocated_model_name(::std::string* model_name) {
  if (model_name != NULL) {
    set_has_model_name();
  } else {
    clear_has_model_name();
  }
  model_name_.SetAllocatedNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), model_name);
  // @@protoc_insertion_point(field_set_allocated:mw.internal.robotics.gazebotransport.GazeboModelSDF.model_name)
}

// required string sdf_string = 2;
bool GazeboModelSDF::has_sdf_string() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
void GazeboModelSDF::set_has_sdf_string() {
  _has_bits_[0] |= 0x00000002u;
}
void GazeboModelSDF::clear_has_sdf_string() {
  _has_bits_[0] &= ~0x00000002u;
}
void GazeboModelSDF::clear_sdf_string() {
  sdf_string_.ClearToEmptyNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
  clear_has_sdf_string();
}
 const ::std::string& GazeboModelSDF::sdf_string() const {
  // @@protoc_insertion_point(field_get:mw.internal.robotics.gazebotransport.GazeboModelSDF.sdf_string)
  return sdf_string_.GetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
 void GazeboModelSDF::set_sdf_string(const ::std::string& value) {
  set_has_sdf_string();
  sdf_string_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), value);
  // @@protoc_insertion_point(field_set:mw.internal.robotics.gazebotransport.GazeboModelSDF.sdf_string)
}
 void GazeboModelSDF::set_sdf_string(const char* value) {
  set_has_sdf_string();
  sdf_string_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::string(value));
  // @@protoc_insertion_point(field_set_char:mw.internal.robotics.gazebotransport.GazeboModelSDF.sdf_string)
}
 void GazeboModelSDF::set_sdf_string(const char* value, size_t size) {
  set_has_sdf_string();
  sdf_string_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(),
      ::std::string(reinterpret_cast<const char*>(value), size));
  // @@protoc_insertion_point(field_set_pointer:mw.internal.robotics.gazebotransport.GazeboModelSDF.sdf_string)
}
 ::std::string* GazeboModelSDF::mutable_sdf_string() {
  set_has_sdf_string();
  // @@protoc_insertion_point(field_mutable:mw.internal.robotics.gazebotransport.GazeboModelSDF.sdf_string)
  return sdf_string_.MutableNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
 ::std::string* GazeboModelSDF::release_sdf_string() {
  // @@protoc_insertion_point(field_release:mw.internal.robotics.gazebotransport.GazeboModelSDF.sdf_string)
  clear_has_sdf_string();
  return sdf_string_.ReleaseNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
 void GazeboModelSDF::set_allocated_sdf_string(::std::string* sdf_string) {
  if (sdf_string != NULL) {
    set_has_sdf_string();
  } else {
    clear_has_sdf_string();
  }
  sdf_string_.SetAllocatedNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), sdf_string);
  // @@protoc_insertion_point(field_set_allocated:mw.internal.robotics.gazebotransport.GazeboModelSDF.sdf_string)
}

#endif  // PROTOBUF_INLINE_NOT_IN_HEADERS

// ===================================================================

#if !defined(_MSC_VER) || _MSC_VER >= 1900
const int GetGazeboModelSDF::kModelNameFieldNumber;
#endif  // !defined(_MSC_VER) || _MSC_VER >= 1900

GetGazeboModelSDF::GetGazeboModelSDF()
  : ::google::protobuf::Message(), _internal_metadata_(NULL) {
  SharedCtor();
  // @@protoc_insertion_point(constructor:mw.internal.robotics.gazebotransport.GetGazeboModelSDF)
}

void GetGazeboModelSDF::InitAsDefaultInstance() {
}

GetGazeboModelSDF::GetGazeboModelSDF(const GetGazeboModelSDF& from)
  : ::google::protobuf::Message(),
    _internal_metadata_(NULL) {
  SharedCtor();
  MergeFrom(from);
  // @@protoc_insertion_point(copy_constructor:mw.internal.robotics.gazebotransport.GetGazeboModelSDF)
}

void GetGazeboModelSDF::SharedCtor() {
  ::google::protobuf::internal::GetEmptyString();
  _cached_size_ = 0;
  model_name_.UnsafeSetDefault(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
  ::memset(_has_bits_, 0, sizeof(_has_bits_));
}

GetGazeboModelSDF::~GetGazeboModelSDF() {
  // @@protoc_insertion_point(destructor:mw.internal.robotics.gazebotransport.GetGazeboModelSDF)
  SharedDtor();
}

void GetGazeboModelSDF::SharedDtor() {
  model_name_.DestroyNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
  if (this != default_instance_) {
  }
}

void GetGazeboModelSDF::SetCachedSize(int size) const {
  GOOGLE_SAFE_CONCURRENT_WRITES_BEGIN();
  _cached_size_ = size;
  GOOGLE_SAFE_CONCURRENT_WRITES_END();
}
const ::google::protobuf::Descriptor* GetGazeboModelSDF::descriptor() {
  protobuf_AssignDescriptorsOnce();
  return GetGazeboModelSDF_descriptor_;
}

const GetGazeboModelSDF& GetGazeboModelSDF::default_instance() {
  if (default_instance_ == NULL) protobuf_AddDesc_mw_2einternal_2erobotics_2egazebotransport_2eCoSimMsgs_2eproto();
  return *default_instance_;
}

GetGazeboModelSDF* GetGazeboModelSDF::default_instance_ = NULL;

GetGazeboModelSDF* GetGazeboModelSDF::New(::google::protobuf::Arena* arena) const {
  GetGazeboModelSDF* n = new GetGazeboModelSDF;
  if (arena != NULL) {
    arena->Own(n);
  }
  return n;
}

void GetGazeboModelSDF::Clear() {
// @@protoc_insertion_point(message_clear_start:mw.internal.robotics.gazebotransport.GetGazeboModelSDF)
  if (has_model_name()) {
    model_name_.ClearToEmptyNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
  }
  ::memset(_has_bits_, 0, sizeof(_has_bits_));
  if (_internal_metadata_.have_unknown_fields()) {
    mutable_unknown_fields()->Clear();
  }
}

bool GetGazeboModelSDF::MergePartialFromCodedStream(
    ::google::protobuf::io::CodedInputStream* input) {
#define DO_(EXPRESSION) if (!GOOGLE_PREDICT_TRUE(EXPRESSION)) goto failure
  ::google::protobuf::uint32 tag;
  // @@protoc_insertion_point(parse_start:mw.internal.robotics.gazebotransport.GetGazeboModelSDF)
  for (;;) {
    ::std::pair< ::google::protobuf::uint32, bool> p = input->ReadTagWithCutoff(127);
    tag = p.first;
    if (!p.second) goto handle_unusual;
    switch (::google::protobuf::internal::WireFormatLite::GetTagFieldNumber(tag)) {
      // required string model_name = 1;
      case 1: {
        if (tag == 10) {
          DO_(::google::protobuf::internal::WireFormatLite::ReadString(
                input, this->mutable_model_name()));
          ::google::protobuf::internal::WireFormat::VerifyUTF8StringNamedField(
            this->model_name().data(), this->model_name().length(),
            ::google::protobuf::internal::WireFormat::PARSE,
            "mw.internal.robotics.gazebotransport.GetGazeboModelSDF.model_name");
        } else {
          goto handle_unusual;
        }
        if (input->ExpectAtEnd()) goto success;
        break;
      }

      default: {
      handle_unusual:
        if (tag == 0 ||
            ::google::protobuf::internal::WireFormatLite::GetTagWireType(tag) ==
            ::google::protobuf::internal::WireFormatLite::WIRETYPE_END_GROUP) {
          goto success;
        }
        DO_(::google::protobuf::internal::WireFormat::SkipField(
              input, tag, mutable_unknown_fields()));
        break;
      }
    }
  }
success:
  // @@protoc_insertion_point(parse_success:mw.internal.robotics.gazebotransport.GetGazeboModelSDF)
  return true;
failure:
  // @@protoc_insertion_point(parse_failure:mw.internal.robotics.gazebotransport.GetGazeboModelSDF)
  return false;
#undef DO_
}

void GetGazeboModelSDF::SerializeWithCachedSizes(
    ::google::protobuf::io::CodedOutputStream* output) const {
  // @@protoc_insertion_point(serialize_start:mw.internal.robotics.gazebotransport.GetGazeboModelSDF)
  // required string model_name = 1;
  if (has_model_name()) {
    ::google::protobuf::internal::WireFormat::VerifyUTF8StringNamedField(
      this->model_name().data(), this->model_name().length(),
      ::google::protobuf::internal::WireFormat::SERIALIZE,
      "mw.internal.robotics.gazebotransport.GetGazeboModelSDF.model_name");
    ::google::protobuf::internal::WireFormatLite::WriteStringMaybeAliased(
      1, this->model_name(), output);
  }

  if (_internal_metadata_.have_unknown_fields()) {
    ::google::protobuf::internal::WireFormat::SerializeUnknownFields(
        unknown_fields(), output);
  }
  // @@protoc_insertion_point(serialize_end:mw.internal.robotics.gazebotransport.GetGazeboModelSDF)
}

::google::protobuf::uint8* GetGazeboModelSDF::InternalSerializeWithCachedSizesToArray(
    bool deterministic, ::google::protobuf::uint8* target) const {
  // @@protoc_insertion_point(serialize_to_array_start:mw.internal.robotics.gazebotransport.GetGazeboModelSDF)
  // required string model_name = 1;
  if (has_model_name()) {
    ::google::protobuf::internal::WireFormat::VerifyUTF8StringNamedField(
      this->model_name().data(), this->model_name().length(),
      ::google::protobuf::internal::WireFormat::SERIALIZE,
      "mw.internal.robotics.gazebotransport.GetGazeboModelSDF.model_name");
    target =
      ::google::protobuf::internal::WireFormatLite::WriteStringToArray(
        1, this->model_name(), target);
  }

  if (_internal_metadata_.have_unknown_fields()) {
    target = ::google::protobuf::internal::WireFormat::SerializeUnknownFieldsToArray(
        unknown_fields(), target);
  }
  // @@protoc_insertion_point(serialize_to_array_end:mw.internal.robotics.gazebotransport.GetGazeboModelSDF)
  return target;
}

int GetGazeboModelSDF::ByteSize() const {
// @@protoc_insertion_point(message_byte_size_start:mw.internal.robotics.gazebotransport.GetGazeboModelSDF)
  int total_size = 0;

  // required string model_name = 1;
  if (has_model_name()) {
    total_size += 1 +
      ::google::protobuf::internal::WireFormatLite::StringSize(
        this->model_name());
  }
  if (_internal_metadata_.have_unknown_fields()) {
    total_size +=
      ::google::protobuf::internal::WireFormat::ComputeUnknownFieldsSize(
        unknown_fields());
  }
  GOOGLE_SAFE_CONCURRENT_WRITES_BEGIN();
  _cached_size_ = total_size;
  GOOGLE_SAFE_CONCURRENT_WRITES_END();
  return total_size;
}

void GetGazeboModelSDF::MergeFrom(const ::google::protobuf::Message& from) {
// @@protoc_insertion_point(generalized_merge_from_start:mw.internal.robotics.gazebotransport.GetGazeboModelSDF)
  if (GOOGLE_PREDICT_FALSE(&from == this)) {
    ::google::protobuf::internal::MergeFromFail(__FILE__, __LINE__);
  }
  const GetGazeboModelSDF* source = 
      ::google::protobuf::internal::DynamicCastToGenerated<const GetGazeboModelSDF>(
          &from);
  if (source == NULL) {
  // @@protoc_insertion_point(generalized_merge_from_cast_fail:mw.internal.robotics.gazebotransport.GetGazeboModelSDF)
    ::google::protobuf::internal::ReflectionOps::Merge(from, this);
  } else {
  // @@protoc_insertion_point(generalized_merge_from_cast_success:mw.internal.robotics.gazebotransport.GetGazeboModelSDF)
    MergeFrom(*source);
  }
}

void GetGazeboModelSDF::MergeFrom(const GetGazeboModelSDF& from) {
// @@protoc_insertion_point(class_specific_merge_from_start:mw.internal.robotics.gazebotransport.GetGazeboModelSDF)
  if (GOOGLE_PREDICT_FALSE(&from == this)) {
    ::google::protobuf::internal::MergeFromFail(__FILE__, __LINE__);
  }
  if (from._has_bits_[0 / 32] & (0xffu << (0 % 32))) {
    if (from.has_model_name()) {
      set_has_model_name();
      model_name_.AssignWithDefault(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), from.model_name_);
    }
  }
  if (from._internal_metadata_.have_unknown_fields()) {
    mutable_unknown_fields()->MergeFrom(from.unknown_fields());
  }
}

void GetGazeboModelSDF::CopyFrom(const ::google::protobuf::Message& from) {
// @@protoc_insertion_point(generalized_copy_from_start:mw.internal.robotics.gazebotransport.GetGazeboModelSDF)
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

void GetGazeboModelSDF::CopyFrom(const GetGazeboModelSDF& from) {
// @@protoc_insertion_point(class_specific_copy_from_start:mw.internal.robotics.gazebotransport.GetGazeboModelSDF)
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

bool GetGazeboModelSDF::IsInitialized() const {
  if ((_has_bits_[0] & 0x00000001) != 0x00000001) return false;

  return true;
}

void GetGazeboModelSDF::Swap(GetGazeboModelSDF* other) {
  if (other == this) return;
  InternalSwap(other);
}
void GetGazeboModelSDF::InternalSwap(GetGazeboModelSDF* other) {
  model_name_.Swap(&other->model_name_);
  std::swap(_has_bits_[0], other->_has_bits_[0]);
  _internal_metadata_.Swap(&other->_internal_metadata_);
  std::swap(_cached_size_, other->_cached_size_);
}

::google::protobuf::Metadata GetGazeboModelSDF::GetMetadata() const {
  protobuf_AssignDescriptorsOnce();
  ::google::protobuf::Metadata metadata;
  metadata.descriptor = GetGazeboModelSDF_descriptor_;
  metadata.reflection = GetGazeboModelSDF_reflection_;
  return metadata;
}

#if PROTOBUF_INLINE_NOT_IN_HEADERS
// GetGazeboModelSDF

// required string model_name = 1;
bool GetGazeboModelSDF::has_model_name() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
void GetGazeboModelSDF::set_has_model_name() {
  _has_bits_[0] |= 0x00000001u;
}
void GetGazeboModelSDF::clear_has_model_name() {
  _has_bits_[0] &= ~0x00000001u;
}
void GetGazeboModelSDF::clear_model_name() {
  model_name_.ClearToEmptyNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
  clear_has_model_name();
}
 const ::std::string& GetGazeboModelSDF::model_name() const {
  // @@protoc_insertion_point(field_get:mw.internal.robotics.gazebotransport.GetGazeboModelSDF.model_name)
  return model_name_.GetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
 void GetGazeboModelSDF::set_model_name(const ::std::string& value) {
  set_has_model_name();
  model_name_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), value);
  // @@protoc_insertion_point(field_set:mw.internal.robotics.gazebotransport.GetGazeboModelSDF.model_name)
}
 void GetGazeboModelSDF::set_model_name(const char* value) {
  set_has_model_name();
  model_name_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::string(value));
  // @@protoc_insertion_point(field_set_char:mw.internal.robotics.gazebotransport.GetGazeboModelSDF.model_name)
}
 void GetGazeboModelSDF::set_model_name(const char* value, size_t size) {
  set_has_model_name();
  model_name_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(),
      ::std::string(reinterpret_cast<const char*>(value), size));
  // @@protoc_insertion_point(field_set_pointer:mw.internal.robotics.gazebotransport.GetGazeboModelSDF.model_name)
}
 ::std::string* GetGazeboModelSDF::mutable_model_name() {
  set_has_model_name();
  // @@protoc_insertion_point(field_mutable:mw.internal.robotics.gazebotransport.GetGazeboModelSDF.model_name)
  return model_name_.MutableNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
 ::std::string* GetGazeboModelSDF::release_model_name() {
  // @@protoc_insertion_point(field_release:mw.internal.robotics.gazebotransport.GetGazeboModelSDF.model_name)
  clear_has_model_name();
  return model_name_.ReleaseNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
 void GetGazeboModelSDF::set_allocated_model_name(::std::string* model_name) {
  if (model_name != NULL) {
    set_has_model_name();
  } else {
    clear_has_model_name();
  }
  model_name_.SetAllocatedNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), model_name);
  // @@protoc_insertion_point(field_set_allocated:mw.internal.robotics.gazebotransport.GetGazeboModelSDF.model_name)
}

#endif  // PROTOBUF_INLINE_NOT_IN_HEADERS

// @@protoc_insertion_point(namespace_scope)

}  // namespace gazebotransport
}  // namespace robotics
}  // namespace internal
}  // namespace mw

// @@protoc_insertion_point(global_scope)
