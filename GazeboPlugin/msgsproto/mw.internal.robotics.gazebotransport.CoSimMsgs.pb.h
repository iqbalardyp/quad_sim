// Generated by the protocol buffer compiler.  DO NOT EDIT!
// source: mw.internal.robotics.gazebotransport.CoSimMsgs.proto

#ifndef PROTOBUF_mw_2einternal_2erobotics_2egazebotransport_2eCoSimMsgs_2eproto__INCLUDED
#define PROTOBUF_mw_2einternal_2erobotics_2egazebotransport_2eCoSimMsgs_2eproto__INCLUDED

#include <string>

#include <google/protobuf/stubs/common.h>

#if GOOGLE_PROTOBUF_VERSION < 3000000
#error This file was generated by a newer version of protoc which is
#error incompatible with your Protocol Buffer headers.  Please update
#error your headers.
#endif
#if 3000000 < GOOGLE_PROTOBUF_MIN_PROTOC_VERSION
#error This file was generated by an older version of protoc which is
#error incompatible with your Protocol Buffer headers.  Please
#error regenerate this file with a newer version of protoc.
#endif

#include <google/protobuf/arena.h>
#include <google/protobuf/arenastring.h>
#include <google/protobuf/generated_message_util.h>
#include <google/protobuf/metadata.h>
#include <google/protobuf/message.h>
#include <google/protobuf/repeated_field.h>
#include <google/protobuf/extension_set.h>
#include <google/protobuf/generated_enum_reflection.h>
#include <google/protobuf/unknown_field_set.h>
// @@protoc_insertion_point(includes)

namespace mw {
namespace internal {
namespace robotics {
namespace gazebotransport {

// Internal implementation detail -- do not call these.
void protobuf_AddDesc_mw_2einternal_2erobotics_2egazebotransport_2eCoSimMsgs_2eproto();
void protobuf_AssignDesc_mw_2einternal_2erobotics_2egazebotransport_2eCoSimMsgs_2eproto();
void protobuf_ShutdownFile_mw_2einternal_2erobotics_2egazebotransport_2eCoSimMsgs_2eproto();

class ApplyJointTorque;
class ApplyLinkWrench;
class Axis;
class CustomMessageSupport;
class GazeboModelSDF;
class Gazebomodel;
class GetGazeboModelParam;
class GetGazeboModelSDF;
class GetGroundTruthWorldPose;
class GetJointState;
class GetLinkState;
class GetModelInfo;
class GetPose;
class GetTopicList;
class Image;
class ImuData;
class InitCustomPublisher;
class InitCustomSubscriber;
class JointState;
class LaserData;
class LinkState;
class ML_Axis;
class ML_Cord;
class ML_Inertial;
class ML_Joints;
class ML_Links;
class ML_Point;
class ML_Pose;
class ML_Quat;
class MaxStepSize;
class ModelInfo;
class ModelInfo_JOINTS;
class ModelInfo_LINKS;
class ModelInfo_Model;
class Packet;
class PacketHeader;
class PluginVersion;
class Point;
class Pose;
class Quaternion;
class RequestCoSim;
class RequestCustomMessageSupport;
class RequestImage;
class RequestImu;
class RequestLaser;
class ResetSimulation;
class SetJointPosition;
class SetJointVelocity;
class SetLinkAngularVelocity;
class SetLinkLinearVelocity;
class SetLinkWorldPose;
class StepSimulation;
class StopCoSim;
class StopSimulation;
class SubscribeImage;
class SubscribeImu;
class SubscribeLaser;
class Time;
class TopicList;
class TopicList_TopicInfo;

enum PacketHeader_MsgID {
  PacketHeader_MsgID_STATUS = 0,
  PacketHeader_MsgID_STEP_SIMULATION = 1,
  PacketHeader_MsgID_RESET_SIMULATION = 2,
  PacketHeader_MsgID_IMAGE = 3,
  PacketHeader_MsgID_REQUEST_IMAGE = 4,
  PacketHeader_MsgID_REQUEST_COSIM = 5,
  PacketHeader_MsgID_STOP_COSIM = 6,
  PacketHeader_MsgID_GET_GROUND_TRUTH_WORLD_POSE = 7,
  PacketHeader_MsgID_POSE = 8,
  PacketHeader_MsgID_STOP_SIMULATION = 9,
  PacketHeader_MsgID_LASER_DATA = 10,
  PacketHeader_MsgID_REQUEST_LASER = 11,
  PacketHeader_MsgID_IMU_DATA = 12,
  PacketHeader_MsgID_REQUEST_IMU = 13,
  PacketHeader_MsgID_SUBSCRIBE_IMAGE = 14,
  PacketHeader_MsgID_SUBSCRIBE_LASER = 15,
  PacketHeader_MsgID_SUBSCRIBE_IMU = 16,
  PacketHeader_MsgID_APPLY_JOINT_TORQUE = 17,
  PacketHeader_MsgID_GET_POSE = 18,
  PacketHeader_MsgID_GET_TOPIC_LIST = 19,
  PacketHeader_MsgID_TOPIC_LIST = 20,
  PacketHeader_MsgID_GET_MODEL_INFO = 21,
  PacketHeader_MsgID_MODEL_INFO = 22,
  PacketHeader_MsgID_APPLY_LINK_WRENCH = 23,
  PacketHeader_MsgID_MAX_STEP_SIZE = 24,
  PacketHeader_MsgID_CUSTOM_MESSAGE_SUBSCRIBER = 25,
  PacketHeader_MsgID_CUSTOM_MESSAGE_PUBLISHER = 26,
  PacketHeader_MsgID_INIT_CUSTOM_MESSAGE_PUBLISHER = 27,
  PacketHeader_MsgID_INIT_CUSTOM_MESSAGE_SUBSCRIBER = 28,
  PacketHeader_MsgID_SET_JOINT_POSITION = 29,
  PacketHeader_MsgID_SET_JOINT_VELOCITY = 30,
  PacketHeader_MsgID_GET_JOINT_STATE = 31,
  PacketHeader_MsgID_JOINT_STATE = 32,
  PacketHeader_MsgID_SET_LINK_WORLD_POSE = 33,
  PacketHeader_MsgID_SET_LINK_LINEAR_VELOCITY = 34,
  PacketHeader_MsgID_SET_LINK_ANGULAR_VELOCITY = 35,
  PacketHeader_MsgID_GET_LINK_STATE = 36,
  PacketHeader_MsgID_LINK_STATE = 37,
  PacketHeader_MsgID_GAZEBO_MODEL = 38,
  PacketHeader_MsgID_SET_GAZEBO_MODEL_PARAM = 39,
  PacketHeader_MsgID_GET_GAZEBO_MODEL_PARAM = 40,
  PacketHeader_MsgID_GAZEBO_MODEL_SDF = 41,
  PacketHeader_MsgID_GET_GAZEBO_MODEL_SDF = 42
};
bool PacketHeader_MsgID_IsValid(int value);
const PacketHeader_MsgID PacketHeader_MsgID_MsgID_MIN = PacketHeader_MsgID_STATUS;
const PacketHeader_MsgID PacketHeader_MsgID_MsgID_MAX = PacketHeader_MsgID_GET_GAZEBO_MODEL_SDF;
const int PacketHeader_MsgID_MsgID_ARRAYSIZE = PacketHeader_MsgID_MsgID_MAX + 1;

const ::google::protobuf::EnumDescriptor* PacketHeader_MsgID_descriptor();
inline const ::std::string& PacketHeader_MsgID_Name(PacketHeader_MsgID value) {
  return ::google::protobuf::internal::NameOfEnum(
    PacketHeader_MsgID_descriptor(), value);
}
inline bool PacketHeader_MsgID_Parse(
    const ::std::string& name, PacketHeader_MsgID* value) {
  return ::google::protobuf::internal::ParseNamedEnum<PacketHeader_MsgID>(
    PacketHeader_MsgID_descriptor(), name, value);
}
enum Packet_CoSimError {
  Packet_CoSimError_NONE = 0,
  Packet_CoSimError_STEP_FAILED = 1,
  Packet_CoSimError_MSG_INVALID = 2,
  Packet_CoSimError_SOCKET_FAILED = 3,
  Packet_CoSimError_RESET_FAILED = 4,
  Packet_CoSimError_COSIM_FAILED = 5,
  Packet_CoSimError_STOP_COSIM_FAILED = 6,
  Packet_CoSimError_GET_GROUND_TRUTH_WORLD_POSE_FAILED = 7,
  Packet_CoSimError_RESET_TIME_SCENE_FAILED = 8,
  Packet_CoSimError_RESET_TIME_FAILED = 9,
  Packet_CoSimError_STOP_FAILED = 10,
  Packet_CoSimError_FORCE_TYPE_INVALID = 11,
  Packet_CoSimError_MODEL_NAME_INVALID = 12,
  Packet_CoSimError_LINK_NAME_INVALID = 13,
  Packet_CoSimError_JOINT_NAME_INVALID = 14,
  Packet_CoSimError_TOPIC_NAME_INVALID = 15,
  Packet_CoSimError_TORQUE_TYPE_INVALID = 16,
  Packet_CoSimError_MAX_STEP_SIZE_ERROR = 17,
  Packet_CoSimError_CUSTOM_MESSAGE_INVALID = 18,
  Packet_CoSimError_MESSAGE_TYPE_INVALID = 19,
  Packet_CoSimError_JOINT_AXIS_NONE = 20,
  Packet_CoSimError_INVALID_JOINT_AXIS = 21
};
bool Packet_CoSimError_IsValid(int value);
const Packet_CoSimError Packet_CoSimError_CoSimError_MIN = Packet_CoSimError_NONE;
const Packet_CoSimError Packet_CoSimError_CoSimError_MAX = Packet_CoSimError_INVALID_JOINT_AXIS;
const int Packet_CoSimError_CoSimError_ARRAYSIZE = Packet_CoSimError_CoSimError_MAX + 1;

const ::google::protobuf::EnumDescriptor* Packet_CoSimError_descriptor();
inline const ::std::string& Packet_CoSimError_Name(Packet_CoSimError value) {
  return ::google::protobuf::internal::NameOfEnum(
    Packet_CoSimError_descriptor(), value);
}
inline bool Packet_CoSimError_Parse(
    const ::std::string& name, Packet_CoSimError* value) {
  return ::google::protobuf::internal::ParseNamedEnum<Packet_CoSimError>(
    Packet_CoSimError_descriptor(), name, value);
}
enum ResetSimulation_ResetBehavior {
  ResetSimulation_ResetBehavior_RESET_TIME = 0,
  ResetSimulation_ResetBehavior_RESET_TIME_AND_SCENE = 1
};
bool ResetSimulation_ResetBehavior_IsValid(int value);
const ResetSimulation_ResetBehavior ResetSimulation_ResetBehavior_ResetBehavior_MIN = ResetSimulation_ResetBehavior_RESET_TIME;
const ResetSimulation_ResetBehavior ResetSimulation_ResetBehavior_ResetBehavior_MAX = ResetSimulation_ResetBehavior_RESET_TIME_AND_SCENE;
const int ResetSimulation_ResetBehavior_ResetBehavior_ARRAYSIZE = ResetSimulation_ResetBehavior_ResetBehavior_MAX + 1;

const ::google::protobuf::EnumDescriptor* ResetSimulation_ResetBehavior_descriptor();
inline const ::std::string& ResetSimulation_ResetBehavior_Name(ResetSimulation_ResetBehavior value) {
  return ::google::protobuf::internal::NameOfEnum(
    ResetSimulation_ResetBehavior_descriptor(), value);
}
inline bool ResetSimulation_ResetBehavior_Parse(
    const ::std::string& name, ResetSimulation_ResetBehavior* value) {
  return ::google::protobuf::internal::ParseNamedEnum<ResetSimulation_ResetBehavior>(
    ResetSimulation_ResetBehavior_descriptor(), name, value);
}
enum MaxStepSize_TYPE {
  MaxStepSize_TYPE_SET_STEP_SIZE = 0,
  MaxStepSize_TYPE_GET_STEP_SIZE = 1
};
bool MaxStepSize_TYPE_IsValid(int value);
const MaxStepSize_TYPE MaxStepSize_TYPE_TYPE_MIN = MaxStepSize_TYPE_SET_STEP_SIZE;
const MaxStepSize_TYPE MaxStepSize_TYPE_TYPE_MAX = MaxStepSize_TYPE_GET_STEP_SIZE;
const int MaxStepSize_TYPE_TYPE_ARRAYSIZE = MaxStepSize_TYPE_TYPE_MAX + 1;

const ::google::protobuf::EnumDescriptor* MaxStepSize_TYPE_descriptor();
inline const ::std::string& MaxStepSize_TYPE_Name(MaxStepSize_TYPE value) {
  return ::google::protobuf::internal::NameOfEnum(
    MaxStepSize_TYPE_descriptor(), value);
}
inline bool MaxStepSize_TYPE_Parse(
    const ::std::string& name, MaxStepSize_TYPE* value) {
  return ::google::protobuf::internal::ParseNamedEnum<MaxStepSize_TYPE>(
    MaxStepSize_TYPE_descriptor(), name, value);
}
enum JointState_Joint_Type {
  JointState_Joint_Type_REVOLUTE = 1,
  JointState_Joint_Type_REVOLUTE2 = 2,
  JointState_Joint_Type_PRISMATIC = 3,
  JointState_Joint_Type_UNIVERSAL = 4,
  JointState_Joint_Type_BALL = 5,
  JointState_Joint_Type_SCREW = 6,
  JointState_Joint_Type_GEARBOX = 7,
  JointState_Joint_Type_FIXED = 8
};
bool JointState_Joint_Type_IsValid(int value);
const JointState_Joint_Type JointState_Joint_Type_Joint_Type_MIN = JointState_Joint_Type_REVOLUTE;
const JointState_Joint_Type JointState_Joint_Type_Joint_Type_MAX = JointState_Joint_Type_FIXED;
const int JointState_Joint_Type_Joint_Type_ARRAYSIZE = JointState_Joint_Type_Joint_Type_MAX + 1;

const ::google::protobuf::EnumDescriptor* JointState_Joint_Type_descriptor();
inline const ::std::string& JointState_Joint_Type_Name(JointState_Joint_Type value) {
  return ::google::protobuf::internal::NameOfEnum(
    JointState_Joint_Type_descriptor(), value);
}
inline bool JointState_Joint_Type_Parse(
    const ::std::string& name, JointState_Joint_Type* value) {
  return ::google::protobuf::internal::ParseNamedEnum<JointState_Joint_Type>(
    JointState_Joint_Type_descriptor(), name, value);
}
// ===================================================================

class PluginVersion : public ::google::protobuf::Message /* @@protoc_insertion_point(class_definition:mw.internal.robotics.gazebotransport.PluginVersion) */ {
 public:
  PluginVersion();
  virtual ~PluginVersion();

  PluginVersion(const PluginVersion& from);

  inline PluginVersion& operator=(const PluginVersion& from) {
    CopyFrom(from);
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _internal_metadata_.unknown_fields();
  }

  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return _internal_metadata_.mutable_unknown_fields();
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const PluginVersion& default_instance();

  void Swap(PluginVersion* other);

  // implements Message ----------------------------------------------

  inline PluginVersion* New() const { return New(NULL); }

  PluginVersion* New(::google::protobuf::Arena* arena) const;
  void CopyFrom(const ::google::protobuf::Message& from);
  void MergeFrom(const ::google::protobuf::Message& from);
  void CopyFrom(const PluginVersion& from);
  void MergeFrom(const PluginVersion& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  ::google::protobuf::uint8* InternalSerializeWithCachedSizesToArray(
      bool deterministic, ::google::protobuf::uint8* output) const;
  ::google::protobuf::uint8* SerializeWithCachedSizesToArray(::google::protobuf::uint8* output) const {
    return InternalSerializeWithCachedSizesToArray(false, output);
  }
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  void InternalSwap(PluginVersion* other);
  private:
  inline ::google::protobuf::Arena* GetArenaNoVirtual() const {
    return _internal_metadata_.arena();
  }
  inline void* MaybeArenaPtr() const {
    return _internal_metadata_.raw_arena_ptr();
  }
  public:

  ::google::protobuf::Metadata GetMetadata() const;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // required string version = 1 [default = "R2021b"];
  bool has_version() const;
  void clear_version();
  static const int kVersionFieldNumber = 1;
  const ::std::string& version() const;
  void set_version(const ::std::string& value);
  void set_version(const char* value);
  void set_version(const char* value, size_t size);
  ::std::string* mutable_version();
  ::std::string* release_version();
  void set_allocated_version(::std::string* version);

  // @@protoc_insertion_point(class_scope:mw.internal.robotics.gazebotransport.PluginVersion)
 private:
  inline void set_has_version();
  inline void clear_has_version();

  ::google::protobuf::internal::InternalMetadataWithArena _internal_metadata_;
  ::google::protobuf::uint32 _has_bits_[1];
  mutable int _cached_size_;
  static ::std::string* _default_version_;
  ::google::protobuf::internal::ArenaStringPtr version_;
  friend void  protobuf_AddDesc_mw_2einternal_2erobotics_2egazebotransport_2eCoSimMsgs_2eproto();
  friend void protobuf_AssignDesc_mw_2einternal_2erobotics_2egazebotransport_2eCoSimMsgs_2eproto();
  friend void protobuf_ShutdownFile_mw_2einternal_2erobotics_2egazebotransport_2eCoSimMsgs_2eproto();

  void InitAsDefaultInstance();
  static PluginVersion* default_instance_;
};
// -------------------------------------------------------------------

class Time : public ::google::protobuf::Message /* @@protoc_insertion_point(class_definition:mw.internal.robotics.gazebotransport.Time) */ {
 public:
  Time();
  virtual ~Time();

  Time(const Time& from);

  inline Time& operator=(const Time& from) {
    CopyFrom(from);
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _internal_metadata_.unknown_fields();
  }

  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return _internal_metadata_.mutable_unknown_fields();
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const Time& default_instance();

  void Swap(Time* other);

  // implements Message ----------------------------------------------

  inline Time* New() const { return New(NULL); }

  Time* New(::google::protobuf::Arena* arena) const;
  void CopyFrom(const ::google::protobuf::Message& from);
  void MergeFrom(const ::google::protobuf::Message& from);
  void CopyFrom(const Time& from);
  void MergeFrom(const Time& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  ::google::protobuf::uint8* InternalSerializeWithCachedSizesToArray(
      bool deterministic, ::google::protobuf::uint8* output) const;
  ::google::protobuf::uint8* SerializeWithCachedSizesToArray(::google::protobuf::uint8* output) const {
    return InternalSerializeWithCachedSizesToArray(false, output);
  }
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  void InternalSwap(Time* other);
  private:
  inline ::google::protobuf::Arena* GetArenaNoVirtual() const {
    return _internal_metadata_.arena();
  }
  inline void* MaybeArenaPtr() const {
    return _internal_metadata_.raw_arena_ptr();
  }
  public:

  ::google::protobuf::Metadata GetMetadata() const;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // required uint64 seconds = 1;
  bool has_seconds() const;
  void clear_seconds();
  static const int kSecondsFieldNumber = 1;
  ::google::protobuf::uint64 seconds() const;
  void set_seconds(::google::protobuf::uint64 value);

  // required uint64 nano_seconds = 2;
  bool has_nano_seconds() const;
  void clear_nano_seconds();
  static const int kNanoSecondsFieldNumber = 2;
  ::google::protobuf::uint64 nano_seconds() const;
  void set_nano_seconds(::google::protobuf::uint64 value);

  // @@protoc_insertion_point(class_scope:mw.internal.robotics.gazebotransport.Time)
 private:
  inline void set_has_seconds();
  inline void clear_has_seconds();
  inline void set_has_nano_seconds();
  inline void clear_has_nano_seconds();

  // helper for ByteSize()
  int RequiredFieldsByteSizeFallback() const;

  ::google::protobuf::internal::InternalMetadataWithArena _internal_metadata_;
  ::google::protobuf::uint32 _has_bits_[1];
  mutable int _cached_size_;
  ::google::protobuf::uint64 seconds_;
  ::google::protobuf::uint64 nano_seconds_;
  friend void  protobuf_AddDesc_mw_2einternal_2erobotics_2egazebotransport_2eCoSimMsgs_2eproto();
  friend void protobuf_AssignDesc_mw_2einternal_2erobotics_2egazebotransport_2eCoSimMsgs_2eproto();
  friend void protobuf_ShutdownFile_mw_2einternal_2erobotics_2egazebotransport_2eCoSimMsgs_2eproto();

  void InitAsDefaultInstance();
  static Time* default_instance_;
};
// -------------------------------------------------------------------

class PacketHeader : public ::google::protobuf::Message /* @@protoc_insertion_point(class_definition:mw.internal.robotics.gazebotransport.PacketHeader) */ {
 public:
  PacketHeader();
  virtual ~PacketHeader();

  PacketHeader(const PacketHeader& from);

  inline PacketHeader& operator=(const PacketHeader& from) {
    CopyFrom(from);
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _internal_metadata_.unknown_fields();
  }

  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return _internal_metadata_.mutable_unknown_fields();
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const PacketHeader& default_instance();

  void Swap(PacketHeader* other);

  // implements Message ----------------------------------------------

  inline PacketHeader* New() const { return New(NULL); }

  PacketHeader* New(::google::protobuf::Arena* arena) const;
  void CopyFrom(const ::google::protobuf::Message& from);
  void MergeFrom(const ::google::protobuf::Message& from);
  void CopyFrom(const PacketHeader& from);
  void MergeFrom(const PacketHeader& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  ::google::protobuf::uint8* InternalSerializeWithCachedSizesToArray(
      bool deterministic, ::google::protobuf::uint8* output) const;
  ::google::protobuf::uint8* SerializeWithCachedSizesToArray(::google::protobuf::uint8* output) const {
    return InternalSerializeWithCachedSizesToArray(false, output);
  }
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  void InternalSwap(PacketHeader* other);
  private:
  inline ::google::protobuf::Arena* GetArenaNoVirtual() const {
    return _internal_metadata_.arena();
  }
  inline void* MaybeArenaPtr() const {
    return _internal_metadata_.raw_arena_ptr();
  }
  public:

  ::google::protobuf::Metadata GetMetadata() const;

  // nested types ----------------------------------------------------

  typedef PacketHeader_MsgID MsgID;
  static const MsgID STATUS =
    PacketHeader_MsgID_STATUS;
  static const MsgID STEP_SIMULATION =
    PacketHeader_MsgID_STEP_SIMULATION;
  static const MsgID RESET_SIMULATION =
    PacketHeader_MsgID_RESET_SIMULATION;
  static const MsgID IMAGE =
    PacketHeader_MsgID_IMAGE;
  static const MsgID REQUEST_IMAGE =
    PacketHeader_MsgID_REQUEST_IMAGE;
  static const MsgID REQUEST_COSIM =
    PacketHeader_MsgID_REQUEST_COSIM;
  static const MsgID STOP_COSIM =
    PacketHeader_MsgID_STOP_COSIM;
  static const MsgID GET_GROUND_TRUTH_WORLD_POSE =
    PacketHeader_MsgID_GET_GROUND_TRUTH_WORLD_POSE;
  static const MsgID POSE =
    PacketHeader_MsgID_POSE;
  static const MsgID STOP_SIMULATION =
    PacketHeader_MsgID_STOP_SIMULATION;
  static const MsgID LASER_DATA =
    PacketHeader_MsgID_LASER_DATA;
  static const MsgID REQUEST_LASER =
    PacketHeader_MsgID_REQUEST_LASER;
  static const MsgID IMU_DATA =
    PacketHeader_MsgID_IMU_DATA;
  static const MsgID REQUEST_IMU =
    PacketHeader_MsgID_REQUEST_IMU;
  static const MsgID SUBSCRIBE_IMAGE =
    PacketHeader_MsgID_SUBSCRIBE_IMAGE;
  static const MsgID SUBSCRIBE_LASER =
    PacketHeader_MsgID_SUBSCRIBE_LASER;
  static const MsgID SUBSCRIBE_IMU =
    PacketHeader_MsgID_SUBSCRIBE_IMU;
  static const MsgID APPLY_JOINT_TORQUE =
    PacketHeader_MsgID_APPLY_JOINT_TORQUE;
  static const MsgID GET_POSE =
    PacketHeader_MsgID_GET_POSE;
  static const MsgID GET_TOPIC_LIST =
    PacketHeader_MsgID_GET_TOPIC_LIST;
  static const MsgID TOPIC_LIST =
    PacketHeader_MsgID_TOPIC_LIST;
  static const MsgID GET_MODEL_INFO =
    PacketHeader_MsgID_GET_MODEL_INFO;
  static const MsgID MODEL_INFO =
    PacketHeader_MsgID_MODEL_INFO;
  static const MsgID APPLY_LINK_WRENCH =
    PacketHeader_MsgID_APPLY_LINK_WRENCH;
  static const MsgID MAX_STEP_SIZE =
    PacketHeader_MsgID_MAX_STEP_SIZE;
  static const MsgID CUSTOM_MESSAGE_SUBSCRIBER =
    PacketHeader_MsgID_CUSTOM_MESSAGE_SUBSCRIBER;
  static const MsgID CUSTOM_MESSAGE_PUBLISHER =
    PacketHeader_MsgID_CUSTOM_MESSAGE_PUBLISHER;
  static const MsgID INIT_CUSTOM_MESSAGE_PUBLISHER =
    PacketHeader_MsgID_INIT_CUSTOM_MESSAGE_PUBLISHER;
  static const MsgID INIT_CUSTOM_MESSAGE_SUBSCRIBER =
    PacketHeader_MsgID_INIT_CUSTOM_MESSAGE_SUBSCRIBER;
  static const MsgID SET_JOINT_POSITION =
    PacketHeader_MsgID_SET_JOINT_POSITION;
  static const MsgID SET_JOINT_VELOCITY =
    PacketHeader_MsgID_SET_JOINT_VELOCITY;
  static const MsgID GET_JOINT_STATE =
    PacketHeader_MsgID_GET_JOINT_STATE;
  static const MsgID JOINT_STATE =
    PacketHeader_MsgID_JOINT_STATE;
  static const MsgID SET_LINK_WORLD_POSE =
    PacketHeader_MsgID_SET_LINK_WORLD_POSE;
  static const MsgID SET_LINK_LINEAR_VELOCITY =
    PacketHeader_MsgID_SET_LINK_LINEAR_VELOCITY;
  static const MsgID SET_LINK_ANGULAR_VELOCITY =
    PacketHeader_MsgID_SET_LINK_ANGULAR_VELOCITY;
  static const MsgID GET_LINK_STATE =
    PacketHeader_MsgID_GET_LINK_STATE;
  static const MsgID LINK_STATE =
    PacketHeader_MsgID_LINK_STATE;
  static const MsgID GAZEBO_MODEL =
    PacketHeader_MsgID_GAZEBO_MODEL;
  static const MsgID SET_GAZEBO_MODEL_PARAM =
    PacketHeader_MsgID_SET_GAZEBO_MODEL_PARAM;
  static const MsgID GET_GAZEBO_MODEL_PARAM =
    PacketHeader_MsgID_GET_GAZEBO_MODEL_PARAM;
  static const MsgID GAZEBO_MODEL_SDF =
    PacketHeader_MsgID_GAZEBO_MODEL_SDF;
  static const MsgID GET_GAZEBO_MODEL_SDF =
    PacketHeader_MsgID_GET_GAZEBO_MODEL_SDF;
  static inline bool MsgID_IsValid(int value) {
    return PacketHeader_MsgID_IsValid(value);
  }
  static const MsgID MsgID_MIN =
    PacketHeader_MsgID_MsgID_MIN;
  static const MsgID MsgID_MAX =
    PacketHeader_MsgID_MsgID_MAX;
  static const int MsgID_ARRAYSIZE =
    PacketHeader_MsgID_MsgID_ARRAYSIZE;
  static inline const ::google::protobuf::EnumDescriptor*
  MsgID_descriptor() {
    return PacketHeader_MsgID_descriptor();
  }
  static inline const ::std::string& MsgID_Name(MsgID value) {
    return PacketHeader_MsgID_Name(value);
  }
  static inline bool MsgID_Parse(const ::std::string& name,
      MsgID* value) {
    return PacketHeader_MsgID_Parse(name, value);
  }

  // accessors -------------------------------------------------------

  // required .mw.internal.robotics.gazebotransport.PacketHeader.MsgID id = 1;
  bool has_id() const;
  void clear_id();
  static const int kIdFieldNumber = 1;
  ::mw::internal::robotics::gazebotransport::PacketHeader_MsgID id() const;
  void set_id(::mw::internal::robotics::gazebotransport::PacketHeader_MsgID value);

  // required .mw.internal.robotics.gazebotransport.Time time_stamp = 2;
  bool has_time_stamp() const;
  void clear_time_stamp();
  static const int kTimeStampFieldNumber = 2;
  const ::mw::internal::robotics::gazebotransport::Time& time_stamp() const;
  ::mw::internal::robotics::gazebotransport::Time* mutable_time_stamp();
  ::mw::internal::robotics::gazebotransport::Time* release_time_stamp();
  void set_allocated_time_stamp(::mw::internal::robotics::gazebotransport::Time* time_stamp);

  // @@protoc_insertion_point(class_scope:mw.internal.robotics.gazebotransport.PacketHeader)
 private:
  inline void set_has_id();
  inline void clear_has_id();
  inline void set_has_time_stamp();
  inline void clear_has_time_stamp();

  // helper for ByteSize()
  int RequiredFieldsByteSizeFallback() const;

  ::google::protobuf::internal::InternalMetadataWithArena _internal_metadata_;
  ::google::protobuf::uint32 _has_bits_[1];
  mutable int _cached_size_;
  ::mw::internal::robotics::gazebotransport::Time* time_stamp_;
  int id_;
  friend void  protobuf_AddDesc_mw_2einternal_2erobotics_2egazebotransport_2eCoSimMsgs_2eproto();
  friend void protobuf_AssignDesc_mw_2einternal_2erobotics_2egazebotransport_2eCoSimMsgs_2eproto();
  friend void protobuf_ShutdownFile_mw_2einternal_2erobotics_2egazebotransport_2eCoSimMsgs_2eproto();

  void InitAsDefaultInstance();
  static PacketHeader* default_instance_;
};
// -------------------------------------------------------------------

class Packet : public ::google::protobuf::Message /* @@protoc_insertion_point(class_definition:mw.internal.robotics.gazebotransport.Packet) */ {
 public:
  Packet();
  virtual ~Packet();

  Packet(const Packet& from);

  inline Packet& operator=(const Packet& from) {
    CopyFrom(from);
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _internal_metadata_.unknown_fields();
  }

  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return _internal_metadata_.mutable_unknown_fields();
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const Packet& default_instance();

  enum PayloadCase {
    kStatus = 2,
    kStepSimulation = 3,
    kResetSimulation = 4,
    kImage = 5,
    kRequestImage = 6,
    kRequestCosim = 7,
    kStopCosim = 8,
    kGetGroundTruthWorldPose = 9,
    kPose = 10,
    kStopSimulation = 11,
    kLaserData = 12,
    kRequestLaser = 13,
    kImuData = 14,
    kRequestImu = 15,
    kSubscribeImage = 16,
    kSubscribeLaser = 17,
    kSubscribeImu = 18,
    kApplyJointTorque = 19,
    kGetPose = 20,
    kGetTopicList = 21,
    kTopicList = 22,
    kGetModelInfo = 23,
    kModelInfo = 24,
    kApplyLinkWrench = 25,
    kMaxStepSize = 26,
    kCustomMessageSupport = 27,
    kInitCustomPublisher = 28,
    kInitCustomSubscriber = 29,
    kRequestCustomMessageSupport = 30,
    kSetJointPosition = 31,
    kSetJointVelocity = 32,
    kGetJointState = 33,
    kJointState = 34,
    kSetLinkWorldPose = 35,
    kSetLinkLinearVelocity = 36,
    kSetLinkAngularVelocity = 37,
    kGetLinkState = 38,
    kLinkState = 39,
    kGazeboModel = 40,
    kGetGazeboModelParam = 41,
    kGazeboModelSdf = 42,
    kGetGazeboModelSdf = 43,
    PAYLOAD_NOT_SET = 0,
  };

  void Swap(Packet* other);

  // implements Message ----------------------------------------------

  inline Packet* New() const { return New(NULL); }

  Packet* New(::google::protobuf::Arena* arena) const;
  void CopyFrom(const ::google::protobuf::Message& from);
  void MergeFrom(const ::google::protobuf::Message& from);
  void CopyFrom(const Packet& from);
  void MergeFrom(const Packet& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  ::google::protobuf::uint8* InternalSerializeWithCachedSizesToArray(
      bool deterministic, ::google::protobuf::uint8* output) const;
  ::google::protobuf::uint8* SerializeWithCachedSizesToArray(::google::protobuf::uint8* output) const {
    return InternalSerializeWithCachedSizesToArray(false, output);
  }
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  void InternalSwap(Packet* other);
  private:
  inline ::google::protobuf::Arena* GetArenaNoVirtual() const {
    return _internal_metadata_.arena();
  }
  inline void* MaybeArenaPtr() const {
    return _internal_metadata_.raw_arena_ptr();
  }
  public:

  ::google::protobuf::Metadata GetMetadata() const;

  // nested types ----------------------------------------------------

  typedef Packet_CoSimError CoSimError;
  static const CoSimError NONE =
    Packet_CoSimError_NONE;
  static const CoSimError STEP_FAILED =
    Packet_CoSimError_STEP_FAILED;
  static const CoSimError MSG_INVALID =
    Packet_CoSimError_MSG_INVALID;
  static const CoSimError SOCKET_FAILED =
    Packet_CoSimError_SOCKET_FAILED;
  static const CoSimError RESET_FAILED =
    Packet_CoSimError_RESET_FAILED;
  static const CoSimError COSIM_FAILED =
    Packet_CoSimError_COSIM_FAILED;
  static const CoSimError STOP_COSIM_FAILED =
    Packet_CoSimError_STOP_COSIM_FAILED;
  static const CoSimError GET_GROUND_TRUTH_WORLD_POSE_FAILED =
    Packet_CoSimError_GET_GROUND_TRUTH_WORLD_POSE_FAILED;
  static const CoSimError RESET_TIME_SCENE_FAILED =
    Packet_CoSimError_RESET_TIME_SCENE_FAILED;
  static const CoSimError RESET_TIME_FAILED =
    Packet_CoSimError_RESET_TIME_FAILED;
  static const CoSimError STOP_FAILED =
    Packet_CoSimError_STOP_FAILED;
  static const CoSimError FORCE_TYPE_INVALID =
    Packet_CoSimError_FORCE_TYPE_INVALID;
  static const CoSimError MODEL_NAME_INVALID =
    Packet_CoSimError_MODEL_NAME_INVALID;
  static const CoSimError LINK_NAME_INVALID =
    Packet_CoSimError_LINK_NAME_INVALID;
  static const CoSimError JOINT_NAME_INVALID =
    Packet_CoSimError_JOINT_NAME_INVALID;
  static const CoSimError TOPIC_NAME_INVALID =
    Packet_CoSimError_TOPIC_NAME_INVALID;
  static const CoSimError TORQUE_TYPE_INVALID =
    Packet_CoSimError_TORQUE_TYPE_INVALID;
  static const CoSimError MAX_STEP_SIZE_ERROR =
    Packet_CoSimError_MAX_STEP_SIZE_ERROR;
  static const CoSimError CUSTOM_MESSAGE_INVALID =
    Packet_CoSimError_CUSTOM_MESSAGE_INVALID;
  static const CoSimError MESSAGE_TYPE_INVALID =
    Packet_CoSimError_MESSAGE_TYPE_INVALID;
  static const CoSimError JOINT_AXIS_NONE =
    Packet_CoSimError_JOINT_AXIS_NONE;
  static const CoSimError INVALID_JOINT_AXIS =
    Packet_CoSimError_INVALID_JOINT_AXIS;
  static inline bool CoSimError_IsValid(int value) {
    return Packet_CoSimError_IsValid(value);
  }
  static const CoSimError CoSimError_MIN =
    Packet_CoSimError_CoSimError_MIN;
  static const CoSimError CoSimError_MAX =
    Packet_CoSimError_CoSimError_MAX;
  static const int CoSimError_ARRAYSIZE =
    Packet_CoSimError_CoSimError_ARRAYSIZE;
  static inline const ::google::protobuf::EnumDescriptor*
  CoSimError_descriptor() {
    return Packet_CoSimError_descriptor();
  }
  static inline const ::std::string& CoSimError_Name(CoSimError value) {
    return Packet_CoSimError_Name(value);
  }
  static inline bool CoSimError_Parse(const ::std::string& name,
      CoSimError* value) {
    return Packet_CoSimError_Parse(name, value);
  }

  // accessors -------------------------------------------------------

  // required .mw.internal.robotics.gazebotransport.PacketHeader header = 1;
  bool has_header() const;
  void clear_header();
  static const int kHeaderFieldNumber = 1;
  const ::mw::internal::robotics::gazebotransport::PacketHeader& header() const;
  ::mw::internal::robotics::gazebotransport::PacketHeader* mutable_header();
  ::mw::internal::robotics::gazebotransport::PacketHeader* release_header();
  void set_allocated_header(::mw::internal::robotics::gazebotransport::PacketHeader* header);

  // optional .mw.internal.robotics.gazebotransport.Packet.CoSimError status = 2;
  bool has_status() const;
  void clear_status();
  static const int kStatusFieldNumber = 2;
  ::mw::internal::robotics::gazebotransport::Packet_CoSimError status() const;
  void set_status(::mw::internal::robotics::gazebotransport::Packet_CoSimError value);

  // optional .mw.internal.robotics.gazebotransport.StepSimulation step_simulation = 3;
  bool has_step_simulation() const;
  void clear_step_simulation();
  static const int kStepSimulationFieldNumber = 3;
  const ::mw::internal::robotics::gazebotransport::StepSimulation& step_simulation() const;
  ::mw::internal::robotics::gazebotransport::StepSimulation* mutable_step_simulation();
  ::mw::internal::robotics::gazebotransport::StepSimulation* release_step_simulation();
  void set_allocated_step_simulation(::mw::internal::robotics::gazebotransport::StepSimulation* step_simulation);

  // optional .mw.internal.robotics.gazebotransport.ResetSimulation reset_simulation = 4;
  bool has_reset_simulation() const;
  void clear_reset_simulation();
  static const int kResetSimulationFieldNumber = 4;
  const ::mw::internal::robotics::gazebotransport::ResetSimulation& reset_simulation() const;
  ::mw::internal::robotics::gazebotransport::ResetSimulation* mutable_reset_simulation();
  ::mw::internal::robotics::gazebotransport::ResetSimulation* release_reset_simulation();
  void set_allocated_reset_simulation(::mw::internal::robotics::gazebotransport::ResetSimulation* reset_simulation);

  // optional .mw.internal.robotics.gazebotransport.Image image = 5;
  bool has_image() const;
  void clear_image();
  static const int kImageFieldNumber = 5;
  const ::mw::internal::robotics::gazebotransport::Image& image() const;
  ::mw::internal::robotics::gazebotransport::Image* mutable_image();
  ::mw::internal::robotics::gazebotransport::Image* release_image();
  void set_allocated_image(::mw::internal::robotics::gazebotransport::Image* image);

  // optional .mw.internal.robotics.gazebotransport.RequestImage request_image = 6;
  bool has_request_image() const;
  void clear_request_image();
  static const int kRequestImageFieldNumber = 6;
  const ::mw::internal::robotics::gazebotransport::RequestImage& request_image() const;
  ::mw::internal::robotics::gazebotransport::RequestImage* mutable_request_image();
  ::mw::internal::robotics::gazebotransport::RequestImage* release_request_image();
  void set_allocated_request_image(::mw::internal::robotics::gazebotransport::RequestImage* request_image);

  // optional .mw.internal.robotics.gazebotransport.RequestCoSim request_cosim = 7;
  bool has_request_cosim() const;
  void clear_request_cosim();
  static const int kRequestCosimFieldNumber = 7;
  const ::mw::internal::robotics::gazebotransport::RequestCoSim& request_cosim() const;
  ::mw::internal::robotics::gazebotransport::RequestCoSim* mutable_request_cosim();
  ::mw::internal::robotics::gazebotransport::RequestCoSim* release_request_cosim();
  void set_allocated_request_cosim(::mw::internal::robotics::gazebotransport::RequestCoSim* request_cosim);

  // optional .mw.internal.robotics.gazebotransport.StopCoSim stop_cosim = 8;
  bool has_stop_cosim() const;
  void clear_stop_cosim();
  static const int kStopCosimFieldNumber = 8;
  const ::mw::internal::robotics::gazebotransport::StopCoSim& stop_cosim() const;
  ::mw::internal::robotics::gazebotransport::StopCoSim* mutable_stop_cosim();
  ::mw::internal::robotics::gazebotransport::StopCoSim* release_stop_cosim();
  void set_allocated_stop_cosim(::mw::internal::robotics::gazebotransport::StopCoSim* stop_cosim);

  // optional .mw.internal.robotics.gazebotransport.GetGroundTruthWorldPose get_ground_truth_world_pose = 9;
  bool has_get_ground_truth_world_pose() const;
  void clear_get_ground_truth_world_pose();
  static const int kGetGroundTruthWorldPoseFieldNumber = 9;
  const ::mw::internal::robotics::gazebotransport::GetGroundTruthWorldPose& get_ground_truth_world_pose() const;
  ::mw::internal::robotics::gazebotransport::GetGroundTruthWorldPose* mutable_get_ground_truth_world_pose();
  ::mw::internal::robotics::gazebotransport::GetGroundTruthWorldPose* release_get_ground_truth_world_pose();
  void set_allocated_get_ground_truth_world_pose(::mw::internal::robotics::gazebotransport::GetGroundTruthWorldPose* get_ground_truth_world_pose);

  // optional .mw.internal.robotics.gazebotransport.Pose pose = 10;
  bool has_pose() const;
  void clear_pose();
  static const int kPoseFieldNumber = 10;
  const ::mw::internal::robotics::gazebotransport::Pose& pose() const;
  ::mw::internal::robotics::gazebotransport::Pose* mutable_pose();
  ::mw::internal::robotics::gazebotransport::Pose* release_pose();
  void set_allocated_pose(::mw::internal::robotics::gazebotransport::Pose* pose);

  // optional .mw.internal.robotics.gazebotransport.StopSimulation stop_simulation = 11;
  bool has_stop_simulation() const;
  void clear_stop_simulation();
  static const int kStopSimulationFieldNumber = 11;
  const ::mw::internal::robotics::gazebotransport::StopSimulation& stop_simulation() const;
  ::mw::internal::robotics::gazebotransport::StopSimulation* mutable_stop_simulation();
  ::mw::internal::robotics::gazebotransport::StopSimulation* release_stop_simulation();
  void set_allocated_stop_simulation(::mw::internal::robotics::gazebotransport::StopSimulation* stop_simulation);

  // optional .mw.internal.robotics.gazebotransport.LaserData laser_data = 12;
  bool has_laser_data() const;
  void clear_laser_data();
  static const int kLaserDataFieldNumber = 12;
  const ::mw::internal::robotics::gazebotransport::LaserData& laser_data() const;
  ::mw::internal::robotics::gazebotransport::LaserData* mutable_laser_data();
  ::mw::internal::robotics::gazebotransport::LaserData* release_laser_data();
  void set_allocated_laser_data(::mw::internal::robotics::gazebotransport::LaserData* laser_data);

  // optional .mw.internal.robotics.gazebotransport.RequestLaser request_laser = 13;
  bool has_request_laser() const;
  void clear_request_laser();
  static const int kRequestLaserFieldNumber = 13;
  const ::mw::internal::robotics::gazebotransport::RequestLaser& request_laser() const;
  ::mw::internal::robotics::gazebotransport::RequestLaser* mutable_request_laser();
  ::mw::internal::robotics::gazebotransport::RequestLaser* release_request_laser();
  void set_allocated_request_laser(::mw::internal::robotics::gazebotransport::RequestLaser* request_laser);

  // optional .mw.internal.robotics.gazebotransport.ImuData imu_data = 14;
  bool has_imu_data() const;
  void clear_imu_data();
  static const int kImuDataFieldNumber = 14;
  const ::mw::internal::robotics::gazebotransport::ImuData& imu_data() const;
  ::mw::internal::robotics::gazebotransport::ImuData* mutable_imu_data();
  ::mw::internal::robotics::gazebotransport::ImuData* release_imu_data();
  void set_allocated_imu_data(::mw::internal::robotics::gazebotransport::ImuData* imu_data);

  // optional .mw.internal.robotics.gazebotransport.RequestImu request_imu = 15;
  bool has_request_imu() const;
  void clear_request_imu();
  static const int kRequestImuFieldNumber = 15;
  const ::mw::internal::robotics::gazebotransport::RequestImu& request_imu() const;
  ::mw::internal::robotics::gazebotransport::RequestImu* mutable_request_imu();
  ::mw::internal::robotics::gazebotransport::RequestImu* release_request_imu();
  void set_allocated_request_imu(::mw::internal::robotics::gazebotransport::RequestImu* request_imu);

  // optional .mw.internal.robotics.gazebotransport.SubscribeImage subscribe_image = 16;
  bool has_subscribe_image() const;
  void clear_subscribe_image();
  static const int kSubscribeImageFieldNumber = 16;
  const ::mw::internal::robotics::gazebotransport::SubscribeImage& subscribe_image() const;
  ::mw::internal::robotics::gazebotransport::SubscribeImage* mutable_subscribe_image();
  ::mw::internal::robotics::gazebotransport::SubscribeImage* release_subscribe_image();
  void set_allocated_subscribe_image(::mw::internal::robotics::gazebotransport::SubscribeImage* subscribe_image);

  // optional .mw.internal.robotics.gazebotransport.SubscribeLaser subscribe_laser = 17;
  bool has_subscribe_laser() const;
  void clear_subscribe_laser();
  static const int kSubscribeLaserFieldNumber = 17;
  const ::mw::internal::robotics::gazebotransport::SubscribeLaser& subscribe_laser() const;
  ::mw::internal::robotics::gazebotransport::SubscribeLaser* mutable_subscribe_laser();
  ::mw::internal::robotics::gazebotransport::SubscribeLaser* release_subscribe_laser();
  void set_allocated_subscribe_laser(::mw::internal::robotics::gazebotransport::SubscribeLaser* subscribe_laser);

  // optional .mw.internal.robotics.gazebotransport.SubscribeImu subscribe_imu = 18;
  bool has_subscribe_imu() const;
  void clear_subscribe_imu();
  static const int kSubscribeImuFieldNumber = 18;
  const ::mw::internal::robotics::gazebotransport::SubscribeImu& subscribe_imu() const;
  ::mw::internal::robotics::gazebotransport::SubscribeImu* mutable_subscribe_imu();
  ::mw::internal::robotics::gazebotransport::SubscribeImu* release_subscribe_imu();
  void set_allocated_subscribe_imu(::mw::internal::robotics::gazebotransport::SubscribeImu* subscribe_imu);

  // optional .mw.internal.robotics.gazebotransport.ApplyJointTorque apply_joint_torque = 19;
  bool has_apply_joint_torque() const;
  void clear_apply_joint_torque();
  static const int kApplyJointTorqueFieldNumber = 19;
  const ::mw::internal::robotics::gazebotransport::ApplyJointTorque& apply_joint_torque() const;
  ::mw::internal::robotics::gazebotransport::ApplyJointTorque* mutable_apply_joint_torque();
  ::mw::internal::robotics::gazebotransport::ApplyJointTorque* release_apply_joint_torque();
  void set_allocated_apply_joint_torque(::mw::internal::robotics::gazebotransport::ApplyJointTorque* apply_joint_torque);

  // optional .mw.internal.robotics.gazebotransport.GetPose get_pose = 20;
  bool has_get_pose() const;
  void clear_get_pose();
  static const int kGetPoseFieldNumber = 20;
  const ::mw::internal::robotics::gazebotransport::GetPose& get_pose() const;
  ::mw::internal::robotics::gazebotransport::GetPose* mutable_get_pose();
  ::mw::internal::robotics::gazebotransport::GetPose* release_get_pose();
  void set_allocated_get_pose(::mw::internal::robotics::gazebotransport::GetPose* get_pose);

  // optional .mw.internal.robotics.gazebotransport.GetTopicList get_topic_list = 21;
  bool has_get_topic_list() const;
  void clear_get_topic_list();
  static const int kGetTopicListFieldNumber = 21;
  const ::mw::internal::robotics::gazebotransport::GetTopicList& get_topic_list() const;
  ::mw::internal::robotics::gazebotransport::GetTopicList* mutable_get_topic_list();
  ::mw::internal::robotics::gazebotransport::GetTopicList* release_get_topic_list();
  void set_allocated_get_topic_list(::mw::internal::robotics::gazebotransport::GetTopicList* get_topic_list);

  // optional .mw.internal.robotics.gazebotransport.TopicList topic_list = 22;
  bool has_topic_list() const;
  void clear_topic_list();
  static const int kTopicListFieldNumber = 22;
  const ::mw::internal::robotics::gazebotransport::TopicList& topic_list() const;
  ::mw::internal::robotics::gazebotransport::TopicList* mutable_topic_list();
  ::mw::internal::robotics::gazebotransport::TopicList* release_topic_list();
  void set_allocated_topic_list(::mw::internal::robotics::gazebotransport::TopicList* topic_list);

  // optional .mw.internal.robotics.gazebotransport.GetModelInfo get_model_info = 23;
  bool has_get_model_info() const;
  void clear_get_model_info();
  static const int kGetModelInfoFieldNumber = 23;
  const ::mw::internal::robotics::gazebotransport::GetModelInfo& get_model_info() const;
  ::mw::internal::robotics::gazebotransport::GetModelInfo* mutable_get_model_info();
  ::mw::internal::robotics::gazebotransport::GetModelInfo* release_get_model_info();
  void set_allocated_get_model_info(::mw::internal::robotics::gazebotransport::GetModelInfo* get_model_info);

  // optional .mw.internal.robotics.gazebotransport.ModelInfo model_info = 24;
  bool has_model_info() const;
  void clear_model_info();
  static const int kModelInfoFieldNumber = 24;
  const ::mw::internal::robotics::gazebotransport::ModelInfo& model_info() const;
  ::mw::internal::robotics::gazebotransport::ModelInfo* mutable_model_info();
  ::mw::internal::robotics::gazebotransport::ModelInfo* release_model_info();
  void set_allocated_model_info(::mw::internal::robotics::gazebotransport::ModelInfo* model_info);

  // optional .mw.internal.robotics.gazebotransport.ApplyLinkWrench apply_link_wrench = 25;
  bool has_apply_link_wrench() const;
  void clear_apply_link_wrench();
  static const int kApplyLinkWrenchFieldNumber = 25;
  const ::mw::internal::robotics::gazebotransport::ApplyLinkWrench& apply_link_wrench() const;
  ::mw::internal::robotics::gazebotransport::ApplyLinkWrench* mutable_apply_link_wrench();
  ::mw::internal::robotics::gazebotransport::ApplyLinkWrench* release_apply_link_wrench();
  void set_allocated_apply_link_wrench(::mw::internal::robotics::gazebotransport::ApplyLinkWrench* apply_link_wrench);

  // optional .mw.internal.robotics.gazebotransport.MaxStepSize max_step_size = 26;
  bool has_max_step_size() const;
  void clear_max_step_size();
  static const int kMaxStepSizeFieldNumber = 26;
  const ::mw::internal::robotics::gazebotransport::MaxStepSize& max_step_size() const;
  ::mw::internal::robotics::gazebotransport::MaxStepSize* mutable_max_step_size();
  ::mw::internal::robotics::gazebotransport::MaxStepSize* release_max_step_size();
  void set_allocated_max_step_size(::mw::internal::robotics::gazebotransport::MaxStepSize* max_step_size);

  // optional .mw.internal.robotics.gazebotransport.CustomMessageSupport custom_message_support = 27;
  bool has_custom_message_support() const;
  void clear_custom_message_support();
  static const int kCustomMessageSupportFieldNumber = 27;
  const ::mw::internal::robotics::gazebotransport::CustomMessageSupport& custom_message_support() const;
  ::mw::internal::robotics::gazebotransport::CustomMessageSupport* mutable_custom_message_support();
  ::mw::internal::robotics::gazebotransport::CustomMessageSupport* release_custom_message_support();
  void set_allocated_custom_message_support(::mw::internal::robotics::gazebotransport::CustomMessageSupport* custom_message_support);

  // optional .mw.internal.robotics.gazebotransport.InitCustomPublisher init_custom_publisher = 28;
  bool has_init_custom_publisher() const;
  void clear_init_custom_publisher();
  static const int kInitCustomPublisherFieldNumber = 28;
  const ::mw::internal::robotics::gazebotransport::InitCustomPublisher& init_custom_publisher() const;
  ::mw::internal::robotics::gazebotransport::InitCustomPublisher* mutable_init_custom_publisher();
  ::mw::internal::robotics::gazebotransport::InitCustomPublisher* release_init_custom_publisher();
  void set_allocated_init_custom_publisher(::mw::internal::robotics::gazebotransport::InitCustomPublisher* init_custom_publisher);

  // optional .mw.internal.robotics.gazebotransport.InitCustomSubscriber init_custom_subscriber = 29;
  bool has_init_custom_subscriber() const;
  void clear_init_custom_subscriber();
  static const int kInitCustomSubscriberFieldNumber = 29;
  const ::mw::internal::robotics::gazebotransport::InitCustomSubscriber& init_custom_subscriber() const;
  ::mw::internal::robotics::gazebotransport::InitCustomSubscriber* mutable_init_custom_subscriber();
  ::mw::internal::robotics::gazebotransport::InitCustomSubscriber* release_init_custom_subscriber();
  void set_allocated_init_custom_subscriber(::mw::internal::robotics::gazebotransport::InitCustomSubscriber* init_custom_subscriber);

  // optional .mw.internal.robotics.gazebotransport.RequestCustomMessageSupport request_custom_message_support = 30;
  bool has_request_custom_message_support() const;
  void clear_request_custom_message_support();
  static const int kRequestCustomMessageSupportFieldNumber = 30;
  const ::mw::internal::robotics::gazebotransport::RequestCustomMessageSupport& request_custom_message_support() const;
  ::mw::internal::robotics::gazebotransport::RequestCustomMessageSupport* mutable_request_custom_message_support();
  ::mw::internal::robotics::gazebotransport::RequestCustomMessageSupport* release_request_custom_message_support();
  void set_allocated_request_custom_message_support(::mw::internal::robotics::gazebotransport::RequestCustomMessageSupport* request_custom_message_support);

  // optional .mw.internal.robotics.gazebotransport.SetJointPosition set_joint_position = 31;
  bool has_set_joint_position() const;
  void clear_set_joint_position();
  static const int kSetJointPositionFieldNumber = 31;
  const ::mw::internal::robotics::gazebotransport::SetJointPosition& set_joint_position() const;
  ::mw::internal::robotics::gazebotransport::SetJointPosition* mutable_set_joint_position();
  ::mw::internal::robotics::gazebotransport::SetJointPosition* release_set_joint_position();
  void set_allocated_set_joint_position(::mw::internal::robotics::gazebotransport::SetJointPosition* set_joint_position);

  // optional .mw.internal.robotics.gazebotransport.SetJointVelocity set_joint_velocity = 32;
  bool has_set_joint_velocity() const;
  void clear_set_joint_velocity();
  static const int kSetJointVelocityFieldNumber = 32;
  const ::mw::internal::robotics::gazebotransport::SetJointVelocity& set_joint_velocity() const;
  ::mw::internal::robotics::gazebotransport::SetJointVelocity* mutable_set_joint_velocity();
  ::mw::internal::robotics::gazebotransport::SetJointVelocity* release_set_joint_velocity();
  void set_allocated_set_joint_velocity(::mw::internal::robotics::gazebotransport::SetJointVelocity* set_joint_velocity);

  // optional .mw.internal.robotics.gazebotransport.GetJointState get_joint_state = 33;
  bool has_get_joint_state() const;
  void clear_get_joint_state();
  static const int kGetJointStateFieldNumber = 33;
  const ::mw::internal::robotics::gazebotransport::GetJointState& get_joint_state() const;
  ::mw::internal::robotics::gazebotransport::GetJointState* mutable_get_joint_state();
  ::mw::internal::robotics::gazebotransport::GetJointState* release_get_joint_state();
  void set_allocated_get_joint_state(::mw::internal::robotics::gazebotransport::GetJointState* get_joint_state);

  // optional .mw.internal.robotics.gazebotransport.JointState joint_state = 34;
  bool has_joint_state() const;
  void clear_joint_state();
  static const int kJointStateFieldNumber = 34;
  const ::mw::internal::robotics::gazebotransport::JointState& joint_state() const;
  ::mw::internal::robotics::gazebotransport::JointState* mutable_joint_state();
  ::mw::internal::robotics::gazebotransport::JointState* release_joint_state();
  void set_allocated_joint_state(::mw::internal::robotics::gazebotransport::JointState* joint_state);

  // optional .mw.internal.robotics.gazebotransport.SetLinkWorldPose set_link_world_pose = 35;
  bool has_set_link_world_pose() const;
  void clear_set_link_world_pose();
  static const int kSetLinkWorldPoseFieldNumber = 35;
  const ::mw::internal::robotics::gazebotransport::SetLinkWorldPose& set_link_world_pose() const;
  ::mw::internal::robotics::gazebotransport::SetLinkWorldPose* mutable_set_link_world_pose();
  ::mw::internal::robotics::gazebotransport::SetLinkWorldPose* release_set_link_world_pose();
  void set_allocated_set_link_world_pose(::mw::internal::robotics::gazebotransport::SetLinkWorldPose* set_link_world_pose);

  // optional .mw.internal.robotics.gazebotransport.SetLinkLinearVelocity set_link_linear_velocity = 36;
  bool has_set_link_linear_velocity() const;
  void clear_set_link_linear_velocity();
  static const int kSetLinkLinearVelocityFieldNumber = 36;
  const ::mw::internal::robotics::gazebotransport::SetLinkLinearVelocity& set_link_linear_velocity() const;
  ::mw::internal::robotics::gazebotransport::SetLinkLinearVelocity* mutable_set_link_linear_velocity();
  ::mw::internal::robotics::gazebotransport::SetLinkLinearVelocity* release_set_link_linear_velocity();
  void set_allocated_set_link_linear_velocity(::mw::internal::robotics::gazebotransport::SetLinkLinearVelocity* set_link_linear_velocity);

  // optional .mw.internal.robotics.gazebotransport.SetLinkAngularVelocity set_link_angular_velocity = 37;
  bool has_set_link_angular_velocity() const;
  void clear_set_link_angular_velocity();
  static const int kSetLinkAngularVelocityFieldNumber = 37;
  const ::mw::internal::robotics::gazebotransport::SetLinkAngularVelocity& set_link_angular_velocity() const;
  ::mw::internal::robotics::gazebotransport::SetLinkAngularVelocity* mutable_set_link_angular_velocity();
  ::mw::internal::robotics::gazebotransport::SetLinkAngularVelocity* release_set_link_angular_velocity();
  void set_allocated_set_link_angular_velocity(::mw::internal::robotics::gazebotransport::SetLinkAngularVelocity* set_link_angular_velocity);

  // optional .mw.internal.robotics.gazebotransport.GetLinkState get_link_state = 38;
  bool has_get_link_state() const;
  void clear_get_link_state();
  static const int kGetLinkStateFieldNumber = 38;
  const ::mw::internal::robotics::gazebotransport::GetLinkState& get_link_state() const;
  ::mw::internal::robotics::gazebotransport::GetLinkState* mutable_get_link_state();
  ::mw::internal::robotics::gazebotransport::GetLinkState* release_get_link_state();
  void set_allocated_get_link_state(::mw::internal::robotics::gazebotransport::GetLinkState* get_link_state);

  // optional .mw.internal.robotics.gazebotransport.LinkState link_state = 39;
  bool has_link_state() const;
  void clear_link_state();
  static const int kLinkStateFieldNumber = 39;
  const ::mw::internal::robotics::gazebotransport::LinkState& link_state() const;
  ::mw::internal::robotics::gazebotransport::LinkState* mutable_link_state();
  ::mw::internal::robotics::gazebotransport::LinkState* release_link_state();
  void set_allocated_link_state(::mw::internal::robotics::gazebotransport::LinkState* link_state);

  // optional .mw.internal.robotics.gazebotransport.Gazebomodel gazebo_model = 40;
  bool has_gazebo_model() const;
  void clear_gazebo_model();
  static const int kGazeboModelFieldNumber = 40;
  const ::mw::internal::robotics::gazebotransport::Gazebomodel& gazebo_model() const;
  ::mw::internal::robotics::gazebotransport::Gazebomodel* mutable_gazebo_model();
  ::mw::internal::robotics::gazebotransport::Gazebomodel* release_gazebo_model();
  void set_allocated_gazebo_model(::mw::internal::robotics::gazebotransport::Gazebomodel* gazebo_model);

  // optional .mw.internal.robotics.gazebotransport.GetGazeboModelParam get_gazebo_model_param = 41;
  bool has_get_gazebo_model_param() const;
  void clear_get_gazebo_model_param();
  static const int kGetGazeboModelParamFieldNumber = 41;
  const ::mw::internal::robotics::gazebotransport::GetGazeboModelParam& get_gazebo_model_param() const;
  ::mw::internal::robotics::gazebotransport::GetGazeboModelParam* mutable_get_gazebo_model_param();
  ::mw::internal::robotics::gazebotransport::GetGazeboModelParam* release_get_gazebo_model_param();
  void set_allocated_get_gazebo_model_param(::mw::internal::robotics::gazebotransport::GetGazeboModelParam* get_gazebo_model_param);

  // optional .mw.internal.robotics.gazebotransport.GazeboModelSDF gazebo_model_sdf = 42;
  bool has_gazebo_model_sdf() const;
  void clear_gazebo_model_sdf();
  static const int kGazeboModelSdfFieldNumber = 42;
  const ::mw::internal::robotics::gazebotransport::GazeboModelSDF& gazebo_model_sdf() const;
  ::mw::internal::robotics::gazebotransport::GazeboModelSDF* mutable_gazebo_model_sdf();
  ::mw::internal::robotics::gazebotransport::GazeboModelSDF* release_gazebo_model_sdf();
  void set_allocated_gazebo_model_sdf(::mw::internal::robotics::gazebotransport::GazeboModelSDF* gazebo_model_sdf);

  // optional .mw.internal.robotics.gazebotransport.GetGazeboModelSDF get_gazebo_model_sdf = 43;
  bool has_get_gazebo_model_sdf() const;
  void clear_get_gazebo_model_sdf();
  static const int kGetGazeboModelSdfFieldNumber = 43;
  const ::mw::internal::robotics::gazebotransport::GetGazeboModelSDF& get_gazebo_model_sdf() const;
  ::mw::internal::robotics::gazebotransport::GetGazeboModelSDF* mutable_get_gazebo_model_sdf();
  ::mw::internal::robotics::gazebotransport::GetGazeboModelSDF* release_get_gazebo_model_sdf();
  void set_allocated_get_gazebo_model_sdf(::mw::internal::robotics::gazebotransport::GetGazeboModelSDF* get_gazebo_model_sdf);

  // optional string error_message = 44;
  bool has_error_message() const;
  void clear_error_message();
  static const int kErrorMessageFieldNumber = 44;
  const ::std::string& error_message() const;
  void set_error_message(const ::std::string& value);
  void set_error_message(const char* value);
  void set_error_message(const char* value, size_t size);
  ::std::string* mutable_error_message();
  ::std::string* release_error_message();
  void set_allocated_error_message(::std::string* error_message);

  PayloadCase payload_case() const;
  // @@protoc_insertion_point(class_scope:mw.internal.robotics.gazebotransport.Packet)
 private:
  inline void set_has_header();
  inline void clear_has_header();
  inline void set_has_status();
  inline void set_has_step_simulation();
  inline void set_has_reset_simulation();
  inline void set_has_image();
  inline void set_has_request_image();
  inline void set_has_request_cosim();
  inline void set_has_stop_cosim();
  inline void set_has_get_ground_truth_world_pose();
  inline void set_has_pose();
  inline void set_has_stop_simulation();
  inline void set_has_laser_data();
  inline void set_has_request_laser();
  inline void set_has_imu_data();
  inline void set_has_request_imu();
  inline void set_has_subscribe_image();
  inline void set_has_subscribe_laser();
  inline void set_has_subscribe_imu();
  inline void set_has_apply_joint_torque();
  inline void set_has_get_pose();
  inline void set_has_get_topic_list();
  inline void set_has_topic_list();
  inline void set_has_get_model_info();
  inline void set_has_model_info();
  inline void set_has_apply_link_wrench();
  inline void set_has_max_step_size();
  inline void set_has_custom_message_support();
  inline void set_has_init_custom_publisher();
  inline void set_has_init_custom_subscriber();
  inline void set_has_request_custom_message_support();
  inline void set_has_set_joint_position();
  inline void set_has_set_joint_velocity();
  inline void set_has_get_joint_state();
  inline void set_has_joint_state();
  inline void set_has_set_link_world_pose();
  inline void set_has_set_link_linear_velocity();
  inline void set_has_set_link_angular_velocity();
  inline void set_has_get_link_state();
  inline void set_has_link_state();
  inline void set_has_gazebo_model();
  inline void set_has_get_gazebo_model_param();
  inline void set_has_gazebo_model_sdf();
  inline void set_has_get_gazebo_model_sdf();
  inline void set_has_error_message();
  inline void clear_has_error_message();

  inline bool has_payload() const;
  void clear_payload();
  inline void clear_has_payload();

  ::google::protobuf::internal::InternalMetadataWithArena _internal_metadata_;
  ::google::protobuf::uint32 _has_bits_[2];
  ::mw::internal::robotics::gazebotransport::PacketHeader* header_;
  ::google::protobuf::internal::ArenaStringPtr error_message_;
  union PayloadUnion {
    PayloadUnion() {}
    int status_;
    ::mw::internal::robotics::gazebotransport::StepSimulation* step_simulation_;
    ::mw::internal::robotics::gazebotransport::ResetSimulation* reset_simulation_;
    ::mw::internal::robotics::gazebotransport::Image* image_;
    ::mw::internal::robotics::gazebotransport::RequestImage* request_image_;
    ::mw::internal::robotics::gazebotransport::RequestCoSim* request_cosim_;
    ::mw::internal::robotics::gazebotransport::StopCoSim* stop_cosim_;
    ::mw::internal::robotics::gazebotransport::GetGroundTruthWorldPose* get_ground_truth_world_pose_;
    ::mw::internal::robotics::gazebotransport::Pose* pose_;
    ::mw::internal::robotics::gazebotransport::StopSimulation* stop_simulation_;
    ::mw::internal::robotics::gazebotransport::LaserData* laser_data_;
    ::mw::internal::robotics::gazebotransport::RequestLaser* request_laser_;
    ::mw::internal::robotics::gazebotransport::ImuData* imu_data_;
    ::mw::internal::robotics::gazebotransport::RequestImu* request_imu_;
    ::mw::internal::robotics::gazebotransport::SubscribeImage* subscribe_image_;
    ::mw::internal::robotics::gazebotransport::SubscribeLaser* subscribe_laser_;
    ::mw::internal::robotics::gazebotransport::SubscribeImu* subscribe_imu_;
    ::mw::internal::robotics::gazebotransport::ApplyJointTorque* apply_joint_torque_;
    ::mw::internal::robotics::gazebotransport::GetPose* get_pose_;
    ::mw::internal::robotics::gazebotransport::GetTopicList* get_topic_list_;
    ::mw::internal::robotics::gazebotransport::TopicList* topic_list_;
    ::mw::internal::robotics::gazebotransport::GetModelInfo* get_model_info_;
    ::mw::internal::robotics::gazebotransport::ModelInfo* model_info_;
    ::mw::internal::robotics::gazebotransport::ApplyLinkWrench* apply_link_wrench_;
    ::mw::internal::robotics::gazebotransport::MaxStepSize* max_step_size_;
    ::mw::internal::robotics::gazebotransport::CustomMessageSupport* custom_message_support_;
    ::mw::internal::robotics::gazebotransport::InitCustomPublisher* init_custom_publisher_;
    ::mw::internal::robotics::gazebotransport::InitCustomSubscriber* init_custom_subscriber_;
    ::mw::internal::robotics::gazebotransport::RequestCustomMessageSupport* request_custom_message_support_;
    ::mw::internal::robotics::gazebotransport::SetJointPosition* set_joint_position_;
    ::mw::internal::robotics::gazebotransport::SetJointVelocity* set_joint_velocity_;
    ::mw::internal::robotics::gazebotransport::GetJointState* get_joint_state_;
    ::mw::internal::robotics::gazebotransport::JointState* joint_state_;
    ::mw::internal::robotics::gazebotransport::SetLinkWorldPose* set_link_world_pose_;
    ::mw::internal::robotics::gazebotransport::SetLinkLinearVelocity* set_link_linear_velocity_;
    ::mw::internal::robotics::gazebotransport::SetLinkAngularVelocity* set_link_angular_velocity_;
    ::mw::internal::robotics::gazebotransport::GetLinkState* get_link_state_;
    ::mw::internal::robotics::gazebotransport::LinkState* link_state_;
    ::mw::internal::robotics::gazebotransport::Gazebomodel* gazebo_model_;
    ::mw::internal::robotics::gazebotransport::GetGazeboModelParam* get_gazebo_model_param_;
    ::mw::internal::robotics::gazebotransport::GazeboModelSDF* gazebo_model_sdf_;
    ::mw::internal::robotics::gazebotransport::GetGazeboModelSDF* get_gazebo_model_sdf_;
  } payload_;
  mutable int _cached_size_;
  ::google::protobuf::uint32 _oneof_case_[1];

  friend void  protobuf_AddDesc_mw_2einternal_2erobotics_2egazebotransport_2eCoSimMsgs_2eproto();
  friend void protobuf_AssignDesc_mw_2einternal_2erobotics_2egazebotransport_2eCoSimMsgs_2eproto();
  friend void protobuf_ShutdownFile_mw_2einternal_2erobotics_2egazebotransport_2eCoSimMsgs_2eproto();

  void InitAsDefaultInstance();
  static Packet* default_instance_;
};
// -------------------------------------------------------------------

class StepSimulation : public ::google::protobuf::Message /* @@protoc_insertion_point(class_definition:mw.internal.robotics.gazebotransport.StepSimulation) */ {
 public:
  StepSimulation();
  virtual ~StepSimulation();

  StepSimulation(const StepSimulation& from);

  inline StepSimulation& operator=(const StepSimulation& from) {
    CopyFrom(from);
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _internal_metadata_.unknown_fields();
  }

  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return _internal_metadata_.mutable_unknown_fields();
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const StepSimulation& default_instance();

  void Swap(StepSimulation* other);

  // implements Message ----------------------------------------------

  inline StepSimulation* New() const { return New(NULL); }

  StepSimulation* New(::google::protobuf::Arena* arena) const;
  void CopyFrom(const ::google::protobuf::Message& from);
  void MergeFrom(const ::google::protobuf::Message& from);
  void CopyFrom(const StepSimulation& from);
  void MergeFrom(const StepSimulation& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  ::google::protobuf::uint8* InternalSerializeWithCachedSizesToArray(
      bool deterministic, ::google::protobuf::uint8* output) const;
  ::google::protobuf::uint8* SerializeWithCachedSizesToArray(::google::protobuf::uint8* output) const {
    return InternalSerializeWithCachedSizesToArray(false, output);
  }
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  void InternalSwap(StepSimulation* other);
  private:
  inline ::google::protobuf::Arena* GetArenaNoVirtual() const {
    return _internal_metadata_.arena();
  }
  inline void* MaybeArenaPtr() const {
    return _internal_metadata_.raw_arena_ptr();
  }
  public:

  ::google::protobuf::Metadata GetMetadata() const;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // required uint32 num_steps = 1;
  bool has_num_steps() const;
  void clear_num_steps();
  static const int kNumStepsFieldNumber = 1;
  ::google::protobuf::uint32 num_steps() const;
  void set_num_steps(::google::protobuf::uint32 value);

  // @@protoc_insertion_point(class_scope:mw.internal.robotics.gazebotransport.StepSimulation)
 private:
  inline void set_has_num_steps();
  inline void clear_has_num_steps();

  ::google::protobuf::internal::InternalMetadataWithArena _internal_metadata_;
  ::google::protobuf::uint32 _has_bits_[1];
  mutable int _cached_size_;
  ::google::protobuf::uint32 num_steps_;
  friend void  protobuf_AddDesc_mw_2einternal_2erobotics_2egazebotransport_2eCoSimMsgs_2eproto();
  friend void protobuf_AssignDesc_mw_2einternal_2erobotics_2egazebotransport_2eCoSimMsgs_2eproto();
  friend void protobuf_ShutdownFile_mw_2einternal_2erobotics_2egazebotransport_2eCoSimMsgs_2eproto();

  void InitAsDefaultInstance();
  static StepSimulation* default_instance_;
};
// -------------------------------------------------------------------

class ResetSimulation : public ::google::protobuf::Message /* @@protoc_insertion_point(class_definition:mw.internal.robotics.gazebotransport.ResetSimulation) */ {
 public:
  ResetSimulation();
  virtual ~ResetSimulation();

  ResetSimulation(const ResetSimulation& from);

  inline ResetSimulation& operator=(const ResetSimulation& from) {
    CopyFrom(from);
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _internal_metadata_.unknown_fields();
  }

  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return _internal_metadata_.mutable_unknown_fields();
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const ResetSimulation& default_instance();

  void Swap(ResetSimulation* other);

  // implements Message ----------------------------------------------

  inline ResetSimulation* New() const { return New(NULL); }

  ResetSimulation* New(::google::protobuf::Arena* arena) const;
  void CopyFrom(const ::google::protobuf::Message& from);
  void MergeFrom(const ::google::protobuf::Message& from);
  void CopyFrom(const ResetSimulation& from);
  void MergeFrom(const ResetSimulation& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  ::google::protobuf::uint8* InternalSerializeWithCachedSizesToArray(
      bool deterministic, ::google::protobuf::uint8* output) const;
  ::google::protobuf::uint8* SerializeWithCachedSizesToArray(::google::protobuf::uint8* output) const {
    return InternalSerializeWithCachedSizesToArray(false, output);
  }
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  void InternalSwap(ResetSimulation* other);
  private:
  inline ::google::protobuf::Arena* GetArenaNoVirtual() const {
    return _internal_metadata_.arena();
  }
  inline void* MaybeArenaPtr() const {
    return _internal_metadata_.raw_arena_ptr();
  }
  public:

  ::google::protobuf::Metadata GetMetadata() const;

  // nested types ----------------------------------------------------

  typedef ResetSimulation_ResetBehavior ResetBehavior;
  static const ResetBehavior RESET_TIME =
    ResetSimulation_ResetBehavior_RESET_TIME;
  static const ResetBehavior RESET_TIME_AND_SCENE =
    ResetSimulation_ResetBehavior_RESET_TIME_AND_SCENE;
  static inline bool ResetBehavior_IsValid(int value) {
    return ResetSimulation_ResetBehavior_IsValid(value);
  }
  static const ResetBehavior ResetBehavior_MIN =
    ResetSimulation_ResetBehavior_ResetBehavior_MIN;
  static const ResetBehavior ResetBehavior_MAX =
    ResetSimulation_ResetBehavior_ResetBehavior_MAX;
  static const int ResetBehavior_ARRAYSIZE =
    ResetSimulation_ResetBehavior_ResetBehavior_ARRAYSIZE;
  static inline const ::google::protobuf::EnumDescriptor*
  ResetBehavior_descriptor() {
    return ResetSimulation_ResetBehavior_descriptor();
  }
  static inline const ::std::string& ResetBehavior_Name(ResetBehavior value) {
    return ResetSimulation_ResetBehavior_Name(value);
  }
  static inline bool ResetBehavior_Parse(const ::std::string& name,
      ResetBehavior* value) {
    return ResetSimulation_ResetBehavior_Parse(name, value);
  }

  // accessors -------------------------------------------------------

  // required .mw.internal.robotics.gazebotransport.ResetSimulation.ResetBehavior behavior = 1;
  bool has_behavior() const;
  void clear_behavior();
  static const int kBehaviorFieldNumber = 1;
  ::mw::internal::robotics::gazebotransport::ResetSimulation_ResetBehavior behavior() const;
  void set_behavior(::mw::internal::robotics::gazebotransport::ResetSimulation_ResetBehavior value);

  // @@protoc_insertion_point(class_scope:mw.internal.robotics.gazebotransport.ResetSimulation)
 private:
  inline void set_has_behavior();
  inline void clear_has_behavior();

  ::google::protobuf::internal::InternalMetadataWithArena _internal_metadata_;
  ::google::protobuf::uint32 _has_bits_[1];
  mutable int _cached_size_;
  int behavior_;
  friend void  protobuf_AddDesc_mw_2einternal_2erobotics_2egazebotransport_2eCoSimMsgs_2eproto();
  friend void protobuf_AssignDesc_mw_2einternal_2erobotics_2egazebotransport_2eCoSimMsgs_2eproto();
  friend void protobuf_ShutdownFile_mw_2einternal_2erobotics_2egazebotransport_2eCoSimMsgs_2eproto();

  void InitAsDefaultInstance();
  static ResetSimulation* default_instance_;
};
// -------------------------------------------------------------------

class Image : public ::google::protobuf::Message /* @@protoc_insertion_point(class_definition:mw.internal.robotics.gazebotransport.Image) */ {
 public:
  Image();
  virtual ~Image();

  Image(const Image& from);

  inline Image& operator=(const Image& from) {
    CopyFrom(from);
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _internal_metadata_.unknown_fields();
  }

  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return _internal_metadata_.mutable_unknown_fields();
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const Image& default_instance();

  void Swap(Image* other);

  // implements Message ----------------------------------------------

  inline Image* New() const { return New(NULL); }

  Image* New(::google::protobuf::Arena* arena) const;
  void CopyFrom(const ::google::protobuf::Message& from);
  void MergeFrom(const ::google::protobuf::Message& from);
  void CopyFrom(const Image& from);
  void MergeFrom(const Image& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  ::google::protobuf::uint8* InternalSerializeWithCachedSizesToArray(
      bool deterministic, ::google::protobuf::uint8* output) const;
  ::google::protobuf::uint8* SerializeWithCachedSizesToArray(::google::protobuf::uint8* output) const {
    return InternalSerializeWithCachedSizesToArray(false, output);
  }
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  void InternalSwap(Image* other);
  private:
  inline ::google::protobuf::Arena* GetArenaNoVirtual() const {
    return _internal_metadata_.arena();
  }
  inline void* MaybeArenaPtr() const {
    return _internal_metadata_.raw_arena_ptr();
  }
  public:

  ::google::protobuf::Metadata GetMetadata() const;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // required uint32 width = 1;
  bool has_width() const;
  void clear_width();
  static const int kWidthFieldNumber = 1;
  ::google::protobuf::uint32 width() const;
  void set_width(::google::protobuf::uint32 value);

  // required uint32 height = 2;
  bool has_height() const;
  void clear_height();
  static const int kHeightFieldNumber = 2;
  ::google::protobuf::uint32 height() const;
  void set_height(::google::protobuf::uint32 value);

  // required bytes data = 3;
  bool has_data() const;
  void clear_data();
  static const int kDataFieldNumber = 3;
  const ::std::string& data() const;
  void set_data(const ::std::string& value);
  void set_data(const char* value);
  void set_data(const void* value, size_t size);
  ::std::string* mutable_data();
  ::std::string* release_data();
  void set_allocated_data(::std::string* data);

  // required string data_type = 4;
  bool has_data_type() const;
  void clear_data_type();
  static const int kDataTypeFieldNumber = 4;
  const ::std::string& data_type() const;
  void set_data_type(const ::std::string& value);
  void set_data_type(const char* value);
  void set_data_type(const char* value, size_t size);
  ::std::string* mutable_data_type();
  ::std::string* release_data_type();
  void set_allocated_data_type(::std::string* data_type);

  // @@protoc_insertion_point(class_scope:mw.internal.robotics.gazebotransport.Image)
 private:
  inline void set_has_width();
  inline void clear_has_width();
  inline void set_has_height();
  inline void clear_has_height();
  inline void set_has_data();
  inline void clear_has_data();
  inline void set_has_data_type();
  inline void clear_has_data_type();

  // helper for ByteSize()
  int RequiredFieldsByteSizeFallback() const;

  ::google::protobuf::internal::InternalMetadataWithArena _internal_metadata_;
  ::google::protobuf::uint32 _has_bits_[1];
  mutable int _cached_size_;
  ::google::protobuf::uint32 width_;
  ::google::protobuf::uint32 height_;
  ::google::protobuf::internal::ArenaStringPtr data_;
  ::google::protobuf::internal::ArenaStringPtr data_type_;
  friend void  protobuf_AddDesc_mw_2einternal_2erobotics_2egazebotransport_2eCoSimMsgs_2eproto();
  friend void protobuf_AssignDesc_mw_2einternal_2erobotics_2egazebotransport_2eCoSimMsgs_2eproto();
  friend void protobuf_ShutdownFile_mw_2einternal_2erobotics_2egazebotransport_2eCoSimMsgs_2eproto();

  void InitAsDefaultInstance();
  static Image* default_instance_;
};
// -------------------------------------------------------------------

class RequestImage : public ::google::protobuf::Message /* @@protoc_insertion_point(class_definition:mw.internal.robotics.gazebotransport.RequestImage) */ {
 public:
  RequestImage();
  virtual ~RequestImage();

  RequestImage(const RequestImage& from);

  inline RequestImage& operator=(const RequestImage& from) {
    CopyFrom(from);
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _internal_metadata_.unknown_fields();
  }

  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return _internal_metadata_.mutable_unknown_fields();
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const RequestImage& default_instance();

  void Swap(RequestImage* other);

  // implements Message ----------------------------------------------

  inline RequestImage* New() const { return New(NULL); }

  RequestImage* New(::google::protobuf::Arena* arena) const;
  void CopyFrom(const ::google::protobuf::Message& from);
  void MergeFrom(const ::google::protobuf::Message& from);
  void CopyFrom(const RequestImage& from);
  void MergeFrom(const RequestImage& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  ::google::protobuf::uint8* InternalSerializeWithCachedSizesToArray(
      bool deterministic, ::google::protobuf::uint8* output) const;
  ::google::protobuf::uint8* SerializeWithCachedSizesToArray(::google::protobuf::uint8* output) const {
    return InternalSerializeWithCachedSizesToArray(false, output);
  }
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  void InternalSwap(RequestImage* other);
  private:
  inline ::google::protobuf::Arena* GetArenaNoVirtual() const {
    return _internal_metadata_.arena();
  }
  inline void* MaybeArenaPtr() const {
    return _internal_metadata_.raw_arena_ptr();
  }
  public:

  ::google::protobuf::Metadata GetMetadata() const;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // required string topic_name = 1;
  bool has_topic_name() const;
  void clear_topic_name();
  static const int kTopicNameFieldNumber = 1;
  const ::std::string& topic_name() const;
  void set_topic_name(const ::std::string& value);
  void set_topic_name(const char* value);
  void set_topic_name(const char* value, size_t size);
  ::std::string* mutable_topic_name();
  ::std::string* release_topic_name();
  void set_allocated_topic_name(::std::string* topic_name);

  // @@protoc_insertion_point(class_scope:mw.internal.robotics.gazebotransport.RequestImage)
 private:
  inline void set_has_topic_name();
  inline void clear_has_topic_name();

  ::google::protobuf::internal::InternalMetadataWithArena _internal_metadata_;
  ::google::protobuf::uint32 _has_bits_[1];
  mutable int _cached_size_;
  ::google::protobuf::internal::ArenaStringPtr topic_name_;
  friend void  protobuf_AddDesc_mw_2einternal_2erobotics_2egazebotransport_2eCoSimMsgs_2eproto();
  friend void protobuf_AssignDesc_mw_2einternal_2erobotics_2egazebotransport_2eCoSimMsgs_2eproto();
  friend void protobuf_ShutdownFile_mw_2einternal_2erobotics_2egazebotransport_2eCoSimMsgs_2eproto();

  void InitAsDefaultInstance();
  static RequestImage* default_instance_;
};
// -------------------------------------------------------------------

class RequestCoSim : public ::google::protobuf::Message /* @@protoc_insertion_point(class_definition:mw.internal.robotics.gazebotransport.RequestCoSim) */ {
 public:
  RequestCoSim();
  virtual ~RequestCoSim();

  RequestCoSim(const RequestCoSim& from);

  inline RequestCoSim& operator=(const RequestCoSim& from) {
    CopyFrom(from);
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _internal_metadata_.unknown_fields();
  }

  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return _internal_metadata_.mutable_unknown_fields();
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const RequestCoSim& default_instance();

  void Swap(RequestCoSim* other);

  // implements Message ----------------------------------------------

  inline RequestCoSim* New() const { return New(NULL); }

  RequestCoSim* New(::google::protobuf::Arena* arena) const;
  void CopyFrom(const ::google::protobuf::Message& from);
  void MergeFrom(const ::google::protobuf::Message& from);
  void CopyFrom(const RequestCoSim& from);
  void MergeFrom(const RequestCoSim& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  ::google::protobuf::uint8* InternalSerializeWithCachedSizesToArray(
      bool deterministic, ::google::protobuf::uint8* output) const;
  ::google::protobuf::uint8* SerializeWithCachedSizesToArray(::google::protobuf::uint8* output) const {
    return InternalSerializeWithCachedSizesToArray(false, output);
  }
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  void InternalSwap(RequestCoSim* other);
  private:
  inline ::google::protobuf::Arena* GetArenaNoVirtual() const {
    return _internal_metadata_.arena();
  }
  inline void* MaybeArenaPtr() const {
    return _internal_metadata_.raw_arena_ptr();
  }
  public:

  ::google::protobuf::Metadata GetMetadata() const;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // required string client_id = 1;
  bool has_client_id() const;
  void clear_client_id();
  static const int kClientIdFieldNumber = 1;
  const ::std::string& client_id() const;
  void set_client_id(const ::std::string& value);
  void set_client_id(const char* value);
  void set_client_id(const char* value, size_t size);
  ::std::string* mutable_client_id();
  ::std::string* release_client_id();
  void set_allocated_client_id(::std::string* client_id);

  // required double duration = 2;
  bool has_duration() const;
  void clear_duration();
  static const int kDurationFieldNumber = 2;
  double duration() const;
  void set_duration(double value);

  // @@protoc_insertion_point(class_scope:mw.internal.robotics.gazebotransport.RequestCoSim)
 private:
  inline void set_has_client_id();
  inline void clear_has_client_id();
  inline void set_has_duration();
  inline void clear_has_duration();

  // helper for ByteSize()
  int RequiredFieldsByteSizeFallback() const;

  ::google::protobuf::internal::InternalMetadataWithArena _internal_metadata_;
  ::google::protobuf::uint32 _has_bits_[1];
  mutable int _cached_size_;
  ::google::protobuf::internal::ArenaStringPtr client_id_;
  double duration_;
  friend void  protobuf_AddDesc_mw_2einternal_2erobotics_2egazebotransport_2eCoSimMsgs_2eproto();
  friend void protobuf_AssignDesc_mw_2einternal_2erobotics_2egazebotransport_2eCoSimMsgs_2eproto();
  friend void protobuf_ShutdownFile_mw_2einternal_2erobotics_2egazebotransport_2eCoSimMsgs_2eproto();

  void InitAsDefaultInstance();
  static RequestCoSim* default_instance_;
};
// -------------------------------------------------------------------

class StopCoSim : public ::google::protobuf::Message /* @@protoc_insertion_point(class_definition:mw.internal.robotics.gazebotransport.StopCoSim) */ {
 public:
  StopCoSim();
  virtual ~StopCoSim();

  StopCoSim(const StopCoSim& from);

  inline StopCoSim& operator=(const StopCoSim& from) {
    CopyFrom(from);
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _internal_metadata_.unknown_fields();
  }

  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return _internal_metadata_.mutable_unknown_fields();
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const StopCoSim& default_instance();

  void Swap(StopCoSim* other);

  // implements Message ----------------------------------------------

  inline StopCoSim* New() const { return New(NULL); }

  StopCoSim* New(::google::protobuf::Arena* arena) const;
  void CopyFrom(const ::google::protobuf::Message& from);
  void MergeFrom(const ::google::protobuf::Message& from);
  void CopyFrom(const StopCoSim& from);
  void MergeFrom(const StopCoSim& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  ::google::protobuf::uint8* InternalSerializeWithCachedSizesToArray(
      bool deterministic, ::google::protobuf::uint8* output) const;
  ::google::protobuf::uint8* SerializeWithCachedSizesToArray(::google::protobuf::uint8* output) const {
    return InternalSerializeWithCachedSizesToArray(false, output);
  }
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  void InternalSwap(StopCoSim* other);
  private:
  inline ::google::protobuf::Arena* GetArenaNoVirtual() const {
    return _internal_metadata_.arena();
  }
  inline void* MaybeArenaPtr() const {
    return _internal_metadata_.raw_arena_ptr();
  }
  public:

  ::google::protobuf::Metadata GetMetadata() const;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // required string client_id = 1;
  bool has_client_id() const;
  void clear_client_id();
  static const int kClientIdFieldNumber = 1;
  const ::std::string& client_id() const;
  void set_client_id(const ::std::string& value);
  void set_client_id(const char* value);
  void set_client_id(const char* value, size_t size);
  ::std::string* mutable_client_id();
  ::std::string* release_client_id();
  void set_allocated_client_id(::std::string* client_id);

  // @@protoc_insertion_point(class_scope:mw.internal.robotics.gazebotransport.StopCoSim)
 private:
  inline void set_has_client_id();
  inline void clear_has_client_id();

  ::google::protobuf::internal::InternalMetadataWithArena _internal_metadata_;
  ::google::protobuf::uint32 _has_bits_[1];
  mutable int _cached_size_;
  ::google::protobuf::internal::ArenaStringPtr client_id_;
  friend void  protobuf_AddDesc_mw_2einternal_2erobotics_2egazebotransport_2eCoSimMsgs_2eproto();
  friend void protobuf_AssignDesc_mw_2einternal_2erobotics_2egazebotransport_2eCoSimMsgs_2eproto();
  friend void protobuf_ShutdownFile_mw_2einternal_2erobotics_2egazebotransport_2eCoSimMsgs_2eproto();

  void InitAsDefaultInstance();
  static StopCoSim* default_instance_;
};
// -------------------------------------------------------------------

class GetGroundTruthWorldPose : public ::google::protobuf::Message /* @@protoc_insertion_point(class_definition:mw.internal.robotics.gazebotransport.GetGroundTruthWorldPose) */ {
 public:
  GetGroundTruthWorldPose();
  virtual ~GetGroundTruthWorldPose();

  GetGroundTruthWorldPose(const GetGroundTruthWorldPose& from);

  inline GetGroundTruthWorldPose& operator=(const GetGroundTruthWorldPose& from) {
    CopyFrom(from);
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _internal_metadata_.unknown_fields();
  }

  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return _internal_metadata_.mutable_unknown_fields();
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const GetGroundTruthWorldPose& default_instance();

  void Swap(GetGroundTruthWorldPose* other);

  // implements Message ----------------------------------------------

  inline GetGroundTruthWorldPose* New() const { return New(NULL); }

  GetGroundTruthWorldPose* New(::google::protobuf::Arena* arena) const;
  void CopyFrom(const ::google::protobuf::Message& from);
  void MergeFrom(const ::google::protobuf::Message& from);
  void CopyFrom(const GetGroundTruthWorldPose& from);
  void MergeFrom(const GetGroundTruthWorldPose& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  ::google::protobuf::uint8* InternalSerializeWithCachedSizesToArray(
      bool deterministic, ::google::protobuf::uint8* output) const;
  ::google::protobuf::uint8* SerializeWithCachedSizesToArray(::google::protobuf::uint8* output) const {
    return InternalSerializeWithCachedSizesToArray(false, output);
  }
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  void InternalSwap(GetGroundTruthWorldPose* other);
  private:
  inline ::google::protobuf::Arena* GetArenaNoVirtual() const {
    return _internal_metadata_.arena();
  }
  inline void* MaybeArenaPtr() const {
    return _internal_metadata_.raw_arena_ptr();
  }
  public:

  ::google::protobuf::Metadata GetMetadata() const;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // required string model_name = 1;
  bool has_model_name() const;
  void clear_model_name();
  static const int kModelNameFieldNumber = 1;
  const ::std::string& model_name() const;
  void set_model_name(const ::std::string& value);
  void set_model_name(const char* value);
  void set_model_name(const char* value, size_t size);
  ::std::string* mutable_model_name();
  ::std::string* release_model_name();
  void set_allocated_model_name(::std::string* model_name);

  // required string link_name = 2;
  bool has_link_name() const;
  void clear_link_name();
  static const int kLinkNameFieldNumber = 2;
  const ::std::string& link_name() const;
  void set_link_name(const ::std::string& value);
  void set_link_name(const char* value);
  void set_link_name(const char* value, size_t size);
  ::std::string* mutable_link_name();
  ::std::string* release_link_name();
  void set_allocated_link_name(::std::string* link_name);

  // @@protoc_insertion_point(class_scope:mw.internal.robotics.gazebotransport.GetGroundTruthWorldPose)
 private:
  inline void set_has_model_name();
  inline void clear_has_model_name();
  inline void set_has_link_name();
  inline void clear_has_link_name();

  // helper for ByteSize()
  int RequiredFieldsByteSizeFallback() const;

  ::google::protobuf::internal::InternalMetadataWithArena _internal_metadata_;
  ::google::protobuf::uint32 _has_bits_[1];
  mutable int _cached_size_;
  ::google::protobuf::internal::ArenaStringPtr model_name_;
  ::google::protobuf::internal::ArenaStringPtr link_name_;
  friend void  protobuf_AddDesc_mw_2einternal_2erobotics_2egazebotransport_2eCoSimMsgs_2eproto();
  friend void protobuf_AssignDesc_mw_2einternal_2erobotics_2egazebotransport_2eCoSimMsgs_2eproto();
  friend void protobuf_ShutdownFile_mw_2einternal_2erobotics_2egazebotransport_2eCoSimMsgs_2eproto();

  void InitAsDefaultInstance();
  static GetGroundTruthWorldPose* default_instance_;
};
// -------------------------------------------------------------------

class Point : public ::google::protobuf::Message /* @@protoc_insertion_point(class_definition:mw.internal.robotics.gazebotransport.Point) */ {
 public:
  Point();
  virtual ~Point();

  Point(const Point& from);

  inline Point& operator=(const Point& from) {
    CopyFrom(from);
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _internal_metadata_.unknown_fields();
  }

  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return _internal_metadata_.mutable_unknown_fields();
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const Point& default_instance();

  void Swap(Point* other);

  // implements Message ----------------------------------------------

  inline Point* New() const { return New(NULL); }

  Point* New(::google::protobuf::Arena* arena) const;
  void CopyFrom(const ::google::protobuf::Message& from);
  void MergeFrom(const ::google::protobuf::Message& from);
  void CopyFrom(const Point& from);
  void MergeFrom(const Point& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  ::google::protobuf::uint8* InternalSerializeWithCachedSizesToArray(
      bool deterministic, ::google::protobuf::uint8* output) const;
  ::google::protobuf::uint8* SerializeWithCachedSizesToArray(::google::protobuf::uint8* output) const {
    return InternalSerializeWithCachedSizesToArray(false, output);
  }
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  void InternalSwap(Point* other);
  private:
  inline ::google::protobuf::Arena* GetArenaNoVirtual() const {
    return _internal_metadata_.arena();
  }
  inline void* MaybeArenaPtr() const {
    return _internal_metadata_.raw_arena_ptr();
  }
  public:

  ::google::protobuf::Metadata GetMetadata() const;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // required double x = 1;
  bool has_x() const;
  void clear_x();
  static const int kXFieldNumber = 1;
  double x() const;
  void set_x(double value);

  // required double y = 2;
  bool has_y() const;
  void clear_y();
  static const int kYFieldNumber = 2;
  double y() const;
  void set_y(double value);

  // required double z = 3;
  bool has_z() const;
  void clear_z();
  static const int kZFieldNumber = 3;
  double z() const;
  void set_z(double value);

  // @@protoc_insertion_point(class_scope:mw.internal.robotics.gazebotransport.Point)
 private:
  inline void set_has_x();
  inline void clear_has_x();
  inline void set_has_y();
  inline void clear_has_y();
  inline void set_has_z();
  inline void clear_has_z();

  // helper for ByteSize()
  int RequiredFieldsByteSizeFallback() const;

  ::google::protobuf::internal::InternalMetadataWithArena _internal_metadata_;
  ::google::protobuf::uint32 _has_bits_[1];
  mutable int _cached_size_;
  double x_;
  double y_;
  double z_;
  friend void  protobuf_AddDesc_mw_2einternal_2erobotics_2egazebotransport_2eCoSimMsgs_2eproto();
  friend void protobuf_AssignDesc_mw_2einternal_2erobotics_2egazebotransport_2eCoSimMsgs_2eproto();
  friend void protobuf_ShutdownFile_mw_2einternal_2erobotics_2egazebotransport_2eCoSimMsgs_2eproto();

  void InitAsDefaultInstance();
  static Point* default_instance_;
};
// -------------------------------------------------------------------

class Quaternion : public ::google::protobuf::Message /* @@protoc_insertion_point(class_definition:mw.internal.robotics.gazebotransport.Quaternion) */ {
 public:
  Quaternion();
  virtual ~Quaternion();

  Quaternion(const Quaternion& from);

  inline Quaternion& operator=(const Quaternion& from) {
    CopyFrom(from);
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _internal_metadata_.unknown_fields();
  }

  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return _internal_metadata_.mutable_unknown_fields();
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const Quaternion& default_instance();

  void Swap(Quaternion* other);

  // implements Message ----------------------------------------------

  inline Quaternion* New() const { return New(NULL); }

  Quaternion* New(::google::protobuf::Arena* arena) const;
  void CopyFrom(const ::google::protobuf::Message& from);
  void MergeFrom(const ::google::protobuf::Message& from);
  void CopyFrom(const Quaternion& from);
  void MergeFrom(const Quaternion& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  ::google::protobuf::uint8* InternalSerializeWithCachedSizesToArray(
      bool deterministic, ::google::protobuf::uint8* output) const;
  ::google::protobuf::uint8* SerializeWithCachedSizesToArray(::google::protobuf::uint8* output) const {
    return InternalSerializeWithCachedSizesToArray(false, output);
  }
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  void InternalSwap(Quaternion* other);
  private:
  inline ::google::protobuf::Arena* GetArenaNoVirtual() const {
    return _internal_metadata_.arena();
  }
  inline void* MaybeArenaPtr() const {
    return _internal_metadata_.raw_arena_ptr();
  }
  public:

  ::google::protobuf::Metadata GetMetadata() const;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // required double x = 1;
  bool has_x() const;
  void clear_x();
  static const int kXFieldNumber = 1;
  double x() const;
  void set_x(double value);

  // required double y = 2;
  bool has_y() const;
  void clear_y();
  static const int kYFieldNumber = 2;
  double y() const;
  void set_y(double value);

  // required double z = 3;
  bool has_z() const;
  void clear_z();
  static const int kZFieldNumber = 3;
  double z() const;
  void set_z(double value);

  // required double w = 4;
  bool has_w() const;
  void clear_w();
  static const int kWFieldNumber = 4;
  double w() const;
  void set_w(double value);

  // @@protoc_insertion_point(class_scope:mw.internal.robotics.gazebotransport.Quaternion)
 private:
  inline void set_has_x();
  inline void clear_has_x();
  inline void set_has_y();
  inline void clear_has_y();
  inline void set_has_z();
  inline void clear_has_z();
  inline void set_has_w();
  inline void clear_has_w();

  // helper for ByteSize()
  int RequiredFieldsByteSizeFallback() const;

  ::google::protobuf::internal::InternalMetadataWithArena _internal_metadata_;
  ::google::protobuf::uint32 _has_bits_[1];
  mutable int _cached_size_;
  double x_;
  double y_;
  double z_;
  double w_;
  friend void  protobuf_AddDesc_mw_2einternal_2erobotics_2egazebotransport_2eCoSimMsgs_2eproto();
  friend void protobuf_AssignDesc_mw_2einternal_2erobotics_2egazebotransport_2eCoSimMsgs_2eproto();
  friend void protobuf_ShutdownFile_mw_2einternal_2erobotics_2egazebotransport_2eCoSimMsgs_2eproto();

  void InitAsDefaultInstance();
  static Quaternion* default_instance_;
};
// -------------------------------------------------------------------

class Pose : public ::google::protobuf::Message /* @@protoc_insertion_point(class_definition:mw.internal.robotics.gazebotransport.Pose) */ {
 public:
  Pose();
  virtual ~Pose();

  Pose(const Pose& from);

  inline Pose& operator=(const Pose& from) {
    CopyFrom(from);
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _internal_metadata_.unknown_fields();
  }

  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return _internal_metadata_.mutable_unknown_fields();
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const Pose& default_instance();

  void Swap(Pose* other);

  // implements Message ----------------------------------------------

  inline Pose* New() const { return New(NULL); }

  Pose* New(::google::protobuf::Arena* arena) const;
  void CopyFrom(const ::google::protobuf::Message& from);
  void MergeFrom(const ::google::protobuf::Message& from);
  void CopyFrom(const Pose& from);
  void MergeFrom(const Pose& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  ::google::protobuf::uint8* InternalSerializeWithCachedSizesToArray(
      bool deterministic, ::google::protobuf::uint8* output) const;
  ::google::protobuf::uint8* SerializeWithCachedSizesToArray(::google::protobuf::uint8* output) const {
    return InternalSerializeWithCachedSizesToArray(false, output);
  }
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  void InternalSwap(Pose* other);
  private:
  inline ::google::protobuf::Arena* GetArenaNoVirtual() const {
    return _internal_metadata_.arena();
  }
  inline void* MaybeArenaPtr() const {
    return _internal_metadata_.raw_arena_ptr();
  }
  public:

  ::google::protobuf::Metadata GetMetadata() const;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // required .mw.internal.robotics.gazebotransport.Point position = 1;
  bool has_position() const;
  void clear_position();
  static const int kPositionFieldNumber = 1;
  const ::mw::internal::robotics::gazebotransport::Point& position() const;
  ::mw::internal::robotics::gazebotransport::Point* mutable_position();
  ::mw::internal::robotics::gazebotransport::Point* release_position();
  void set_allocated_position(::mw::internal::robotics::gazebotransport::Point* position);

  // required .mw.internal.robotics.gazebotransport.Quaternion orientation = 2;
  bool has_orientation() const;
  void clear_orientation();
  static const int kOrientationFieldNumber = 2;
  const ::mw::internal::robotics::gazebotransport::Quaternion& orientation() const;
  ::mw::internal::robotics::gazebotransport::Quaternion* mutable_orientation();
  ::mw::internal::robotics::gazebotransport::Quaternion* release_orientation();
  void set_allocated_orientation(::mw::internal::robotics::gazebotransport::Quaternion* orientation);

  // @@protoc_insertion_point(class_scope:mw.internal.robotics.gazebotransport.Pose)
 private:
  inline void set_has_position();
  inline void clear_has_position();
  inline void set_has_orientation();
  inline void clear_has_orientation();

  // helper for ByteSize()
  int RequiredFieldsByteSizeFallback() const;

  ::google::protobuf::internal::InternalMetadataWithArena _internal_metadata_;
  ::google::protobuf::uint32 _has_bits_[1];
  mutable int _cached_size_;
  ::mw::internal::robotics::gazebotransport::Point* position_;
  ::mw::internal::robotics::gazebotransport::Quaternion* orientation_;
  friend void  protobuf_AddDesc_mw_2einternal_2erobotics_2egazebotransport_2eCoSimMsgs_2eproto();
  friend void protobuf_AssignDesc_mw_2einternal_2erobotics_2egazebotransport_2eCoSimMsgs_2eproto();
  friend void protobuf_ShutdownFile_mw_2einternal_2erobotics_2egazebotransport_2eCoSimMsgs_2eproto();

  void InitAsDefaultInstance();
  static Pose* default_instance_;
};
// -------------------------------------------------------------------

class StopSimulation : public ::google::protobuf::Message /* @@protoc_insertion_point(class_definition:mw.internal.robotics.gazebotransport.StopSimulation) */ {
 public:
  StopSimulation();
  virtual ~StopSimulation();

  StopSimulation(const StopSimulation& from);

  inline StopSimulation& operator=(const StopSimulation& from) {
    CopyFrom(from);
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _internal_metadata_.unknown_fields();
  }

  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return _internal_metadata_.mutable_unknown_fields();
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const StopSimulation& default_instance();

  void Swap(StopSimulation* other);

  // implements Message ----------------------------------------------

  inline StopSimulation* New() const { return New(NULL); }

  StopSimulation* New(::google::protobuf::Arena* arena) const;
  void CopyFrom(const ::google::protobuf::Message& from);
  void MergeFrom(const ::google::protobuf::Message& from);
  void CopyFrom(const StopSimulation& from);
  void MergeFrom(const StopSimulation& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  ::google::protobuf::uint8* InternalSerializeWithCachedSizesToArray(
      bool deterministic, ::google::protobuf::uint8* output) const;
  ::google::protobuf::uint8* SerializeWithCachedSizesToArray(::google::protobuf::uint8* output) const {
    return InternalSerializeWithCachedSizesToArray(false, output);
  }
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  void InternalSwap(StopSimulation* other);
  private:
  inline ::google::protobuf::Arena* GetArenaNoVirtual() const {
    return _internal_metadata_.arena();
  }
  inline void* MaybeArenaPtr() const {
    return _internal_metadata_.raw_arena_ptr();
  }
  public:

  ::google::protobuf::Metadata GetMetadata() const;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // required bool stop_scene = 1;
  bool has_stop_scene() const;
  void clear_stop_scene();
  static const int kStopSceneFieldNumber = 1;
  bool stop_scene() const;
  void set_stop_scene(bool value);

  // @@protoc_insertion_point(class_scope:mw.internal.robotics.gazebotransport.StopSimulation)
 private:
  inline void set_has_stop_scene();
  inline void clear_has_stop_scene();

  ::google::protobuf::internal::InternalMetadataWithArena _internal_metadata_;
  ::google::protobuf::uint32 _has_bits_[1];
  mutable int _cached_size_;
  bool stop_scene_;
  friend void  protobuf_AddDesc_mw_2einternal_2erobotics_2egazebotransport_2eCoSimMsgs_2eproto();
  friend void protobuf_AssignDesc_mw_2einternal_2erobotics_2egazebotransport_2eCoSimMsgs_2eproto();
  friend void protobuf_ShutdownFile_mw_2einternal_2erobotics_2egazebotransport_2eCoSimMsgs_2eproto();

  void InitAsDefaultInstance();
  static StopSimulation* default_instance_;
};
// -------------------------------------------------------------------

class LaserData : public ::google::protobuf::Message /* @@protoc_insertion_point(class_definition:mw.internal.robotics.gazebotransport.LaserData) */ {
 public:
  LaserData();
  virtual ~LaserData();

  LaserData(const LaserData& from);

  inline LaserData& operator=(const LaserData& from) {
    CopyFrom(from);
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _internal_metadata_.unknown_fields();
  }

  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return _internal_metadata_.mutable_unknown_fields();
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const LaserData& default_instance();

  void Swap(LaserData* other);

  // implements Message ----------------------------------------------

  inline LaserData* New() const { return New(NULL); }

  LaserData* New(::google::protobuf::Arena* arena) const;
  void CopyFrom(const ::google::protobuf::Message& from);
  void MergeFrom(const ::google::protobuf::Message& from);
  void CopyFrom(const LaserData& from);
  void MergeFrom(const LaserData& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  ::google::protobuf::uint8* InternalSerializeWithCachedSizesToArray(
      bool deterministic, ::google::protobuf::uint8* output) const;
  ::google::protobuf::uint8* SerializeWithCachedSizesToArray(::google::protobuf::uint8* output) const {
    return InternalSerializeWithCachedSizesToArray(false, output);
  }
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  void InternalSwap(LaserData* other);
  private:
  inline ::google::protobuf::Arena* GetArenaNoVirtual() const {
    return _internal_metadata_.arena();
  }
  inline void* MaybeArenaPtr() const {
    return _internal_metadata_.raw_arena_ptr();
  }
  public:

  ::google::protobuf::Metadata GetMetadata() const;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // required double angle_min = 1;
  bool has_angle_min() const;
  void clear_angle_min();
  static const int kAngleMinFieldNumber = 1;
  double angle_min() const;
  void set_angle_min(double value);

  // required double angle_max = 2;
  bool has_angle_max() const;
  void clear_angle_max();
  static const int kAngleMaxFieldNumber = 2;
  double angle_max() const;
  void set_angle_max(double value);

  // required double angle_step = 3;
  bool has_angle_step() const;
  void clear_angle_step();
  static const int kAngleStepFieldNumber = 3;
  double angle_step() const;
  void set_angle_step(double value);

  // required double range_min = 4;
  bool has_range_min() const;
  void clear_range_min();
  static const int kRangeMinFieldNumber = 4;
  double range_min() const;
  void set_range_min(double value);

  // required double range_max = 5;
  bool has_range_max() const;
  void clear_range_max();
  static const int kRangeMaxFieldNumber = 5;
  double range_max() const;
  void set_range_max(double value);

  // required double count = 6;
  bool has_count() const;
  void clear_count();
  static const int kCountFieldNumber = 6;
  double count() const;
  void set_count(double value);

  // required double vertical_angle_min = 7;
  bool has_vertical_angle_min() const;
  void clear_vertical_angle_min();
  static const int kVerticalAngleMinFieldNumber = 7;
  double vertical_angle_min() const;
  void set_vertical_angle_min(double value);

  // required double vertical_angle_max = 8;
  bool has_vertical_angle_max() const;
  void clear_vertical_angle_max();
  static const int kVerticalAngleMaxFieldNumber = 8;
  double vertical_angle_max() const;
  void set_vertical_angle_max(double value);

  // required double vertical_angle_step = 9;
  bool has_vertical_angle_step() const;
  void clear_vertical_angle_step();
  static const int kVerticalAngleStepFieldNumber = 9;
  double vertical_angle_step() const;
  void set_vertical_angle_step(double value);

  // repeated double range = 10;
  int range_size() const;
  void clear_range();
  static const int kRangeFieldNumber = 10;
  double range(int index) const;
  void set_range(int index, double value);
  void add_range(double value);
  const ::google::protobuf::RepeatedField< double >&
      range() const;
  ::google::protobuf::RepeatedField< double >*
      mutable_range();

  // repeated double intensities = 11;
  int intensities_size() const;
  void clear_intensities();
  static const int kIntensitiesFieldNumber = 11;
  double intensities(int index) const;
  void set_intensities(int index, double value);
  void add_intensities(double value);
  const ::google::protobuf::RepeatedField< double >&
      intensities() const;
  ::google::protobuf::RepeatedField< double >*
      mutable_intensities();

  // @@protoc_insertion_point(class_scope:mw.internal.robotics.gazebotransport.LaserData)
 private:
  inline void set_has_angle_min();
  inline void clear_has_angle_min();
  inline void set_has_angle_max();
  inline void clear_has_angle_max();
  inline void set_has_angle_step();
  inline void clear_has_angle_step();
  inline void set_has_range_min();
  inline void clear_has_range_min();
  inline void set_has_range_max();
  inline void clear_has_range_max();
  inline void set_has_count();
  inline void clear_has_count();
  inline void set_has_vertical_angle_min();
  inline void clear_has_vertical_angle_min();
  inline void set_has_vertical_angle_max();
  inline void clear_has_vertical_angle_max();
  inline void set_has_vertical_angle_step();
  inline void clear_has_vertical_angle_step();

  // helper for ByteSize()
  int RequiredFieldsByteSizeFallback() const;

  ::google::protobuf::internal::InternalMetadataWithArena _internal_metadata_;
  ::google::protobuf::uint32 _has_bits_[1];
  mutable int _cached_size_;
  double angle_min_;
  double angle_max_;
  double angle_step_;
  double range_min_;
  double range_max_;
  double count_;
  double vertical_angle_min_;
  double vertical_angle_max_;
  double vertical_angle_step_;
  ::google::protobuf::RepeatedField< double > range_;
  ::google::protobuf::RepeatedField< double > intensities_;
  friend void  protobuf_AddDesc_mw_2einternal_2erobotics_2egazebotransport_2eCoSimMsgs_2eproto();
  friend void protobuf_AssignDesc_mw_2einternal_2erobotics_2egazebotransport_2eCoSimMsgs_2eproto();
  friend void protobuf_ShutdownFile_mw_2einternal_2erobotics_2egazebotransport_2eCoSimMsgs_2eproto();

  void InitAsDefaultInstance();
  static LaserData* default_instance_;
};
// -------------------------------------------------------------------

class RequestLaser : public ::google::protobuf::Message /* @@protoc_insertion_point(class_definition:mw.internal.robotics.gazebotransport.RequestLaser) */ {
 public:
  RequestLaser();
  virtual ~RequestLaser();

  RequestLaser(const RequestLaser& from);

  inline RequestLaser& operator=(const RequestLaser& from) {
    CopyFrom(from);
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _internal_metadata_.unknown_fields();
  }

  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return _internal_metadata_.mutable_unknown_fields();
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const RequestLaser& default_instance();

  void Swap(RequestLaser* other);

  // implements Message ----------------------------------------------

  inline RequestLaser* New() const { return New(NULL); }

  RequestLaser* New(::google::protobuf::Arena* arena) const;
  void CopyFrom(const ::google::protobuf::Message& from);
  void MergeFrom(const ::google::protobuf::Message& from);
  void CopyFrom(const RequestLaser& from);
  void MergeFrom(const RequestLaser& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  ::google::protobuf::uint8* InternalSerializeWithCachedSizesToArray(
      bool deterministic, ::google::protobuf::uint8* output) const;
  ::google::protobuf::uint8* SerializeWithCachedSizesToArray(::google::protobuf::uint8* output) const {
    return InternalSerializeWithCachedSizesToArray(false, output);
  }
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  void InternalSwap(RequestLaser* other);
  private:
  inline ::google::protobuf::Arena* GetArenaNoVirtual() const {
    return _internal_metadata_.arena();
  }
  inline void* MaybeArenaPtr() const {
    return _internal_metadata_.raw_arena_ptr();
  }
  public:

  ::google::protobuf::Metadata GetMetadata() const;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // required string topic_name = 1;
  bool has_topic_name() const;
  void clear_topic_name();
  static const int kTopicNameFieldNumber = 1;
  const ::std::string& topic_name() const;
  void set_topic_name(const ::std::string& value);
  void set_topic_name(const char* value);
  void set_topic_name(const char* value, size_t size);
  ::std::string* mutable_topic_name();
  ::std::string* release_topic_name();
  void set_allocated_topic_name(::std::string* topic_name);

  // @@protoc_insertion_point(class_scope:mw.internal.robotics.gazebotransport.RequestLaser)
 private:
  inline void set_has_topic_name();
  inline void clear_has_topic_name();

  ::google::protobuf::internal::InternalMetadataWithArena _internal_metadata_;
  ::google::protobuf::uint32 _has_bits_[1];
  mutable int _cached_size_;
  ::google::protobuf::internal::ArenaStringPtr topic_name_;
  friend void  protobuf_AddDesc_mw_2einternal_2erobotics_2egazebotransport_2eCoSimMsgs_2eproto();
  friend void protobuf_AssignDesc_mw_2einternal_2erobotics_2egazebotransport_2eCoSimMsgs_2eproto();
  friend void protobuf_ShutdownFile_mw_2einternal_2erobotics_2egazebotransport_2eCoSimMsgs_2eproto();

  void InitAsDefaultInstance();
  static RequestLaser* default_instance_;
};
// -------------------------------------------------------------------

class ImuData : public ::google::protobuf::Message /* @@protoc_insertion_point(class_definition:mw.internal.robotics.gazebotransport.ImuData) */ {
 public:
  ImuData();
  virtual ~ImuData();

  ImuData(const ImuData& from);

  inline ImuData& operator=(const ImuData& from) {
    CopyFrom(from);
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _internal_metadata_.unknown_fields();
  }

  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return _internal_metadata_.mutable_unknown_fields();
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const ImuData& default_instance();

  void Swap(ImuData* other);

  // implements Message ----------------------------------------------

  inline ImuData* New() const { return New(NULL); }

  ImuData* New(::google::protobuf::Arena* arena) const;
  void CopyFrom(const ::google::protobuf::Message& from);
  void MergeFrom(const ::google::protobuf::Message& from);
  void CopyFrom(const ImuData& from);
  void MergeFrom(const ImuData& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  ::google::protobuf::uint8* InternalSerializeWithCachedSizesToArray(
      bool deterministic, ::google::protobuf::uint8* output) const;
  ::google::protobuf::uint8* SerializeWithCachedSizesToArray(::google::protobuf::uint8* output) const {
    return InternalSerializeWithCachedSizesToArray(false, output);
  }
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  void InternalSwap(ImuData* other);
  private:
  inline ::google::protobuf::Arena* GetArenaNoVirtual() const {
    return _internal_metadata_.arena();
  }
  inline void* MaybeArenaPtr() const {
    return _internal_metadata_.raw_arena_ptr();
  }
  public:

  ::google::protobuf::Metadata GetMetadata() const;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // required .mw.internal.robotics.gazebotransport.Point linear_acceleration = 1;
  bool has_linear_acceleration() const;
  void clear_linear_acceleration();
  static const int kLinearAccelerationFieldNumber = 1;
  const ::mw::internal::robotics::gazebotransport::Point& linear_acceleration() const;
  ::mw::internal::robotics::gazebotransport::Point* mutable_linear_acceleration();
  ::mw::internal::robotics::gazebotransport::Point* release_linear_acceleration();
  void set_allocated_linear_acceleration(::mw::internal::robotics::gazebotransport::Point* linear_acceleration);

  // required .mw.internal.robotics.gazebotransport.Point angular_velocity = 2;
  bool has_angular_velocity() const;
  void clear_angular_velocity();
  static const int kAngularVelocityFieldNumber = 2;
  const ::mw::internal::robotics::gazebotransport::Point& angular_velocity() const;
  ::mw::internal::robotics::gazebotransport::Point* mutable_angular_velocity();
  ::mw::internal::robotics::gazebotransport::Point* release_angular_velocity();
  void set_allocated_angular_velocity(::mw::internal::robotics::gazebotransport::Point* angular_velocity);

  // required .mw.internal.robotics.gazebotransport.Quaternion orientation = 3;
  bool has_orientation() const;
  void clear_orientation();
  static const int kOrientationFieldNumber = 3;
  const ::mw::internal::robotics::gazebotransport::Quaternion& orientation() const;
  ::mw::internal::robotics::gazebotransport::Quaternion* mutable_orientation();
  ::mw::internal::robotics::gazebotransport::Quaternion* release_orientation();
  void set_allocated_orientation(::mw::internal::robotics::gazebotransport::Quaternion* orientation);

  // @@protoc_insertion_point(class_scope:mw.internal.robotics.gazebotransport.ImuData)
 private:
  inline void set_has_linear_acceleration();
  inline void clear_has_linear_acceleration();
  inline void set_has_angular_velocity();
  inline void clear_has_angular_velocity();
  inline void set_has_orientation();
  inline void clear_has_orientation();

  // helper for ByteSize()
  int RequiredFieldsByteSizeFallback() const;

  ::google::protobuf::internal::InternalMetadataWithArena _internal_metadata_;
  ::google::protobuf::uint32 _has_bits_[1];
  mutable int _cached_size_;
  ::mw::internal::robotics::gazebotransport::Point* linear_acceleration_;
  ::mw::internal::robotics::gazebotransport::Point* angular_velocity_;
  ::mw::internal::robotics::gazebotransport::Quaternion* orientation_;
  friend void  protobuf_AddDesc_mw_2einternal_2erobotics_2egazebotransport_2eCoSimMsgs_2eproto();
  friend void protobuf_AssignDesc_mw_2einternal_2erobotics_2egazebotransport_2eCoSimMsgs_2eproto();
  friend void protobuf_ShutdownFile_mw_2einternal_2erobotics_2egazebotransport_2eCoSimMsgs_2eproto();

  void InitAsDefaultInstance();
  static ImuData* default_instance_;
};
// -------------------------------------------------------------------

class RequestImu : public ::google::protobuf::Message /* @@protoc_insertion_point(class_definition:mw.internal.robotics.gazebotransport.RequestImu) */ {
 public:
  RequestImu();
  virtual ~RequestImu();

  RequestImu(const RequestImu& from);

  inline RequestImu& operator=(const RequestImu& from) {
    CopyFrom(from);
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _internal_metadata_.unknown_fields();
  }

  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return _internal_metadata_.mutable_unknown_fields();
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const RequestImu& default_instance();

  void Swap(RequestImu* other);

  // implements Message ----------------------------------------------

  inline RequestImu* New() const { return New(NULL); }

  RequestImu* New(::google::protobuf::Arena* arena) const;
  void CopyFrom(const ::google::protobuf::Message& from);
  void MergeFrom(const ::google::protobuf::Message& from);
  void CopyFrom(const RequestImu& from);
  void MergeFrom(const RequestImu& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  ::google::protobuf::uint8* InternalSerializeWithCachedSizesToArray(
      bool deterministic, ::google::protobuf::uint8* output) const;
  ::google::protobuf::uint8* SerializeWithCachedSizesToArray(::google::protobuf::uint8* output) const {
    return InternalSerializeWithCachedSizesToArray(false, output);
  }
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  void InternalSwap(RequestImu* other);
  private:
  inline ::google::protobuf::Arena* GetArenaNoVirtual() const {
    return _internal_metadata_.arena();
  }
  inline void* MaybeArenaPtr() const {
    return _internal_metadata_.raw_arena_ptr();
  }
  public:

  ::google::protobuf::Metadata GetMetadata() const;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // required string topic_name = 1;
  bool has_topic_name() const;
  void clear_topic_name();
  static const int kTopicNameFieldNumber = 1;
  const ::std::string& topic_name() const;
  void set_topic_name(const ::std::string& value);
  void set_topic_name(const char* value);
  void set_topic_name(const char* value, size_t size);
  ::std::string* mutable_topic_name();
  ::std::string* release_topic_name();
  void set_allocated_topic_name(::std::string* topic_name);

  // @@protoc_insertion_point(class_scope:mw.internal.robotics.gazebotransport.RequestImu)
 private:
  inline void set_has_topic_name();
  inline void clear_has_topic_name();

  ::google::protobuf::internal::InternalMetadataWithArena _internal_metadata_;
  ::google::protobuf::uint32 _has_bits_[1];
  mutable int _cached_size_;
  ::google::protobuf::internal::ArenaStringPtr topic_name_;
  friend void  protobuf_AddDesc_mw_2einternal_2erobotics_2egazebotransport_2eCoSimMsgs_2eproto();
  friend void protobuf_AssignDesc_mw_2einternal_2erobotics_2egazebotransport_2eCoSimMsgs_2eproto();
  friend void protobuf_ShutdownFile_mw_2einternal_2erobotics_2egazebotransport_2eCoSimMsgs_2eproto();

  void InitAsDefaultInstance();
  static RequestImu* default_instance_;
};
// -------------------------------------------------------------------

class SubscribeImage : public ::google::protobuf::Message /* @@protoc_insertion_point(class_definition:mw.internal.robotics.gazebotransport.SubscribeImage) */ {
 public:
  SubscribeImage();
  virtual ~SubscribeImage();

  SubscribeImage(const SubscribeImage& from);

  inline SubscribeImage& operator=(const SubscribeImage& from) {
    CopyFrom(from);
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _internal_metadata_.unknown_fields();
  }

  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return _internal_metadata_.mutable_unknown_fields();
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const SubscribeImage& default_instance();

  void Swap(SubscribeImage* other);

  // implements Message ----------------------------------------------

  inline SubscribeImage* New() const { return New(NULL); }

  SubscribeImage* New(::google::protobuf::Arena* arena) const;
  void CopyFrom(const ::google::protobuf::Message& from);
  void MergeFrom(const ::google::protobuf::Message& from);
  void CopyFrom(const SubscribeImage& from);
  void MergeFrom(const SubscribeImage& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  ::google::protobuf::uint8* InternalSerializeWithCachedSizesToArray(
      bool deterministic, ::google::protobuf::uint8* output) const;
  ::google::protobuf::uint8* SerializeWithCachedSizesToArray(::google::protobuf::uint8* output) const {
    return InternalSerializeWithCachedSizesToArray(false, output);
  }
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  void InternalSwap(SubscribeImage* other);
  private:
  inline ::google::protobuf::Arena* GetArenaNoVirtual() const {
    return _internal_metadata_.arena();
  }
  inline void* MaybeArenaPtr() const {
    return _internal_metadata_.raw_arena_ptr();
  }
  public:

  ::google::protobuf::Metadata GetMetadata() const;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // required string topic_name = 1;
  bool has_topic_name() const;
  void clear_topic_name();
  static const int kTopicNameFieldNumber = 1;
  const ::std::string& topic_name() const;
  void set_topic_name(const ::std::string& value);
  void set_topic_name(const char* value);
  void set_topic_name(const char* value, size_t size);
  ::std::string* mutable_topic_name();
  ::std::string* release_topic_name();
  void set_allocated_topic_name(::std::string* topic_name);

  // @@protoc_insertion_point(class_scope:mw.internal.robotics.gazebotransport.SubscribeImage)
 private:
  inline void set_has_topic_name();
  inline void clear_has_topic_name();

  ::google::protobuf::internal::InternalMetadataWithArena _internal_metadata_;
  ::google::protobuf::uint32 _has_bits_[1];
  mutable int _cached_size_;
  ::google::protobuf::internal::ArenaStringPtr topic_name_;
  friend void  protobuf_AddDesc_mw_2einternal_2erobotics_2egazebotransport_2eCoSimMsgs_2eproto();
  friend void protobuf_AssignDesc_mw_2einternal_2erobotics_2egazebotransport_2eCoSimMsgs_2eproto();
  friend void protobuf_ShutdownFile_mw_2einternal_2erobotics_2egazebotransport_2eCoSimMsgs_2eproto();

  void InitAsDefaultInstance();
  static SubscribeImage* default_instance_;
};
// -------------------------------------------------------------------

class SubscribeLaser : public ::google::protobuf::Message /* @@protoc_insertion_point(class_definition:mw.internal.robotics.gazebotransport.SubscribeLaser) */ {
 public:
  SubscribeLaser();
  virtual ~SubscribeLaser();

  SubscribeLaser(const SubscribeLaser& from);

  inline SubscribeLaser& operator=(const SubscribeLaser& from) {
    CopyFrom(from);
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _internal_metadata_.unknown_fields();
  }

  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return _internal_metadata_.mutable_unknown_fields();
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const SubscribeLaser& default_instance();

  void Swap(SubscribeLaser* other);

  // implements Message ----------------------------------------------

  inline SubscribeLaser* New() const { return New(NULL); }

  SubscribeLaser* New(::google::protobuf::Arena* arena) const;
  void CopyFrom(const ::google::protobuf::Message& from);
  void MergeFrom(const ::google::protobuf::Message& from);
  void CopyFrom(const SubscribeLaser& from);
  void MergeFrom(const SubscribeLaser& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  ::google::protobuf::uint8* InternalSerializeWithCachedSizesToArray(
      bool deterministic, ::google::protobuf::uint8* output) const;
  ::google::protobuf::uint8* SerializeWithCachedSizesToArray(::google::protobuf::uint8* output) const {
    return InternalSerializeWithCachedSizesToArray(false, output);
  }
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  void InternalSwap(SubscribeLaser* other);
  private:
  inline ::google::protobuf::Arena* GetArenaNoVirtual() const {
    return _internal_metadata_.arena();
  }
  inline void* MaybeArenaPtr() const {
    return _internal_metadata_.raw_arena_ptr();
  }
  public:

  ::google::protobuf::Metadata GetMetadata() const;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // required string topic_name = 1;
  bool has_topic_name() const;
  void clear_topic_name();
  static const int kTopicNameFieldNumber = 1;
  const ::std::string& topic_name() const;
  void set_topic_name(const ::std::string& value);
  void set_topic_name(const char* value);
  void set_topic_name(const char* value, size_t size);
  ::std::string* mutable_topic_name();
  ::std::string* release_topic_name();
  void set_allocated_topic_name(::std::string* topic_name);

  // @@protoc_insertion_point(class_scope:mw.internal.robotics.gazebotransport.SubscribeLaser)
 private:
  inline void set_has_topic_name();
  inline void clear_has_topic_name();

  ::google::protobuf::internal::InternalMetadataWithArena _internal_metadata_;
  ::google::protobuf::uint32 _has_bits_[1];
  mutable int _cached_size_;
  ::google::protobuf::internal::ArenaStringPtr topic_name_;
  friend void  protobuf_AddDesc_mw_2einternal_2erobotics_2egazebotransport_2eCoSimMsgs_2eproto();
  friend void protobuf_AssignDesc_mw_2einternal_2erobotics_2egazebotransport_2eCoSimMsgs_2eproto();
  friend void protobuf_ShutdownFile_mw_2einternal_2erobotics_2egazebotransport_2eCoSimMsgs_2eproto();

  void InitAsDefaultInstance();
  static SubscribeLaser* default_instance_;
};
// -------------------------------------------------------------------

class SubscribeImu : public ::google::protobuf::Message /* @@protoc_insertion_point(class_definition:mw.internal.robotics.gazebotransport.SubscribeImu) */ {
 public:
  SubscribeImu();
  virtual ~SubscribeImu();

  SubscribeImu(const SubscribeImu& from);

  inline SubscribeImu& operator=(const SubscribeImu& from) {
    CopyFrom(from);
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _internal_metadata_.unknown_fields();
  }

  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return _internal_metadata_.mutable_unknown_fields();
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const SubscribeImu& default_instance();

  void Swap(SubscribeImu* other);

  // implements Message ----------------------------------------------

  inline SubscribeImu* New() const { return New(NULL); }

  SubscribeImu* New(::google::protobuf::Arena* arena) const;
  void CopyFrom(const ::google::protobuf::Message& from);
  void MergeFrom(const ::google::protobuf::Message& from);
  void CopyFrom(const SubscribeImu& from);
  void MergeFrom(const SubscribeImu& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  ::google::protobuf::uint8* InternalSerializeWithCachedSizesToArray(
      bool deterministic, ::google::protobuf::uint8* output) const;
  ::google::protobuf::uint8* SerializeWithCachedSizesToArray(::google::protobuf::uint8* output) const {
    return InternalSerializeWithCachedSizesToArray(false, output);
  }
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  void InternalSwap(SubscribeImu* other);
  private:
  inline ::google::protobuf::Arena* GetArenaNoVirtual() const {
    return _internal_metadata_.arena();
  }
  inline void* MaybeArenaPtr() const {
    return _internal_metadata_.raw_arena_ptr();
  }
  public:

  ::google::protobuf::Metadata GetMetadata() const;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // required string topic_name = 1;
  bool has_topic_name() const;
  void clear_topic_name();
  static const int kTopicNameFieldNumber = 1;
  const ::std::string& topic_name() const;
  void set_topic_name(const ::std::string& value);
  void set_topic_name(const char* value);
  void set_topic_name(const char* value, size_t size);
  ::std::string* mutable_topic_name();
  ::std::string* release_topic_name();
  void set_allocated_topic_name(::std::string* topic_name);

  // @@protoc_insertion_point(class_scope:mw.internal.robotics.gazebotransport.SubscribeImu)
 private:
  inline void set_has_topic_name();
  inline void clear_has_topic_name();

  ::google::protobuf::internal::InternalMetadataWithArena _internal_metadata_;
  ::google::protobuf::uint32 _has_bits_[1];
  mutable int _cached_size_;
  ::google::protobuf::internal::ArenaStringPtr topic_name_;
  friend void  protobuf_AddDesc_mw_2einternal_2erobotics_2egazebotransport_2eCoSimMsgs_2eproto();
  friend void protobuf_AssignDesc_mw_2einternal_2erobotics_2egazebotransport_2eCoSimMsgs_2eproto();
  friend void protobuf_ShutdownFile_mw_2einternal_2erobotics_2egazebotransport_2eCoSimMsgs_2eproto();

  void InitAsDefaultInstance();
  static SubscribeImu* default_instance_;
};
// -------------------------------------------------------------------

class ApplyLinkWrench : public ::google::protobuf::Message /* @@protoc_insertion_point(class_definition:mw.internal.robotics.gazebotransport.ApplyLinkWrench) */ {
 public:
  ApplyLinkWrench();
  virtual ~ApplyLinkWrench();

  ApplyLinkWrench(const ApplyLinkWrench& from);

  inline ApplyLinkWrench& operator=(const ApplyLinkWrench& from) {
    CopyFrom(from);
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _internal_metadata_.unknown_fields();
  }

  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return _internal_metadata_.mutable_unknown_fields();
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const ApplyLinkWrench& default_instance();

  void Swap(ApplyLinkWrench* other);

  // implements Message ----------------------------------------------

  inline ApplyLinkWrench* New() const { return New(NULL); }

  ApplyLinkWrench* New(::google::protobuf::Arena* arena) const;
  void CopyFrom(const ::google::protobuf::Message& from);
  void MergeFrom(const ::google::protobuf::Message& from);
  void CopyFrom(const ApplyLinkWrench& from);
  void MergeFrom(const ApplyLinkWrench& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  ::google::protobuf::uint8* InternalSerializeWithCachedSizesToArray(
      bool deterministic, ::google::protobuf::uint8* output) const;
  ::google::protobuf::uint8* SerializeWithCachedSizesToArray(::google::protobuf::uint8* output) const {
    return InternalSerializeWithCachedSizesToArray(false, output);
  }
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  void InternalSwap(ApplyLinkWrench* other);
  private:
  inline ::google::protobuf::Arena* GetArenaNoVirtual() const {
    return _internal_metadata_.arena();
  }
  inline void* MaybeArenaPtr() const {
    return _internal_metadata_.raw_arena_ptr();
  }
  public:

  ::google::protobuf::Metadata GetMetadata() const;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // required string model_name = 1;
  bool has_model_name() const;
  void clear_model_name();
  static const int kModelNameFieldNumber = 1;
  const ::std::string& model_name() const;
  void set_model_name(const ::std::string& value);
  void set_model_name(const char* value);
  void set_model_name(const char* value, size_t size);
  ::std::string* mutable_model_name();
  ::std::string* release_model_name();
  void set_allocated_model_name(::std::string* model_name);

  // required string link_name = 2;
  bool has_link_name() const;
  void clear_link_name();
  static const int kLinkNameFieldNumber = 2;
  const ::std::string& link_name() const;
  void set_link_name(const ::std::string& value);
  void set_link_name(const char* value);
  void set_link_name(const char* value, size_t size);
  ::std::string* mutable_link_name();
  ::std::string* release_link_name();
  void set_allocated_link_name(::std::string* link_name);

  // required string force_type = 3;
  bool has_force_type() const;
  void clear_force_type();
  static const int kForceTypeFieldNumber = 3;
  const ::std::string& force_type() const;
  void set_force_type(const ::std::string& value);
  void set_force_type(const char* value);
  void set_force_type(const char* value, size_t size);
  ::std::string* mutable_force_type();
  ::std::string* release_force_type();
  void set_allocated_force_type(::std::string* force_type);

  // required double fx = 4;
  bool has_fx() const;
  void clear_fx();
  static const int kFxFieldNumber = 4;
  double fx() const;
  void set_fx(double value);

  // required double fy = 5;
  bool has_fy() const;
  void clear_fy();
  static const int kFyFieldNumber = 5;
  double fy() const;
  void set_fy(double value);

  // required double fz = 6;
  bool has_fz() const;
  void clear_fz();
  static const int kFzFieldNumber = 6;
  double fz() const;
  void set_fz(double value);

  // required string torque_type = 7;
  bool has_torque_type() const;
  void clear_torque_type();
  static const int kTorqueTypeFieldNumber = 7;
  const ::std::string& torque_type() const;
  void set_torque_type(const ::std::string& value);
  void set_torque_type(const char* value);
  void set_torque_type(const char* value, size_t size);
  ::std::string* mutable_torque_type();
  ::std::string* release_torque_type();
  void set_allocated_torque_type(::std::string* torque_type);

  // required double tx = 8;
  bool has_tx() const;
  void clear_tx();
  static const int kTxFieldNumber = 8;
  double tx() const;
  void set_tx(double value);

  // required double ty = 9;
  bool has_ty() const;
  void clear_ty();
  static const int kTyFieldNumber = 9;
  double ty() const;
  void set_ty(double value);

  // required double tz = 10;
  bool has_tz() const;
  void clear_tz();
  static const int kTzFieldNumber = 10;
  double tz() const;
  void set_tz(double value);

  // required .mw.internal.robotics.gazebotransport.Time duration = 11;
  bool has_duration() const;
  void clear_duration();
  static const int kDurationFieldNumber = 11;
  const ::mw::internal::robotics::gazebotransport::Time& duration() const;
  ::mw::internal::robotics::gazebotransport::Time* mutable_duration();
  ::mw::internal::robotics::gazebotransport::Time* release_duration();
  void set_allocated_duration(::mw::internal::robotics::gazebotransport::Time* duration);

  // @@protoc_insertion_point(class_scope:mw.internal.robotics.gazebotransport.ApplyLinkWrench)
 private:
  inline void set_has_model_name();
  inline void clear_has_model_name();
  inline void set_has_link_name();
  inline void clear_has_link_name();
  inline void set_has_force_type();
  inline void clear_has_force_type();
  inline void set_has_fx();
  inline void clear_has_fx();
  inline void set_has_fy();
  inline void clear_has_fy();
  inline void set_has_fz();
  inline void clear_has_fz();
  inline void set_has_torque_type();
  inline void clear_has_torque_type();
  inline void set_has_tx();
  inline void clear_has_tx();
  inline void set_has_ty();
  inline void clear_has_ty();
  inline void set_has_tz();
  inline void clear_has_tz();
  inline void set_has_duration();
  inline void clear_has_duration();

  // helper for ByteSize()
  int RequiredFieldsByteSizeFallback() const;

  ::google::protobuf::internal::InternalMetadataWithArena _internal_metadata_;
  ::google::protobuf::uint32 _has_bits_[1];
  mutable int _cached_size_;
  ::google::protobuf::internal::ArenaStringPtr model_name_;
  ::google::protobuf::internal::ArenaStringPtr link_name_;
  ::google::protobuf::internal::ArenaStringPtr force_type_;
  double fx_;
  double fy_;
  double fz_;
  ::google::protobuf::internal::ArenaStringPtr torque_type_;
  double tx_;
  double ty_;
  double tz_;
  ::mw::internal::robotics::gazebotransport::Time* duration_;
  friend void  protobuf_AddDesc_mw_2einternal_2erobotics_2egazebotransport_2eCoSimMsgs_2eproto();
  friend void protobuf_AssignDesc_mw_2einternal_2erobotics_2egazebotransport_2eCoSimMsgs_2eproto();
  friend void protobuf_ShutdownFile_mw_2einternal_2erobotics_2egazebotransport_2eCoSimMsgs_2eproto();

  void InitAsDefaultInstance();
  static ApplyLinkWrench* default_instance_;
};
// -------------------------------------------------------------------

class ApplyJointTorque : public ::google::protobuf::Message /* @@protoc_insertion_point(class_definition:mw.internal.robotics.gazebotransport.ApplyJointTorque) */ {
 public:
  ApplyJointTorque();
  virtual ~ApplyJointTorque();

  ApplyJointTorque(const ApplyJointTorque& from);

  inline ApplyJointTorque& operator=(const ApplyJointTorque& from) {
    CopyFrom(from);
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _internal_metadata_.unknown_fields();
  }

  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return _internal_metadata_.mutable_unknown_fields();
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const ApplyJointTorque& default_instance();

  void Swap(ApplyJointTorque* other);

  // implements Message ----------------------------------------------

  inline ApplyJointTorque* New() const { return New(NULL); }

  ApplyJointTorque* New(::google::protobuf::Arena* arena) const;
  void CopyFrom(const ::google::protobuf::Message& from);
  void MergeFrom(const ::google::protobuf::Message& from);
  void CopyFrom(const ApplyJointTorque& from);
  void MergeFrom(const ApplyJointTorque& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  ::google::protobuf::uint8* InternalSerializeWithCachedSizesToArray(
      bool deterministic, ::google::protobuf::uint8* output) const;
  ::google::protobuf::uint8* SerializeWithCachedSizesToArray(::google::protobuf::uint8* output) const {
    return InternalSerializeWithCachedSizesToArray(false, output);
  }
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  void InternalSwap(ApplyJointTorque* other);
  private:
  inline ::google::protobuf::Arena* GetArenaNoVirtual() const {
    return _internal_metadata_.arena();
  }
  inline void* MaybeArenaPtr() const {
    return _internal_metadata_.raw_arena_ptr();
  }
  public:

  ::google::protobuf::Metadata GetMetadata() const;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // required string model_name = 1;
  bool has_model_name() const;
  void clear_model_name();
  static const int kModelNameFieldNumber = 1;
  const ::std::string& model_name() const;
  void set_model_name(const ::std::string& value);
  void set_model_name(const char* value);
  void set_model_name(const char* value, size_t size);
  ::std::string* mutable_model_name();
  ::std::string* release_model_name();
  void set_allocated_model_name(::std::string* model_name);

  // required string joint_name = 2;
  bool has_joint_name() const;
  void clear_joint_name();
  static const int kJointNameFieldNumber = 2;
  const ::std::string& joint_name() const;
  void set_joint_name(const ::std::string& value);
  void set_joint_name(const char* value);
  void set_joint_name(const char* value, size_t size);
  ::std::string* mutable_joint_name();
  ::std::string* release_joint_name();
  void set_allocated_joint_name(::std::string* joint_name);

  // required uint32 index = 3;
  bool has_index() const;
  void clear_index();
  static const int kIndexFieldNumber = 3;
  ::google::protobuf::uint32 index() const;
  void set_index(::google::protobuf::uint32 value);

  // required double effort = 4;
  bool has_effort() const;
  void clear_effort();
  static const int kEffortFieldNumber = 4;
  double effort() const;
  void set_effort(double value);

  // required .mw.internal.robotics.gazebotransport.Time duration = 5;
  bool has_duration() const;
  void clear_duration();
  static const int kDurationFieldNumber = 5;
  const ::mw::internal::robotics::gazebotransport::Time& duration() const;
  ::mw::internal::robotics::gazebotransport::Time* mutable_duration();
  ::mw::internal::robotics::gazebotransport::Time* release_duration();
  void set_allocated_duration(::mw::internal::robotics::gazebotransport::Time* duration);

  // @@protoc_insertion_point(class_scope:mw.internal.robotics.gazebotransport.ApplyJointTorque)
 private:
  inline void set_has_model_name();
  inline void clear_has_model_name();
  inline void set_has_joint_name();
  inline void clear_has_joint_name();
  inline void set_has_index();
  inline void clear_has_index();
  inline void set_has_effort();
  inline void clear_has_effort();
  inline void set_has_duration();
  inline void clear_has_duration();

  // helper for ByteSize()
  int RequiredFieldsByteSizeFallback() const;

  ::google::protobuf::internal::InternalMetadataWithArena _internal_metadata_;
  ::google::protobuf::uint32 _has_bits_[1];
  mutable int _cached_size_;
  ::google::protobuf::internal::ArenaStringPtr model_name_;
  ::google::protobuf::internal::ArenaStringPtr joint_name_;
  double effort_;
  ::mw::internal::robotics::gazebotransport::Time* duration_;
  ::google::protobuf::uint32 index_;
  friend void  protobuf_AddDesc_mw_2einternal_2erobotics_2egazebotransport_2eCoSimMsgs_2eproto();
  friend void protobuf_AssignDesc_mw_2einternal_2erobotics_2egazebotransport_2eCoSimMsgs_2eproto();
  friend void protobuf_ShutdownFile_mw_2einternal_2erobotics_2egazebotransport_2eCoSimMsgs_2eproto();

  void InitAsDefaultInstance();
  static ApplyJointTorque* default_instance_;
};
// -------------------------------------------------------------------

class GetPose : public ::google::protobuf::Message /* @@protoc_insertion_point(class_definition:mw.internal.robotics.gazebotransport.GetPose) */ {
 public:
  GetPose();
  virtual ~GetPose();

  GetPose(const GetPose& from);

  inline GetPose& operator=(const GetPose& from) {
    CopyFrom(from);
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _internal_metadata_.unknown_fields();
  }

  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return _internal_metadata_.mutable_unknown_fields();
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const GetPose& default_instance();

  void Swap(GetPose* other);

  // implements Message ----------------------------------------------

  inline GetPose* New() const { return New(NULL); }

  GetPose* New(::google::protobuf::Arena* arena) const;
  void CopyFrom(const ::google::protobuf::Message& from);
  void MergeFrom(const ::google::protobuf::Message& from);
  void CopyFrom(const GetPose& from);
  void MergeFrom(const GetPose& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  ::google::protobuf::uint8* InternalSerializeWithCachedSizesToArray(
      bool deterministic, ::google::protobuf::uint8* output) const;
  ::google::protobuf::uint8* SerializeWithCachedSizesToArray(::google::protobuf::uint8* output) const {
    return InternalSerializeWithCachedSizesToArray(false, output);
  }
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  void InternalSwap(GetPose* other);
  private:
  inline ::google::protobuf::Arena* GetArenaNoVirtual() const {
    return _internal_metadata_.arena();
  }
  inline void* MaybeArenaPtr() const {
    return _internal_metadata_.raw_arena_ptr();
  }
  public:

  ::google::protobuf::Metadata GetMetadata() const;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // required string model_name = 1;
  bool has_model_name() const;
  void clear_model_name();
  static const int kModelNameFieldNumber = 1;
  const ::std::string& model_name() const;
  void set_model_name(const ::std::string& value);
  void set_model_name(const char* value);
  void set_model_name(const char* value, size_t size);
  ::std::string* mutable_model_name();
  ::std::string* release_model_name();
  void set_allocated_model_name(::std::string* model_name);

  // @@protoc_insertion_point(class_scope:mw.internal.robotics.gazebotransport.GetPose)
 private:
  inline void set_has_model_name();
  inline void clear_has_model_name();

  ::google::protobuf::internal::InternalMetadataWithArena _internal_metadata_;
  ::google::protobuf::uint32 _has_bits_[1];
  mutable int _cached_size_;
  ::google::protobuf::internal::ArenaStringPtr model_name_;
  friend void  protobuf_AddDesc_mw_2einternal_2erobotics_2egazebotransport_2eCoSimMsgs_2eproto();
  friend void protobuf_AssignDesc_mw_2einternal_2erobotics_2egazebotransport_2eCoSimMsgs_2eproto();
  friend void protobuf_ShutdownFile_mw_2einternal_2erobotics_2egazebotransport_2eCoSimMsgs_2eproto();

  void InitAsDefaultInstance();
  static GetPose* default_instance_;
};
// -------------------------------------------------------------------

class GetTopicList : public ::google::protobuf::Message /* @@protoc_insertion_point(class_definition:mw.internal.robotics.gazebotransport.GetTopicList) */ {
 public:
  GetTopicList();
  virtual ~GetTopicList();

  GetTopicList(const GetTopicList& from);

  inline GetTopicList& operator=(const GetTopicList& from) {
    CopyFrom(from);
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _internal_metadata_.unknown_fields();
  }

  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return _internal_metadata_.mutable_unknown_fields();
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const GetTopicList& default_instance();

  void Swap(GetTopicList* other);

  // implements Message ----------------------------------------------

  inline GetTopicList* New() const { return New(NULL); }

  GetTopicList* New(::google::protobuf::Arena* arena) const;
  void CopyFrom(const ::google::protobuf::Message& from);
  void MergeFrom(const ::google::protobuf::Message& from);
  void CopyFrom(const GetTopicList& from);
  void MergeFrom(const GetTopicList& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  ::google::protobuf::uint8* InternalSerializeWithCachedSizesToArray(
      bool deterministic, ::google::protobuf::uint8* output) const;
  ::google::protobuf::uint8* SerializeWithCachedSizesToArray(::google::protobuf::uint8* output) const {
    return InternalSerializeWithCachedSizesToArray(false, output);
  }
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  void InternalSwap(GetTopicList* other);
  private:
  inline ::google::protobuf::Arena* GetArenaNoVirtual() const {
    return _internal_metadata_.arena();
  }
  inline void* MaybeArenaPtr() const {
    return _internal_metadata_.raw_arena_ptr();
  }
  public:

  ::google::protobuf::Metadata GetMetadata() const;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // required string topic_name = 1;
  bool has_topic_name() const;
  void clear_topic_name();
  static const int kTopicNameFieldNumber = 1;
  const ::std::string& topic_name() const;
  void set_topic_name(const ::std::string& value);
  void set_topic_name(const char* value);
  void set_topic_name(const char* value, size_t size);
  ::std::string* mutable_topic_name();
  ::std::string* release_topic_name();
  void set_allocated_topic_name(::std::string* topic_name);

  // @@protoc_insertion_point(class_scope:mw.internal.robotics.gazebotransport.GetTopicList)
 private:
  inline void set_has_topic_name();
  inline void clear_has_topic_name();

  ::google::protobuf::internal::InternalMetadataWithArena _internal_metadata_;
  ::google::protobuf::uint32 _has_bits_[1];
  mutable int _cached_size_;
  ::google::protobuf::internal::ArenaStringPtr topic_name_;
  friend void  protobuf_AddDesc_mw_2einternal_2erobotics_2egazebotransport_2eCoSimMsgs_2eproto();
  friend void protobuf_AssignDesc_mw_2einternal_2erobotics_2egazebotransport_2eCoSimMsgs_2eproto();
  friend void protobuf_ShutdownFile_mw_2einternal_2erobotics_2egazebotransport_2eCoSimMsgs_2eproto();

  void InitAsDefaultInstance();
  static GetTopicList* default_instance_;
};
// -------------------------------------------------------------------

class TopicList_TopicInfo : public ::google::protobuf::Message /* @@protoc_insertion_point(class_definition:mw.internal.robotics.gazebotransport.TopicList.TopicInfo) */ {
 public:
  TopicList_TopicInfo();
  virtual ~TopicList_TopicInfo();

  TopicList_TopicInfo(const TopicList_TopicInfo& from);

  inline TopicList_TopicInfo& operator=(const TopicList_TopicInfo& from) {
    CopyFrom(from);
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _internal_metadata_.unknown_fields();
  }

  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return _internal_metadata_.mutable_unknown_fields();
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const TopicList_TopicInfo& default_instance();

  void Swap(TopicList_TopicInfo* other);

  // implements Message ----------------------------------------------

  inline TopicList_TopicInfo* New() const { return New(NULL); }

  TopicList_TopicInfo* New(::google::protobuf::Arena* arena) const;
  void CopyFrom(const ::google::protobuf::Message& from);
  void MergeFrom(const ::google::protobuf::Message& from);
  void CopyFrom(const TopicList_TopicInfo& from);
  void MergeFrom(const TopicList_TopicInfo& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  ::google::protobuf::uint8* InternalSerializeWithCachedSizesToArray(
      bool deterministic, ::google::protobuf::uint8* output) const;
  ::google::protobuf::uint8* SerializeWithCachedSizesToArray(::google::protobuf::uint8* output) const {
    return InternalSerializeWithCachedSizesToArray(false, output);
  }
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  void InternalSwap(TopicList_TopicInfo* other);
  private:
  inline ::google::protobuf::Arena* GetArenaNoVirtual() const {
    return _internal_metadata_.arena();
  }
  inline void* MaybeArenaPtr() const {
    return _internal_metadata_.raw_arena_ptr();
  }
  public:

  ::google::protobuf::Metadata GetMetadata() const;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // required string name = 1;
  bool has_name() const;
  void clear_name();
  static const int kNameFieldNumber = 1;
  const ::std::string& name() const;
  void set_name(const ::std::string& value);
  void set_name(const char* value);
  void set_name(const char* value, size_t size);
  ::std::string* mutable_name();
  ::std::string* release_name();
  void set_allocated_name(::std::string* name);

  // required string type = 2;
  bool has_type() const;
  void clear_type();
  static const int kTypeFieldNumber = 2;
  const ::std::string& type() const;
  void set_type(const ::std::string& value);
  void set_type(const char* value);
  void set_type(const char* value, size_t size);
  ::std::string* mutable_type();
  ::std::string* release_type();
  void set_allocated_type(::std::string* type);

  // @@protoc_insertion_point(class_scope:mw.internal.robotics.gazebotransport.TopicList.TopicInfo)
 private:
  inline void set_has_name();
  inline void clear_has_name();
  inline void set_has_type();
  inline void clear_has_type();

  // helper for ByteSize()
  int RequiredFieldsByteSizeFallback() const;

  ::google::protobuf::internal::InternalMetadataWithArena _internal_metadata_;
  ::google::protobuf::uint32 _has_bits_[1];
  mutable int _cached_size_;
  ::google::protobuf::internal::ArenaStringPtr name_;
  ::google::protobuf::internal::ArenaStringPtr type_;
  friend void  protobuf_AddDesc_mw_2einternal_2erobotics_2egazebotransport_2eCoSimMsgs_2eproto();
  friend void protobuf_AssignDesc_mw_2einternal_2erobotics_2egazebotransport_2eCoSimMsgs_2eproto();
  friend void protobuf_ShutdownFile_mw_2einternal_2erobotics_2egazebotransport_2eCoSimMsgs_2eproto();

  void InitAsDefaultInstance();
  static TopicList_TopicInfo* default_instance_;
};
// -------------------------------------------------------------------

class TopicList : public ::google::protobuf::Message /* @@protoc_insertion_point(class_definition:mw.internal.robotics.gazebotransport.TopicList) */ {
 public:
  TopicList();
  virtual ~TopicList();

  TopicList(const TopicList& from);

  inline TopicList& operator=(const TopicList& from) {
    CopyFrom(from);
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _internal_metadata_.unknown_fields();
  }

  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return _internal_metadata_.mutable_unknown_fields();
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const TopicList& default_instance();

  void Swap(TopicList* other);

  // implements Message ----------------------------------------------

  inline TopicList* New() const { return New(NULL); }

  TopicList* New(::google::protobuf::Arena* arena) const;
  void CopyFrom(const ::google::protobuf::Message& from);
  void MergeFrom(const ::google::protobuf::Message& from);
  void CopyFrom(const TopicList& from);
  void MergeFrom(const TopicList& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  ::google::protobuf::uint8* InternalSerializeWithCachedSizesToArray(
      bool deterministic, ::google::protobuf::uint8* output) const;
  ::google::protobuf::uint8* SerializeWithCachedSizesToArray(::google::protobuf::uint8* output) const {
    return InternalSerializeWithCachedSizesToArray(false, output);
  }
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  void InternalSwap(TopicList* other);
  private:
  inline ::google::protobuf::Arena* GetArenaNoVirtual() const {
    return _internal_metadata_.arena();
  }
  inline void* MaybeArenaPtr() const {
    return _internal_metadata_.raw_arena_ptr();
  }
  public:

  ::google::protobuf::Metadata GetMetadata() const;

  // nested types ----------------------------------------------------

  typedef TopicList_TopicInfo TopicInfo;

  // accessors -------------------------------------------------------

  // repeated .mw.internal.robotics.gazebotransport.TopicList.TopicInfo data = 1;
  int data_size() const;
  void clear_data();
  static const int kDataFieldNumber = 1;
  const ::mw::internal::robotics::gazebotransport::TopicList_TopicInfo& data(int index) const;
  ::mw::internal::robotics::gazebotransport::TopicList_TopicInfo* mutable_data(int index);
  ::mw::internal::robotics::gazebotransport::TopicList_TopicInfo* add_data();
  ::google::protobuf::RepeatedPtrField< ::mw::internal::robotics::gazebotransport::TopicList_TopicInfo >*
      mutable_data();
  const ::google::protobuf::RepeatedPtrField< ::mw::internal::robotics::gazebotransport::TopicList_TopicInfo >&
      data() const;

  // @@protoc_insertion_point(class_scope:mw.internal.robotics.gazebotransport.TopicList)
 private:

  ::google::protobuf::internal::InternalMetadataWithArena _internal_metadata_;
  ::google::protobuf::uint32 _has_bits_[1];
  mutable int _cached_size_;
  ::google::protobuf::RepeatedPtrField< ::mw::internal::robotics::gazebotransport::TopicList_TopicInfo > data_;
  friend void  protobuf_AddDesc_mw_2einternal_2erobotics_2egazebotransport_2eCoSimMsgs_2eproto();
  friend void protobuf_AssignDesc_mw_2einternal_2erobotics_2egazebotransport_2eCoSimMsgs_2eproto();
  friend void protobuf_ShutdownFile_mw_2einternal_2erobotics_2egazebotransport_2eCoSimMsgs_2eproto();

  void InitAsDefaultInstance();
  static TopicList* default_instance_;
};
// -------------------------------------------------------------------

class GetModelInfo : public ::google::protobuf::Message /* @@protoc_insertion_point(class_definition:mw.internal.robotics.gazebotransport.GetModelInfo) */ {
 public:
  GetModelInfo();
  virtual ~GetModelInfo();

  GetModelInfo(const GetModelInfo& from);

  inline GetModelInfo& operator=(const GetModelInfo& from) {
    CopyFrom(from);
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _internal_metadata_.unknown_fields();
  }

  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return _internal_metadata_.mutable_unknown_fields();
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const GetModelInfo& default_instance();

  void Swap(GetModelInfo* other);

  // implements Message ----------------------------------------------

  inline GetModelInfo* New() const { return New(NULL); }

  GetModelInfo* New(::google::protobuf::Arena* arena) const;
  void CopyFrom(const ::google::protobuf::Message& from);
  void MergeFrom(const ::google::protobuf::Message& from);
  void CopyFrom(const GetModelInfo& from);
  void MergeFrom(const GetModelInfo& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  ::google::protobuf::uint8* InternalSerializeWithCachedSizesToArray(
      bool deterministic, ::google::protobuf::uint8* output) const;
  ::google::protobuf::uint8* SerializeWithCachedSizesToArray(::google::protobuf::uint8* output) const {
    return InternalSerializeWithCachedSizesToArray(false, output);
  }
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  void InternalSwap(GetModelInfo* other);
  private:
  inline ::google::protobuf::Arena* GetArenaNoVirtual() const {
    return _internal_metadata_.arena();
  }
  inline void* MaybeArenaPtr() const {
    return _internal_metadata_.raw_arena_ptr();
  }
  public:

  ::google::protobuf::Metadata GetMetadata() const;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // required string topic_name = 1;
  bool has_topic_name() const;
  void clear_topic_name();
  static const int kTopicNameFieldNumber = 1;
  const ::std::string& topic_name() const;
  void set_topic_name(const ::std::string& value);
  void set_topic_name(const char* value);
  void set_topic_name(const char* value, size_t size);
  ::std::string* mutable_topic_name();
  ::std::string* release_topic_name();
  void set_allocated_topic_name(::std::string* topic_name);

  // @@protoc_insertion_point(class_scope:mw.internal.robotics.gazebotransport.GetModelInfo)
 private:
  inline void set_has_topic_name();
  inline void clear_has_topic_name();

  ::google::protobuf::internal::InternalMetadataWithArena _internal_metadata_;
  ::google::protobuf::uint32 _has_bits_[1];
  mutable int _cached_size_;
  ::google::protobuf::internal::ArenaStringPtr topic_name_;
  friend void  protobuf_AddDesc_mw_2einternal_2erobotics_2egazebotransport_2eCoSimMsgs_2eproto();
  friend void protobuf_AssignDesc_mw_2einternal_2erobotics_2egazebotransport_2eCoSimMsgs_2eproto();
  friend void protobuf_ShutdownFile_mw_2einternal_2erobotics_2egazebotransport_2eCoSimMsgs_2eproto();

  void InitAsDefaultInstance();
  static GetModelInfo* default_instance_;
};
// -------------------------------------------------------------------

class ModelInfo_LINKS : public ::google::protobuf::Message /* @@protoc_insertion_point(class_definition:mw.internal.robotics.gazebotransport.ModelInfo.LINKS) */ {
 public:
  ModelInfo_LINKS();
  virtual ~ModelInfo_LINKS();

  ModelInfo_LINKS(const ModelInfo_LINKS& from);

  inline ModelInfo_LINKS& operator=(const ModelInfo_LINKS& from) {
    CopyFrom(from);
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _internal_metadata_.unknown_fields();
  }

  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return _internal_metadata_.mutable_unknown_fields();
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const ModelInfo_LINKS& default_instance();

  void Swap(ModelInfo_LINKS* other);

  // implements Message ----------------------------------------------

  inline ModelInfo_LINKS* New() const { return New(NULL); }

  ModelInfo_LINKS* New(::google::protobuf::Arena* arena) const;
  void CopyFrom(const ::google::protobuf::Message& from);
  void MergeFrom(const ::google::protobuf::Message& from);
  void CopyFrom(const ModelInfo_LINKS& from);
  void MergeFrom(const ModelInfo_LINKS& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  ::google::protobuf::uint8* InternalSerializeWithCachedSizesToArray(
      bool deterministic, ::google::protobuf::uint8* output) const;
  ::google::protobuf::uint8* SerializeWithCachedSizesToArray(::google::protobuf::uint8* output) const {
    return InternalSerializeWithCachedSizesToArray(false, output);
  }
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  void InternalSwap(ModelInfo_LINKS* other);
  private:
  inline ::google::protobuf::Arena* GetArenaNoVirtual() const {
    return _internal_metadata_.arena();
  }
  inline void* MaybeArenaPtr() const {
    return _internal_metadata_.raw_arena_ptr();
  }
  public:

  ::google::protobuf::Metadata GetMetadata() const;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // repeated string link_name = 1;
  int link_name_size() const;
  void clear_link_name();
  static const int kLinkNameFieldNumber = 1;
  const ::std::string& link_name(int index) const;
  ::std::string* mutable_link_name(int index);
  void set_link_name(int index, const ::std::string& value);
  void set_link_name(int index, const char* value);
  void set_link_name(int index, const char* value, size_t size);
  ::std::string* add_link_name();
  void add_link_name(const ::std::string& value);
  void add_link_name(const char* value);
  void add_link_name(const char* value, size_t size);
  const ::google::protobuf::RepeatedPtrField< ::std::string>& link_name() const;
  ::google::protobuf::RepeatedPtrField< ::std::string>* mutable_link_name();

  // @@protoc_insertion_point(class_scope:mw.internal.robotics.gazebotransport.ModelInfo.LINKS)
 private:

  ::google::protobuf::internal::InternalMetadataWithArena _internal_metadata_;
  ::google::protobuf::uint32 _has_bits_[1];
  mutable int _cached_size_;
  ::google::protobuf::RepeatedPtrField< ::std::string> link_name_;
  friend void  protobuf_AddDesc_mw_2einternal_2erobotics_2egazebotransport_2eCoSimMsgs_2eproto();
  friend void protobuf_AssignDesc_mw_2einternal_2erobotics_2egazebotransport_2eCoSimMsgs_2eproto();
  friend void protobuf_ShutdownFile_mw_2einternal_2erobotics_2egazebotransport_2eCoSimMsgs_2eproto();

  void InitAsDefaultInstance();
  static ModelInfo_LINKS* default_instance_;
};
// -------------------------------------------------------------------

class ModelInfo_JOINTS : public ::google::protobuf::Message /* @@protoc_insertion_point(class_definition:mw.internal.robotics.gazebotransport.ModelInfo.JOINTS) */ {
 public:
  ModelInfo_JOINTS();
  virtual ~ModelInfo_JOINTS();

  ModelInfo_JOINTS(const ModelInfo_JOINTS& from);

  inline ModelInfo_JOINTS& operator=(const ModelInfo_JOINTS& from) {
    CopyFrom(from);
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _internal_metadata_.unknown_fields();
  }

  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return _internal_metadata_.mutable_unknown_fields();
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const ModelInfo_JOINTS& default_instance();

  void Swap(ModelInfo_JOINTS* other);

  // implements Message ----------------------------------------------

  inline ModelInfo_JOINTS* New() const { return New(NULL); }

  ModelInfo_JOINTS* New(::google::protobuf::Arena* arena) const;
  void CopyFrom(const ::google::protobuf::Message& from);
  void MergeFrom(const ::google::protobuf::Message& from);
  void CopyFrom(const ModelInfo_JOINTS& from);
  void MergeFrom(const ModelInfo_JOINTS& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  ::google::protobuf::uint8* InternalSerializeWithCachedSizesToArray(
      bool deterministic, ::google::protobuf::uint8* output) const;
  ::google::protobuf::uint8* SerializeWithCachedSizesToArray(::google::protobuf::uint8* output) const {
    return InternalSerializeWithCachedSizesToArray(false, output);
  }
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  void InternalSwap(ModelInfo_JOINTS* other);
  private:
  inline ::google::protobuf::Arena* GetArenaNoVirtual() const {
    return _internal_metadata_.arena();
  }
  inline void* MaybeArenaPtr() const {
    return _internal_metadata_.raw_arena_ptr();
  }
  public:

  ::google::protobuf::Metadata GetMetadata() const;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // repeated string joint_name = 1;
  int joint_name_size() const;
  void clear_joint_name();
  static const int kJointNameFieldNumber = 1;
  const ::std::string& joint_name(int index) const;
  ::std::string* mutable_joint_name(int index);
  void set_joint_name(int index, const ::std::string& value);
  void set_joint_name(int index, const char* value);
  void set_joint_name(int index, const char* value, size_t size);
  ::std::string* add_joint_name();
  void add_joint_name(const ::std::string& value);
  void add_joint_name(const char* value);
  void add_joint_name(const char* value, size_t size);
  const ::google::protobuf::RepeatedPtrField< ::std::string>& joint_name() const;
  ::google::protobuf::RepeatedPtrField< ::std::string>* mutable_joint_name();

  // @@protoc_insertion_point(class_scope:mw.internal.robotics.gazebotransport.ModelInfo.JOINTS)
 private:

  ::google::protobuf::internal::InternalMetadataWithArena _internal_metadata_;
  ::google::protobuf::uint32 _has_bits_[1];
  mutable int _cached_size_;
  ::google::protobuf::RepeatedPtrField< ::std::string> joint_name_;
  friend void  protobuf_AddDesc_mw_2einternal_2erobotics_2egazebotransport_2eCoSimMsgs_2eproto();
  friend void protobuf_AssignDesc_mw_2einternal_2erobotics_2egazebotransport_2eCoSimMsgs_2eproto();
  friend void protobuf_ShutdownFile_mw_2einternal_2erobotics_2egazebotransport_2eCoSimMsgs_2eproto();

  void InitAsDefaultInstance();
  static ModelInfo_JOINTS* default_instance_;
};
// -------------------------------------------------------------------

class ModelInfo_Model : public ::google::protobuf::Message /* @@protoc_insertion_point(class_definition:mw.internal.robotics.gazebotransport.ModelInfo.Model) */ {
 public:
  ModelInfo_Model();
  virtual ~ModelInfo_Model();

  ModelInfo_Model(const ModelInfo_Model& from);

  inline ModelInfo_Model& operator=(const ModelInfo_Model& from) {
    CopyFrom(from);
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _internal_metadata_.unknown_fields();
  }

  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return _internal_metadata_.mutable_unknown_fields();
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const ModelInfo_Model& default_instance();

  void Swap(ModelInfo_Model* other);

  // implements Message ----------------------------------------------

  inline ModelInfo_Model* New() const { return New(NULL); }

  ModelInfo_Model* New(::google::protobuf::Arena* arena) const;
  void CopyFrom(const ::google::protobuf::Message& from);
  void MergeFrom(const ::google::protobuf::Message& from);
  void CopyFrom(const ModelInfo_Model& from);
  void MergeFrom(const ModelInfo_Model& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  ::google::protobuf::uint8* InternalSerializeWithCachedSizesToArray(
      bool deterministic, ::google::protobuf::uint8* output) const;
  ::google::protobuf::uint8* SerializeWithCachedSizesToArray(::google::protobuf::uint8* output) const {
    return InternalSerializeWithCachedSizesToArray(false, output);
  }
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  void InternalSwap(ModelInfo_Model* other);
  private:
  inline ::google::protobuf::Arena* GetArenaNoVirtual() const {
    return _internal_metadata_.arena();
  }
  inline void* MaybeArenaPtr() const {
    return _internal_metadata_.raw_arena_ptr();
  }
  public:

  ::google::protobuf::Metadata GetMetadata() const;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // required string model_name = 1;
  bool has_model_name() const;
  void clear_model_name();
  static const int kModelNameFieldNumber = 1;
  const ::std::string& model_name() const;
  void set_model_name(const ::std::string& value);
  void set_model_name(const char* value);
  void set_model_name(const char* value, size_t size);
  ::std::string* mutable_model_name();
  ::std::string* release_model_name();
  void set_allocated_model_name(::std::string* model_name);

  // optional .mw.internal.robotics.gazebotransport.ModelInfo.LINKS links = 2;
  bool has_links() const;
  void clear_links();
  static const int kLinksFieldNumber = 2;
  const ::mw::internal::robotics::gazebotransport::ModelInfo_LINKS& links() const;
  ::mw::internal::robotics::gazebotransport::ModelInfo_LINKS* mutable_links();
  ::mw::internal::robotics::gazebotransport::ModelInfo_LINKS* release_links();
  void set_allocated_links(::mw::internal::robotics::gazebotransport::ModelInfo_LINKS* links);

  // optional .mw.internal.robotics.gazebotransport.ModelInfo.JOINTS joints = 3;
  bool has_joints() const;
  void clear_joints();
  static const int kJointsFieldNumber = 3;
  const ::mw::internal::robotics::gazebotransport::ModelInfo_JOINTS& joints() const;
  ::mw::internal::robotics::gazebotransport::ModelInfo_JOINTS* mutable_joints();
  ::mw::internal::robotics::gazebotransport::ModelInfo_JOINTS* release_joints();
  void set_allocated_joints(::mw::internal::robotics::gazebotransport::ModelInfo_JOINTS* joints);

  // @@protoc_insertion_point(class_scope:mw.internal.robotics.gazebotransport.ModelInfo.Model)
 private:
  inline void set_has_model_name();
  inline void clear_has_model_name();
  inline void set_has_links();
  inline void clear_has_links();
  inline void set_has_joints();
  inline void clear_has_joints();

  ::google::protobuf::internal::InternalMetadataWithArena _internal_metadata_;
  ::google::protobuf::uint32 _has_bits_[1];
  mutable int _cached_size_;
  ::google::protobuf::internal::ArenaStringPtr model_name_;
  ::mw::internal::robotics::gazebotransport::ModelInfo_LINKS* links_;
  ::mw::internal::robotics::gazebotransport::ModelInfo_JOINTS* joints_;
  friend void  protobuf_AddDesc_mw_2einternal_2erobotics_2egazebotransport_2eCoSimMsgs_2eproto();
  friend void protobuf_AssignDesc_mw_2einternal_2erobotics_2egazebotransport_2eCoSimMsgs_2eproto();
  friend void protobuf_ShutdownFile_mw_2einternal_2erobotics_2egazebotransport_2eCoSimMsgs_2eproto();

  void InitAsDefaultInstance();
  static ModelInfo_Model* default_instance_;
};
// -------------------------------------------------------------------

class ModelInfo : public ::google::protobuf::Message /* @@protoc_insertion_point(class_definition:mw.internal.robotics.gazebotransport.ModelInfo) */ {
 public:
  ModelInfo();
  virtual ~ModelInfo();

  ModelInfo(const ModelInfo& from);

  inline ModelInfo& operator=(const ModelInfo& from) {
    CopyFrom(from);
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _internal_metadata_.unknown_fields();
  }

  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return _internal_metadata_.mutable_unknown_fields();
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const ModelInfo& default_instance();

  void Swap(ModelInfo* other);

  // implements Message ----------------------------------------------

  inline ModelInfo* New() const { return New(NULL); }

  ModelInfo* New(::google::protobuf::Arena* arena) const;
  void CopyFrom(const ::google::protobuf::Message& from);
  void MergeFrom(const ::google::protobuf::Message& from);
  void CopyFrom(const ModelInfo& from);
  void MergeFrom(const ModelInfo& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  ::google::protobuf::uint8* InternalSerializeWithCachedSizesToArray(
      bool deterministic, ::google::protobuf::uint8* output) const;
  ::google::protobuf::uint8* SerializeWithCachedSizesToArray(::google::protobuf::uint8* output) const {
    return InternalSerializeWithCachedSizesToArray(false, output);
  }
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  void InternalSwap(ModelInfo* other);
  private:
  inline ::google::protobuf::Arena* GetArenaNoVirtual() const {
    return _internal_metadata_.arena();
  }
  inline void* MaybeArenaPtr() const {
    return _internal_metadata_.raw_arena_ptr();
  }
  public:

  ::google::protobuf::Metadata GetMetadata() const;

  // nested types ----------------------------------------------------

  typedef ModelInfo_LINKS LINKS;
  typedef ModelInfo_JOINTS JOINTS;
  typedef ModelInfo_Model Model;

  // accessors -------------------------------------------------------

  // repeated .mw.internal.robotics.gazebotransport.ModelInfo.Model model_data = 1;
  int model_data_size() const;
  void clear_model_data();
  static const int kModelDataFieldNumber = 1;
  const ::mw::internal::robotics::gazebotransport::ModelInfo_Model& model_data(int index) const;
  ::mw::internal::robotics::gazebotransport::ModelInfo_Model* mutable_model_data(int index);
  ::mw::internal::robotics::gazebotransport::ModelInfo_Model* add_model_data();
  ::google::protobuf::RepeatedPtrField< ::mw::internal::robotics::gazebotransport::ModelInfo_Model >*
      mutable_model_data();
  const ::google::protobuf::RepeatedPtrField< ::mw::internal::robotics::gazebotransport::ModelInfo_Model >&
      model_data() const;

  // @@protoc_insertion_point(class_scope:mw.internal.robotics.gazebotransport.ModelInfo)
 private:

  ::google::protobuf::internal::InternalMetadataWithArena _internal_metadata_;
  ::google::protobuf::uint32 _has_bits_[1];
  mutable int _cached_size_;
  ::google::protobuf::RepeatedPtrField< ::mw::internal::robotics::gazebotransport::ModelInfo_Model > model_data_;
  friend void  protobuf_AddDesc_mw_2einternal_2erobotics_2egazebotransport_2eCoSimMsgs_2eproto();
  friend void protobuf_AssignDesc_mw_2einternal_2erobotics_2egazebotransport_2eCoSimMsgs_2eproto();
  friend void protobuf_ShutdownFile_mw_2einternal_2erobotics_2egazebotransport_2eCoSimMsgs_2eproto();

  void InitAsDefaultInstance();
  static ModelInfo* default_instance_;
};
// -------------------------------------------------------------------

class MaxStepSize : public ::google::protobuf::Message /* @@protoc_insertion_point(class_definition:mw.internal.robotics.gazebotransport.MaxStepSize) */ {
 public:
  MaxStepSize();
  virtual ~MaxStepSize();

  MaxStepSize(const MaxStepSize& from);

  inline MaxStepSize& operator=(const MaxStepSize& from) {
    CopyFrom(from);
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _internal_metadata_.unknown_fields();
  }

  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return _internal_metadata_.mutable_unknown_fields();
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const MaxStepSize& default_instance();

  void Swap(MaxStepSize* other);

  // implements Message ----------------------------------------------

  inline MaxStepSize* New() const { return New(NULL); }

  MaxStepSize* New(::google::protobuf::Arena* arena) const;
  void CopyFrom(const ::google::protobuf::Message& from);
  void MergeFrom(const ::google::protobuf::Message& from);
  void CopyFrom(const MaxStepSize& from);
  void MergeFrom(const MaxStepSize& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  ::google::protobuf::uint8* InternalSerializeWithCachedSizesToArray(
      bool deterministic, ::google::protobuf::uint8* output) const;
  ::google::protobuf::uint8* SerializeWithCachedSizesToArray(::google::protobuf::uint8* output) const {
    return InternalSerializeWithCachedSizesToArray(false, output);
  }
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  void InternalSwap(MaxStepSize* other);
  private:
  inline ::google::protobuf::Arena* GetArenaNoVirtual() const {
    return _internal_metadata_.arena();
  }
  inline void* MaybeArenaPtr() const {
    return _internal_metadata_.raw_arena_ptr();
  }
  public:

  ::google::protobuf::Metadata GetMetadata() const;

  // nested types ----------------------------------------------------

  typedef MaxStepSize_TYPE TYPE;
  static const TYPE SET_STEP_SIZE =
    MaxStepSize_TYPE_SET_STEP_SIZE;
  static const TYPE GET_STEP_SIZE =
    MaxStepSize_TYPE_GET_STEP_SIZE;
  static inline bool TYPE_IsValid(int value) {
    return MaxStepSize_TYPE_IsValid(value);
  }
  static const TYPE TYPE_MIN =
    MaxStepSize_TYPE_TYPE_MIN;
  static const TYPE TYPE_MAX =
    MaxStepSize_TYPE_TYPE_MAX;
  static const int TYPE_ARRAYSIZE =
    MaxStepSize_TYPE_TYPE_ARRAYSIZE;
  static inline const ::google::protobuf::EnumDescriptor*
  TYPE_descriptor() {
    return MaxStepSize_TYPE_descriptor();
  }
  static inline const ::std::string& TYPE_Name(TYPE value) {
    return MaxStepSize_TYPE_Name(value);
  }
  static inline bool TYPE_Parse(const ::std::string& name,
      TYPE* value) {
    return MaxStepSize_TYPE_Parse(name, value);
  }

  // accessors -------------------------------------------------------

  // required .mw.internal.robotics.gazebotransport.MaxStepSize.TYPE type = 1;
  bool has_type() const;
  void clear_type();
  static const int kTypeFieldNumber = 1;
  ::mw::internal::robotics::gazebotransport::MaxStepSize_TYPE type() const;
  void set_type(::mw::internal::robotics::gazebotransport::MaxStepSize_TYPE value);

  // required double size = 2;
  bool has_size() const;
  void clear_size();
  static const int kSizeFieldNumber = 2;
  double size() const;
  void set_size(double value);

  // @@protoc_insertion_point(class_scope:mw.internal.robotics.gazebotransport.MaxStepSize)
 private:
  inline void set_has_type();
  inline void clear_has_type();
  inline void set_has_size();
  inline void clear_has_size();

  // helper for ByteSize()
  int RequiredFieldsByteSizeFallback() const;

  ::google::protobuf::internal::InternalMetadataWithArena _internal_metadata_;
  ::google::protobuf::uint32 _has_bits_[1];
  mutable int _cached_size_;
  double size_;
  int type_;
  friend void  protobuf_AddDesc_mw_2einternal_2erobotics_2egazebotransport_2eCoSimMsgs_2eproto();
  friend void protobuf_AssignDesc_mw_2einternal_2erobotics_2egazebotransport_2eCoSimMsgs_2eproto();
  friend void protobuf_ShutdownFile_mw_2einternal_2erobotics_2egazebotransport_2eCoSimMsgs_2eproto();

  void InitAsDefaultInstance();
  static MaxStepSize* default_instance_;
};
// -------------------------------------------------------------------

class InitCustomPublisher : public ::google::protobuf::Message /* @@protoc_insertion_point(class_definition:mw.internal.robotics.gazebotransport.InitCustomPublisher) */ {
 public:
  InitCustomPublisher();
  virtual ~InitCustomPublisher();

  InitCustomPublisher(const InitCustomPublisher& from);

  inline InitCustomPublisher& operator=(const InitCustomPublisher& from) {
    CopyFrom(from);
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _internal_metadata_.unknown_fields();
  }

  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return _internal_metadata_.mutable_unknown_fields();
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const InitCustomPublisher& default_instance();

  void Swap(InitCustomPublisher* other);

  // implements Message ----------------------------------------------

  inline InitCustomPublisher* New() const { return New(NULL); }

  InitCustomPublisher* New(::google::protobuf::Arena* arena) const;
  void CopyFrom(const ::google::protobuf::Message& from);
  void MergeFrom(const ::google::protobuf::Message& from);
  void CopyFrom(const InitCustomPublisher& from);
  void MergeFrom(const InitCustomPublisher& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  ::google::protobuf::uint8* InternalSerializeWithCachedSizesToArray(
      bool deterministic, ::google::protobuf::uint8* output) const;
  ::google::protobuf::uint8* SerializeWithCachedSizesToArray(::google::protobuf::uint8* output) const {
    return InternalSerializeWithCachedSizesToArray(false, output);
  }
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  void InternalSwap(InitCustomPublisher* other);
  private:
  inline ::google::protobuf::Arena* GetArenaNoVirtual() const {
    return _internal_metadata_.arena();
  }
  inline void* MaybeArenaPtr() const {
    return _internal_metadata_.raw_arena_ptr();
  }
  public:

  ::google::protobuf::Metadata GetMetadata() const;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // required string topic_name = 1;
  bool has_topic_name() const;
  void clear_topic_name();
  static const int kTopicNameFieldNumber = 1;
  const ::std::string& topic_name() const;
  void set_topic_name(const ::std::string& value);
  void set_topic_name(const char* value);
  void set_topic_name(const char* value, size_t size);
  ::std::string* mutable_topic_name();
  ::std::string* release_topic_name();
  void set_allocated_topic_name(::std::string* topic_name);

  // required string message_type = 2;
  bool has_message_type() const;
  void clear_message_type();
  static const int kMessageTypeFieldNumber = 2;
  const ::std::string& message_type() const;
  void set_message_type(const ::std::string& value);
  void set_message_type(const char* value);
  void set_message_type(const char* value, size_t size);
  ::std::string* mutable_message_type();
  ::std::string* release_message_type();
  void set_allocated_message_type(::std::string* message_type);

  // @@protoc_insertion_point(class_scope:mw.internal.robotics.gazebotransport.InitCustomPublisher)
 private:
  inline void set_has_topic_name();
  inline void clear_has_topic_name();
  inline void set_has_message_type();
  inline void clear_has_message_type();

  // helper for ByteSize()
  int RequiredFieldsByteSizeFallback() const;

  ::google::protobuf::internal::InternalMetadataWithArena _internal_metadata_;
  ::google::protobuf::uint32 _has_bits_[1];
  mutable int _cached_size_;
  ::google::protobuf::internal::ArenaStringPtr topic_name_;
  ::google::protobuf::internal::ArenaStringPtr message_type_;
  friend void  protobuf_AddDesc_mw_2einternal_2erobotics_2egazebotransport_2eCoSimMsgs_2eproto();
  friend void protobuf_AssignDesc_mw_2einternal_2erobotics_2egazebotransport_2eCoSimMsgs_2eproto();
  friend void protobuf_ShutdownFile_mw_2einternal_2erobotics_2egazebotransport_2eCoSimMsgs_2eproto();

  void InitAsDefaultInstance();
  static InitCustomPublisher* default_instance_;
};
// -------------------------------------------------------------------

class InitCustomSubscriber : public ::google::protobuf::Message /* @@protoc_insertion_point(class_definition:mw.internal.robotics.gazebotransport.InitCustomSubscriber) */ {
 public:
  InitCustomSubscriber();
  virtual ~InitCustomSubscriber();

  InitCustomSubscriber(const InitCustomSubscriber& from);

  inline InitCustomSubscriber& operator=(const InitCustomSubscriber& from) {
    CopyFrom(from);
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _internal_metadata_.unknown_fields();
  }

  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return _internal_metadata_.mutable_unknown_fields();
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const InitCustomSubscriber& default_instance();

  void Swap(InitCustomSubscriber* other);

  // implements Message ----------------------------------------------

  inline InitCustomSubscriber* New() const { return New(NULL); }

  InitCustomSubscriber* New(::google::protobuf::Arena* arena) const;
  void CopyFrom(const ::google::protobuf::Message& from);
  void MergeFrom(const ::google::protobuf::Message& from);
  void CopyFrom(const InitCustomSubscriber& from);
  void MergeFrom(const InitCustomSubscriber& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  ::google::protobuf::uint8* InternalSerializeWithCachedSizesToArray(
      bool deterministic, ::google::protobuf::uint8* output) const;
  ::google::protobuf::uint8* SerializeWithCachedSizesToArray(::google::protobuf::uint8* output) const {
    return InternalSerializeWithCachedSizesToArray(false, output);
  }
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  void InternalSwap(InitCustomSubscriber* other);
  private:
  inline ::google::protobuf::Arena* GetArenaNoVirtual() const {
    return _internal_metadata_.arena();
  }
  inline void* MaybeArenaPtr() const {
    return _internal_metadata_.raw_arena_ptr();
  }
  public:

  ::google::protobuf::Metadata GetMetadata() const;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // required string topic_name = 1;
  bool has_topic_name() const;
  void clear_topic_name();
  static const int kTopicNameFieldNumber = 1;
  const ::std::string& topic_name() const;
  void set_topic_name(const ::std::string& value);
  void set_topic_name(const char* value);
  void set_topic_name(const char* value, size_t size);
  ::std::string* mutable_topic_name();
  ::std::string* release_topic_name();
  void set_allocated_topic_name(::std::string* topic_name);

  // required string message_type = 2;
  bool has_message_type() const;
  void clear_message_type();
  static const int kMessageTypeFieldNumber = 2;
  const ::std::string& message_type() const;
  void set_message_type(const ::std::string& value);
  void set_message_type(const char* value);
  void set_message_type(const char* value, size_t size);
  ::std::string* mutable_message_type();
  ::std::string* release_message_type();
  void set_allocated_message_type(::std::string* message_type);

  // @@protoc_insertion_point(class_scope:mw.internal.robotics.gazebotransport.InitCustomSubscriber)
 private:
  inline void set_has_topic_name();
  inline void clear_has_topic_name();
  inline void set_has_message_type();
  inline void clear_has_message_type();

  // helper for ByteSize()
  int RequiredFieldsByteSizeFallback() const;

  ::google::protobuf::internal::InternalMetadataWithArena _internal_metadata_;
  ::google::protobuf::uint32 _has_bits_[1];
  mutable int _cached_size_;
  ::google::protobuf::internal::ArenaStringPtr topic_name_;
  ::google::protobuf::internal::ArenaStringPtr message_type_;
  friend void  protobuf_AddDesc_mw_2einternal_2erobotics_2egazebotransport_2eCoSimMsgs_2eproto();
  friend void protobuf_AssignDesc_mw_2einternal_2erobotics_2egazebotransport_2eCoSimMsgs_2eproto();
  friend void protobuf_ShutdownFile_mw_2einternal_2erobotics_2egazebotransport_2eCoSimMsgs_2eproto();

  void InitAsDefaultInstance();
  static InitCustomSubscriber* default_instance_;
};
// -------------------------------------------------------------------

class CustomMessageSupport : public ::google::protobuf::Message /* @@protoc_insertion_point(class_definition:mw.internal.robotics.gazebotransport.CustomMessageSupport) */ {
 public:
  CustomMessageSupport();
  virtual ~CustomMessageSupport();

  CustomMessageSupport(const CustomMessageSupport& from);

  inline CustomMessageSupport& operator=(const CustomMessageSupport& from) {
    CopyFrom(from);
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _internal_metadata_.unknown_fields();
  }

  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return _internal_metadata_.mutable_unknown_fields();
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const CustomMessageSupport& default_instance();

  void Swap(CustomMessageSupport* other);

  // implements Message ----------------------------------------------

  inline CustomMessageSupport* New() const { return New(NULL); }

  CustomMessageSupport* New(::google::protobuf::Arena* arena) const;
  void CopyFrom(const ::google::protobuf::Message& from);
  void MergeFrom(const ::google::protobuf::Message& from);
  void CopyFrom(const CustomMessageSupport& from);
  void MergeFrom(const CustomMessageSupport& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  ::google::protobuf::uint8* InternalSerializeWithCachedSizesToArray(
      bool deterministic, ::google::protobuf::uint8* output) const;
  ::google::protobuf::uint8* SerializeWithCachedSizesToArray(::google::protobuf::uint8* output) const {
    return InternalSerializeWithCachedSizesToArray(false, output);
  }
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  void InternalSwap(CustomMessageSupport* other);
  private:
  inline ::google::protobuf::Arena* GetArenaNoVirtual() const {
    return _internal_metadata_.arena();
  }
  inline void* MaybeArenaPtr() const {
    return _internal_metadata_.raw_arena_ptr();
  }
  public:

  ::google::protobuf::Metadata GetMetadata() const;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // required string topic_name = 1;
  bool has_topic_name() const;
  void clear_topic_name();
  static const int kTopicNameFieldNumber = 1;
  const ::std::string& topic_name() const;
  void set_topic_name(const ::std::string& value);
  void set_topic_name(const char* value);
  void set_topic_name(const char* value, size_t size);
  ::std::string* mutable_topic_name();
  ::std::string* release_topic_name();
  void set_allocated_topic_name(::std::string* topic_name);

  // required string message_type = 2;
  bool has_message_type() const;
  void clear_message_type();
  static const int kMessageTypeFieldNumber = 2;
  const ::std::string& message_type() const;
  void set_message_type(const ::std::string& value);
  void set_message_type(const char* value);
  void set_message_type(const char* value, size_t size);
  ::std::string* mutable_message_type();
  ::std::string* release_message_type();
  void set_allocated_message_type(::std::string* message_type);

  // required bytes data = 3;
  bool has_data() const;
  void clear_data();
  static const int kDataFieldNumber = 3;
  const ::std::string& data() const;
  void set_data(const ::std::string& value);
  void set_data(const char* value);
  void set_data(const void* value, size_t size);
  ::std::string* mutable_data();
  ::std::string* release_data();
  void set_allocated_data(::std::string* data);

  // optional bool is_new = 4;
  bool has_is_new() const;
  void clear_is_new();
  static const int kIsNewFieldNumber = 4;
  bool is_new() const;
  void set_is_new(bool value);

  // @@protoc_insertion_point(class_scope:mw.internal.robotics.gazebotransport.CustomMessageSupport)
 private:
  inline void set_has_topic_name();
  inline void clear_has_topic_name();
  inline void set_has_message_type();
  inline void clear_has_message_type();
  inline void set_has_data();
  inline void clear_has_data();
  inline void set_has_is_new();
  inline void clear_has_is_new();

  // helper for ByteSize()
  int RequiredFieldsByteSizeFallback() const;

  ::google::protobuf::internal::InternalMetadataWithArena _internal_metadata_;
  ::google::protobuf::uint32 _has_bits_[1];
  mutable int _cached_size_;
  ::google::protobuf::internal::ArenaStringPtr topic_name_;
  ::google::protobuf::internal::ArenaStringPtr message_type_;
  ::google::protobuf::internal::ArenaStringPtr data_;
  bool is_new_;
  friend void  protobuf_AddDesc_mw_2einternal_2erobotics_2egazebotransport_2eCoSimMsgs_2eproto();
  friend void protobuf_AssignDesc_mw_2einternal_2erobotics_2egazebotransport_2eCoSimMsgs_2eproto();
  friend void protobuf_ShutdownFile_mw_2einternal_2erobotics_2egazebotransport_2eCoSimMsgs_2eproto();

  void InitAsDefaultInstance();
  static CustomMessageSupport* default_instance_;
};
// -------------------------------------------------------------------

class RequestCustomMessageSupport : public ::google::protobuf::Message /* @@protoc_insertion_point(class_definition:mw.internal.robotics.gazebotransport.RequestCustomMessageSupport) */ {
 public:
  RequestCustomMessageSupport();
  virtual ~RequestCustomMessageSupport();

  RequestCustomMessageSupport(const RequestCustomMessageSupport& from);

  inline RequestCustomMessageSupport& operator=(const RequestCustomMessageSupport& from) {
    CopyFrom(from);
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _internal_metadata_.unknown_fields();
  }

  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return _internal_metadata_.mutable_unknown_fields();
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const RequestCustomMessageSupport& default_instance();

  void Swap(RequestCustomMessageSupport* other);

  // implements Message ----------------------------------------------

  inline RequestCustomMessageSupport* New() const { return New(NULL); }

  RequestCustomMessageSupport* New(::google::protobuf::Arena* arena) const;
  void CopyFrom(const ::google::protobuf::Message& from);
  void MergeFrom(const ::google::protobuf::Message& from);
  void CopyFrom(const RequestCustomMessageSupport& from);
  void MergeFrom(const RequestCustomMessageSupport& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  ::google::protobuf::uint8* InternalSerializeWithCachedSizesToArray(
      bool deterministic, ::google::protobuf::uint8* output) const;
  ::google::protobuf::uint8* SerializeWithCachedSizesToArray(::google::protobuf::uint8* output) const {
    return InternalSerializeWithCachedSizesToArray(false, output);
  }
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  void InternalSwap(RequestCustomMessageSupport* other);
  private:
  inline ::google::protobuf::Arena* GetArenaNoVirtual() const {
    return _internal_metadata_.arena();
  }
  inline void* MaybeArenaPtr() const {
    return _internal_metadata_.raw_arena_ptr();
  }
  public:

  ::google::protobuf::Metadata GetMetadata() const;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // required string topic_name = 1;
  bool has_topic_name() const;
  void clear_topic_name();
  static const int kTopicNameFieldNumber = 1;
  const ::std::string& topic_name() const;
  void set_topic_name(const ::std::string& value);
  void set_topic_name(const char* value);
  void set_topic_name(const char* value, size_t size);
  ::std::string* mutable_topic_name();
  ::std::string* release_topic_name();
  void set_allocated_topic_name(::std::string* topic_name);

  // required string message_type = 2;
  bool has_message_type() const;
  void clear_message_type();
  static const int kMessageTypeFieldNumber = 2;
  const ::std::string& message_type() const;
  void set_message_type(const ::std::string& value);
  void set_message_type(const char* value);
  void set_message_type(const char* value, size_t size);
  ::std::string* mutable_message_type();
  ::std::string* release_message_type();
  void set_allocated_message_type(::std::string* message_type);

  // @@protoc_insertion_point(class_scope:mw.internal.robotics.gazebotransport.RequestCustomMessageSupport)
 private:
  inline void set_has_topic_name();
  inline void clear_has_topic_name();
  inline void set_has_message_type();
  inline void clear_has_message_type();

  // helper for ByteSize()
  int RequiredFieldsByteSizeFallback() const;

  ::google::protobuf::internal::InternalMetadataWithArena _internal_metadata_;
  ::google::protobuf::uint32 _has_bits_[1];
  mutable int _cached_size_;
  ::google::protobuf::internal::ArenaStringPtr topic_name_;
  ::google::protobuf::internal::ArenaStringPtr message_type_;
  friend void  protobuf_AddDesc_mw_2einternal_2erobotics_2egazebotransport_2eCoSimMsgs_2eproto();
  friend void protobuf_AssignDesc_mw_2einternal_2erobotics_2egazebotransport_2eCoSimMsgs_2eproto();
  friend void protobuf_ShutdownFile_mw_2einternal_2erobotics_2egazebotransport_2eCoSimMsgs_2eproto();

  void InitAsDefaultInstance();
  static RequestCustomMessageSupport* default_instance_;
};
// -------------------------------------------------------------------

class SetJointPosition : public ::google::protobuf::Message /* @@protoc_insertion_point(class_definition:mw.internal.robotics.gazebotransport.SetJointPosition) */ {
 public:
  SetJointPosition();
  virtual ~SetJointPosition();

  SetJointPosition(const SetJointPosition& from);

  inline SetJointPosition& operator=(const SetJointPosition& from) {
    CopyFrom(from);
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _internal_metadata_.unknown_fields();
  }

  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return _internal_metadata_.mutable_unknown_fields();
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const SetJointPosition& default_instance();

  void Swap(SetJointPosition* other);

  // implements Message ----------------------------------------------

  inline SetJointPosition* New() const { return New(NULL); }

  SetJointPosition* New(::google::protobuf::Arena* arena) const;
  void CopyFrom(const ::google::protobuf::Message& from);
  void MergeFrom(const ::google::protobuf::Message& from);
  void CopyFrom(const SetJointPosition& from);
  void MergeFrom(const SetJointPosition& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  ::google::protobuf::uint8* InternalSerializeWithCachedSizesToArray(
      bool deterministic, ::google::protobuf::uint8* output) const;
  ::google::protobuf::uint8* SerializeWithCachedSizesToArray(::google::protobuf::uint8* output) const {
    return InternalSerializeWithCachedSizesToArray(false, output);
  }
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  void InternalSwap(SetJointPosition* other);
  private:
  inline ::google::protobuf::Arena* GetArenaNoVirtual() const {
    return _internal_metadata_.arena();
  }
  inline void* MaybeArenaPtr() const {
    return _internal_metadata_.raw_arena_ptr();
  }
  public:

  ::google::protobuf::Metadata GetMetadata() const;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // required string model_name = 1;
  bool has_model_name() const;
  void clear_model_name();
  static const int kModelNameFieldNumber = 1;
  const ::std::string& model_name() const;
  void set_model_name(const ::std::string& value);
  void set_model_name(const char* value);
  void set_model_name(const char* value, size_t size);
  ::std::string* mutable_model_name();
  ::std::string* release_model_name();
  void set_allocated_model_name(::std::string* model_name);

  // required string joint_name = 2;
  bool has_joint_name() const;
  void clear_joint_name();
  static const int kJointNameFieldNumber = 2;
  const ::std::string& joint_name() const;
  void set_joint_name(const ::std::string& value);
  void set_joint_name(const char* value);
  void set_joint_name(const char* value, size_t size);
  ::std::string* mutable_joint_name();
  ::std::string* release_joint_name();
  void set_allocated_joint_name(::std::string* joint_name);

  // required uint32 index = 3;
  bool has_index() const;
  void clear_index();
  static const int kIndexFieldNumber = 3;
  ::google::protobuf::uint32 index() const;
  void set_index(::google::protobuf::uint32 value);

  // required double position = 4;
  bool has_position() const;
  void clear_position();
  static const int kPositionFieldNumber = 4;
  double position() const;
  void set_position(double value);

  // required .mw.internal.robotics.gazebotransport.Time duration = 5;
  bool has_duration() const;
  void clear_duration();
  static const int kDurationFieldNumber = 5;
  const ::mw::internal::robotics::gazebotransport::Time& duration() const;
  ::mw::internal::robotics::gazebotransport::Time* mutable_duration();
  ::mw::internal::robotics::gazebotransport::Time* release_duration();
  void set_allocated_duration(::mw::internal::robotics::gazebotransport::Time* duration);

  // @@protoc_insertion_point(class_scope:mw.internal.robotics.gazebotransport.SetJointPosition)
 private:
  inline void set_has_model_name();
  inline void clear_has_model_name();
  inline void set_has_joint_name();
  inline void clear_has_joint_name();
  inline void set_has_index();
  inline void clear_has_index();
  inline void set_has_position();
  inline void clear_has_position();
  inline void set_has_duration();
  inline void clear_has_duration();

  // helper for ByteSize()
  int RequiredFieldsByteSizeFallback() const;

  ::google::protobuf::internal::InternalMetadataWithArena _internal_metadata_;
  ::google::protobuf::uint32 _has_bits_[1];
  mutable int _cached_size_;
  ::google::protobuf::internal::ArenaStringPtr model_name_;
  ::google::protobuf::internal::ArenaStringPtr joint_name_;
  double position_;
  ::mw::internal::robotics::gazebotransport::Time* duration_;
  ::google::protobuf::uint32 index_;
  friend void  protobuf_AddDesc_mw_2einternal_2erobotics_2egazebotransport_2eCoSimMsgs_2eproto();
  friend void protobuf_AssignDesc_mw_2einternal_2erobotics_2egazebotransport_2eCoSimMsgs_2eproto();
  friend void protobuf_ShutdownFile_mw_2einternal_2erobotics_2egazebotransport_2eCoSimMsgs_2eproto();

  void InitAsDefaultInstance();
  static SetJointPosition* default_instance_;
};
// -------------------------------------------------------------------

class SetJointVelocity : public ::google::protobuf::Message /* @@protoc_insertion_point(class_definition:mw.internal.robotics.gazebotransport.SetJointVelocity) */ {
 public:
  SetJointVelocity();
  virtual ~SetJointVelocity();

  SetJointVelocity(const SetJointVelocity& from);

  inline SetJointVelocity& operator=(const SetJointVelocity& from) {
    CopyFrom(from);
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _internal_metadata_.unknown_fields();
  }

  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return _internal_metadata_.mutable_unknown_fields();
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const SetJointVelocity& default_instance();

  void Swap(SetJointVelocity* other);

  // implements Message ----------------------------------------------

  inline SetJointVelocity* New() const { return New(NULL); }

  SetJointVelocity* New(::google::protobuf::Arena* arena) const;
  void CopyFrom(const ::google::protobuf::Message& from);
  void MergeFrom(const ::google::protobuf::Message& from);
  void CopyFrom(const SetJointVelocity& from);
  void MergeFrom(const SetJointVelocity& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  ::google::protobuf::uint8* InternalSerializeWithCachedSizesToArray(
      bool deterministic, ::google::protobuf::uint8* output) const;
  ::google::protobuf::uint8* SerializeWithCachedSizesToArray(::google::protobuf::uint8* output) const {
    return InternalSerializeWithCachedSizesToArray(false, output);
  }
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  void InternalSwap(SetJointVelocity* other);
  private:
  inline ::google::protobuf::Arena* GetArenaNoVirtual() const {
    return _internal_metadata_.arena();
  }
  inline void* MaybeArenaPtr() const {
    return _internal_metadata_.raw_arena_ptr();
  }
  public:

  ::google::protobuf::Metadata GetMetadata() const;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // required string model_name = 1;
  bool has_model_name() const;
  void clear_model_name();
  static const int kModelNameFieldNumber = 1;
  const ::std::string& model_name() const;
  void set_model_name(const ::std::string& value);
  void set_model_name(const char* value);
  void set_model_name(const char* value, size_t size);
  ::std::string* mutable_model_name();
  ::std::string* release_model_name();
  void set_allocated_model_name(::std::string* model_name);

  // required string joint_name = 2;
  bool has_joint_name() const;
  void clear_joint_name();
  static const int kJointNameFieldNumber = 2;
  const ::std::string& joint_name() const;
  void set_joint_name(const ::std::string& value);
  void set_joint_name(const char* value);
  void set_joint_name(const char* value, size_t size);
  ::std::string* mutable_joint_name();
  ::std::string* release_joint_name();
  void set_allocated_joint_name(::std::string* joint_name);

  // required uint32 index = 3;
  bool has_index() const;
  void clear_index();
  static const int kIndexFieldNumber = 3;
  ::google::protobuf::uint32 index() const;
  void set_index(::google::protobuf::uint32 value);

  // required double velocity = 4;
  bool has_velocity() const;
  void clear_velocity();
  static const int kVelocityFieldNumber = 4;
  double velocity() const;
  void set_velocity(double value);

  // required .mw.internal.robotics.gazebotransport.Time duration = 5;
  bool has_duration() const;
  void clear_duration();
  static const int kDurationFieldNumber = 5;
  const ::mw::internal::robotics::gazebotransport::Time& duration() const;
  ::mw::internal::robotics::gazebotransport::Time* mutable_duration();
  ::mw::internal::robotics::gazebotransport::Time* release_duration();
  void set_allocated_duration(::mw::internal::robotics::gazebotransport::Time* duration);

  // @@protoc_insertion_point(class_scope:mw.internal.robotics.gazebotransport.SetJointVelocity)
 private:
  inline void set_has_model_name();
  inline void clear_has_model_name();
  inline void set_has_joint_name();
  inline void clear_has_joint_name();
  inline void set_has_index();
  inline void clear_has_index();
  inline void set_has_velocity();
  inline void clear_has_velocity();
  inline void set_has_duration();
  inline void clear_has_duration();

  // helper for ByteSize()
  int RequiredFieldsByteSizeFallback() const;

  ::google::protobuf::internal::InternalMetadataWithArena _internal_metadata_;
  ::google::protobuf::uint32 _has_bits_[1];
  mutable int _cached_size_;
  ::google::protobuf::internal::ArenaStringPtr model_name_;
  ::google::protobuf::internal::ArenaStringPtr joint_name_;
  double velocity_;
  ::mw::internal::robotics::gazebotransport::Time* duration_;
  ::google::protobuf::uint32 index_;
  friend void  protobuf_AddDesc_mw_2einternal_2erobotics_2egazebotransport_2eCoSimMsgs_2eproto();
  friend void protobuf_AssignDesc_mw_2einternal_2erobotics_2egazebotransport_2eCoSimMsgs_2eproto();
  friend void protobuf_ShutdownFile_mw_2einternal_2erobotics_2egazebotransport_2eCoSimMsgs_2eproto();

  void InitAsDefaultInstance();
  static SetJointVelocity* default_instance_;
};
// -------------------------------------------------------------------

class GetJointState : public ::google::protobuf::Message /* @@protoc_insertion_point(class_definition:mw.internal.robotics.gazebotransport.GetJointState) */ {
 public:
  GetJointState();
  virtual ~GetJointState();

  GetJointState(const GetJointState& from);

  inline GetJointState& operator=(const GetJointState& from) {
    CopyFrom(from);
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _internal_metadata_.unknown_fields();
  }

  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return _internal_metadata_.mutable_unknown_fields();
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const GetJointState& default_instance();

  void Swap(GetJointState* other);

  // implements Message ----------------------------------------------

  inline GetJointState* New() const { return New(NULL); }

  GetJointState* New(::google::protobuf::Arena* arena) const;
  void CopyFrom(const ::google::protobuf::Message& from);
  void MergeFrom(const ::google::protobuf::Message& from);
  void CopyFrom(const GetJointState& from);
  void MergeFrom(const GetJointState& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  ::google::protobuf::uint8* InternalSerializeWithCachedSizesToArray(
      bool deterministic, ::google::protobuf::uint8* output) const;
  ::google::protobuf::uint8* SerializeWithCachedSizesToArray(::google::protobuf::uint8* output) const {
    return InternalSerializeWithCachedSizesToArray(false, output);
  }
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  void InternalSwap(GetJointState* other);
  private:
  inline ::google::protobuf::Arena* GetArenaNoVirtual() const {
    return _internal_metadata_.arena();
  }
  inline void* MaybeArenaPtr() const {
    return _internal_metadata_.raw_arena_ptr();
  }
  public:

  ::google::protobuf::Metadata GetMetadata() const;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // required string model_name = 1;
  bool has_model_name() const;
  void clear_model_name();
  static const int kModelNameFieldNumber = 1;
  const ::std::string& model_name() const;
  void set_model_name(const ::std::string& value);
  void set_model_name(const char* value);
  void set_model_name(const char* value, size_t size);
  ::std::string* mutable_model_name();
  ::std::string* release_model_name();
  void set_allocated_model_name(::std::string* model_name);

  // required string joint_name = 2;
  bool has_joint_name() const;
  void clear_joint_name();
  static const int kJointNameFieldNumber = 2;
  const ::std::string& joint_name() const;
  void set_joint_name(const ::std::string& value);
  void set_joint_name(const char* value);
  void set_joint_name(const char* value, size_t size);
  ::std::string* mutable_joint_name();
  ::std::string* release_joint_name();
  void set_allocated_joint_name(::std::string* joint_name);

  // @@protoc_insertion_point(class_scope:mw.internal.robotics.gazebotransport.GetJointState)
 private:
  inline void set_has_model_name();
  inline void clear_has_model_name();
  inline void set_has_joint_name();
  inline void clear_has_joint_name();

  // helper for ByteSize()
  int RequiredFieldsByteSizeFallback() const;

  ::google::protobuf::internal::InternalMetadataWithArena _internal_metadata_;
  ::google::protobuf::uint32 _has_bits_[1];
  mutable int _cached_size_;
  ::google::protobuf::internal::ArenaStringPtr model_name_;
  ::google::protobuf::internal::ArenaStringPtr joint_name_;
  friend void  protobuf_AddDesc_mw_2einternal_2erobotics_2egazebotransport_2eCoSimMsgs_2eproto();
  friend void protobuf_AssignDesc_mw_2einternal_2erobotics_2egazebotransport_2eCoSimMsgs_2eproto();
  friend void protobuf_ShutdownFile_mw_2einternal_2erobotics_2egazebotransport_2eCoSimMsgs_2eproto();

  void InitAsDefaultInstance();
  static GetJointState* default_instance_;
};
// -------------------------------------------------------------------

class Axis : public ::google::protobuf::Message /* @@protoc_insertion_point(class_definition:mw.internal.robotics.gazebotransport.Axis) */ {
 public:
  Axis();
  virtual ~Axis();

  Axis(const Axis& from);

  inline Axis& operator=(const Axis& from) {
    CopyFrom(from);
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _internal_metadata_.unknown_fields();
  }

  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return _internal_metadata_.mutable_unknown_fields();
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const Axis& default_instance();

  void Swap(Axis* other);

  // implements Message ----------------------------------------------

  inline Axis* New() const { return New(NULL); }

  Axis* New(::google::protobuf::Arena* arena) const;
  void CopyFrom(const ::google::protobuf::Message& from);
  void MergeFrom(const ::google::protobuf::Message& from);
  void CopyFrom(const Axis& from);
  void MergeFrom(const Axis& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  ::google::protobuf::uint8* InternalSerializeWithCachedSizesToArray(
      bool deterministic, ::google::protobuf::uint8* output) const;
  ::google::protobuf::uint8* SerializeWithCachedSizesToArray(::google::protobuf::uint8* output) const {
    return InternalSerializeWithCachedSizesToArray(false, output);
  }
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  void InternalSwap(Axis* other);
  private:
  inline ::google::protobuf::Arena* GetArenaNoVirtual() const {
    return _internal_metadata_.arena();
  }
  inline void* MaybeArenaPtr() const {
    return _internal_metadata_.raw_arena_ptr();
  }
  public:

  ::google::protobuf::Metadata GetMetadata() const;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // required .mw.internal.robotics.gazebotransport.Point xyz = 1;
  bool has_xyz() const;
  void clear_xyz();
  static const int kXyzFieldNumber = 1;
  const ::mw::internal::robotics::gazebotransport::Point& xyz() const;
  ::mw::internal::robotics::gazebotransport::Point* mutable_xyz();
  ::mw::internal::robotics::gazebotransport::Point* release_xyz();
  void set_allocated_xyz(::mw::internal::robotics::gazebotransport::Point* xyz);

  // required double limit_lower = 2;
  bool has_limit_lower() const;
  void clear_limit_lower();
  static const int kLimitLowerFieldNumber = 2;
  double limit_lower() const;
  void set_limit_lower(double value);

  // required double limit_upper = 3;
  bool has_limit_upper() const;
  void clear_limit_upper();
  static const int kLimitUpperFieldNumber = 3;
  double limit_upper() const;
  void set_limit_upper(double value);

  // required double limit_effort = 4;
  bool has_limit_effort() const;
  void clear_limit_effort();
  static const int kLimitEffortFieldNumber = 4;
  double limit_effort() const;
  void set_limit_effort(double value);

  // required double limit_velocity = 5;
  bool has_limit_velocity() const;
  void clear_limit_velocity();
  static const int kLimitVelocityFieldNumber = 5;
  double limit_velocity() const;
  void set_limit_velocity(double value);

  // required double damping = 6;
  bool has_damping() const;
  void clear_damping();
  static const int kDampingFieldNumber = 6;
  double damping() const;
  void set_damping(double value);

  // required double friction = 7;
  bool has_friction() const;
  void clear_friction();
  static const int kFrictionFieldNumber = 7;
  double friction() const;
  void set_friction(double value);

  // required bool use_parent_model_frame = 8;
  bool has_use_parent_model_frame() const;
  void clear_use_parent_model_frame();
  static const int kUseParentModelFrameFieldNumber = 8;
  bool use_parent_model_frame() const;
  void set_use_parent_model_frame(bool value);

  // @@protoc_insertion_point(class_scope:mw.internal.robotics.gazebotransport.Axis)
 private:
  inline void set_has_xyz();
  inline void clear_has_xyz();
  inline void set_has_limit_lower();
  inline void clear_has_limit_lower();
  inline void set_has_limit_upper();
  inline void clear_has_limit_upper();
  inline void set_has_limit_effort();
  inline void clear_has_limit_effort();
  inline void set_has_limit_velocity();
  inline void clear_has_limit_velocity();
  inline void set_has_damping();
  inline void clear_has_damping();
  inline void set_has_friction();
  inline void clear_has_friction();
  inline void set_has_use_parent_model_frame();
  inline void clear_has_use_parent_model_frame();

  // helper for ByteSize()
  int RequiredFieldsByteSizeFallback() const;

  ::google::protobuf::internal::InternalMetadataWithArena _internal_metadata_;
  ::google::protobuf::uint32 _has_bits_[1];
  mutable int _cached_size_;
  ::mw::internal::robotics::gazebotransport::Point* xyz_;
  double limit_lower_;
  double limit_upper_;
  double limit_effort_;
  double limit_velocity_;
  double damping_;
  double friction_;
  bool use_parent_model_frame_;
  friend void  protobuf_AddDesc_mw_2einternal_2erobotics_2egazebotransport_2eCoSimMsgs_2eproto();
  friend void protobuf_AssignDesc_mw_2einternal_2erobotics_2egazebotransport_2eCoSimMsgs_2eproto();
  friend void protobuf_ShutdownFile_mw_2einternal_2erobotics_2egazebotransport_2eCoSimMsgs_2eproto();

  void InitAsDefaultInstance();
  static Axis* default_instance_;
};
// -------------------------------------------------------------------

class JointState : public ::google::protobuf::Message /* @@protoc_insertion_point(class_definition:mw.internal.robotics.gazebotransport.JointState) */ {
 public:
  JointState();
  virtual ~JointState();

  JointState(const JointState& from);

  inline JointState& operator=(const JointState& from) {
    CopyFrom(from);
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _internal_metadata_.unknown_fields();
  }

  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return _internal_metadata_.mutable_unknown_fields();
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const JointState& default_instance();

  void Swap(JointState* other);

  // implements Message ----------------------------------------------

  inline JointState* New() const { return New(NULL); }

  JointState* New(::google::protobuf::Arena* arena) const;
  void CopyFrom(const ::google::protobuf::Message& from);
  void MergeFrom(const ::google::protobuf::Message& from);
  void CopyFrom(const JointState& from);
  void MergeFrom(const JointState& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  ::google::protobuf::uint8* InternalSerializeWithCachedSizesToArray(
      bool deterministic, ::google::protobuf::uint8* output) const;
  ::google::protobuf::uint8* SerializeWithCachedSizesToArray(::google::protobuf::uint8* output) const {
    return InternalSerializeWithCachedSizesToArray(false, output);
  }
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  void InternalSwap(JointState* other);
  private:
  inline ::google::protobuf::Arena* GetArenaNoVirtual() const {
    return _internal_metadata_.arena();
  }
  inline void* MaybeArenaPtr() const {
    return _internal_metadata_.raw_arena_ptr();
  }
  public:

  ::google::protobuf::Metadata GetMetadata() const;

  // nested types ----------------------------------------------------

  typedef JointState_Joint_Type Joint_Type;
  static const Joint_Type REVOLUTE =
    JointState_Joint_Type_REVOLUTE;
  static const Joint_Type REVOLUTE2 =
    JointState_Joint_Type_REVOLUTE2;
  static const Joint_Type PRISMATIC =
    JointState_Joint_Type_PRISMATIC;
  static const Joint_Type UNIVERSAL =
    JointState_Joint_Type_UNIVERSAL;
  static const Joint_Type BALL =
    JointState_Joint_Type_BALL;
  static const Joint_Type SCREW =
    JointState_Joint_Type_SCREW;
  static const Joint_Type GEARBOX =
    JointState_Joint_Type_GEARBOX;
  static const Joint_Type FIXED =
    JointState_Joint_Type_FIXED;
  static inline bool Joint_Type_IsValid(int value) {
    return JointState_Joint_Type_IsValid(value);
  }
  static const Joint_Type Joint_Type_MIN =
    JointState_Joint_Type_Joint_Type_MIN;
  static const Joint_Type Joint_Type_MAX =
    JointState_Joint_Type_Joint_Type_MAX;
  static const int Joint_Type_ARRAYSIZE =
    JointState_Joint_Type_Joint_Type_ARRAYSIZE;
  static inline const ::google::protobuf::EnumDescriptor*
  Joint_Type_descriptor() {
    return JointState_Joint_Type_descriptor();
  }
  static inline const ::std::string& Joint_Type_Name(Joint_Type value) {
    return JointState_Joint_Type_Name(value);
  }
  static inline bool Joint_Type_Parse(const ::std::string& name,
      Joint_Type* value) {
    return JointState_Joint_Type_Parse(name, value);
  }

  // accessors -------------------------------------------------------

  // required string model_name = 1;
  bool has_model_name() const;
  void clear_model_name();
  static const int kModelNameFieldNumber = 1;
  const ::std::string& model_name() const;
  void set_model_name(const ::std::string& value);
  void set_model_name(const char* value);
  void set_model_name(const char* value, size_t size);
  ::std::string* mutable_model_name();
  ::std::string* release_model_name();
  void set_allocated_model_name(::std::string* model_name);

  // required string joint_name = 2;
  bool has_joint_name() const;
  void clear_joint_name();
  static const int kJointNameFieldNumber = 2;
  const ::std::string& joint_name() const;
  void set_joint_name(const ::std::string& value);
  void set_joint_name(const char* value);
  void set_joint_name(const char* value, size_t size);
  ::std::string* mutable_joint_name();
  ::std::string* release_joint_name();
  void set_allocated_joint_name(::std::string* joint_name);

  // required uint32 joint_id = 3;
  bool has_joint_id() const;
  void clear_joint_id();
  static const int kJointIdFieldNumber = 3;
  ::google::protobuf::uint32 joint_id() const;
  void set_joint_id(::google::protobuf::uint32 value);

  // repeated double joint_position = 4;
  int joint_position_size() const;
  void clear_joint_position();
  static const int kJointPositionFieldNumber = 4;
  double joint_position(int index) const;
  void set_joint_position(int index, double value);
  void add_joint_position(double value);
  const ::google::protobuf::RepeatedField< double >&
      joint_position() const;
  ::google::protobuf::RepeatedField< double >*
      mutable_joint_position();

  // repeated double joint_velocity = 5;
  int joint_velocity_size() const;
  void clear_joint_velocity();
  static const int kJointVelocityFieldNumber = 5;
  double joint_velocity(int index) const;
  void set_joint_velocity(int index, double value);
  void add_joint_velocity(double value);
  const ::google::protobuf::RepeatedField< double >&
      joint_velocity() const;
  ::google::protobuf::RepeatedField< double >*
      mutable_joint_velocity();

  // optional .mw.internal.robotics.gazebotransport.JointState.Joint_Type joint_type = 6;
  bool has_joint_type() const;
  void clear_joint_type();
  static const int kJointTypeFieldNumber = 6;
  ::mw::internal::robotics::gazebotransport::JointState_Joint_Type joint_type() const;
  void set_joint_type(::mw::internal::robotics::gazebotransport::JointState_Joint_Type value);

  // optional string parent_name = 7;
  bool has_parent_name() const;
  void clear_parent_name();
  static const int kParentNameFieldNumber = 7;
  const ::std::string& parent_name() const;
  void set_parent_name(const ::std::string& value);
  void set_parent_name(const char* value);
  void set_parent_name(const char* value, size_t size);
  ::std::string* mutable_parent_name();
  ::std::string* release_parent_name();
  void set_allocated_parent_name(::std::string* parent_name);

  // optional uint32 parent_id = 8;
  bool has_parent_id() const;
  void clear_parent_id();
  static const int kParentIdFieldNumber = 8;
  ::google::protobuf::uint32 parent_id() const;
  void set_parent_id(::google::protobuf::uint32 value);

  // optional string child_name = 9;
  bool has_child_name() const;
  void clear_child_name();
  static const int kChildNameFieldNumber = 9;
  const ::std::string& child_name() const;
  void set_child_name(const ::std::string& value);
  void set_child_name(const char* value);
  void set_child_name(const char* value, size_t size);
  ::std::string* mutable_child_name();
  ::std::string* release_child_name();
  void set_allocated_child_name(::std::string* child_name);

  // optional uint32 child_id = 10;
  bool has_child_id() const;
  void clear_child_id();
  static const int kChildIdFieldNumber = 10;
  ::google::protobuf::uint32 child_id() const;
  void set_child_id(::google::protobuf::uint32 value);

  // optional .mw.internal.robotics.gazebotransport.Pose initial_anchor_pose = 11;
  bool has_initial_anchor_pose() const;
  void clear_initial_anchor_pose();
  static const int kInitialAnchorPoseFieldNumber = 11;
  const ::mw::internal::robotics::gazebotransport::Pose& initial_anchor_pose() const;
  ::mw::internal::robotics::gazebotransport::Pose* mutable_initial_anchor_pose();
  ::mw::internal::robotics::gazebotransport::Pose* release_initial_anchor_pose();
  void set_allocated_initial_anchor_pose(::mw::internal::robotics::gazebotransport::Pose* initial_anchor_pose);

  // optional .mw.internal.robotics.gazebotransport.Pose world_pose = 12;
  bool has_world_pose() const;
  void clear_world_pose();
  static const int kWorldPoseFieldNumber = 12;
  const ::mw::internal::robotics::gazebotransport::Pose& world_pose() const;
  ::mw::internal::robotics::gazebotransport::Pose* mutable_world_pose();
  ::mw::internal::robotics::gazebotransport::Pose* release_world_pose();
  void set_allocated_world_pose(::mw::internal::robotics::gazebotransport::Pose* world_pose);

  // optional .mw.internal.robotics.gazebotransport.Pose parent_world_pose = 13;
  bool has_parent_world_pose() const;
  void clear_parent_world_pose();
  static const int kParentWorldPoseFieldNumber = 13;
  const ::mw::internal::robotics::gazebotransport::Pose& parent_world_pose() const;
  ::mw::internal::robotics::gazebotransport::Pose* mutable_parent_world_pose();
  ::mw::internal::robotics::gazebotransport::Pose* release_parent_world_pose();
  void set_allocated_parent_world_pose(::mw::internal::robotics::gazebotransport::Pose* parent_world_pose);

  // repeated .mw.internal.robotics.gazebotransport.Axis axis = 14;
  int axis_size() const;
  void clear_axis();
  static const int kAxisFieldNumber = 14;
  const ::mw::internal::robotics::gazebotransport::Axis& axis(int index) const;
  ::mw::internal::robotics::gazebotransport::Axis* mutable_axis(int index);
  ::mw::internal::robotics::gazebotransport::Axis* add_axis();
  ::google::protobuf::RepeatedPtrField< ::mw::internal::robotics::gazebotransport::Axis >*
      mutable_axis();
  const ::google::protobuf::RepeatedPtrField< ::mw::internal::robotics::gazebotransport::Axis >&
      axis() const;

  // @@protoc_insertion_point(class_scope:mw.internal.robotics.gazebotransport.JointState)
 private:
  inline void set_has_model_name();
  inline void clear_has_model_name();
  inline void set_has_joint_name();
  inline void clear_has_joint_name();
  inline void set_has_joint_id();
  inline void clear_has_joint_id();
  inline void set_has_joint_type();
  inline void clear_has_joint_type();
  inline void set_has_parent_name();
  inline void clear_has_parent_name();
  inline void set_has_parent_id();
  inline void clear_has_parent_id();
  inline void set_has_child_name();
  inline void clear_has_child_name();
  inline void set_has_child_id();
  inline void clear_has_child_id();
  inline void set_has_initial_anchor_pose();
  inline void clear_has_initial_anchor_pose();
  inline void set_has_world_pose();
  inline void clear_has_world_pose();
  inline void set_has_parent_world_pose();
  inline void clear_has_parent_world_pose();

  // helper for ByteSize()
  int RequiredFieldsByteSizeFallback() const;

  ::google::protobuf::internal::InternalMetadataWithArena _internal_metadata_;
  ::google::protobuf::uint32 _has_bits_[1];
  mutable int _cached_size_;
  ::google::protobuf::internal::ArenaStringPtr model_name_;
  ::google::protobuf::internal::ArenaStringPtr joint_name_;
  ::google::protobuf::RepeatedField< double > joint_position_;
  ::google::protobuf::uint32 joint_id_;
  int joint_type_;
  ::google::protobuf::RepeatedField< double > joint_velocity_;
  ::google::protobuf::internal::ArenaStringPtr parent_name_;
  ::google::protobuf::internal::ArenaStringPtr child_name_;
  ::google::protobuf::uint32 parent_id_;
  ::google::protobuf::uint32 child_id_;
  ::mw::internal::robotics::gazebotransport::Pose* initial_anchor_pose_;
  ::mw::internal::robotics::gazebotransport::Pose* world_pose_;
  ::mw::internal::robotics::gazebotransport::Pose* parent_world_pose_;
  ::google::protobuf::RepeatedPtrField< ::mw::internal::robotics::gazebotransport::Axis > axis_;
  friend void  protobuf_AddDesc_mw_2einternal_2erobotics_2egazebotransport_2eCoSimMsgs_2eproto();
  friend void protobuf_AssignDesc_mw_2einternal_2erobotics_2egazebotransport_2eCoSimMsgs_2eproto();
  friend void protobuf_ShutdownFile_mw_2einternal_2erobotics_2egazebotransport_2eCoSimMsgs_2eproto();

  void InitAsDefaultInstance();
  static JointState* default_instance_;
};
// -------------------------------------------------------------------

class SetLinkWorldPose : public ::google::protobuf::Message /* @@protoc_insertion_point(class_definition:mw.internal.robotics.gazebotransport.SetLinkWorldPose) */ {
 public:
  SetLinkWorldPose();
  virtual ~SetLinkWorldPose();

  SetLinkWorldPose(const SetLinkWorldPose& from);

  inline SetLinkWorldPose& operator=(const SetLinkWorldPose& from) {
    CopyFrom(from);
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _internal_metadata_.unknown_fields();
  }

  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return _internal_metadata_.mutable_unknown_fields();
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const SetLinkWorldPose& default_instance();

  void Swap(SetLinkWorldPose* other);

  // implements Message ----------------------------------------------

  inline SetLinkWorldPose* New() const { return New(NULL); }

  SetLinkWorldPose* New(::google::protobuf::Arena* arena) const;
  void CopyFrom(const ::google::protobuf::Message& from);
  void MergeFrom(const ::google::protobuf::Message& from);
  void CopyFrom(const SetLinkWorldPose& from);
  void MergeFrom(const SetLinkWorldPose& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  ::google::protobuf::uint8* InternalSerializeWithCachedSizesToArray(
      bool deterministic, ::google::protobuf::uint8* output) const;
  ::google::protobuf::uint8* SerializeWithCachedSizesToArray(::google::protobuf::uint8* output) const {
    return InternalSerializeWithCachedSizesToArray(false, output);
  }
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  void InternalSwap(SetLinkWorldPose* other);
  private:
  inline ::google::protobuf::Arena* GetArenaNoVirtual() const {
    return _internal_metadata_.arena();
  }
  inline void* MaybeArenaPtr() const {
    return _internal_metadata_.raw_arena_ptr();
  }
  public:

  ::google::protobuf::Metadata GetMetadata() const;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // required string model_name = 1;
  bool has_model_name() const;
  void clear_model_name();
  static const int kModelNameFieldNumber = 1;
  const ::std::string& model_name() const;
  void set_model_name(const ::std::string& value);
  void set_model_name(const char* value);
  void set_model_name(const char* value, size_t size);
  ::std::string* mutable_model_name();
  ::std::string* release_model_name();
  void set_allocated_model_name(::std::string* model_name);

  // required string link_name = 2;
  bool has_link_name() const;
  void clear_link_name();
  static const int kLinkNameFieldNumber = 2;
  const ::std::string& link_name() const;
  void set_link_name(const ::std::string& value);
  void set_link_name(const char* value);
  void set_link_name(const char* value, size_t size);
  ::std::string* mutable_link_name();
  ::std::string* release_link_name();
  void set_allocated_link_name(::std::string* link_name);

  // required .mw.internal.robotics.gazebotransport.Pose pose = 3;
  bool has_pose() const;
  void clear_pose();
  static const int kPoseFieldNumber = 3;
  const ::mw::internal::robotics::gazebotransport::Pose& pose() const;
  ::mw::internal::robotics::gazebotransport::Pose* mutable_pose();
  ::mw::internal::robotics::gazebotransport::Pose* release_pose();
  void set_allocated_pose(::mw::internal::robotics::gazebotransport::Pose* pose);

  // required .mw.internal.robotics.gazebotransport.Time duration = 4;
  bool has_duration() const;
  void clear_duration();
  static const int kDurationFieldNumber = 4;
  const ::mw::internal::robotics::gazebotransport::Time& duration() const;
  ::mw::internal::robotics::gazebotransport::Time* mutable_duration();
  ::mw::internal::robotics::gazebotransport::Time* release_duration();
  void set_allocated_duration(::mw::internal::robotics::gazebotransport::Time* duration);

  // @@protoc_insertion_point(class_scope:mw.internal.robotics.gazebotransport.SetLinkWorldPose)
 private:
  inline void set_has_model_name();
  inline void clear_has_model_name();
  inline void set_has_link_name();
  inline void clear_has_link_name();
  inline void set_has_pose();
  inline void clear_has_pose();
  inline void set_has_duration();
  inline void clear_has_duration();

  // helper for ByteSize()
  int RequiredFieldsByteSizeFallback() const;

  ::google::protobuf::internal::InternalMetadataWithArena _internal_metadata_;
  ::google::protobuf::uint32 _has_bits_[1];
  mutable int _cached_size_;
  ::google::protobuf::internal::ArenaStringPtr model_name_;
  ::google::protobuf::internal::ArenaStringPtr link_name_;
  ::mw::internal::robotics::gazebotransport::Pose* pose_;
  ::mw::internal::robotics::gazebotransport::Time* duration_;
  friend void  protobuf_AddDesc_mw_2einternal_2erobotics_2egazebotransport_2eCoSimMsgs_2eproto();
  friend void protobuf_AssignDesc_mw_2einternal_2erobotics_2egazebotransport_2eCoSimMsgs_2eproto();
  friend void protobuf_ShutdownFile_mw_2einternal_2erobotics_2egazebotransport_2eCoSimMsgs_2eproto();

  void InitAsDefaultInstance();
  static SetLinkWorldPose* default_instance_;
};
// -------------------------------------------------------------------

class SetLinkLinearVelocity : public ::google::protobuf::Message /* @@protoc_insertion_point(class_definition:mw.internal.robotics.gazebotransport.SetLinkLinearVelocity) */ {
 public:
  SetLinkLinearVelocity();
  virtual ~SetLinkLinearVelocity();

  SetLinkLinearVelocity(const SetLinkLinearVelocity& from);

  inline SetLinkLinearVelocity& operator=(const SetLinkLinearVelocity& from) {
    CopyFrom(from);
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _internal_metadata_.unknown_fields();
  }

  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return _internal_metadata_.mutable_unknown_fields();
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const SetLinkLinearVelocity& default_instance();

  void Swap(SetLinkLinearVelocity* other);

  // implements Message ----------------------------------------------

  inline SetLinkLinearVelocity* New() const { return New(NULL); }

  SetLinkLinearVelocity* New(::google::protobuf::Arena* arena) const;
  void CopyFrom(const ::google::protobuf::Message& from);
  void MergeFrom(const ::google::protobuf::Message& from);
  void CopyFrom(const SetLinkLinearVelocity& from);
  void MergeFrom(const SetLinkLinearVelocity& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  ::google::protobuf::uint8* InternalSerializeWithCachedSizesToArray(
      bool deterministic, ::google::protobuf::uint8* output) const;
  ::google::protobuf::uint8* SerializeWithCachedSizesToArray(::google::protobuf::uint8* output) const {
    return InternalSerializeWithCachedSizesToArray(false, output);
  }
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  void InternalSwap(SetLinkLinearVelocity* other);
  private:
  inline ::google::protobuf::Arena* GetArenaNoVirtual() const {
    return _internal_metadata_.arena();
  }
  inline void* MaybeArenaPtr() const {
    return _internal_metadata_.raw_arena_ptr();
  }
  public:

  ::google::protobuf::Metadata GetMetadata() const;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // required string model_name = 1;
  bool has_model_name() const;
  void clear_model_name();
  static const int kModelNameFieldNumber = 1;
  const ::std::string& model_name() const;
  void set_model_name(const ::std::string& value);
  void set_model_name(const char* value);
  void set_model_name(const char* value, size_t size);
  ::std::string* mutable_model_name();
  ::std::string* release_model_name();
  void set_allocated_model_name(::std::string* model_name);

  // required string link_name = 2;
  bool has_link_name() const;
  void clear_link_name();
  static const int kLinkNameFieldNumber = 2;
  const ::std::string& link_name() const;
  void set_link_name(const ::std::string& value);
  void set_link_name(const char* value);
  void set_link_name(const char* value, size_t size);
  ::std::string* mutable_link_name();
  ::std::string* release_link_name();
  void set_allocated_link_name(::std::string* link_name);

  // required .mw.internal.robotics.gazebotransport.Point velocity = 3;
  bool has_velocity() const;
  void clear_velocity();
  static const int kVelocityFieldNumber = 3;
  const ::mw::internal::robotics::gazebotransport::Point& velocity() const;
  ::mw::internal::robotics::gazebotransport::Point* mutable_velocity();
  ::mw::internal::robotics::gazebotransport::Point* release_velocity();
  void set_allocated_velocity(::mw::internal::robotics::gazebotransport::Point* velocity);

  // required .mw.internal.robotics.gazebotransport.Time duration = 4;
  bool has_duration() const;
  void clear_duration();
  static const int kDurationFieldNumber = 4;
  const ::mw::internal::robotics::gazebotransport::Time& duration() const;
  ::mw::internal::robotics::gazebotransport::Time* mutable_duration();
  ::mw::internal::robotics::gazebotransport::Time* release_duration();
  void set_allocated_duration(::mw::internal::robotics::gazebotransport::Time* duration);

  // @@protoc_insertion_point(class_scope:mw.internal.robotics.gazebotransport.SetLinkLinearVelocity)
 private:
  inline void set_has_model_name();
  inline void clear_has_model_name();
  inline void set_has_link_name();
  inline void clear_has_link_name();
  inline void set_has_velocity();
  inline void clear_has_velocity();
  inline void set_has_duration();
  inline void clear_has_duration();

  // helper for ByteSize()
  int RequiredFieldsByteSizeFallback() const;

  ::google::protobuf::internal::InternalMetadataWithArena _internal_metadata_;
  ::google::protobuf::uint32 _has_bits_[1];
  mutable int _cached_size_;
  ::google::protobuf::internal::ArenaStringPtr model_name_;
  ::google::protobuf::internal::ArenaStringPtr link_name_;
  ::mw::internal::robotics::gazebotransport::Point* velocity_;
  ::mw::internal::robotics::gazebotransport::Time* duration_;
  friend void  protobuf_AddDesc_mw_2einternal_2erobotics_2egazebotransport_2eCoSimMsgs_2eproto();
  friend void protobuf_AssignDesc_mw_2einternal_2erobotics_2egazebotransport_2eCoSimMsgs_2eproto();
  friend void protobuf_ShutdownFile_mw_2einternal_2erobotics_2egazebotransport_2eCoSimMsgs_2eproto();

  void InitAsDefaultInstance();
  static SetLinkLinearVelocity* default_instance_;
};
// -------------------------------------------------------------------

class SetLinkAngularVelocity : public ::google::protobuf::Message /* @@protoc_insertion_point(class_definition:mw.internal.robotics.gazebotransport.SetLinkAngularVelocity) */ {
 public:
  SetLinkAngularVelocity();
  virtual ~SetLinkAngularVelocity();

  SetLinkAngularVelocity(const SetLinkAngularVelocity& from);

  inline SetLinkAngularVelocity& operator=(const SetLinkAngularVelocity& from) {
    CopyFrom(from);
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _internal_metadata_.unknown_fields();
  }

  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return _internal_metadata_.mutable_unknown_fields();
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const SetLinkAngularVelocity& default_instance();

  void Swap(SetLinkAngularVelocity* other);

  // implements Message ----------------------------------------------

  inline SetLinkAngularVelocity* New() const { return New(NULL); }

  SetLinkAngularVelocity* New(::google::protobuf::Arena* arena) const;
  void CopyFrom(const ::google::protobuf::Message& from);
  void MergeFrom(const ::google::protobuf::Message& from);
  void CopyFrom(const SetLinkAngularVelocity& from);
  void MergeFrom(const SetLinkAngularVelocity& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  ::google::protobuf::uint8* InternalSerializeWithCachedSizesToArray(
      bool deterministic, ::google::protobuf::uint8* output) const;
  ::google::protobuf::uint8* SerializeWithCachedSizesToArray(::google::protobuf::uint8* output) const {
    return InternalSerializeWithCachedSizesToArray(false, output);
  }
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  void InternalSwap(SetLinkAngularVelocity* other);
  private:
  inline ::google::protobuf::Arena* GetArenaNoVirtual() const {
    return _internal_metadata_.arena();
  }
  inline void* MaybeArenaPtr() const {
    return _internal_metadata_.raw_arena_ptr();
  }
  public:

  ::google::protobuf::Metadata GetMetadata() const;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // required string model_name = 1;
  bool has_model_name() const;
  void clear_model_name();
  static const int kModelNameFieldNumber = 1;
  const ::std::string& model_name() const;
  void set_model_name(const ::std::string& value);
  void set_model_name(const char* value);
  void set_model_name(const char* value, size_t size);
  ::std::string* mutable_model_name();
  ::std::string* release_model_name();
  void set_allocated_model_name(::std::string* model_name);

  // required string link_name = 2;
  bool has_link_name() const;
  void clear_link_name();
  static const int kLinkNameFieldNumber = 2;
  const ::std::string& link_name() const;
  void set_link_name(const ::std::string& value);
  void set_link_name(const char* value);
  void set_link_name(const char* value, size_t size);
  ::std::string* mutable_link_name();
  ::std::string* release_link_name();
  void set_allocated_link_name(::std::string* link_name);

  // required .mw.internal.robotics.gazebotransport.Point velocity = 3;
  bool has_velocity() const;
  void clear_velocity();
  static const int kVelocityFieldNumber = 3;
  const ::mw::internal::robotics::gazebotransport::Point& velocity() const;
  ::mw::internal::robotics::gazebotransport::Point* mutable_velocity();
  ::mw::internal::robotics::gazebotransport::Point* release_velocity();
  void set_allocated_velocity(::mw::internal::robotics::gazebotransport::Point* velocity);

  // required .mw.internal.robotics.gazebotransport.Time duration = 4;
  bool has_duration() const;
  void clear_duration();
  static const int kDurationFieldNumber = 4;
  const ::mw::internal::robotics::gazebotransport::Time& duration() const;
  ::mw::internal::robotics::gazebotransport::Time* mutable_duration();
  ::mw::internal::robotics::gazebotransport::Time* release_duration();
  void set_allocated_duration(::mw::internal::robotics::gazebotransport::Time* duration);

  // @@protoc_insertion_point(class_scope:mw.internal.robotics.gazebotransport.SetLinkAngularVelocity)
 private:
  inline void set_has_model_name();
  inline void clear_has_model_name();
  inline void set_has_link_name();
  inline void clear_has_link_name();
  inline void set_has_velocity();
  inline void clear_has_velocity();
  inline void set_has_duration();
  inline void clear_has_duration();

  // helper for ByteSize()
  int RequiredFieldsByteSizeFallback() const;

  ::google::protobuf::internal::InternalMetadataWithArena _internal_metadata_;
  ::google::protobuf::uint32 _has_bits_[1];
  mutable int _cached_size_;
  ::google::protobuf::internal::ArenaStringPtr model_name_;
  ::google::protobuf::internal::ArenaStringPtr link_name_;
  ::mw::internal::robotics::gazebotransport::Point* velocity_;
  ::mw::internal::robotics::gazebotransport::Time* duration_;
  friend void  protobuf_AddDesc_mw_2einternal_2erobotics_2egazebotransport_2eCoSimMsgs_2eproto();
  friend void protobuf_AssignDesc_mw_2einternal_2erobotics_2egazebotransport_2eCoSimMsgs_2eproto();
  friend void protobuf_ShutdownFile_mw_2einternal_2erobotics_2egazebotransport_2eCoSimMsgs_2eproto();

  void InitAsDefaultInstance();
  static SetLinkAngularVelocity* default_instance_;
};
// -------------------------------------------------------------------

class GetLinkState : public ::google::protobuf::Message /* @@protoc_insertion_point(class_definition:mw.internal.robotics.gazebotransport.GetLinkState) */ {
 public:
  GetLinkState();
  virtual ~GetLinkState();

  GetLinkState(const GetLinkState& from);

  inline GetLinkState& operator=(const GetLinkState& from) {
    CopyFrom(from);
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _internal_metadata_.unknown_fields();
  }

  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return _internal_metadata_.mutable_unknown_fields();
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const GetLinkState& default_instance();

  void Swap(GetLinkState* other);

  // implements Message ----------------------------------------------

  inline GetLinkState* New() const { return New(NULL); }

  GetLinkState* New(::google::protobuf::Arena* arena) const;
  void CopyFrom(const ::google::protobuf::Message& from);
  void MergeFrom(const ::google::protobuf::Message& from);
  void CopyFrom(const GetLinkState& from);
  void MergeFrom(const GetLinkState& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  ::google::protobuf::uint8* InternalSerializeWithCachedSizesToArray(
      bool deterministic, ::google::protobuf::uint8* output) const;
  ::google::protobuf::uint8* SerializeWithCachedSizesToArray(::google::protobuf::uint8* output) const {
    return InternalSerializeWithCachedSizesToArray(false, output);
  }
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  void InternalSwap(GetLinkState* other);
  private:
  inline ::google::protobuf::Arena* GetArenaNoVirtual() const {
    return _internal_metadata_.arena();
  }
  inline void* MaybeArenaPtr() const {
    return _internal_metadata_.raw_arena_ptr();
  }
  public:

  ::google::protobuf::Metadata GetMetadata() const;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // required string model_name = 1;
  bool has_model_name() const;
  void clear_model_name();
  static const int kModelNameFieldNumber = 1;
  const ::std::string& model_name() const;
  void set_model_name(const ::std::string& value);
  void set_model_name(const char* value);
  void set_model_name(const char* value, size_t size);
  ::std::string* mutable_model_name();
  ::std::string* release_model_name();
  void set_allocated_model_name(::std::string* model_name);

  // required string link_name = 2;
  bool has_link_name() const;
  void clear_link_name();
  static const int kLinkNameFieldNumber = 2;
  const ::std::string& link_name() const;
  void set_link_name(const ::std::string& value);
  void set_link_name(const char* value);
  void set_link_name(const char* value, size_t size);
  ::std::string* mutable_link_name();
  ::std::string* release_link_name();
  void set_allocated_link_name(::std::string* link_name);

  // @@protoc_insertion_point(class_scope:mw.internal.robotics.gazebotransport.GetLinkState)
 private:
  inline void set_has_model_name();
  inline void clear_has_model_name();
  inline void set_has_link_name();
  inline void clear_has_link_name();

  // helper for ByteSize()
  int RequiredFieldsByteSizeFallback() const;

  ::google::protobuf::internal::InternalMetadataWithArena _internal_metadata_;
  ::google::protobuf::uint32 _has_bits_[1];
  mutable int _cached_size_;
  ::google::protobuf::internal::ArenaStringPtr model_name_;
  ::google::protobuf::internal::ArenaStringPtr link_name_;
  friend void  protobuf_AddDesc_mw_2einternal_2erobotics_2egazebotransport_2eCoSimMsgs_2eproto();
  friend void protobuf_AssignDesc_mw_2einternal_2erobotics_2egazebotransport_2eCoSimMsgs_2eproto();
  friend void protobuf_ShutdownFile_mw_2einternal_2erobotics_2egazebotransport_2eCoSimMsgs_2eproto();

  void InitAsDefaultInstance();
  static GetLinkState* default_instance_;
};
// -------------------------------------------------------------------

class LinkState : public ::google::protobuf::Message /* @@protoc_insertion_point(class_definition:mw.internal.robotics.gazebotransport.LinkState) */ {
 public:
  LinkState();
  virtual ~LinkState();

  LinkState(const LinkState& from);

  inline LinkState& operator=(const LinkState& from) {
    CopyFrom(from);
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _internal_metadata_.unknown_fields();
  }

  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return _internal_metadata_.mutable_unknown_fields();
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const LinkState& default_instance();

  void Swap(LinkState* other);

  // implements Message ----------------------------------------------

  inline LinkState* New() const { return New(NULL); }

  LinkState* New(::google::protobuf::Arena* arena) const;
  void CopyFrom(const ::google::protobuf::Message& from);
  void MergeFrom(const ::google::protobuf::Message& from);
  void CopyFrom(const LinkState& from);
  void MergeFrom(const LinkState& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  ::google::protobuf::uint8* InternalSerializeWithCachedSizesToArray(
      bool deterministic, ::google::protobuf::uint8* output) const;
  ::google::protobuf::uint8* SerializeWithCachedSizesToArray(::google::protobuf::uint8* output) const {
    return InternalSerializeWithCachedSizesToArray(false, output);
  }
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  void InternalSwap(LinkState* other);
  private:
  inline ::google::protobuf::Arena* GetArenaNoVirtual() const {
    return _internal_metadata_.arena();
  }
  inline void* MaybeArenaPtr() const {
    return _internal_metadata_.raw_arena_ptr();
  }
  public:

  ::google::protobuf::Metadata GetMetadata() const;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // required string model_name = 1;
  bool has_model_name() const;
  void clear_model_name();
  static const int kModelNameFieldNumber = 1;
  const ::std::string& model_name() const;
  void set_model_name(const ::std::string& value);
  void set_model_name(const char* value);
  void set_model_name(const char* value, size_t size);
  ::std::string* mutable_model_name();
  ::std::string* release_model_name();
  void set_allocated_model_name(::std::string* model_name);

  // required string link_name = 2;
  bool has_link_name() const;
  void clear_link_name();
  static const int kLinkNameFieldNumber = 2;
  const ::std::string& link_name() const;
  void set_link_name(const ::std::string& value);
  void set_link_name(const char* value);
  void set_link_name(const char* value, size_t size);
  ::std::string* mutable_link_name();
  ::std::string* release_link_name();
  void set_allocated_link_name(::std::string* link_name);

  // required uint32 link_id = 3;
  bool has_link_id() const;
  void clear_link_id();
  static const int kLinkIdFieldNumber = 3;
  ::google::protobuf::uint32 link_id() const;
  void set_link_id(::google::protobuf::uint32 value);

  // required .mw.internal.robotics.gazebotransport.Point world_linear_velocity = 4;
  bool has_world_linear_velocity() const;
  void clear_world_linear_velocity();
  static const int kWorldLinearVelocityFieldNumber = 4;
  const ::mw::internal::robotics::gazebotransport::Point& world_linear_velocity() const;
  ::mw::internal::robotics::gazebotransport::Point* mutable_world_linear_velocity();
  ::mw::internal::robotics::gazebotransport::Point* release_world_linear_velocity();
  void set_allocated_world_linear_velocity(::mw::internal::robotics::gazebotransport::Point* world_linear_velocity);

  // required .mw.internal.robotics.gazebotransport.Point world_angular_velocity = 5;
  bool has_world_angular_velocity() const;
  void clear_world_angular_velocity();
  static const int kWorldAngularVelocityFieldNumber = 5;
  const ::mw::internal::robotics::gazebotransport::Point& world_angular_velocity() const;
  ::mw::internal::robotics::gazebotransport::Point* mutable_world_angular_velocity();
  ::mw::internal::robotics::gazebotransport::Point* release_world_angular_velocity();
  void set_allocated_world_angular_velocity(::mw::internal::robotics::gazebotransport::Point* world_angular_velocity);

  // required .mw.internal.robotics.gazebotransport.Point relative_linear_velocity = 6;
  bool has_relative_linear_velocity() const;
  void clear_relative_linear_velocity();
  static const int kRelativeLinearVelocityFieldNumber = 6;
  const ::mw::internal::robotics::gazebotransport::Point& relative_linear_velocity() const;
  ::mw::internal::robotics::gazebotransport::Point* mutable_relative_linear_velocity();
  ::mw::internal::robotics::gazebotransport::Point* release_relative_linear_velocity();
  void set_allocated_relative_linear_velocity(::mw::internal::robotics::gazebotransport::Point* relative_linear_velocity);

  // required .mw.internal.robotics.gazebotransport.Point relative_angular_velocity = 7;
  bool has_relative_angular_velocity() const;
  void clear_relative_angular_velocity();
  static const int kRelativeAngularVelocityFieldNumber = 7;
  const ::mw::internal::robotics::gazebotransport::Point& relative_angular_velocity() const;
  ::mw::internal::robotics::gazebotransport::Point* mutable_relative_angular_velocity();
  ::mw::internal::robotics::gazebotransport::Point* release_relative_angular_velocity();
  void set_allocated_relative_angular_velocity(::mw::internal::robotics::gazebotransport::Point* relative_angular_velocity);

  // optional .mw.internal.robotics.gazebotransport.Pose world_pose = 8;
  bool has_world_pose() const;
  void clear_world_pose();
  static const int kWorldPoseFieldNumber = 8;
  const ::mw::internal::robotics::gazebotransport::Pose& world_pose() const;
  ::mw::internal::robotics::gazebotransport::Pose* mutable_world_pose();
  ::mw::internal::robotics::gazebotransport::Pose* release_world_pose();
  void set_allocated_world_pose(::mw::internal::robotics::gazebotransport::Pose* world_pose);

  // optional .mw.internal.robotics.gazebotransport.Pose relative_pose = 9;
  bool has_relative_pose() const;
  void clear_relative_pose();
  static const int kRelativePoseFieldNumber = 9;
  const ::mw::internal::robotics::gazebotransport::Pose& relative_pose() const;
  ::mw::internal::robotics::gazebotransport::Pose* mutable_relative_pose();
  ::mw::internal::robotics::gazebotransport::Pose* release_relative_pose();
  void set_allocated_relative_pose(::mw::internal::robotics::gazebotransport::Pose* relative_pose);

  // optional bool self_collide = 10;
  bool has_self_collide() const;
  void clear_self_collide();
  static const int kSelfCollideFieldNumber = 10;
  bool self_collide() const;
  void set_self_collide(bool value);

  // optional bool gravity = 11;
  bool has_gravity() const;
  void clear_gravity();
  static const int kGravityFieldNumber = 11;
  bool gravity() const;
  void set_gravity(bool value);

  // optional bool kinematic = 12;
  bool has_kinematic() const;
  void clear_kinematic();
  static const int kKinematicFieldNumber = 12;
  bool kinematic() const;
  void set_kinematic(bool value);

  // optional bool enable_wind = 13;
  bool has_enable_wind() const;
  void clear_enable_wind();
  static const int kEnableWindFieldNumber = 13;
  bool enable_wind() const;
  void set_enable_wind(bool value);

  // optional bool canonical = 14;
  bool has_canonical() const;
  void clear_canonical();
  static const int kCanonicalFieldNumber = 14;
  bool canonical() const;
  void set_canonical(bool value);

  // @@protoc_insertion_point(class_scope:mw.internal.robotics.gazebotransport.LinkState)
 private:
  inline void set_has_model_name();
  inline void clear_has_model_name();
  inline void set_has_link_name();
  inline void clear_has_link_name();
  inline void set_has_link_id();
  inline void clear_has_link_id();
  inline void set_has_world_linear_velocity();
  inline void clear_has_world_linear_velocity();
  inline void set_has_world_angular_velocity();
  inline void clear_has_world_angular_velocity();
  inline void set_has_relative_linear_velocity();
  inline void clear_has_relative_linear_velocity();
  inline void set_has_relative_angular_velocity();
  inline void clear_has_relative_angular_velocity();
  inline void set_has_world_pose();
  inline void clear_has_world_pose();
  inline void set_has_relative_pose();
  inline void clear_has_relative_pose();
  inline void set_has_self_collide();
  inline void clear_has_self_collide();
  inline void set_has_gravity();
  inline void clear_has_gravity();
  inline void set_has_kinematic();
  inline void clear_has_kinematic();
  inline void set_has_enable_wind();
  inline void clear_has_enable_wind();
  inline void set_has_canonical();
  inline void clear_has_canonical();

  // helper for ByteSize()
  int RequiredFieldsByteSizeFallback() const;

  ::google::protobuf::internal::InternalMetadataWithArena _internal_metadata_;
  ::google::protobuf::uint32 _has_bits_[1];
  mutable int _cached_size_;
  ::google::protobuf::internal::ArenaStringPtr model_name_;
  ::google::protobuf::internal::ArenaStringPtr link_name_;
  ::mw::internal::robotics::gazebotransport::Point* world_linear_velocity_;
  ::mw::internal::robotics::gazebotransport::Point* world_angular_velocity_;
  ::mw::internal::robotics::gazebotransport::Point* relative_linear_velocity_;
  ::mw::internal::robotics::gazebotransport::Point* relative_angular_velocity_;
  ::mw::internal::robotics::gazebotransport::Pose* world_pose_;
  ::mw::internal::robotics::gazebotransport::Pose* relative_pose_;
  ::google::protobuf::uint32 link_id_;
  bool self_collide_;
  bool gravity_;
  bool kinematic_;
  bool enable_wind_;
  bool canonical_;
  friend void  protobuf_AddDesc_mw_2einternal_2erobotics_2egazebotransport_2eCoSimMsgs_2eproto();
  friend void protobuf_AssignDesc_mw_2einternal_2erobotics_2egazebotransport_2eCoSimMsgs_2eproto();
  friend void protobuf_ShutdownFile_mw_2einternal_2erobotics_2egazebotransport_2eCoSimMsgs_2eproto();

  void InitAsDefaultInstance();
  static LinkState* default_instance_;
};
// -------------------------------------------------------------------

class ML_Cord : public ::google::protobuf::Message /* @@protoc_insertion_point(class_definition:mw.internal.robotics.gazebotransport.ML_Cord) */ {
 public:
  ML_Cord();
  virtual ~ML_Cord();

  ML_Cord(const ML_Cord& from);

  inline ML_Cord& operator=(const ML_Cord& from) {
    CopyFrom(from);
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _internal_metadata_.unknown_fields();
  }

  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return _internal_metadata_.mutable_unknown_fields();
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const ML_Cord& default_instance();

  void Swap(ML_Cord* other);

  // implements Message ----------------------------------------------

  inline ML_Cord* New() const { return New(NULL); }

  ML_Cord* New(::google::protobuf::Arena* arena) const;
  void CopyFrom(const ::google::protobuf::Message& from);
  void MergeFrom(const ::google::protobuf::Message& from);
  void CopyFrom(const ML_Cord& from);
  void MergeFrom(const ML_Cord& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  ::google::protobuf::uint8* InternalSerializeWithCachedSizesToArray(
      bool deterministic, ::google::protobuf::uint8* output) const;
  ::google::protobuf::uint8* SerializeWithCachedSizesToArray(::google::protobuf::uint8* output) const {
    return InternalSerializeWithCachedSizesToArray(false, output);
  }
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  void InternalSwap(ML_Cord* other);
  private:
  inline ::google::protobuf::Arena* GetArenaNoVirtual() const {
    return _internal_metadata_.arena();
  }
  inline void* MaybeArenaPtr() const {
    return _internal_metadata_.raw_arena_ptr();
  }
  public:

  ::google::protobuf::Metadata GetMetadata() const;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // optional double x = 1;
  bool has_x() const;
  void clear_x();
  static const int kXFieldNumber = 1;
  double x() const;
  void set_x(double value);

  // optional double y = 2;
  bool has_y() const;
  void clear_y();
  static const int kYFieldNumber = 2;
  double y() const;
  void set_y(double value);

  // @@protoc_insertion_point(class_scope:mw.internal.robotics.gazebotransport.ML_Cord)
 private:
  inline void set_has_x();
  inline void clear_has_x();
  inline void set_has_y();
  inline void clear_has_y();

  ::google::protobuf::internal::InternalMetadataWithArena _internal_metadata_;
  ::google::protobuf::uint32 _has_bits_[1];
  mutable int _cached_size_;
  double x_;
  double y_;
  friend void  protobuf_AddDesc_mw_2einternal_2erobotics_2egazebotransport_2eCoSimMsgs_2eproto();
  friend void protobuf_AssignDesc_mw_2einternal_2erobotics_2egazebotransport_2eCoSimMsgs_2eproto();
  friend void protobuf_ShutdownFile_mw_2einternal_2erobotics_2egazebotransport_2eCoSimMsgs_2eproto();

  void InitAsDefaultInstance();
  static ML_Cord* default_instance_;
};
// -------------------------------------------------------------------

class ML_Point : public ::google::protobuf::Message /* @@protoc_insertion_point(class_definition:mw.internal.robotics.gazebotransport.ML_Point) */ {
 public:
  ML_Point();
  virtual ~ML_Point();

  ML_Point(const ML_Point& from);

  inline ML_Point& operator=(const ML_Point& from) {
    CopyFrom(from);
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _internal_metadata_.unknown_fields();
  }

  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return _internal_metadata_.mutable_unknown_fields();
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const ML_Point& default_instance();

  void Swap(ML_Point* other);

  // implements Message ----------------------------------------------

  inline ML_Point* New() const { return New(NULL); }

  ML_Point* New(::google::protobuf::Arena* arena) const;
  void CopyFrom(const ::google::protobuf::Message& from);
  void MergeFrom(const ::google::protobuf::Message& from);
  void CopyFrom(const ML_Point& from);
  void MergeFrom(const ML_Point& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  ::google::protobuf::uint8* InternalSerializeWithCachedSizesToArray(
      bool deterministic, ::google::protobuf::uint8* output) const;
  ::google::protobuf::uint8* SerializeWithCachedSizesToArray(::google::protobuf::uint8* output) const {
    return InternalSerializeWithCachedSizesToArray(false, output);
  }
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  void InternalSwap(ML_Point* other);
  private:
  inline ::google::protobuf::Arena* GetArenaNoVirtual() const {
    return _internal_metadata_.arena();
  }
  inline void* MaybeArenaPtr() const {
    return _internal_metadata_.raw_arena_ptr();
  }
  public:

  ::google::protobuf::Metadata GetMetadata() const;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // optional double x = 1;
  bool has_x() const;
  void clear_x();
  static const int kXFieldNumber = 1;
  double x() const;
  void set_x(double value);

  // optional double y = 2;
  bool has_y() const;
  void clear_y();
  static const int kYFieldNumber = 2;
  double y() const;
  void set_y(double value);

  // optional double z = 3;
  bool has_z() const;
  void clear_z();
  static const int kZFieldNumber = 3;
  double z() const;
  void set_z(double value);

  // @@protoc_insertion_point(class_scope:mw.internal.robotics.gazebotransport.ML_Point)
 private:
  inline void set_has_x();
  inline void clear_has_x();
  inline void set_has_y();
  inline void clear_has_y();
  inline void set_has_z();
  inline void clear_has_z();

  ::google::protobuf::internal::InternalMetadataWithArena _internal_metadata_;
  ::google::protobuf::uint32 _has_bits_[1];
  mutable int _cached_size_;
  double x_;
  double y_;
  double z_;
  friend void  protobuf_AddDesc_mw_2einternal_2erobotics_2egazebotransport_2eCoSimMsgs_2eproto();
  friend void protobuf_AssignDesc_mw_2einternal_2erobotics_2egazebotransport_2eCoSimMsgs_2eproto();
  friend void protobuf_ShutdownFile_mw_2einternal_2erobotics_2egazebotransport_2eCoSimMsgs_2eproto();

  void InitAsDefaultInstance();
  static ML_Point* default_instance_;
};
// -------------------------------------------------------------------

class ML_Quat : public ::google::protobuf::Message /* @@protoc_insertion_point(class_definition:mw.internal.robotics.gazebotransport.ML_Quat) */ {
 public:
  ML_Quat();
  virtual ~ML_Quat();

  ML_Quat(const ML_Quat& from);

  inline ML_Quat& operator=(const ML_Quat& from) {
    CopyFrom(from);
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _internal_metadata_.unknown_fields();
  }

  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return _internal_metadata_.mutable_unknown_fields();
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const ML_Quat& default_instance();

  void Swap(ML_Quat* other);

  // implements Message ----------------------------------------------

  inline ML_Quat* New() const { return New(NULL); }

  ML_Quat* New(::google::protobuf::Arena* arena) const;
  void CopyFrom(const ::google::protobuf::Message& from);
  void MergeFrom(const ::google::protobuf::Message& from);
  void CopyFrom(const ML_Quat& from);
  void MergeFrom(const ML_Quat& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  ::google::protobuf::uint8* InternalSerializeWithCachedSizesToArray(
      bool deterministic, ::google::protobuf::uint8* output) const;
  ::google::protobuf::uint8* SerializeWithCachedSizesToArray(::google::protobuf::uint8* output) const {
    return InternalSerializeWithCachedSizesToArray(false, output);
  }
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  void InternalSwap(ML_Quat* other);
  private:
  inline ::google::protobuf::Arena* GetArenaNoVirtual() const {
    return _internal_metadata_.arena();
  }
  inline void* MaybeArenaPtr() const {
    return _internal_metadata_.raw_arena_ptr();
  }
  public:

  ::google::protobuf::Metadata GetMetadata() const;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // optional double x = 1;
  bool has_x() const;
  void clear_x();
  static const int kXFieldNumber = 1;
  double x() const;
  void set_x(double value);

  // optional double y = 2;
  bool has_y() const;
  void clear_y();
  static const int kYFieldNumber = 2;
  double y() const;
  void set_y(double value);

  // optional double z = 3;
  bool has_z() const;
  void clear_z();
  static const int kZFieldNumber = 3;
  double z() const;
  void set_z(double value);

  // optional double w = 4;
  bool has_w() const;
  void clear_w();
  static const int kWFieldNumber = 4;
  double w() const;
  void set_w(double value);

  // @@protoc_insertion_point(class_scope:mw.internal.robotics.gazebotransport.ML_Quat)
 private:
  inline void set_has_x();
  inline void clear_has_x();
  inline void set_has_y();
  inline void clear_has_y();
  inline void set_has_z();
  inline void clear_has_z();
  inline void set_has_w();
  inline void clear_has_w();

  ::google::protobuf::internal::InternalMetadataWithArena _internal_metadata_;
  ::google::protobuf::uint32 _has_bits_[1];
  mutable int _cached_size_;
  double x_;
  double y_;
  double z_;
  double w_;
  friend void  protobuf_AddDesc_mw_2einternal_2erobotics_2egazebotransport_2eCoSimMsgs_2eproto();
  friend void protobuf_AssignDesc_mw_2einternal_2erobotics_2egazebotransport_2eCoSimMsgs_2eproto();
  friend void protobuf_ShutdownFile_mw_2einternal_2erobotics_2egazebotransport_2eCoSimMsgs_2eproto();

  void InitAsDefaultInstance();
  static ML_Quat* default_instance_;
};
// -------------------------------------------------------------------

class ML_Pose : public ::google::protobuf::Message /* @@protoc_insertion_point(class_definition:mw.internal.robotics.gazebotransport.ML_Pose) */ {
 public:
  ML_Pose();
  virtual ~ML_Pose();

  ML_Pose(const ML_Pose& from);

  inline ML_Pose& operator=(const ML_Pose& from) {
    CopyFrom(from);
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _internal_metadata_.unknown_fields();
  }

  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return _internal_metadata_.mutable_unknown_fields();
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const ML_Pose& default_instance();

  void Swap(ML_Pose* other);

  // implements Message ----------------------------------------------

  inline ML_Pose* New() const { return New(NULL); }

  ML_Pose* New(::google::protobuf::Arena* arena) const;
  void CopyFrom(const ::google::protobuf::Message& from);
  void MergeFrom(const ::google::protobuf::Message& from);
  void CopyFrom(const ML_Pose& from);
  void MergeFrom(const ML_Pose& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  ::google::protobuf::uint8* InternalSerializeWithCachedSizesToArray(
      bool deterministic, ::google::protobuf::uint8* output) const;
  ::google::protobuf::uint8* SerializeWithCachedSizesToArray(::google::protobuf::uint8* output) const {
    return InternalSerializeWithCachedSizesToArray(false, output);
  }
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  void InternalSwap(ML_Pose* other);
  private:
  inline ::google::protobuf::Arena* GetArenaNoVirtual() const {
    return _internal_metadata_.arena();
  }
  inline void* MaybeArenaPtr() const {
    return _internal_metadata_.raw_arena_ptr();
  }
  public:

  ::google::protobuf::Metadata GetMetadata() const;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // optional .mw.internal.robotics.gazebotransport.ML_Point position = 1;
  bool has_position() const;
  void clear_position();
  static const int kPositionFieldNumber = 1;
  const ::mw::internal::robotics::gazebotransport::ML_Point& position() const;
  ::mw::internal::robotics::gazebotransport::ML_Point* mutable_position();
  ::mw::internal::robotics::gazebotransport::ML_Point* release_position();
  void set_allocated_position(::mw::internal::robotics::gazebotransport::ML_Point* position);

  // optional .mw.internal.robotics.gazebotransport.ML_Quat orientation = 2;
  bool has_orientation() const;
  void clear_orientation();
  static const int kOrientationFieldNumber = 2;
  const ::mw::internal::robotics::gazebotransport::ML_Quat& orientation() const;
  ::mw::internal::robotics::gazebotransport::ML_Quat* mutable_orientation();
  ::mw::internal::robotics::gazebotransport::ML_Quat* release_orientation();
  void set_allocated_orientation(::mw::internal::robotics::gazebotransport::ML_Quat* orientation);

  // @@protoc_insertion_point(class_scope:mw.internal.robotics.gazebotransport.ML_Pose)
 private:
  inline void set_has_position();
  inline void clear_has_position();
  inline void set_has_orientation();
  inline void clear_has_orientation();

  ::google::protobuf::internal::InternalMetadataWithArena _internal_metadata_;
  ::google::protobuf::uint32 _has_bits_[1];
  mutable int _cached_size_;
  ::mw::internal::robotics::gazebotransport::ML_Point* position_;
  ::mw::internal::robotics::gazebotransport::ML_Quat* orientation_;
  friend void  protobuf_AddDesc_mw_2einternal_2erobotics_2egazebotransport_2eCoSimMsgs_2eproto();
  friend void protobuf_AssignDesc_mw_2einternal_2erobotics_2egazebotransport_2eCoSimMsgs_2eproto();
  friend void protobuf_ShutdownFile_mw_2einternal_2erobotics_2egazebotransport_2eCoSimMsgs_2eproto();

  void InitAsDefaultInstance();
  static ML_Pose* default_instance_;
};
// -------------------------------------------------------------------

class ML_Inertial : public ::google::protobuf::Message /* @@protoc_insertion_point(class_definition:mw.internal.robotics.gazebotransport.ML_Inertial) */ {
 public:
  ML_Inertial();
  virtual ~ML_Inertial();

  ML_Inertial(const ML_Inertial& from);

  inline ML_Inertial& operator=(const ML_Inertial& from) {
    CopyFrom(from);
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _internal_metadata_.unknown_fields();
  }

  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return _internal_metadata_.mutable_unknown_fields();
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const ML_Inertial& default_instance();

  void Swap(ML_Inertial* other);

  // implements Message ----------------------------------------------

  inline ML_Inertial* New() const { return New(NULL); }

  ML_Inertial* New(::google::protobuf::Arena* arena) const;
  void CopyFrom(const ::google::protobuf::Message& from);
  void MergeFrom(const ::google::protobuf::Message& from);
  void CopyFrom(const ML_Inertial& from);
  void MergeFrom(const ML_Inertial& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  ::google::protobuf::uint8* InternalSerializeWithCachedSizesToArray(
      bool deterministic, ::google::protobuf::uint8* output) const;
  ::google::protobuf::uint8* SerializeWithCachedSizesToArray(::google::protobuf::uint8* output) const {
    return InternalSerializeWithCachedSizesToArray(false, output);
  }
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  void InternalSwap(ML_Inertial* other);
  private:
  inline ::google::protobuf::Arena* GetArenaNoVirtual() const {
    return _internal_metadata_.arena();
  }
  inline void* MaybeArenaPtr() const {
    return _internal_metadata_.raw_arena_ptr();
  }
  public:

  ::google::protobuf::Metadata GetMetadata() const;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // optional double mass = 1;
  bool has_mass() const;
  void clear_mass();
  static const int kMassFieldNumber = 1;
  double mass() const;
  void set_mass(double value);

  // optional double ixx = 2;
  bool has_ixx() const;
  void clear_ixx();
  static const int kIxxFieldNumber = 2;
  double ixx() const;
  void set_ixx(double value);

  // optional double ixy = 3;
  bool has_ixy() const;
  void clear_ixy();
  static const int kIxyFieldNumber = 3;
  double ixy() const;
  void set_ixy(double value);

  // optional double ixz = 4;
  bool has_ixz() const;
  void clear_ixz();
  static const int kIxzFieldNumber = 4;
  double ixz() const;
  void set_ixz(double value);

  // optional double iyy = 5;
  bool has_iyy() const;
  void clear_iyy();
  static const int kIyyFieldNumber = 5;
  double iyy() const;
  void set_iyy(double value);

  // optional double iyz = 6;
  bool has_iyz() const;
  void clear_iyz();
  static const int kIyzFieldNumber = 6;
  double iyz() const;
  void set_iyz(double value);

  // optional double izz = 7;
  bool has_izz() const;
  void clear_izz();
  static const int kIzzFieldNumber = 7;
  double izz() const;
  void set_izz(double value);

  // @@protoc_insertion_point(class_scope:mw.internal.robotics.gazebotransport.ML_Inertial)
 private:
  inline void set_has_mass();
  inline void clear_has_mass();
  inline void set_has_ixx();
  inline void clear_has_ixx();
  inline void set_has_ixy();
  inline void clear_has_ixy();
  inline void set_has_ixz();
  inline void clear_has_ixz();
  inline void set_has_iyy();
  inline void clear_has_iyy();
  inline void set_has_iyz();
  inline void clear_has_iyz();
  inline void set_has_izz();
  inline void clear_has_izz();

  ::google::protobuf::internal::InternalMetadataWithArena _internal_metadata_;
  ::google::protobuf::uint32 _has_bits_[1];
  mutable int _cached_size_;
  double mass_;
  double ixx_;
  double ixy_;
  double ixz_;
  double iyy_;
  double iyz_;
  double izz_;
  friend void  protobuf_AddDesc_mw_2einternal_2erobotics_2egazebotransport_2eCoSimMsgs_2eproto();
  friend void protobuf_AssignDesc_mw_2einternal_2erobotics_2egazebotransport_2eCoSimMsgs_2eproto();
  friend void protobuf_ShutdownFile_mw_2einternal_2erobotics_2egazebotransport_2eCoSimMsgs_2eproto();

  void InitAsDefaultInstance();
  static ML_Inertial* default_instance_;
};
// -------------------------------------------------------------------

class ML_Links : public ::google::protobuf::Message /* @@protoc_insertion_point(class_definition:mw.internal.robotics.gazebotransport.ML_Links) */ {
 public:
  ML_Links();
  virtual ~ML_Links();

  ML_Links(const ML_Links& from);

  inline ML_Links& operator=(const ML_Links& from) {
    CopyFrom(from);
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _internal_metadata_.unknown_fields();
  }

  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return _internal_metadata_.mutable_unknown_fields();
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const ML_Links& default_instance();

  void Swap(ML_Links* other);

  // implements Message ----------------------------------------------

  inline ML_Links* New() const { return New(NULL); }

  ML_Links* New(::google::protobuf::Arena* arena) const;
  void CopyFrom(const ::google::protobuf::Message& from);
  void MergeFrom(const ::google::protobuf::Message& from);
  void CopyFrom(const ML_Links& from);
  void MergeFrom(const ML_Links& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  ::google::protobuf::uint8* InternalSerializeWithCachedSizesToArray(
      bool deterministic, ::google::protobuf::uint8* output) const;
  ::google::protobuf::uint8* SerializeWithCachedSizesToArray(::google::protobuf::uint8* output) const {
    return InternalSerializeWithCachedSizesToArray(false, output);
  }
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  void InternalSwap(ML_Links* other);
  private:
  inline ::google::protobuf::Arena* GetArenaNoVirtual() const {
    return _internal_metadata_.arena();
  }
  inline void* MaybeArenaPtr() const {
    return _internal_metadata_.raw_arena_ptr();
  }
  public:

  ::google::protobuf::Metadata GetMetadata() const;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // optional string name = 1;
  bool has_name() const;
  void clear_name();
  static const int kNameFieldNumber = 1;
  const ::std::string& name() const;
  void set_name(const ::std::string& value);
  void set_name(const char* value);
  void set_name(const char* value, size_t size);
  ::std::string* mutable_name();
  ::std::string* release_name();
  void set_allocated_name(::std::string* name);

  // optional .mw.internal.robotics.gazebotransport.ML_Pose pose = 2;
  bool has_pose() const;
  void clear_pose();
  static const int kPoseFieldNumber = 2;
  const ::mw::internal::robotics::gazebotransport::ML_Pose& pose() const;
  ::mw::internal::robotics::gazebotransport::ML_Pose* mutable_pose();
  ::mw::internal::robotics::gazebotransport::ML_Pose* release_pose();
  void set_allocated_pose(::mw::internal::robotics::gazebotransport::ML_Pose* pose);

  // optional .mw.internal.robotics.gazebotransport.ML_Inertial inertial = 3;
  bool has_inertial() const;
  void clear_inertial();
  static const int kInertialFieldNumber = 3;
  const ::mw::internal::robotics::gazebotransport::ML_Inertial& inertial() const;
  ::mw::internal::robotics::gazebotransport::ML_Inertial* mutable_inertial();
  ::mw::internal::robotics::gazebotransport::ML_Inertial* release_inertial();
  void set_allocated_inertial(::mw::internal::robotics::gazebotransport::ML_Inertial* inertial);

  // optional bool self_collide = 4;
  bool has_self_collide() const;
  void clear_self_collide();
  static const int kSelfCollideFieldNumber = 4;
  bool self_collide() const;
  void set_self_collide(bool value);

  // optional bool gravity = 5;
  bool has_gravity() const;
  void clear_gravity();
  static const int kGravityFieldNumber = 5;
  bool gravity() const;
  void set_gravity(bool value);

  // optional bool kinematic = 6;
  bool has_kinematic() const;
  void clear_kinematic();
  static const int kKinematicFieldNumber = 6;
  bool kinematic() const;
  void set_kinematic(bool value);

  // optional bool enabled_wind = 7;
  bool has_enabled_wind() const;
  void clear_enabled_wind();
  static const int kEnabledWindFieldNumber = 7;
  bool enabled_wind() const;
  void set_enabled_wind(bool value);

  // optional bool is_static = 8;
  bool has_is_static() const;
  void clear_is_static();
  static const int kIsStaticFieldNumber = 8;
  bool is_static() const;
  void set_is_static(bool value);

  // optional bool canonical = 9;
  bool has_canonical() const;
  void clear_canonical();
  static const int kCanonicalFieldNumber = 9;
  bool canonical() const;
  void set_canonical(bool value);

  // @@protoc_insertion_point(class_scope:mw.internal.robotics.gazebotransport.ML_Links)
 private:
  inline void set_has_name();
  inline void clear_has_name();
  inline void set_has_pose();
  inline void clear_has_pose();
  inline void set_has_inertial();
  inline void clear_has_inertial();
  inline void set_has_self_collide();
  inline void clear_has_self_collide();
  inline void set_has_gravity();
  inline void clear_has_gravity();
  inline void set_has_kinematic();
  inline void clear_has_kinematic();
  inline void set_has_enabled_wind();
  inline void clear_has_enabled_wind();
  inline void set_has_is_static();
  inline void clear_has_is_static();
  inline void set_has_canonical();
  inline void clear_has_canonical();

  ::google::protobuf::internal::InternalMetadataWithArena _internal_metadata_;
  ::google::protobuf::uint32 _has_bits_[1];
  mutable int _cached_size_;
  ::google::protobuf::internal::ArenaStringPtr name_;
  ::mw::internal::robotics::gazebotransport::ML_Pose* pose_;
  ::mw::internal::robotics::gazebotransport::ML_Inertial* inertial_;
  bool self_collide_;
  bool gravity_;
  bool kinematic_;
  bool enabled_wind_;
  bool is_static_;
  bool canonical_;
  friend void  protobuf_AddDesc_mw_2einternal_2erobotics_2egazebotransport_2eCoSimMsgs_2eproto();
  friend void protobuf_AssignDesc_mw_2einternal_2erobotics_2egazebotransport_2eCoSimMsgs_2eproto();
  friend void protobuf_ShutdownFile_mw_2einternal_2erobotics_2egazebotransport_2eCoSimMsgs_2eproto();

  void InitAsDefaultInstance();
  static ML_Links* default_instance_;
};
// -------------------------------------------------------------------

class ML_Axis : public ::google::protobuf::Message /* @@protoc_insertion_point(class_definition:mw.internal.robotics.gazebotransport.ML_Axis) */ {
 public:
  ML_Axis();
  virtual ~ML_Axis();

  ML_Axis(const ML_Axis& from);

  inline ML_Axis& operator=(const ML_Axis& from) {
    CopyFrom(from);
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _internal_metadata_.unknown_fields();
  }

  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return _internal_metadata_.mutable_unknown_fields();
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const ML_Axis& default_instance();

  void Swap(ML_Axis* other);

  // implements Message ----------------------------------------------

  inline ML_Axis* New() const { return New(NULL); }

  ML_Axis* New(::google::protobuf::Arena* arena) const;
  void CopyFrom(const ::google::protobuf::Message& from);
  void MergeFrom(const ::google::protobuf::Message& from);
  void CopyFrom(const ML_Axis& from);
  void MergeFrom(const ML_Axis& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  ::google::protobuf::uint8* InternalSerializeWithCachedSizesToArray(
      bool deterministic, ::google::protobuf::uint8* output) const;
  ::google::protobuf::uint8* SerializeWithCachedSizesToArray(::google::protobuf::uint8* output) const {
    return InternalSerializeWithCachedSizesToArray(false, output);
  }
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  void InternalSwap(ML_Axis* other);
  private:
  inline ::google::protobuf::Arena* GetArenaNoVirtual() const {
    return _internal_metadata_.arena();
  }
  inline void* MaybeArenaPtr() const {
    return _internal_metadata_.raw_arena_ptr();
  }
  public:

  ::google::protobuf::Metadata GetMetadata() const;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // optional .mw.internal.robotics.gazebotransport.ML_Point xyz = 1;
  bool has_xyz() const;
  void clear_xyz();
  static const int kXyzFieldNumber = 1;
  const ::mw::internal::robotics::gazebotransport::ML_Point& xyz() const;
  ::mw::internal::robotics::gazebotransport::ML_Point* mutable_xyz();
  ::mw::internal::robotics::gazebotransport::ML_Point* release_xyz();
  void set_allocated_xyz(::mw::internal::robotics::gazebotransport::ML_Point* xyz);

  // optional double damping = 2;
  bool has_damping() const;
  void clear_damping();
  static const int kDampingFieldNumber = 2;
  double damping() const;
  void set_damping(double value);

  // optional double friction = 3;
  bool has_friction() const;
  void clear_friction();
  static const int kFrictionFieldNumber = 3;
  double friction() const;
  void set_friction(double value);

  // optional double angle = 4;
  bool has_angle() const;
  void clear_angle();
  static const int kAngleFieldNumber = 4;
  double angle() const;
  void set_angle(double value);

  // @@protoc_insertion_point(class_scope:mw.internal.robotics.gazebotransport.ML_Axis)
 private:
  inline void set_has_xyz();
  inline void clear_has_xyz();
  inline void set_has_damping();
  inline void clear_has_damping();
  inline void set_has_friction();
  inline void clear_has_friction();
  inline void set_has_angle();
  inline void clear_has_angle();

  ::google::protobuf::internal::InternalMetadataWithArena _internal_metadata_;
  ::google::protobuf::uint32 _has_bits_[1];
  mutable int _cached_size_;
  ::mw::internal::robotics::gazebotransport::ML_Point* xyz_;
  double damping_;
  double friction_;
  double angle_;
  friend void  protobuf_AddDesc_mw_2einternal_2erobotics_2egazebotransport_2eCoSimMsgs_2eproto();
  friend void protobuf_AssignDesc_mw_2einternal_2erobotics_2egazebotransport_2eCoSimMsgs_2eproto();
  friend void protobuf_ShutdownFile_mw_2einternal_2erobotics_2egazebotransport_2eCoSimMsgs_2eproto();

  void InitAsDefaultInstance();
  static ML_Axis* default_instance_;
};
// -------------------------------------------------------------------

class ML_Joints : public ::google::protobuf::Message /* @@protoc_insertion_point(class_definition:mw.internal.robotics.gazebotransport.ML_Joints) */ {
 public:
  ML_Joints();
  virtual ~ML_Joints();

  ML_Joints(const ML_Joints& from);

  inline ML_Joints& operator=(const ML_Joints& from) {
    CopyFrom(from);
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _internal_metadata_.unknown_fields();
  }

  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return _internal_metadata_.mutable_unknown_fields();
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const ML_Joints& default_instance();

  void Swap(ML_Joints* other);

  // implements Message ----------------------------------------------

  inline ML_Joints* New() const { return New(NULL); }

  ML_Joints* New(::google::protobuf::Arena* arena) const;
  void CopyFrom(const ::google::protobuf::Message& from);
  void MergeFrom(const ::google::protobuf::Message& from);
  void CopyFrom(const ML_Joints& from);
  void MergeFrom(const ML_Joints& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  ::google::protobuf::uint8* InternalSerializeWithCachedSizesToArray(
      bool deterministic, ::google::protobuf::uint8* output) const;
  ::google::protobuf::uint8* SerializeWithCachedSizesToArray(::google::protobuf::uint8* output) const {
    return InternalSerializeWithCachedSizesToArray(false, output);
  }
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  void InternalSwap(ML_Joints* other);
  private:
  inline ::google::protobuf::Arena* GetArenaNoVirtual() const {
    return _internal_metadata_.arena();
  }
  inline void* MaybeArenaPtr() const {
    return _internal_metadata_.raw_arena_ptr();
  }
  public:

  ::google::protobuf::Metadata GetMetadata() const;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // optional string name = 1;
  bool has_name() const;
  void clear_name();
  static const int kNameFieldNumber = 1;
  const ::std::string& name() const;
  void set_name(const ::std::string& value);
  void set_name(const char* value);
  void set_name(const char* value, size_t size);
  ::std::string* mutable_name();
  ::std::string* release_name();
  void set_allocated_name(::std::string* name);

  // optional .mw.internal.robotics.gazebotransport.ML_Pose pose = 2;
  bool has_pose() const;
  void clear_pose();
  static const int kPoseFieldNumber = 2;
  const ::mw::internal::robotics::gazebotransport::ML_Pose& pose() const;
  ::mw::internal::robotics::gazebotransport::ML_Pose* mutable_pose();
  ::mw::internal::robotics::gazebotransport::ML_Pose* release_pose();
  void set_allocated_pose(::mw::internal::robotics::gazebotransport::ML_Pose* pose);

  // optional .mw.internal.robotics.gazebotransport.ML_Axis axis1 = 3;
  bool has_axis1() const;
  void clear_axis1();
  static const int kAxis1FieldNumber = 3;
  const ::mw::internal::robotics::gazebotransport::ML_Axis& axis1() const;
  ::mw::internal::robotics::gazebotransport::ML_Axis* mutable_axis1();
  ::mw::internal::robotics::gazebotransport::ML_Axis* release_axis1();
  void set_allocated_axis1(::mw::internal::robotics::gazebotransport::ML_Axis* axis1);

  // optional .mw.internal.robotics.gazebotransport.ML_Axis axis2 = 4;
  bool has_axis2() const;
  void clear_axis2();
  static const int kAxis2FieldNumber = 4;
  const ::mw::internal::robotics::gazebotransport::ML_Axis& axis2() const;
  ::mw::internal::robotics::gazebotransport::ML_Axis* mutable_axis2();
  ::mw::internal::robotics::gazebotransport::ML_Axis* release_axis2();
  void set_allocated_axis2(::mw::internal::robotics::gazebotransport::ML_Axis* axis2);

  // optional double cfm = 5;
  bool has_cfm() const;
  void clear_cfm();
  static const int kCfmFieldNumber = 5;
  double cfm() const;
  void set_cfm(double value);

  // optional double fudge_factor = 6;
  bool has_fudge_factor() const;
  void clear_fudge_factor();
  static const int kFudgeFactorFieldNumber = 6;
  double fudge_factor() const;
  void set_fudge_factor(double value);

  // optional double suspension_cfm = 7;
  bool has_suspension_cfm() const;
  void clear_suspension_cfm();
  static const int kSuspensionCfmFieldNumber = 7;
  double suspension_cfm() const;
  void set_suspension_cfm(double value);

  // optional double suspension_erp = 8;
  bool has_suspension_erp() const;
  void clear_suspension_erp();
  static const int kSuspensionErpFieldNumber = 8;
  double suspension_erp() const;
  void set_suspension_erp(double value);

  // optional uint32 dof = 9;
  bool has_dof() const;
  void clear_dof();
  static const int kDofFieldNumber = 9;
  ::google::protobuf::uint32 dof() const;
  void set_dof(::google::protobuf::uint32 value);

  // @@protoc_insertion_point(class_scope:mw.internal.robotics.gazebotransport.ML_Joints)
 private:
  inline void set_has_name();
  inline void clear_has_name();
  inline void set_has_pose();
  inline void clear_has_pose();
  inline void set_has_axis1();
  inline void clear_has_axis1();
  inline void set_has_axis2();
  inline void clear_has_axis2();
  inline void set_has_cfm();
  inline void clear_has_cfm();
  inline void set_has_fudge_factor();
  inline void clear_has_fudge_factor();
  inline void set_has_suspension_cfm();
  inline void clear_has_suspension_cfm();
  inline void set_has_suspension_erp();
  inline void clear_has_suspension_erp();
  inline void set_has_dof();
  inline void clear_has_dof();

  ::google::protobuf::internal::InternalMetadataWithArena _internal_metadata_;
  ::google::protobuf::uint32 _has_bits_[1];
  mutable int _cached_size_;
  ::google::protobuf::internal::ArenaStringPtr name_;
  ::mw::internal::robotics::gazebotransport::ML_Pose* pose_;
  ::mw::internal::robotics::gazebotransport::ML_Axis* axis1_;
  ::mw::internal::robotics::gazebotransport::ML_Axis* axis2_;
  double cfm_;
  double fudge_factor_;
  double suspension_cfm_;
  double suspension_erp_;
  ::google::protobuf::uint32 dof_;
  friend void  protobuf_AddDesc_mw_2einternal_2erobotics_2egazebotransport_2eCoSimMsgs_2eproto();
  friend void protobuf_AssignDesc_mw_2einternal_2erobotics_2egazebotransport_2eCoSimMsgs_2eproto();
  friend void protobuf_ShutdownFile_mw_2einternal_2erobotics_2egazebotransport_2eCoSimMsgs_2eproto();

  void InitAsDefaultInstance();
  static ML_Joints* default_instance_;
};
// -------------------------------------------------------------------

class Gazebomodel : public ::google::protobuf::Message /* @@protoc_insertion_point(class_definition:mw.internal.robotics.gazebotransport.Gazebomodel) */ {
 public:
  Gazebomodel();
  virtual ~Gazebomodel();

  Gazebomodel(const Gazebomodel& from);

  inline Gazebomodel& operator=(const Gazebomodel& from) {
    CopyFrom(from);
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _internal_metadata_.unknown_fields();
  }

  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return _internal_metadata_.mutable_unknown_fields();
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const Gazebomodel& default_instance();

  void Swap(Gazebomodel* other);

  // implements Message ----------------------------------------------

  inline Gazebomodel* New() const { return New(NULL); }

  Gazebomodel* New(::google::protobuf::Arena* arena) const;
  void CopyFrom(const ::google::protobuf::Message& from);
  void MergeFrom(const ::google::protobuf::Message& from);
  void CopyFrom(const Gazebomodel& from);
  void MergeFrom(const Gazebomodel& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  ::google::protobuf::uint8* InternalSerializeWithCachedSizesToArray(
      bool deterministic, ::google::protobuf::uint8* output) const;
  ::google::protobuf::uint8* SerializeWithCachedSizesToArray(::google::protobuf::uint8* output) const {
    return InternalSerializeWithCachedSizesToArray(false, output);
  }
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  void InternalSwap(Gazebomodel* other);
  private:
  inline ::google::protobuf::Arena* GetArenaNoVirtual() const {
    return _internal_metadata_.arena();
  }
  inline void* MaybeArenaPtr() const {
    return _internal_metadata_.raw_arena_ptr();
  }
  public:

  ::google::protobuf::Metadata GetMetadata() const;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // required string name = 1;
  bool has_name() const;
  void clear_name();
  static const int kNameFieldNumber = 1;
  const ::std::string& name() const;
  void set_name(const ::std::string& value);
  void set_name(const char* value);
  void set_name(const char* value, size_t size);
  ::std::string* mutable_name();
  ::std::string* release_name();
  void set_allocated_name(::std::string* name);

  // repeated .mw.internal.robotics.gazebotransport.ML_Links links = 2;
  int links_size() const;
  void clear_links();
  static const int kLinksFieldNumber = 2;
  const ::mw::internal::robotics::gazebotransport::ML_Links& links(int index) const;
  ::mw::internal::robotics::gazebotransport::ML_Links* mutable_links(int index);
  ::mw::internal::robotics::gazebotransport::ML_Links* add_links();
  ::google::protobuf::RepeatedPtrField< ::mw::internal::robotics::gazebotransport::ML_Links >*
      mutable_links();
  const ::google::protobuf::RepeatedPtrField< ::mw::internal::robotics::gazebotransport::ML_Links >&
      links() const;

  // repeated .mw.internal.robotics.gazebotransport.ML_Joints joints = 3;
  int joints_size() const;
  void clear_joints();
  static const int kJointsFieldNumber = 3;
  const ::mw::internal::robotics::gazebotransport::ML_Joints& joints(int index) const;
  ::mw::internal::robotics::gazebotransport::ML_Joints* mutable_joints(int index);
  ::mw::internal::robotics::gazebotransport::ML_Joints* add_joints();
  ::google::protobuf::RepeatedPtrField< ::mw::internal::robotics::gazebotransport::ML_Joints >*
      mutable_joints();
  const ::google::protobuf::RepeatedPtrField< ::mw::internal::robotics::gazebotransport::ML_Joints >&
      joints() const;

  // optional .mw.internal.robotics.gazebotransport.ML_Pose pose = 4;
  bool has_pose() const;
  void clear_pose();
  static const int kPoseFieldNumber = 4;
  const ::mw::internal::robotics::gazebotransport::ML_Pose& pose() const;
  ::mw::internal::robotics::gazebotransport::ML_Pose* mutable_pose();
  ::mw::internal::robotics::gazebotransport::ML_Pose* release_pose();
  void set_allocated_pose(::mw::internal::robotics::gazebotransport::ML_Pose* pose);

  // optional bool enable_wind = 5;
  bool has_enable_wind() const;
  void clear_enable_wind();
  static const int kEnableWindFieldNumber = 5;
  bool enable_wind() const;
  void set_enable_wind(bool value);

  // optional bool self_collide = 6;
  bool has_self_collide() const;
  void clear_self_collide();
  static const int kSelfCollideFieldNumber = 6;
  bool self_collide() const;
  void set_self_collide(bool value);

  // optional bool is_static = 7;
  bool has_is_static() const;
  void clear_is_static();
  static const int kIsStaticFieldNumber = 7;
  bool is_static() const;
  void set_is_static(bool value);

  // @@protoc_insertion_point(class_scope:mw.internal.robotics.gazebotransport.Gazebomodel)
 private:
  inline void set_has_name();
  inline void clear_has_name();
  inline void set_has_pose();
  inline void clear_has_pose();
  inline void set_has_enable_wind();
  inline void clear_has_enable_wind();
  inline void set_has_self_collide();
  inline void clear_has_self_collide();
  inline void set_has_is_static();
  inline void clear_has_is_static();

  ::google::protobuf::internal::InternalMetadataWithArena _internal_metadata_;
  ::google::protobuf::uint32 _has_bits_[1];
  mutable int _cached_size_;
  ::google::protobuf::internal::ArenaStringPtr name_;
  ::google::protobuf::RepeatedPtrField< ::mw::internal::robotics::gazebotransport::ML_Links > links_;
  ::google::protobuf::RepeatedPtrField< ::mw::internal::robotics::gazebotransport::ML_Joints > joints_;
  ::mw::internal::robotics::gazebotransport::ML_Pose* pose_;
  bool enable_wind_;
  bool self_collide_;
  bool is_static_;
  friend void  protobuf_AddDesc_mw_2einternal_2erobotics_2egazebotransport_2eCoSimMsgs_2eproto();
  friend void protobuf_AssignDesc_mw_2einternal_2erobotics_2egazebotransport_2eCoSimMsgs_2eproto();
  friend void protobuf_ShutdownFile_mw_2einternal_2erobotics_2egazebotransport_2eCoSimMsgs_2eproto();

  void InitAsDefaultInstance();
  static Gazebomodel* default_instance_;
};
// -------------------------------------------------------------------

class GetGazeboModelParam : public ::google::protobuf::Message /* @@protoc_insertion_point(class_definition:mw.internal.robotics.gazebotransport.GetGazeboModelParam) */ {
 public:
  GetGazeboModelParam();
  virtual ~GetGazeboModelParam();

  GetGazeboModelParam(const GetGazeboModelParam& from);

  inline GetGazeboModelParam& operator=(const GetGazeboModelParam& from) {
    CopyFrom(from);
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _internal_metadata_.unknown_fields();
  }

  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return _internal_metadata_.mutable_unknown_fields();
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const GetGazeboModelParam& default_instance();

  void Swap(GetGazeboModelParam* other);

  // implements Message ----------------------------------------------

  inline GetGazeboModelParam* New() const { return New(NULL); }

  GetGazeboModelParam* New(::google::protobuf::Arena* arena) const;
  void CopyFrom(const ::google::protobuf::Message& from);
  void MergeFrom(const ::google::protobuf::Message& from);
  void CopyFrom(const GetGazeboModelParam& from);
  void MergeFrom(const GetGazeboModelParam& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  ::google::protobuf::uint8* InternalSerializeWithCachedSizesToArray(
      bool deterministic, ::google::protobuf::uint8* output) const;
  ::google::protobuf::uint8* SerializeWithCachedSizesToArray(::google::protobuf::uint8* output) const {
    return InternalSerializeWithCachedSizesToArray(false, output);
  }
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  void InternalSwap(GetGazeboModelParam* other);
  private:
  inline ::google::protobuf::Arena* GetArenaNoVirtual() const {
    return _internal_metadata_.arena();
  }
  inline void* MaybeArenaPtr() const {
    return _internal_metadata_.raw_arena_ptr();
  }
  public:

  ::google::protobuf::Metadata GetMetadata() const;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // required string model_name = 1;
  bool has_model_name() const;
  void clear_model_name();
  static const int kModelNameFieldNumber = 1;
  const ::std::string& model_name() const;
  void set_model_name(const ::std::string& value);
  void set_model_name(const char* value);
  void set_model_name(const char* value, size_t size);
  ::std::string* mutable_model_name();
  ::std::string* release_model_name();
  void set_allocated_model_name(::std::string* model_name);

  // optional bool is_link = 2;
  bool has_is_link() const;
  void clear_is_link();
  static const int kIsLinkFieldNumber = 2;
  bool is_link() const;
  void set_is_link(bool value);

  // optional string link_joint_name = 3;
  bool has_link_joint_name() const;
  void clear_link_joint_name();
  static const int kLinkJointNameFieldNumber = 3;
  const ::std::string& link_joint_name() const;
  void set_link_joint_name(const ::std::string& value);
  void set_link_joint_name(const char* value);
  void set_link_joint_name(const char* value, size_t size);
  ::std::string* mutable_link_joint_name();
  ::std::string* release_link_joint_name();
  void set_allocated_link_joint_name(::std::string* link_joint_name);

  // @@protoc_insertion_point(class_scope:mw.internal.robotics.gazebotransport.GetGazeboModelParam)
 private:
  inline void set_has_model_name();
  inline void clear_has_model_name();
  inline void set_has_is_link();
  inline void clear_has_is_link();
  inline void set_has_link_joint_name();
  inline void clear_has_link_joint_name();

  ::google::protobuf::internal::InternalMetadataWithArena _internal_metadata_;
  ::google::protobuf::uint32 _has_bits_[1];
  mutable int _cached_size_;
  ::google::protobuf::internal::ArenaStringPtr model_name_;
  ::google::protobuf::internal::ArenaStringPtr link_joint_name_;
  bool is_link_;
  friend void  protobuf_AddDesc_mw_2einternal_2erobotics_2egazebotransport_2eCoSimMsgs_2eproto();
  friend void protobuf_AssignDesc_mw_2einternal_2erobotics_2egazebotransport_2eCoSimMsgs_2eproto();
  friend void protobuf_ShutdownFile_mw_2einternal_2erobotics_2egazebotransport_2eCoSimMsgs_2eproto();

  void InitAsDefaultInstance();
  static GetGazeboModelParam* default_instance_;
};
// -------------------------------------------------------------------

class GazeboModelSDF : public ::google::protobuf::Message /* @@protoc_insertion_point(class_definition:mw.internal.robotics.gazebotransport.GazeboModelSDF) */ {
 public:
  GazeboModelSDF();
  virtual ~GazeboModelSDF();

  GazeboModelSDF(const GazeboModelSDF& from);

  inline GazeboModelSDF& operator=(const GazeboModelSDF& from) {
    CopyFrom(from);
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _internal_metadata_.unknown_fields();
  }

  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return _internal_metadata_.mutable_unknown_fields();
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const GazeboModelSDF& default_instance();

  void Swap(GazeboModelSDF* other);

  // implements Message ----------------------------------------------

  inline GazeboModelSDF* New() const { return New(NULL); }

  GazeboModelSDF* New(::google::protobuf::Arena* arena) const;
  void CopyFrom(const ::google::protobuf::Message& from);
  void MergeFrom(const ::google::protobuf::Message& from);
  void CopyFrom(const GazeboModelSDF& from);
  void MergeFrom(const GazeboModelSDF& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  ::google::protobuf::uint8* InternalSerializeWithCachedSizesToArray(
      bool deterministic, ::google::protobuf::uint8* output) const;
  ::google::protobuf::uint8* SerializeWithCachedSizesToArray(::google::protobuf::uint8* output) const {
    return InternalSerializeWithCachedSizesToArray(false, output);
  }
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  void InternalSwap(GazeboModelSDF* other);
  private:
  inline ::google::protobuf::Arena* GetArenaNoVirtual() const {
    return _internal_metadata_.arena();
  }
  inline void* MaybeArenaPtr() const {
    return _internal_metadata_.raw_arena_ptr();
  }
  public:

  ::google::protobuf::Metadata GetMetadata() const;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // required string model_name = 1;
  bool has_model_name() const;
  void clear_model_name();
  static const int kModelNameFieldNumber = 1;
  const ::std::string& model_name() const;
  void set_model_name(const ::std::string& value);
  void set_model_name(const char* value);
  void set_model_name(const char* value, size_t size);
  ::std::string* mutable_model_name();
  ::std::string* release_model_name();
  void set_allocated_model_name(::std::string* model_name);

  // required string sdf_string = 2;
  bool has_sdf_string() const;
  void clear_sdf_string();
  static const int kSdfStringFieldNumber = 2;
  const ::std::string& sdf_string() const;
  void set_sdf_string(const ::std::string& value);
  void set_sdf_string(const char* value);
  void set_sdf_string(const char* value, size_t size);
  ::std::string* mutable_sdf_string();
  ::std::string* release_sdf_string();
  void set_allocated_sdf_string(::std::string* sdf_string);

  // @@protoc_insertion_point(class_scope:mw.internal.robotics.gazebotransport.GazeboModelSDF)
 private:
  inline void set_has_model_name();
  inline void clear_has_model_name();
  inline void set_has_sdf_string();
  inline void clear_has_sdf_string();

  // helper for ByteSize()
  int RequiredFieldsByteSizeFallback() const;

  ::google::protobuf::internal::InternalMetadataWithArena _internal_metadata_;
  ::google::protobuf::uint32 _has_bits_[1];
  mutable int _cached_size_;
  ::google::protobuf::internal::ArenaStringPtr model_name_;
  ::google::protobuf::internal::ArenaStringPtr sdf_string_;
  friend void  protobuf_AddDesc_mw_2einternal_2erobotics_2egazebotransport_2eCoSimMsgs_2eproto();
  friend void protobuf_AssignDesc_mw_2einternal_2erobotics_2egazebotransport_2eCoSimMsgs_2eproto();
  friend void protobuf_ShutdownFile_mw_2einternal_2erobotics_2egazebotransport_2eCoSimMsgs_2eproto();

  void InitAsDefaultInstance();
  static GazeboModelSDF* default_instance_;
};
// -------------------------------------------------------------------

class GetGazeboModelSDF : public ::google::protobuf::Message /* @@protoc_insertion_point(class_definition:mw.internal.robotics.gazebotransport.GetGazeboModelSDF) */ {
 public:
  GetGazeboModelSDF();
  virtual ~GetGazeboModelSDF();

  GetGazeboModelSDF(const GetGazeboModelSDF& from);

  inline GetGazeboModelSDF& operator=(const GetGazeboModelSDF& from) {
    CopyFrom(from);
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _internal_metadata_.unknown_fields();
  }

  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return _internal_metadata_.mutable_unknown_fields();
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const GetGazeboModelSDF& default_instance();

  void Swap(GetGazeboModelSDF* other);

  // implements Message ----------------------------------------------

  inline GetGazeboModelSDF* New() const { return New(NULL); }

  GetGazeboModelSDF* New(::google::protobuf::Arena* arena) const;
  void CopyFrom(const ::google::protobuf::Message& from);
  void MergeFrom(const ::google::protobuf::Message& from);
  void CopyFrom(const GetGazeboModelSDF& from);
  void MergeFrom(const GetGazeboModelSDF& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  ::google::protobuf::uint8* InternalSerializeWithCachedSizesToArray(
      bool deterministic, ::google::protobuf::uint8* output) const;
  ::google::protobuf::uint8* SerializeWithCachedSizesToArray(::google::protobuf::uint8* output) const {
    return InternalSerializeWithCachedSizesToArray(false, output);
  }
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  void InternalSwap(GetGazeboModelSDF* other);
  private:
  inline ::google::protobuf::Arena* GetArenaNoVirtual() const {
    return _internal_metadata_.arena();
  }
  inline void* MaybeArenaPtr() const {
    return _internal_metadata_.raw_arena_ptr();
  }
  public:

  ::google::protobuf::Metadata GetMetadata() const;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // required string model_name = 1;
  bool has_model_name() const;
  void clear_model_name();
  static const int kModelNameFieldNumber = 1;
  const ::std::string& model_name() const;
  void set_model_name(const ::std::string& value);
  void set_model_name(const char* value);
  void set_model_name(const char* value, size_t size);
  ::std::string* mutable_model_name();
  ::std::string* release_model_name();
  void set_allocated_model_name(::std::string* model_name);

  // @@protoc_insertion_point(class_scope:mw.internal.robotics.gazebotransport.GetGazeboModelSDF)
 private:
  inline void set_has_model_name();
  inline void clear_has_model_name();

  ::google::protobuf::internal::InternalMetadataWithArena _internal_metadata_;
  ::google::protobuf::uint32 _has_bits_[1];
  mutable int _cached_size_;
  ::google::protobuf::internal::ArenaStringPtr model_name_;
  friend void  protobuf_AddDesc_mw_2einternal_2erobotics_2egazebotransport_2eCoSimMsgs_2eproto();
  friend void protobuf_AssignDesc_mw_2einternal_2erobotics_2egazebotransport_2eCoSimMsgs_2eproto();
  friend void protobuf_ShutdownFile_mw_2einternal_2erobotics_2egazebotransport_2eCoSimMsgs_2eproto();

  void InitAsDefaultInstance();
  static GetGazeboModelSDF* default_instance_;
};
// ===================================================================


// ===================================================================

#if !PROTOBUF_INLINE_NOT_IN_HEADERS
// PluginVersion

// required string version = 1 [default = "R2021b"];
inline bool PluginVersion::has_version() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void PluginVersion::set_has_version() {
  _has_bits_[0] |= 0x00000001u;
}
inline void PluginVersion::clear_has_version() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void PluginVersion::clear_version() {
  version_.ClearToDefaultNoArena(_default_version_);
  clear_has_version();
}
inline const ::std::string& PluginVersion::version() const {
  // @@protoc_insertion_point(field_get:mw.internal.robotics.gazebotransport.PluginVersion.version)
  return version_.GetNoArena(_default_version_);
}
inline void PluginVersion::set_version(const ::std::string& value) {
  set_has_version();
  version_.SetNoArena(_default_version_, value);
  // @@protoc_insertion_point(field_set:mw.internal.robotics.gazebotransport.PluginVersion.version)
}
inline void PluginVersion::set_version(const char* value) {
  set_has_version();
  version_.SetNoArena(_default_version_, ::std::string(value));
  // @@protoc_insertion_point(field_set_char:mw.internal.robotics.gazebotransport.PluginVersion.version)
}
inline void PluginVersion::set_version(const char* value, size_t size) {
  set_has_version();
  version_.SetNoArena(_default_version_,
      ::std::string(reinterpret_cast<const char*>(value), size));
  // @@protoc_insertion_point(field_set_pointer:mw.internal.robotics.gazebotransport.PluginVersion.version)
}
inline ::std::string* PluginVersion::mutable_version() {
  set_has_version();
  // @@protoc_insertion_point(field_mutable:mw.internal.robotics.gazebotransport.PluginVersion.version)
  return version_.MutableNoArena(_default_version_);
}
inline ::std::string* PluginVersion::release_version() {
  // @@protoc_insertion_point(field_release:mw.internal.robotics.gazebotransport.PluginVersion.version)
  clear_has_version();
  return version_.ReleaseNoArena(_default_version_);
}
inline void PluginVersion::set_allocated_version(::std::string* version) {
  if (version != NULL) {
    set_has_version();
  } else {
    clear_has_version();
  }
  version_.SetAllocatedNoArena(_default_version_, version);
  // @@protoc_insertion_point(field_set_allocated:mw.internal.robotics.gazebotransport.PluginVersion.version)
}

// -------------------------------------------------------------------

// Time

// required uint64 seconds = 1;
inline bool Time::has_seconds() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void Time::set_has_seconds() {
  _has_bits_[0] |= 0x00000001u;
}
inline void Time::clear_has_seconds() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void Time::clear_seconds() {
  seconds_ = GOOGLE_ULONGLONG(0);
  clear_has_seconds();
}
inline ::google::protobuf::uint64 Time::seconds() const {
  // @@protoc_insertion_point(field_get:mw.internal.robotics.gazebotransport.Time.seconds)
  return seconds_;
}
inline void Time::set_seconds(::google::protobuf::uint64 value) {
  set_has_seconds();
  seconds_ = value;
  // @@protoc_insertion_point(field_set:mw.internal.robotics.gazebotransport.Time.seconds)
}

// required uint64 nano_seconds = 2;
inline bool Time::has_nano_seconds() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void Time::set_has_nano_seconds() {
  _has_bits_[0] |= 0x00000002u;
}
inline void Time::clear_has_nano_seconds() {
  _has_bits_[0] &= ~0x00000002u;
}
inline void Time::clear_nano_seconds() {
  nano_seconds_ = GOOGLE_ULONGLONG(0);
  clear_has_nano_seconds();
}
inline ::google::protobuf::uint64 Time::nano_seconds() const {
  // @@protoc_insertion_point(field_get:mw.internal.robotics.gazebotransport.Time.nano_seconds)
  return nano_seconds_;
}
inline void Time::set_nano_seconds(::google::protobuf::uint64 value) {
  set_has_nano_seconds();
  nano_seconds_ = value;
  // @@protoc_insertion_point(field_set:mw.internal.robotics.gazebotransport.Time.nano_seconds)
}

// -------------------------------------------------------------------

// PacketHeader

// required .mw.internal.robotics.gazebotransport.PacketHeader.MsgID id = 1;
inline bool PacketHeader::has_id() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void PacketHeader::set_has_id() {
  _has_bits_[0] |= 0x00000001u;
}
inline void PacketHeader::clear_has_id() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void PacketHeader::clear_id() {
  id_ = 0;
  clear_has_id();
}
inline ::mw::internal::robotics::gazebotransport::PacketHeader_MsgID PacketHeader::id() const {
  // @@protoc_insertion_point(field_get:mw.internal.robotics.gazebotransport.PacketHeader.id)
  return static_cast< ::mw::internal::robotics::gazebotransport::PacketHeader_MsgID >(id_);
}
inline void PacketHeader::set_id(::mw::internal::robotics::gazebotransport::PacketHeader_MsgID value) {
  assert(::mw::internal::robotics::gazebotransport::PacketHeader_MsgID_IsValid(value));
  set_has_id();
  id_ = value;
  // @@protoc_insertion_point(field_set:mw.internal.robotics.gazebotransport.PacketHeader.id)
}

// required .mw.internal.robotics.gazebotransport.Time time_stamp = 2;
inline bool PacketHeader::has_time_stamp() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void PacketHeader::set_has_time_stamp() {
  _has_bits_[0] |= 0x00000002u;
}
inline void PacketHeader::clear_has_time_stamp() {
  _has_bits_[0] &= ~0x00000002u;
}
inline void PacketHeader::clear_time_stamp() {
  if (time_stamp_ != NULL) time_stamp_->::mw::internal::robotics::gazebotransport::Time::Clear();
  clear_has_time_stamp();
}
inline const ::mw::internal::robotics::gazebotransport::Time& PacketHeader::time_stamp() const {
  // @@protoc_insertion_point(field_get:mw.internal.robotics.gazebotransport.PacketHeader.time_stamp)
  return time_stamp_ != NULL ? *time_stamp_ : *default_instance_->time_stamp_;
}
inline ::mw::internal::robotics::gazebotransport::Time* PacketHeader::mutable_time_stamp() {
  set_has_time_stamp();
  if (time_stamp_ == NULL) {
    time_stamp_ = new ::mw::internal::robotics::gazebotransport::Time;
  }
  // @@protoc_insertion_point(field_mutable:mw.internal.robotics.gazebotransport.PacketHeader.time_stamp)
  return time_stamp_;
}
inline ::mw::internal::robotics::gazebotransport::Time* PacketHeader::release_time_stamp() {
  // @@protoc_insertion_point(field_release:mw.internal.robotics.gazebotransport.PacketHeader.time_stamp)
  clear_has_time_stamp();
  ::mw::internal::robotics::gazebotransport::Time* temp = time_stamp_;
  time_stamp_ = NULL;
  return temp;
}
inline void PacketHeader::set_allocated_time_stamp(::mw::internal::robotics::gazebotransport::Time* time_stamp) {
  delete time_stamp_;
  time_stamp_ = time_stamp;
  if (time_stamp) {
    set_has_time_stamp();
  } else {
    clear_has_time_stamp();
  }
  // @@protoc_insertion_point(field_set_allocated:mw.internal.robotics.gazebotransport.PacketHeader.time_stamp)
}

// -------------------------------------------------------------------

// Packet

// required .mw.internal.robotics.gazebotransport.PacketHeader header = 1;
inline bool Packet::has_header() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void Packet::set_has_header() {
  _has_bits_[0] |= 0x00000001u;
}
inline void Packet::clear_has_header() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void Packet::clear_header() {
  if (header_ != NULL) header_->::mw::internal::robotics::gazebotransport::PacketHeader::Clear();
  clear_has_header();
}
inline const ::mw::internal::robotics::gazebotransport::PacketHeader& Packet::header() const {
  // @@protoc_insertion_point(field_get:mw.internal.robotics.gazebotransport.Packet.header)
  return header_ != NULL ? *header_ : *default_instance_->header_;
}
inline ::mw::internal::robotics::gazebotransport::PacketHeader* Packet::mutable_header() {
  set_has_header();
  if (header_ == NULL) {
    header_ = new ::mw::internal::robotics::gazebotransport::PacketHeader;
  }
  // @@protoc_insertion_point(field_mutable:mw.internal.robotics.gazebotransport.Packet.header)
  return header_;
}
inline ::mw::internal::robotics::gazebotransport::PacketHeader* Packet::release_header() {
  // @@protoc_insertion_point(field_release:mw.internal.robotics.gazebotransport.Packet.header)
  clear_has_header();
  ::mw::internal::robotics::gazebotransport::PacketHeader* temp = header_;
  header_ = NULL;
  return temp;
}
inline void Packet::set_allocated_header(::mw::internal::robotics::gazebotransport::PacketHeader* header) {
  delete header_;
  header_ = header;
  if (header) {
    set_has_header();
  } else {
    clear_has_header();
  }
  // @@protoc_insertion_point(field_set_allocated:mw.internal.robotics.gazebotransport.Packet.header)
}

// optional .mw.internal.robotics.gazebotransport.Packet.CoSimError status = 2;
inline bool Packet::has_status() const {
  return payload_case() == kStatus;
}
inline void Packet::set_has_status() {
  _oneof_case_[0] = kStatus;
}
inline void Packet::clear_status() {
  if (has_status()) {
    payload_.status_ = 0;
    clear_has_payload();
  }
}
inline ::mw::internal::robotics::gazebotransport::Packet_CoSimError Packet::status() const {
  // @@protoc_insertion_point(field_get:mw.internal.robotics.gazebotransport.Packet.status)
  if (has_status()) {
    return static_cast< ::mw::internal::robotics::gazebotransport::Packet_CoSimError >(payload_.status_);
  }
  return static_cast< ::mw::internal::robotics::gazebotransport::Packet_CoSimError >(0);
}
inline void Packet::set_status(::mw::internal::robotics::gazebotransport::Packet_CoSimError value) {
  assert(::mw::internal::robotics::gazebotransport::Packet_CoSimError_IsValid(value));
  if (!has_status()) {
    clear_payload();
    set_has_status();
  }
  payload_.status_ = value;
  // @@protoc_insertion_point(field_set:mw.internal.robotics.gazebotransport.Packet.status)
}

// optional .mw.internal.robotics.gazebotransport.StepSimulation step_simulation = 3;
inline bool Packet::has_step_simulation() const {
  return payload_case() == kStepSimulation;
}
inline void Packet::set_has_step_simulation() {
  _oneof_case_[0] = kStepSimulation;
}
inline void Packet::clear_step_simulation() {
  if (has_step_simulation()) {
    delete payload_.step_simulation_;
    clear_has_payload();
  }
}
inline  const ::mw::internal::robotics::gazebotransport::StepSimulation& Packet::step_simulation() const {
  // @@protoc_insertion_point(field_get:mw.internal.robotics.gazebotransport.Packet.step_simulation)
  return has_step_simulation()
      ? *payload_.step_simulation_
      : ::mw::internal::robotics::gazebotransport::StepSimulation::default_instance();
}
inline ::mw::internal::robotics::gazebotransport::StepSimulation* Packet::mutable_step_simulation() {
  if (!has_step_simulation()) {
    clear_payload();
    set_has_step_simulation();
    payload_.step_simulation_ = new ::mw::internal::robotics::gazebotransport::StepSimulation;
  }
  // @@protoc_insertion_point(field_mutable:mw.internal.robotics.gazebotransport.Packet.step_simulation)
  return payload_.step_simulation_;
}
inline ::mw::internal::robotics::gazebotransport::StepSimulation* Packet::release_step_simulation() {
  // @@protoc_insertion_point(field_release:mw.internal.robotics.gazebotransport.Packet.step_simulation)
  if (has_step_simulation()) {
    clear_has_payload();
    ::mw::internal::robotics::gazebotransport::StepSimulation* temp = payload_.step_simulation_;
    payload_.step_simulation_ = NULL;
    return temp;
  } else {
    return NULL;
  }
}
inline void Packet::set_allocated_step_simulation(::mw::internal::robotics::gazebotransport::StepSimulation* step_simulation) {
  clear_payload();
  if (step_simulation) {
    set_has_step_simulation();
    payload_.step_simulation_ = step_simulation;
  }
  // @@protoc_insertion_point(field_set_allocated:mw.internal.robotics.gazebotransport.Packet.step_simulation)
}

// optional .mw.internal.robotics.gazebotransport.ResetSimulation reset_simulation = 4;
inline bool Packet::has_reset_simulation() const {
  return payload_case() == kResetSimulation;
}
inline void Packet::set_has_reset_simulation() {
  _oneof_case_[0] = kResetSimulation;
}
inline void Packet::clear_reset_simulation() {
  if (has_reset_simulation()) {
    delete payload_.reset_simulation_;
    clear_has_payload();
  }
}
inline  const ::mw::internal::robotics::gazebotransport::ResetSimulation& Packet::reset_simulation() const {
  // @@protoc_insertion_point(field_get:mw.internal.robotics.gazebotransport.Packet.reset_simulation)
  return has_reset_simulation()
      ? *payload_.reset_simulation_
      : ::mw::internal::robotics::gazebotransport::ResetSimulation::default_instance();
}
inline ::mw::internal::robotics::gazebotransport::ResetSimulation* Packet::mutable_reset_simulation() {
  if (!has_reset_simulation()) {
    clear_payload();
    set_has_reset_simulation();
    payload_.reset_simulation_ = new ::mw::internal::robotics::gazebotransport::ResetSimulation;
  }
  // @@protoc_insertion_point(field_mutable:mw.internal.robotics.gazebotransport.Packet.reset_simulation)
  return payload_.reset_simulation_;
}
inline ::mw::internal::robotics::gazebotransport::ResetSimulation* Packet::release_reset_simulation() {
  // @@protoc_insertion_point(field_release:mw.internal.robotics.gazebotransport.Packet.reset_simulation)
  if (has_reset_simulation()) {
    clear_has_payload();
    ::mw::internal::robotics::gazebotransport::ResetSimulation* temp = payload_.reset_simulation_;
    payload_.reset_simulation_ = NULL;
    return temp;
  } else {
    return NULL;
  }
}
inline void Packet::set_allocated_reset_simulation(::mw::internal::robotics::gazebotransport::ResetSimulation* reset_simulation) {
  clear_payload();
  if (reset_simulation) {
    set_has_reset_simulation();
    payload_.reset_simulation_ = reset_simulation;
  }
  // @@protoc_insertion_point(field_set_allocated:mw.internal.robotics.gazebotransport.Packet.reset_simulation)
}

// optional .mw.internal.robotics.gazebotransport.Image image = 5;
inline bool Packet::has_image() const {
  return payload_case() == kImage;
}
inline void Packet::set_has_image() {
  _oneof_case_[0] = kImage;
}
inline void Packet::clear_image() {
  if (has_image()) {
    delete payload_.image_;
    clear_has_payload();
  }
}
inline  const ::mw::internal::robotics::gazebotransport::Image& Packet::image() const {
  // @@protoc_insertion_point(field_get:mw.internal.robotics.gazebotransport.Packet.image)
  return has_image()
      ? *payload_.image_
      : ::mw::internal::robotics::gazebotransport::Image::default_instance();
}
inline ::mw::internal::robotics::gazebotransport::Image* Packet::mutable_image() {
  if (!has_image()) {
    clear_payload();
    set_has_image();
    payload_.image_ = new ::mw::internal::robotics::gazebotransport::Image;
  }
  // @@protoc_insertion_point(field_mutable:mw.internal.robotics.gazebotransport.Packet.image)
  return payload_.image_;
}
inline ::mw::internal::robotics::gazebotransport::Image* Packet::release_image() {
  // @@protoc_insertion_point(field_release:mw.internal.robotics.gazebotransport.Packet.image)
  if (has_image()) {
    clear_has_payload();
    ::mw::internal::robotics::gazebotransport::Image* temp = payload_.image_;
    payload_.image_ = NULL;
    return temp;
  } else {
    return NULL;
  }
}
inline void Packet::set_allocated_image(::mw::internal::robotics::gazebotransport::Image* image) {
  clear_payload();
  if (image) {
    set_has_image();
    payload_.image_ = image;
  }
  // @@protoc_insertion_point(field_set_allocated:mw.internal.robotics.gazebotransport.Packet.image)
}

// optional .mw.internal.robotics.gazebotransport.RequestImage request_image = 6;
inline bool Packet::has_request_image() const {
  return payload_case() == kRequestImage;
}
inline void Packet::set_has_request_image() {
  _oneof_case_[0] = kRequestImage;
}
inline void Packet::clear_request_image() {
  if (has_request_image()) {
    delete payload_.request_image_;
    clear_has_payload();
  }
}
inline  const ::mw::internal::robotics::gazebotransport::RequestImage& Packet::request_image() const {
  // @@protoc_insertion_point(field_get:mw.internal.robotics.gazebotransport.Packet.request_image)
  return has_request_image()
      ? *payload_.request_image_
      : ::mw::internal::robotics::gazebotransport::RequestImage::default_instance();
}
inline ::mw::internal::robotics::gazebotransport::RequestImage* Packet::mutable_request_image() {
  if (!has_request_image()) {
    clear_payload();
    set_has_request_image();
    payload_.request_image_ = new ::mw::internal::robotics::gazebotransport::RequestImage;
  }
  // @@protoc_insertion_point(field_mutable:mw.internal.robotics.gazebotransport.Packet.request_image)
  return payload_.request_image_;
}
inline ::mw::internal::robotics::gazebotransport::RequestImage* Packet::release_request_image() {
  // @@protoc_insertion_point(field_release:mw.internal.robotics.gazebotransport.Packet.request_image)
  if (has_request_image()) {
    clear_has_payload();
    ::mw::internal::robotics::gazebotransport::RequestImage* temp = payload_.request_image_;
    payload_.request_image_ = NULL;
    return temp;
  } else {
    return NULL;
  }
}
inline void Packet::set_allocated_request_image(::mw::internal::robotics::gazebotransport::RequestImage* request_image) {
  clear_payload();
  if (request_image) {
    set_has_request_image();
    payload_.request_image_ = request_image;
  }
  // @@protoc_insertion_point(field_set_allocated:mw.internal.robotics.gazebotransport.Packet.request_image)
}

// optional .mw.internal.robotics.gazebotransport.RequestCoSim request_cosim = 7;
inline bool Packet::has_request_cosim() const {
  return payload_case() == kRequestCosim;
}
inline void Packet::set_has_request_cosim() {
  _oneof_case_[0] = kRequestCosim;
}
inline void Packet::clear_request_cosim() {
  if (has_request_cosim()) {
    delete payload_.request_cosim_;
    clear_has_payload();
  }
}
inline  const ::mw::internal::robotics::gazebotransport::RequestCoSim& Packet::request_cosim() const {
  // @@protoc_insertion_point(field_get:mw.internal.robotics.gazebotransport.Packet.request_cosim)
  return has_request_cosim()
      ? *payload_.request_cosim_
      : ::mw::internal::robotics::gazebotransport::RequestCoSim::default_instance();
}
inline ::mw::internal::robotics::gazebotransport::RequestCoSim* Packet::mutable_request_cosim() {
  if (!has_request_cosim()) {
    clear_payload();
    set_has_request_cosim();
    payload_.request_cosim_ = new ::mw::internal::robotics::gazebotransport::RequestCoSim;
  }
  // @@protoc_insertion_point(field_mutable:mw.internal.robotics.gazebotransport.Packet.request_cosim)
  return payload_.request_cosim_;
}
inline ::mw::internal::robotics::gazebotransport::RequestCoSim* Packet::release_request_cosim() {
  // @@protoc_insertion_point(field_release:mw.internal.robotics.gazebotransport.Packet.request_cosim)
  if (has_request_cosim()) {
    clear_has_payload();
    ::mw::internal::robotics::gazebotransport::RequestCoSim* temp = payload_.request_cosim_;
    payload_.request_cosim_ = NULL;
    return temp;
  } else {
    return NULL;
  }
}
inline void Packet::set_allocated_request_cosim(::mw::internal::robotics::gazebotransport::RequestCoSim* request_cosim) {
  clear_payload();
  if (request_cosim) {
    set_has_request_cosim();
    payload_.request_cosim_ = request_cosim;
  }
  // @@protoc_insertion_point(field_set_allocated:mw.internal.robotics.gazebotransport.Packet.request_cosim)
}

// optional .mw.internal.robotics.gazebotransport.StopCoSim stop_cosim = 8;
inline bool Packet::has_stop_cosim() const {
  return payload_case() == kStopCosim;
}
inline void Packet::set_has_stop_cosim() {
  _oneof_case_[0] = kStopCosim;
}
inline void Packet::clear_stop_cosim() {
  if (has_stop_cosim()) {
    delete payload_.stop_cosim_;
    clear_has_payload();
  }
}
inline  const ::mw::internal::robotics::gazebotransport::StopCoSim& Packet::stop_cosim() const {
  // @@protoc_insertion_point(field_get:mw.internal.robotics.gazebotransport.Packet.stop_cosim)
  return has_stop_cosim()
      ? *payload_.stop_cosim_
      : ::mw::internal::robotics::gazebotransport::StopCoSim::default_instance();
}
inline ::mw::internal::robotics::gazebotransport::StopCoSim* Packet::mutable_stop_cosim() {
  if (!has_stop_cosim()) {
    clear_payload();
    set_has_stop_cosim();
    payload_.stop_cosim_ = new ::mw::internal::robotics::gazebotransport::StopCoSim;
  }
  // @@protoc_insertion_point(field_mutable:mw.internal.robotics.gazebotransport.Packet.stop_cosim)
  return payload_.stop_cosim_;
}
inline ::mw::internal::robotics::gazebotransport::StopCoSim* Packet::release_stop_cosim() {
  // @@protoc_insertion_point(field_release:mw.internal.robotics.gazebotransport.Packet.stop_cosim)
  if (has_stop_cosim()) {
    clear_has_payload();
    ::mw::internal::robotics::gazebotransport::StopCoSim* temp = payload_.stop_cosim_;
    payload_.stop_cosim_ = NULL;
    return temp;
  } else {
    return NULL;
  }
}
inline void Packet::set_allocated_stop_cosim(::mw::internal::robotics::gazebotransport::StopCoSim* stop_cosim) {
  clear_payload();
  if (stop_cosim) {
    set_has_stop_cosim();
    payload_.stop_cosim_ = stop_cosim;
  }
  // @@protoc_insertion_point(field_set_allocated:mw.internal.robotics.gazebotransport.Packet.stop_cosim)
}

// optional .mw.internal.robotics.gazebotransport.GetGroundTruthWorldPose get_ground_truth_world_pose = 9;
inline bool Packet::has_get_ground_truth_world_pose() const {
  return payload_case() == kGetGroundTruthWorldPose;
}
inline void Packet::set_has_get_ground_truth_world_pose() {
  _oneof_case_[0] = kGetGroundTruthWorldPose;
}
inline void Packet::clear_get_ground_truth_world_pose() {
  if (has_get_ground_truth_world_pose()) {
    delete payload_.get_ground_truth_world_pose_;
    clear_has_payload();
  }
}
inline  const ::mw::internal::robotics::gazebotransport::GetGroundTruthWorldPose& Packet::get_ground_truth_world_pose() const {
  // @@protoc_insertion_point(field_get:mw.internal.robotics.gazebotransport.Packet.get_ground_truth_world_pose)
  return has_get_ground_truth_world_pose()
      ? *payload_.get_ground_truth_world_pose_
      : ::mw::internal::robotics::gazebotransport::GetGroundTruthWorldPose::default_instance();
}
inline ::mw::internal::robotics::gazebotransport::GetGroundTruthWorldPose* Packet::mutable_get_ground_truth_world_pose() {
  if (!has_get_ground_truth_world_pose()) {
    clear_payload();
    set_has_get_ground_truth_world_pose();
    payload_.get_ground_truth_world_pose_ = new ::mw::internal::robotics::gazebotransport::GetGroundTruthWorldPose;
  }
  // @@protoc_insertion_point(field_mutable:mw.internal.robotics.gazebotransport.Packet.get_ground_truth_world_pose)
  return payload_.get_ground_truth_world_pose_;
}
inline ::mw::internal::robotics::gazebotransport::GetGroundTruthWorldPose* Packet::release_get_ground_truth_world_pose() {
  // @@protoc_insertion_point(field_release:mw.internal.robotics.gazebotransport.Packet.get_ground_truth_world_pose)
  if (has_get_ground_truth_world_pose()) {
    clear_has_payload();
    ::mw::internal::robotics::gazebotransport::GetGroundTruthWorldPose* temp = payload_.get_ground_truth_world_pose_;
    payload_.get_ground_truth_world_pose_ = NULL;
    return temp;
  } else {
    return NULL;
  }
}
inline void Packet::set_allocated_get_ground_truth_world_pose(::mw::internal::robotics::gazebotransport::GetGroundTruthWorldPose* get_ground_truth_world_pose) {
  clear_payload();
  if (get_ground_truth_world_pose) {
    set_has_get_ground_truth_world_pose();
    payload_.get_ground_truth_world_pose_ = get_ground_truth_world_pose;
  }
  // @@protoc_insertion_point(field_set_allocated:mw.internal.robotics.gazebotransport.Packet.get_ground_truth_world_pose)
}

// optional .mw.internal.robotics.gazebotransport.Pose pose = 10;
inline bool Packet::has_pose() const {
  return payload_case() == kPose;
}
inline void Packet::set_has_pose() {
  _oneof_case_[0] = kPose;
}
inline void Packet::clear_pose() {
  if (has_pose()) {
    delete payload_.pose_;
    clear_has_payload();
  }
}
inline  const ::mw::internal::robotics::gazebotransport::Pose& Packet::pose() const {
  // @@protoc_insertion_point(field_get:mw.internal.robotics.gazebotransport.Packet.pose)
  return has_pose()
      ? *payload_.pose_
      : ::mw::internal::robotics::gazebotransport::Pose::default_instance();
}
inline ::mw::internal::robotics::gazebotransport::Pose* Packet::mutable_pose() {
  if (!has_pose()) {
    clear_payload();
    set_has_pose();
    payload_.pose_ = new ::mw::internal::robotics::gazebotransport::Pose;
  }
  // @@protoc_insertion_point(field_mutable:mw.internal.robotics.gazebotransport.Packet.pose)
  return payload_.pose_;
}
inline ::mw::internal::robotics::gazebotransport::Pose* Packet::release_pose() {
  // @@protoc_insertion_point(field_release:mw.internal.robotics.gazebotransport.Packet.pose)
  if (has_pose()) {
    clear_has_payload();
    ::mw::internal::robotics::gazebotransport::Pose* temp = payload_.pose_;
    payload_.pose_ = NULL;
    return temp;
  } else {
    return NULL;
  }
}
inline void Packet::set_allocated_pose(::mw::internal::robotics::gazebotransport::Pose* pose) {
  clear_payload();
  if (pose) {
    set_has_pose();
    payload_.pose_ = pose;
  }
  // @@protoc_insertion_point(field_set_allocated:mw.internal.robotics.gazebotransport.Packet.pose)
}

// optional .mw.internal.robotics.gazebotransport.StopSimulation stop_simulation = 11;
inline bool Packet::has_stop_simulation() const {
  return payload_case() == kStopSimulation;
}
inline void Packet::set_has_stop_simulation() {
  _oneof_case_[0] = kStopSimulation;
}
inline void Packet::clear_stop_simulation() {
  if (has_stop_simulation()) {
    delete payload_.stop_simulation_;
    clear_has_payload();
  }
}
inline  const ::mw::internal::robotics::gazebotransport::StopSimulation& Packet::stop_simulation() const {
  // @@protoc_insertion_point(field_get:mw.internal.robotics.gazebotransport.Packet.stop_simulation)
  return has_stop_simulation()
      ? *payload_.stop_simulation_
      : ::mw::internal::robotics::gazebotransport::StopSimulation::default_instance();
}
inline ::mw::internal::robotics::gazebotransport::StopSimulation* Packet::mutable_stop_simulation() {
  if (!has_stop_simulation()) {
    clear_payload();
    set_has_stop_simulation();
    payload_.stop_simulation_ = new ::mw::internal::robotics::gazebotransport::StopSimulation;
  }
  // @@protoc_insertion_point(field_mutable:mw.internal.robotics.gazebotransport.Packet.stop_simulation)
  return payload_.stop_simulation_;
}
inline ::mw::internal::robotics::gazebotransport::StopSimulation* Packet::release_stop_simulation() {
  // @@protoc_insertion_point(field_release:mw.internal.robotics.gazebotransport.Packet.stop_simulation)
  if (has_stop_simulation()) {
    clear_has_payload();
    ::mw::internal::robotics::gazebotransport::StopSimulation* temp = payload_.stop_simulation_;
    payload_.stop_simulation_ = NULL;
    return temp;
  } else {
    return NULL;
  }
}
inline void Packet::set_allocated_stop_simulation(::mw::internal::robotics::gazebotransport::StopSimulation* stop_simulation) {
  clear_payload();
  if (stop_simulation) {
    set_has_stop_simulation();
    payload_.stop_simulation_ = stop_simulation;
  }
  // @@protoc_insertion_point(field_set_allocated:mw.internal.robotics.gazebotransport.Packet.stop_simulation)
}

// optional .mw.internal.robotics.gazebotransport.LaserData laser_data = 12;
inline bool Packet::has_laser_data() const {
  return payload_case() == kLaserData;
}
inline void Packet::set_has_laser_data() {
  _oneof_case_[0] = kLaserData;
}
inline void Packet::clear_laser_data() {
  if (has_laser_data()) {
    delete payload_.laser_data_;
    clear_has_payload();
  }
}
inline  const ::mw::internal::robotics::gazebotransport::LaserData& Packet::laser_data() const {
  // @@protoc_insertion_point(field_get:mw.internal.robotics.gazebotransport.Packet.laser_data)
  return has_laser_data()
      ? *payload_.laser_data_
      : ::mw::internal::robotics::gazebotransport::LaserData::default_instance();
}
inline ::mw::internal::robotics::gazebotransport::LaserData* Packet::mutable_laser_data() {
  if (!has_laser_data()) {
    clear_payload();
    set_has_laser_data();
    payload_.laser_data_ = new ::mw::internal::robotics::gazebotransport::LaserData;
  }
  // @@protoc_insertion_point(field_mutable:mw.internal.robotics.gazebotransport.Packet.laser_data)
  return payload_.laser_data_;
}
inline ::mw::internal::robotics::gazebotransport::LaserData* Packet::release_laser_data() {
  // @@protoc_insertion_point(field_release:mw.internal.robotics.gazebotransport.Packet.laser_data)
  if (has_laser_data()) {
    clear_has_payload();
    ::mw::internal::robotics::gazebotransport::LaserData* temp = payload_.laser_data_;
    payload_.laser_data_ = NULL;
    return temp;
  } else {
    return NULL;
  }
}
inline void Packet::set_allocated_laser_data(::mw::internal::robotics::gazebotransport::LaserData* laser_data) {
  clear_payload();
  if (laser_data) {
    set_has_laser_data();
    payload_.laser_data_ = laser_data;
  }
  // @@protoc_insertion_point(field_set_allocated:mw.internal.robotics.gazebotransport.Packet.laser_data)
}

// optional .mw.internal.robotics.gazebotransport.RequestLaser request_laser = 13;
inline bool Packet::has_request_laser() const {
  return payload_case() == kRequestLaser;
}
inline void Packet::set_has_request_laser() {
  _oneof_case_[0] = kRequestLaser;
}
inline void Packet::clear_request_laser() {
  if (has_request_laser()) {
    delete payload_.request_laser_;
    clear_has_payload();
  }
}
inline  const ::mw::internal::robotics::gazebotransport::RequestLaser& Packet::request_laser() const {
  // @@protoc_insertion_point(field_get:mw.internal.robotics.gazebotransport.Packet.request_laser)
  return has_request_laser()
      ? *payload_.request_laser_
      : ::mw::internal::robotics::gazebotransport::RequestLaser::default_instance();
}
inline ::mw::internal::robotics::gazebotransport::RequestLaser* Packet::mutable_request_laser() {
  if (!has_request_laser()) {
    clear_payload();
    set_has_request_laser();
    payload_.request_laser_ = new ::mw::internal::robotics::gazebotransport::RequestLaser;
  }
  // @@protoc_insertion_point(field_mutable:mw.internal.robotics.gazebotransport.Packet.request_laser)
  return payload_.request_laser_;
}
inline ::mw::internal::robotics::gazebotransport::RequestLaser* Packet::release_request_laser() {
  // @@protoc_insertion_point(field_release:mw.internal.robotics.gazebotransport.Packet.request_laser)
  if (has_request_laser()) {
    clear_has_payload();
    ::mw::internal::robotics::gazebotransport::RequestLaser* temp = payload_.request_laser_;
    payload_.request_laser_ = NULL;
    return temp;
  } else {
    return NULL;
  }
}
inline void Packet::set_allocated_request_laser(::mw::internal::robotics::gazebotransport::RequestLaser* request_laser) {
  clear_payload();
  if (request_laser) {
    set_has_request_laser();
    payload_.request_laser_ = request_laser;
  }
  // @@protoc_insertion_point(field_set_allocated:mw.internal.robotics.gazebotransport.Packet.request_laser)
}

// optional .mw.internal.robotics.gazebotransport.ImuData imu_data = 14;
inline bool Packet::has_imu_data() const {
  return payload_case() == kImuData;
}
inline void Packet::set_has_imu_data() {
  _oneof_case_[0] = kImuData;
}
inline void Packet::clear_imu_data() {
  if (has_imu_data()) {
    delete payload_.imu_data_;
    clear_has_payload();
  }
}
inline  const ::mw::internal::robotics::gazebotransport::ImuData& Packet::imu_data() const {
  // @@protoc_insertion_point(field_get:mw.internal.robotics.gazebotransport.Packet.imu_data)
  return has_imu_data()
      ? *payload_.imu_data_
      : ::mw::internal::robotics::gazebotransport::ImuData::default_instance();
}
inline ::mw::internal::robotics::gazebotransport::ImuData* Packet::mutable_imu_data() {
  if (!has_imu_data()) {
    clear_payload();
    set_has_imu_data();
    payload_.imu_data_ = new ::mw::internal::robotics::gazebotransport::ImuData;
  }
  // @@protoc_insertion_point(field_mutable:mw.internal.robotics.gazebotransport.Packet.imu_data)
  return payload_.imu_data_;
}
inline ::mw::internal::robotics::gazebotransport::ImuData* Packet::release_imu_data() {
  // @@protoc_insertion_point(field_release:mw.internal.robotics.gazebotransport.Packet.imu_data)
  if (has_imu_data()) {
    clear_has_payload();
    ::mw::internal::robotics::gazebotransport::ImuData* temp = payload_.imu_data_;
    payload_.imu_data_ = NULL;
    return temp;
  } else {
    return NULL;
  }
}
inline void Packet::set_allocated_imu_data(::mw::internal::robotics::gazebotransport::ImuData* imu_data) {
  clear_payload();
  if (imu_data) {
    set_has_imu_data();
    payload_.imu_data_ = imu_data;
  }
  // @@protoc_insertion_point(field_set_allocated:mw.internal.robotics.gazebotransport.Packet.imu_data)
}

// optional .mw.internal.robotics.gazebotransport.RequestImu request_imu = 15;
inline bool Packet::has_request_imu() const {
  return payload_case() == kRequestImu;
}
inline void Packet::set_has_request_imu() {
  _oneof_case_[0] = kRequestImu;
}
inline void Packet::clear_request_imu() {
  if (has_request_imu()) {
    delete payload_.request_imu_;
    clear_has_payload();
  }
}
inline  const ::mw::internal::robotics::gazebotransport::RequestImu& Packet::request_imu() const {
  // @@protoc_insertion_point(field_get:mw.internal.robotics.gazebotransport.Packet.request_imu)
  return has_request_imu()
      ? *payload_.request_imu_
      : ::mw::internal::robotics::gazebotransport::RequestImu::default_instance();
}
inline ::mw::internal::robotics::gazebotransport::RequestImu* Packet::mutable_request_imu() {
  if (!has_request_imu()) {
    clear_payload();
    set_has_request_imu();
    payload_.request_imu_ = new ::mw::internal::robotics::gazebotransport::RequestImu;
  }
  // @@protoc_insertion_point(field_mutable:mw.internal.robotics.gazebotransport.Packet.request_imu)
  return payload_.request_imu_;
}
inline ::mw::internal::robotics::gazebotransport::RequestImu* Packet::release_request_imu() {
  // @@protoc_insertion_point(field_release:mw.internal.robotics.gazebotransport.Packet.request_imu)
  if (has_request_imu()) {
    clear_has_payload();
    ::mw::internal::robotics::gazebotransport::RequestImu* temp = payload_.request_imu_;
    payload_.request_imu_ = NULL;
    return temp;
  } else {
    return NULL;
  }
}
inline void Packet::set_allocated_request_imu(::mw::internal::robotics::gazebotransport::RequestImu* request_imu) {
  clear_payload();
  if (request_imu) {
    set_has_request_imu();
    payload_.request_imu_ = request_imu;
  }
  // @@protoc_insertion_point(field_set_allocated:mw.internal.robotics.gazebotransport.Packet.request_imu)
}

// optional .mw.internal.robotics.gazebotransport.SubscribeImage subscribe_image = 16;
inline bool Packet::has_subscribe_image() const {
  return payload_case() == kSubscribeImage;
}
inline void Packet::set_has_subscribe_image() {
  _oneof_case_[0] = kSubscribeImage;
}
inline void Packet::clear_subscribe_image() {
  if (has_subscribe_image()) {
    delete payload_.subscribe_image_;
    clear_has_payload();
  }
}
inline  const ::mw::internal::robotics::gazebotransport::SubscribeImage& Packet::subscribe_image() const {
  // @@protoc_insertion_point(field_get:mw.internal.robotics.gazebotransport.Packet.subscribe_image)
  return has_subscribe_image()
      ? *payload_.subscribe_image_
      : ::mw::internal::robotics::gazebotransport::SubscribeImage::default_instance();
}
inline ::mw::internal::robotics::gazebotransport::SubscribeImage* Packet::mutable_subscribe_image() {
  if (!has_subscribe_image()) {
    clear_payload();
    set_has_subscribe_image();
    payload_.subscribe_image_ = new ::mw::internal::robotics::gazebotransport::SubscribeImage;
  }
  // @@protoc_insertion_point(field_mutable:mw.internal.robotics.gazebotransport.Packet.subscribe_image)
  return payload_.subscribe_image_;
}
inline ::mw::internal::robotics::gazebotransport::SubscribeImage* Packet::release_subscribe_image() {
  // @@protoc_insertion_point(field_release:mw.internal.robotics.gazebotransport.Packet.subscribe_image)
  if (has_subscribe_image()) {
    clear_has_payload();
    ::mw::internal::robotics::gazebotransport::SubscribeImage* temp = payload_.subscribe_image_;
    payload_.subscribe_image_ = NULL;
    return temp;
  } else {
    return NULL;
  }
}
inline void Packet::set_allocated_subscribe_image(::mw::internal::robotics::gazebotransport::SubscribeImage* subscribe_image) {
  clear_payload();
  if (subscribe_image) {
    set_has_subscribe_image();
    payload_.subscribe_image_ = subscribe_image;
  }
  // @@protoc_insertion_point(field_set_allocated:mw.internal.robotics.gazebotransport.Packet.subscribe_image)
}

// optional .mw.internal.robotics.gazebotransport.SubscribeLaser subscribe_laser = 17;
inline bool Packet::has_subscribe_laser() const {
  return payload_case() == kSubscribeLaser;
}
inline void Packet::set_has_subscribe_laser() {
  _oneof_case_[0] = kSubscribeLaser;
}
inline void Packet::clear_subscribe_laser() {
  if (has_subscribe_laser()) {
    delete payload_.subscribe_laser_;
    clear_has_payload();
  }
}
inline  const ::mw::internal::robotics::gazebotransport::SubscribeLaser& Packet::subscribe_laser() const {
  // @@protoc_insertion_point(field_get:mw.internal.robotics.gazebotransport.Packet.subscribe_laser)
  return has_subscribe_laser()
      ? *payload_.subscribe_laser_
      : ::mw::internal::robotics::gazebotransport::SubscribeLaser::default_instance();
}
inline ::mw::internal::robotics::gazebotransport::SubscribeLaser* Packet::mutable_subscribe_laser() {
  if (!has_subscribe_laser()) {
    clear_payload();
    set_has_subscribe_laser();
    payload_.subscribe_laser_ = new ::mw::internal::robotics::gazebotransport::SubscribeLaser;
  }
  // @@protoc_insertion_point(field_mutable:mw.internal.robotics.gazebotransport.Packet.subscribe_laser)
  return payload_.subscribe_laser_;
}
inline ::mw::internal::robotics::gazebotransport::SubscribeLaser* Packet::release_subscribe_laser() {
  // @@protoc_insertion_point(field_release:mw.internal.robotics.gazebotransport.Packet.subscribe_laser)
  if (has_subscribe_laser()) {
    clear_has_payload();
    ::mw::internal::robotics::gazebotransport::SubscribeLaser* temp = payload_.subscribe_laser_;
    payload_.subscribe_laser_ = NULL;
    return temp;
  } else {
    return NULL;
  }
}
inline void Packet::set_allocated_subscribe_laser(::mw::internal::robotics::gazebotransport::SubscribeLaser* subscribe_laser) {
  clear_payload();
  if (subscribe_laser) {
    set_has_subscribe_laser();
    payload_.subscribe_laser_ = subscribe_laser;
  }
  // @@protoc_insertion_point(field_set_allocated:mw.internal.robotics.gazebotransport.Packet.subscribe_laser)
}

// optional .mw.internal.robotics.gazebotransport.SubscribeImu subscribe_imu = 18;
inline bool Packet::has_subscribe_imu() const {
  return payload_case() == kSubscribeImu;
}
inline void Packet::set_has_subscribe_imu() {
  _oneof_case_[0] = kSubscribeImu;
}
inline void Packet::clear_subscribe_imu() {
  if (has_subscribe_imu()) {
    delete payload_.subscribe_imu_;
    clear_has_payload();
  }
}
inline  const ::mw::internal::robotics::gazebotransport::SubscribeImu& Packet::subscribe_imu() const {
  // @@protoc_insertion_point(field_get:mw.internal.robotics.gazebotransport.Packet.subscribe_imu)
  return has_subscribe_imu()
      ? *payload_.subscribe_imu_
      : ::mw::internal::robotics::gazebotransport::SubscribeImu::default_instance();
}
inline ::mw::internal::robotics::gazebotransport::SubscribeImu* Packet::mutable_subscribe_imu() {
  if (!has_subscribe_imu()) {
    clear_payload();
    set_has_subscribe_imu();
    payload_.subscribe_imu_ = new ::mw::internal::robotics::gazebotransport::SubscribeImu;
  }
  // @@protoc_insertion_point(field_mutable:mw.internal.robotics.gazebotransport.Packet.subscribe_imu)
  return payload_.subscribe_imu_;
}
inline ::mw::internal::robotics::gazebotransport::SubscribeImu* Packet::release_subscribe_imu() {
  // @@protoc_insertion_point(field_release:mw.internal.robotics.gazebotransport.Packet.subscribe_imu)
  if (has_subscribe_imu()) {
    clear_has_payload();
    ::mw::internal::robotics::gazebotransport::SubscribeImu* temp = payload_.subscribe_imu_;
    payload_.subscribe_imu_ = NULL;
    return temp;
  } else {
    return NULL;
  }
}
inline void Packet::set_allocated_subscribe_imu(::mw::internal::robotics::gazebotransport::SubscribeImu* subscribe_imu) {
  clear_payload();
  if (subscribe_imu) {
    set_has_subscribe_imu();
    payload_.subscribe_imu_ = subscribe_imu;
  }
  // @@protoc_insertion_point(field_set_allocated:mw.internal.robotics.gazebotransport.Packet.subscribe_imu)
}

// optional .mw.internal.robotics.gazebotransport.ApplyJointTorque apply_joint_torque = 19;
inline bool Packet::has_apply_joint_torque() const {
  return payload_case() == kApplyJointTorque;
}
inline void Packet::set_has_apply_joint_torque() {
  _oneof_case_[0] = kApplyJointTorque;
}
inline void Packet::clear_apply_joint_torque() {
  if (has_apply_joint_torque()) {
    delete payload_.apply_joint_torque_;
    clear_has_payload();
  }
}
inline  const ::mw::internal::robotics::gazebotransport::ApplyJointTorque& Packet::apply_joint_torque() const {
  // @@protoc_insertion_point(field_get:mw.internal.robotics.gazebotransport.Packet.apply_joint_torque)
  return has_apply_joint_torque()
      ? *payload_.apply_joint_torque_
      : ::mw::internal::robotics::gazebotransport::ApplyJointTorque::default_instance();
}
inline ::mw::internal::robotics::gazebotransport::ApplyJointTorque* Packet::mutable_apply_joint_torque() {
  if (!has_apply_joint_torque()) {
    clear_payload();
    set_has_apply_joint_torque();
    payload_.apply_joint_torque_ = new ::mw::internal::robotics::gazebotransport::ApplyJointTorque;
  }
  // @@protoc_insertion_point(field_mutable:mw.internal.robotics.gazebotransport.Packet.apply_joint_torque)
  return payload_.apply_joint_torque_;
}
inline ::mw::internal::robotics::gazebotransport::ApplyJointTorque* Packet::release_apply_joint_torque() {
  // @@protoc_insertion_point(field_release:mw.internal.robotics.gazebotransport.Packet.apply_joint_torque)
  if (has_apply_joint_torque()) {
    clear_has_payload();
    ::mw::internal::robotics::gazebotransport::ApplyJointTorque* temp = payload_.apply_joint_torque_;
    payload_.apply_joint_torque_ = NULL;
    return temp;
  } else {
    return NULL;
  }
}
inline void Packet::set_allocated_apply_joint_torque(::mw::internal::robotics::gazebotransport::ApplyJointTorque* apply_joint_torque) {
  clear_payload();
  if (apply_joint_torque) {
    set_has_apply_joint_torque();
    payload_.apply_joint_torque_ = apply_joint_torque;
  }
  // @@protoc_insertion_point(field_set_allocated:mw.internal.robotics.gazebotransport.Packet.apply_joint_torque)
}

// optional .mw.internal.robotics.gazebotransport.GetPose get_pose = 20;
inline bool Packet::has_get_pose() const {
  return payload_case() == kGetPose;
}
inline void Packet::set_has_get_pose() {
  _oneof_case_[0] = kGetPose;
}
inline void Packet::clear_get_pose() {
  if (has_get_pose()) {
    delete payload_.get_pose_;
    clear_has_payload();
  }
}
inline  const ::mw::internal::robotics::gazebotransport::GetPose& Packet::get_pose() const {
  // @@protoc_insertion_point(field_get:mw.internal.robotics.gazebotransport.Packet.get_pose)
  return has_get_pose()
      ? *payload_.get_pose_
      : ::mw::internal::robotics::gazebotransport::GetPose::default_instance();
}
inline ::mw::internal::robotics::gazebotransport::GetPose* Packet::mutable_get_pose() {
  if (!has_get_pose()) {
    clear_payload();
    set_has_get_pose();
    payload_.get_pose_ = new ::mw::internal::robotics::gazebotransport::GetPose;
  }
  // @@protoc_insertion_point(field_mutable:mw.internal.robotics.gazebotransport.Packet.get_pose)
  return payload_.get_pose_;
}
inline ::mw::internal::robotics::gazebotransport::GetPose* Packet::release_get_pose() {
  // @@protoc_insertion_point(field_release:mw.internal.robotics.gazebotransport.Packet.get_pose)
  if (has_get_pose()) {
    clear_has_payload();
    ::mw::internal::robotics::gazebotransport::GetPose* temp = payload_.get_pose_;
    payload_.get_pose_ = NULL;
    return temp;
  } else {
    return NULL;
  }
}
inline void Packet::set_allocated_get_pose(::mw::internal::robotics::gazebotransport::GetPose* get_pose) {
  clear_payload();
  if (get_pose) {
    set_has_get_pose();
    payload_.get_pose_ = get_pose;
  }
  // @@protoc_insertion_point(field_set_allocated:mw.internal.robotics.gazebotransport.Packet.get_pose)
}

// optional .mw.internal.robotics.gazebotransport.GetTopicList get_topic_list = 21;
inline bool Packet::has_get_topic_list() const {
  return payload_case() == kGetTopicList;
}
inline void Packet::set_has_get_topic_list() {
  _oneof_case_[0] = kGetTopicList;
}
inline void Packet::clear_get_topic_list() {
  if (has_get_topic_list()) {
    delete payload_.get_topic_list_;
    clear_has_payload();
  }
}
inline  const ::mw::internal::robotics::gazebotransport::GetTopicList& Packet::get_topic_list() const {
  // @@protoc_insertion_point(field_get:mw.internal.robotics.gazebotransport.Packet.get_topic_list)
  return has_get_topic_list()
      ? *payload_.get_topic_list_
      : ::mw::internal::robotics::gazebotransport::GetTopicList::default_instance();
}
inline ::mw::internal::robotics::gazebotransport::GetTopicList* Packet::mutable_get_topic_list() {
  if (!has_get_topic_list()) {
    clear_payload();
    set_has_get_topic_list();
    payload_.get_topic_list_ = new ::mw::internal::robotics::gazebotransport::GetTopicList;
  }
  // @@protoc_insertion_point(field_mutable:mw.internal.robotics.gazebotransport.Packet.get_topic_list)
  return payload_.get_topic_list_;
}
inline ::mw::internal::robotics::gazebotransport::GetTopicList* Packet::release_get_topic_list() {
  // @@protoc_insertion_point(field_release:mw.internal.robotics.gazebotransport.Packet.get_topic_list)
  if (has_get_topic_list()) {
    clear_has_payload();
    ::mw::internal::robotics::gazebotransport::GetTopicList* temp = payload_.get_topic_list_;
    payload_.get_topic_list_ = NULL;
    return temp;
  } else {
    return NULL;
  }
}
inline void Packet::set_allocated_get_topic_list(::mw::internal::robotics::gazebotransport::GetTopicList* get_topic_list) {
  clear_payload();
  if (get_topic_list) {
    set_has_get_topic_list();
    payload_.get_topic_list_ = get_topic_list;
  }
  // @@protoc_insertion_point(field_set_allocated:mw.internal.robotics.gazebotransport.Packet.get_topic_list)
}

// optional .mw.internal.robotics.gazebotransport.TopicList topic_list = 22;
inline bool Packet::has_topic_list() const {
  return payload_case() == kTopicList;
}
inline void Packet::set_has_topic_list() {
  _oneof_case_[0] = kTopicList;
}
inline void Packet::clear_topic_list() {
  if (has_topic_list()) {
    delete payload_.topic_list_;
    clear_has_payload();
  }
}
inline  const ::mw::internal::robotics::gazebotransport::TopicList& Packet::topic_list() const {
  // @@protoc_insertion_point(field_get:mw.internal.robotics.gazebotransport.Packet.topic_list)
  return has_topic_list()
      ? *payload_.topic_list_
      : ::mw::internal::robotics::gazebotransport::TopicList::default_instance();
}
inline ::mw::internal::robotics::gazebotransport::TopicList* Packet::mutable_topic_list() {
  if (!has_topic_list()) {
    clear_payload();
    set_has_topic_list();
    payload_.topic_list_ = new ::mw::internal::robotics::gazebotransport::TopicList;
  }
  // @@protoc_insertion_point(field_mutable:mw.internal.robotics.gazebotransport.Packet.topic_list)
  return payload_.topic_list_;
}
inline ::mw::internal::robotics::gazebotransport::TopicList* Packet::release_topic_list() {
  // @@protoc_insertion_point(field_release:mw.internal.robotics.gazebotransport.Packet.topic_list)
  if (has_topic_list()) {
    clear_has_payload();
    ::mw::internal::robotics::gazebotransport::TopicList* temp = payload_.topic_list_;
    payload_.topic_list_ = NULL;
    return temp;
  } else {
    return NULL;
  }
}
inline void Packet::set_allocated_topic_list(::mw::internal::robotics::gazebotransport::TopicList* topic_list) {
  clear_payload();
  if (topic_list) {
    set_has_topic_list();
    payload_.topic_list_ = topic_list;
  }
  // @@protoc_insertion_point(field_set_allocated:mw.internal.robotics.gazebotransport.Packet.topic_list)
}

// optional .mw.internal.robotics.gazebotransport.GetModelInfo get_model_info = 23;
inline bool Packet::has_get_model_info() const {
  return payload_case() == kGetModelInfo;
}
inline void Packet::set_has_get_model_info() {
  _oneof_case_[0] = kGetModelInfo;
}
inline void Packet::clear_get_model_info() {
  if (has_get_model_info()) {
    delete payload_.get_model_info_;
    clear_has_payload();
  }
}
inline  const ::mw::internal::robotics::gazebotransport::GetModelInfo& Packet::get_model_info() const {
  // @@protoc_insertion_point(field_get:mw.internal.robotics.gazebotransport.Packet.get_model_info)
  return has_get_model_info()
      ? *payload_.get_model_info_
      : ::mw::internal::robotics::gazebotransport::GetModelInfo::default_instance();
}
inline ::mw::internal::robotics::gazebotransport::GetModelInfo* Packet::mutable_get_model_info() {
  if (!has_get_model_info()) {
    clear_payload();
    set_has_get_model_info();
    payload_.get_model_info_ = new ::mw::internal::robotics::gazebotransport::GetModelInfo;
  }
  // @@protoc_insertion_point(field_mutable:mw.internal.robotics.gazebotransport.Packet.get_model_info)
  return payload_.get_model_info_;
}
inline ::mw::internal::robotics::gazebotransport::GetModelInfo* Packet::release_get_model_info() {
  // @@protoc_insertion_point(field_release:mw.internal.robotics.gazebotransport.Packet.get_model_info)
  if (has_get_model_info()) {
    clear_has_payload();
    ::mw::internal::robotics::gazebotransport::GetModelInfo* temp = payload_.get_model_info_;
    payload_.get_model_info_ = NULL;
    return temp;
  } else {
    return NULL;
  }
}
inline void Packet::set_allocated_get_model_info(::mw::internal::robotics::gazebotransport::GetModelInfo* get_model_info) {
  clear_payload();
  if (get_model_info) {
    set_has_get_model_info();
    payload_.get_model_info_ = get_model_info;
  }
  // @@protoc_insertion_point(field_set_allocated:mw.internal.robotics.gazebotransport.Packet.get_model_info)
}

// optional .mw.internal.robotics.gazebotransport.ModelInfo model_info = 24;
inline bool Packet::has_model_info() const {
  return payload_case() == kModelInfo;
}
inline void Packet::set_has_model_info() {
  _oneof_case_[0] = kModelInfo;
}
inline void Packet::clear_model_info() {
  if (has_model_info()) {
    delete payload_.model_info_;
    clear_has_payload();
  }
}
inline  const ::mw::internal::robotics::gazebotransport::ModelInfo& Packet::model_info() const {
  // @@protoc_insertion_point(field_get:mw.internal.robotics.gazebotransport.Packet.model_info)
  return has_model_info()
      ? *payload_.model_info_
      : ::mw::internal::robotics::gazebotransport::ModelInfo::default_instance();
}
inline ::mw::internal::robotics::gazebotransport::ModelInfo* Packet::mutable_model_info() {
  if (!has_model_info()) {
    clear_payload();
    set_has_model_info();
    payload_.model_info_ = new ::mw::internal::robotics::gazebotransport::ModelInfo;
  }
  // @@protoc_insertion_point(field_mutable:mw.internal.robotics.gazebotransport.Packet.model_info)
  return payload_.model_info_;
}
inline ::mw::internal::robotics::gazebotransport::ModelInfo* Packet::release_model_info() {
  // @@protoc_insertion_point(field_release:mw.internal.robotics.gazebotransport.Packet.model_info)
  if (has_model_info()) {
    clear_has_payload();
    ::mw::internal::robotics::gazebotransport::ModelInfo* temp = payload_.model_info_;
    payload_.model_info_ = NULL;
    return temp;
  } else {
    return NULL;
  }
}
inline void Packet::set_allocated_model_info(::mw::internal::robotics::gazebotransport::ModelInfo* model_info) {
  clear_payload();
  if (model_info) {
    set_has_model_info();
    payload_.model_info_ = model_info;
  }
  // @@protoc_insertion_point(field_set_allocated:mw.internal.robotics.gazebotransport.Packet.model_info)
}

// optional .mw.internal.robotics.gazebotransport.ApplyLinkWrench apply_link_wrench = 25;
inline bool Packet::has_apply_link_wrench() const {
  return payload_case() == kApplyLinkWrench;
}
inline void Packet::set_has_apply_link_wrench() {
  _oneof_case_[0] = kApplyLinkWrench;
}
inline void Packet::clear_apply_link_wrench() {
  if (has_apply_link_wrench()) {
    delete payload_.apply_link_wrench_;
    clear_has_payload();
  }
}
inline  const ::mw::internal::robotics::gazebotransport::ApplyLinkWrench& Packet::apply_link_wrench() const {
  // @@protoc_insertion_point(field_get:mw.internal.robotics.gazebotransport.Packet.apply_link_wrench)
  return has_apply_link_wrench()
      ? *payload_.apply_link_wrench_
      : ::mw::internal::robotics::gazebotransport::ApplyLinkWrench::default_instance();
}
inline ::mw::internal::robotics::gazebotransport::ApplyLinkWrench* Packet::mutable_apply_link_wrench() {
  if (!has_apply_link_wrench()) {
    clear_payload();
    set_has_apply_link_wrench();
    payload_.apply_link_wrench_ = new ::mw::internal::robotics::gazebotransport::ApplyLinkWrench;
  }
  // @@protoc_insertion_point(field_mutable:mw.internal.robotics.gazebotransport.Packet.apply_link_wrench)
  return payload_.apply_link_wrench_;
}
inline ::mw::internal::robotics::gazebotransport::ApplyLinkWrench* Packet::release_apply_link_wrench() {
  // @@protoc_insertion_point(field_release:mw.internal.robotics.gazebotransport.Packet.apply_link_wrench)
  if (has_apply_link_wrench()) {
    clear_has_payload();
    ::mw::internal::robotics::gazebotransport::ApplyLinkWrench* temp = payload_.apply_link_wrench_;
    payload_.apply_link_wrench_ = NULL;
    return temp;
  } else {
    return NULL;
  }
}
inline void Packet::set_allocated_apply_link_wrench(::mw::internal::robotics::gazebotransport::ApplyLinkWrench* apply_link_wrench) {
  clear_payload();
  if (apply_link_wrench) {
    set_has_apply_link_wrench();
    payload_.apply_link_wrench_ = apply_link_wrench;
  }
  // @@protoc_insertion_point(field_set_allocated:mw.internal.robotics.gazebotransport.Packet.apply_link_wrench)
}

// optional .mw.internal.robotics.gazebotransport.MaxStepSize max_step_size = 26;
inline bool Packet::has_max_step_size() const {
  return payload_case() == kMaxStepSize;
}
inline void Packet::set_has_max_step_size() {
  _oneof_case_[0] = kMaxStepSize;
}
inline void Packet::clear_max_step_size() {
  if (has_max_step_size()) {
    delete payload_.max_step_size_;
    clear_has_payload();
  }
}
inline  const ::mw::internal::robotics::gazebotransport::MaxStepSize& Packet::max_step_size() const {
  // @@protoc_insertion_point(field_get:mw.internal.robotics.gazebotransport.Packet.max_step_size)
  return has_max_step_size()
      ? *payload_.max_step_size_
      : ::mw::internal::robotics::gazebotransport::MaxStepSize::default_instance();
}
inline ::mw::internal::robotics::gazebotransport::MaxStepSize* Packet::mutable_max_step_size() {
  if (!has_max_step_size()) {
    clear_payload();
    set_has_max_step_size();
    payload_.max_step_size_ = new ::mw::internal::robotics::gazebotransport::MaxStepSize;
  }
  // @@protoc_insertion_point(field_mutable:mw.internal.robotics.gazebotransport.Packet.max_step_size)
  return payload_.max_step_size_;
}
inline ::mw::internal::robotics::gazebotransport::MaxStepSize* Packet::release_max_step_size() {
  // @@protoc_insertion_point(field_release:mw.internal.robotics.gazebotransport.Packet.max_step_size)
  if (has_max_step_size()) {
    clear_has_payload();
    ::mw::internal::robotics::gazebotransport::MaxStepSize* temp = payload_.max_step_size_;
    payload_.max_step_size_ = NULL;
    return temp;
  } else {
    return NULL;
  }
}
inline void Packet::set_allocated_max_step_size(::mw::internal::robotics::gazebotransport::MaxStepSize* max_step_size) {
  clear_payload();
  if (max_step_size) {
    set_has_max_step_size();
    payload_.max_step_size_ = max_step_size;
  }
  // @@protoc_insertion_point(field_set_allocated:mw.internal.robotics.gazebotransport.Packet.max_step_size)
}

// optional .mw.internal.robotics.gazebotransport.CustomMessageSupport custom_message_support = 27;
inline bool Packet::has_custom_message_support() const {
  return payload_case() == kCustomMessageSupport;
}
inline void Packet::set_has_custom_message_support() {
  _oneof_case_[0] = kCustomMessageSupport;
}
inline void Packet::clear_custom_message_support() {
  if (has_custom_message_support()) {
    delete payload_.custom_message_support_;
    clear_has_payload();
  }
}
inline  const ::mw::internal::robotics::gazebotransport::CustomMessageSupport& Packet::custom_message_support() const {
  // @@protoc_insertion_point(field_get:mw.internal.robotics.gazebotransport.Packet.custom_message_support)
  return has_custom_message_support()
      ? *payload_.custom_message_support_
      : ::mw::internal::robotics::gazebotransport::CustomMessageSupport::default_instance();
}
inline ::mw::internal::robotics::gazebotransport::CustomMessageSupport* Packet::mutable_custom_message_support() {
  if (!has_custom_message_support()) {
    clear_payload();
    set_has_custom_message_support();
    payload_.custom_message_support_ = new ::mw::internal::robotics::gazebotransport::CustomMessageSupport;
  }
  // @@protoc_insertion_point(field_mutable:mw.internal.robotics.gazebotransport.Packet.custom_message_support)
  return payload_.custom_message_support_;
}
inline ::mw::internal::robotics::gazebotransport::CustomMessageSupport* Packet::release_custom_message_support() {
  // @@protoc_insertion_point(field_release:mw.internal.robotics.gazebotransport.Packet.custom_message_support)
  if (has_custom_message_support()) {
    clear_has_payload();
    ::mw::internal::robotics::gazebotransport::CustomMessageSupport* temp = payload_.custom_message_support_;
    payload_.custom_message_support_ = NULL;
    return temp;
  } else {
    return NULL;
  }
}
inline void Packet::set_allocated_custom_message_support(::mw::internal::robotics::gazebotransport::CustomMessageSupport* custom_message_support) {
  clear_payload();
  if (custom_message_support) {
    set_has_custom_message_support();
    payload_.custom_message_support_ = custom_message_support;
  }
  // @@protoc_insertion_point(field_set_allocated:mw.internal.robotics.gazebotransport.Packet.custom_message_support)
}

// optional .mw.internal.robotics.gazebotransport.InitCustomPublisher init_custom_publisher = 28;
inline bool Packet::has_init_custom_publisher() const {
  return payload_case() == kInitCustomPublisher;
}
inline void Packet::set_has_init_custom_publisher() {
  _oneof_case_[0] = kInitCustomPublisher;
}
inline void Packet::clear_init_custom_publisher() {
  if (has_init_custom_publisher()) {
    delete payload_.init_custom_publisher_;
    clear_has_payload();
  }
}
inline  const ::mw::internal::robotics::gazebotransport::InitCustomPublisher& Packet::init_custom_publisher() const {
  // @@protoc_insertion_point(field_get:mw.internal.robotics.gazebotransport.Packet.init_custom_publisher)
  return has_init_custom_publisher()
      ? *payload_.init_custom_publisher_
      : ::mw::internal::robotics::gazebotransport::InitCustomPublisher::default_instance();
}
inline ::mw::internal::robotics::gazebotransport::InitCustomPublisher* Packet::mutable_init_custom_publisher() {
  if (!has_init_custom_publisher()) {
    clear_payload();
    set_has_init_custom_publisher();
    payload_.init_custom_publisher_ = new ::mw::internal::robotics::gazebotransport::InitCustomPublisher;
  }
  // @@protoc_insertion_point(field_mutable:mw.internal.robotics.gazebotransport.Packet.init_custom_publisher)
  return payload_.init_custom_publisher_;
}
inline ::mw::internal::robotics::gazebotransport::InitCustomPublisher* Packet::release_init_custom_publisher() {
  // @@protoc_insertion_point(field_release:mw.internal.robotics.gazebotransport.Packet.init_custom_publisher)
  if (has_init_custom_publisher()) {
    clear_has_payload();
    ::mw::internal::robotics::gazebotransport::InitCustomPublisher* temp = payload_.init_custom_publisher_;
    payload_.init_custom_publisher_ = NULL;
    return temp;
  } else {
    return NULL;
  }
}
inline void Packet::set_allocated_init_custom_publisher(::mw::internal::robotics::gazebotransport::InitCustomPublisher* init_custom_publisher) {
  clear_payload();
  if (init_custom_publisher) {
    set_has_init_custom_publisher();
    payload_.init_custom_publisher_ = init_custom_publisher;
  }
  // @@protoc_insertion_point(field_set_allocated:mw.internal.robotics.gazebotransport.Packet.init_custom_publisher)
}

// optional .mw.internal.robotics.gazebotransport.InitCustomSubscriber init_custom_subscriber = 29;
inline bool Packet::has_init_custom_subscriber() const {
  return payload_case() == kInitCustomSubscriber;
}
inline void Packet::set_has_init_custom_subscriber() {
  _oneof_case_[0] = kInitCustomSubscriber;
}
inline void Packet::clear_init_custom_subscriber() {
  if (has_init_custom_subscriber()) {
    delete payload_.init_custom_subscriber_;
    clear_has_payload();
  }
}
inline  const ::mw::internal::robotics::gazebotransport::InitCustomSubscriber& Packet::init_custom_subscriber() const {
  // @@protoc_insertion_point(field_get:mw.internal.robotics.gazebotransport.Packet.init_custom_subscriber)
  return has_init_custom_subscriber()
      ? *payload_.init_custom_subscriber_
      : ::mw::internal::robotics::gazebotransport::InitCustomSubscriber::default_instance();
}
inline ::mw::internal::robotics::gazebotransport::InitCustomSubscriber* Packet::mutable_init_custom_subscriber() {
  if (!has_init_custom_subscriber()) {
    clear_payload();
    set_has_init_custom_subscriber();
    payload_.init_custom_subscriber_ = new ::mw::internal::robotics::gazebotransport::InitCustomSubscriber;
  }
  // @@protoc_insertion_point(field_mutable:mw.internal.robotics.gazebotransport.Packet.init_custom_subscriber)
  return payload_.init_custom_subscriber_;
}
inline ::mw::internal::robotics::gazebotransport::InitCustomSubscriber* Packet::release_init_custom_subscriber() {
  // @@protoc_insertion_point(field_release:mw.internal.robotics.gazebotransport.Packet.init_custom_subscriber)
  if (has_init_custom_subscriber()) {
    clear_has_payload();
    ::mw::internal::robotics::gazebotransport::InitCustomSubscriber* temp = payload_.init_custom_subscriber_;
    payload_.init_custom_subscriber_ = NULL;
    return temp;
  } else {
    return NULL;
  }
}
inline void Packet::set_allocated_init_custom_subscriber(::mw::internal::robotics::gazebotransport::InitCustomSubscriber* init_custom_subscriber) {
  clear_payload();
  if (init_custom_subscriber) {
    set_has_init_custom_subscriber();
    payload_.init_custom_subscriber_ = init_custom_subscriber;
  }
  // @@protoc_insertion_point(field_set_allocated:mw.internal.robotics.gazebotransport.Packet.init_custom_subscriber)
}

// optional .mw.internal.robotics.gazebotransport.RequestCustomMessageSupport request_custom_message_support = 30;
inline bool Packet::has_request_custom_message_support() const {
  return payload_case() == kRequestCustomMessageSupport;
}
inline void Packet::set_has_request_custom_message_support() {
  _oneof_case_[0] = kRequestCustomMessageSupport;
}
inline void Packet::clear_request_custom_message_support() {
  if (has_request_custom_message_support()) {
    delete payload_.request_custom_message_support_;
    clear_has_payload();
  }
}
inline  const ::mw::internal::robotics::gazebotransport::RequestCustomMessageSupport& Packet::request_custom_message_support() const {
  // @@protoc_insertion_point(field_get:mw.internal.robotics.gazebotransport.Packet.request_custom_message_support)
  return has_request_custom_message_support()
      ? *payload_.request_custom_message_support_
      : ::mw::internal::robotics::gazebotransport::RequestCustomMessageSupport::default_instance();
}
inline ::mw::internal::robotics::gazebotransport::RequestCustomMessageSupport* Packet::mutable_request_custom_message_support() {
  if (!has_request_custom_message_support()) {
    clear_payload();
    set_has_request_custom_message_support();
    payload_.request_custom_message_support_ = new ::mw::internal::robotics::gazebotransport::RequestCustomMessageSupport;
  }
  // @@protoc_insertion_point(field_mutable:mw.internal.robotics.gazebotransport.Packet.request_custom_message_support)
  return payload_.request_custom_message_support_;
}
inline ::mw::internal::robotics::gazebotransport::RequestCustomMessageSupport* Packet::release_request_custom_message_support() {
  // @@protoc_insertion_point(field_release:mw.internal.robotics.gazebotransport.Packet.request_custom_message_support)
  if (has_request_custom_message_support()) {
    clear_has_payload();
    ::mw::internal::robotics::gazebotransport::RequestCustomMessageSupport* temp = payload_.request_custom_message_support_;
    payload_.request_custom_message_support_ = NULL;
    return temp;
  } else {
    return NULL;
  }
}
inline void Packet::set_allocated_request_custom_message_support(::mw::internal::robotics::gazebotransport::RequestCustomMessageSupport* request_custom_message_support) {
  clear_payload();
  if (request_custom_message_support) {
    set_has_request_custom_message_support();
    payload_.request_custom_message_support_ = request_custom_message_support;
  }
  // @@protoc_insertion_point(field_set_allocated:mw.internal.robotics.gazebotransport.Packet.request_custom_message_support)
}

// optional .mw.internal.robotics.gazebotransport.SetJointPosition set_joint_position = 31;
inline bool Packet::has_set_joint_position() const {
  return payload_case() == kSetJointPosition;
}
inline void Packet::set_has_set_joint_position() {
  _oneof_case_[0] = kSetJointPosition;
}
inline void Packet::clear_set_joint_position() {
  if (has_set_joint_position()) {
    delete payload_.set_joint_position_;
    clear_has_payload();
  }
}
inline  const ::mw::internal::robotics::gazebotransport::SetJointPosition& Packet::set_joint_position() const {
  // @@protoc_insertion_point(field_get:mw.internal.robotics.gazebotransport.Packet.set_joint_position)
  return has_set_joint_position()
      ? *payload_.set_joint_position_
      : ::mw::internal::robotics::gazebotransport::SetJointPosition::default_instance();
}
inline ::mw::internal::robotics::gazebotransport::SetJointPosition* Packet::mutable_set_joint_position() {
  if (!has_set_joint_position()) {
    clear_payload();
    set_has_set_joint_position();
    payload_.set_joint_position_ = new ::mw::internal::robotics::gazebotransport::SetJointPosition;
  }
  // @@protoc_insertion_point(field_mutable:mw.internal.robotics.gazebotransport.Packet.set_joint_position)
  return payload_.set_joint_position_;
}
inline ::mw::internal::robotics::gazebotransport::SetJointPosition* Packet::release_set_joint_position() {
  // @@protoc_insertion_point(field_release:mw.internal.robotics.gazebotransport.Packet.set_joint_position)
  if (has_set_joint_position()) {
    clear_has_payload();
    ::mw::internal::robotics::gazebotransport::SetJointPosition* temp = payload_.set_joint_position_;
    payload_.set_joint_position_ = NULL;
    return temp;
  } else {
    return NULL;
  }
}
inline void Packet::set_allocated_set_joint_position(::mw::internal::robotics::gazebotransport::SetJointPosition* set_joint_position) {
  clear_payload();
  if (set_joint_position) {
    set_has_set_joint_position();
    payload_.set_joint_position_ = set_joint_position;
  }
  // @@protoc_insertion_point(field_set_allocated:mw.internal.robotics.gazebotransport.Packet.set_joint_position)
}

// optional .mw.internal.robotics.gazebotransport.SetJointVelocity set_joint_velocity = 32;
inline bool Packet::has_set_joint_velocity() const {
  return payload_case() == kSetJointVelocity;
}
inline void Packet::set_has_set_joint_velocity() {
  _oneof_case_[0] = kSetJointVelocity;
}
inline void Packet::clear_set_joint_velocity() {
  if (has_set_joint_velocity()) {
    delete payload_.set_joint_velocity_;
    clear_has_payload();
  }
}
inline  const ::mw::internal::robotics::gazebotransport::SetJointVelocity& Packet::set_joint_velocity() const {
  // @@protoc_insertion_point(field_get:mw.internal.robotics.gazebotransport.Packet.set_joint_velocity)
  return has_set_joint_velocity()
      ? *payload_.set_joint_velocity_
      : ::mw::internal::robotics::gazebotransport::SetJointVelocity::default_instance();
}
inline ::mw::internal::robotics::gazebotransport::SetJointVelocity* Packet::mutable_set_joint_velocity() {
  if (!has_set_joint_velocity()) {
    clear_payload();
    set_has_set_joint_velocity();
    payload_.set_joint_velocity_ = new ::mw::internal::robotics::gazebotransport::SetJointVelocity;
  }
  // @@protoc_insertion_point(field_mutable:mw.internal.robotics.gazebotransport.Packet.set_joint_velocity)
  return payload_.set_joint_velocity_;
}
inline ::mw::internal::robotics::gazebotransport::SetJointVelocity* Packet::release_set_joint_velocity() {
  // @@protoc_insertion_point(field_release:mw.internal.robotics.gazebotransport.Packet.set_joint_velocity)
  if (has_set_joint_velocity()) {
    clear_has_payload();
    ::mw::internal::robotics::gazebotransport::SetJointVelocity* temp = payload_.set_joint_velocity_;
    payload_.set_joint_velocity_ = NULL;
    return temp;
  } else {
    return NULL;
  }
}
inline void Packet::set_allocated_set_joint_velocity(::mw::internal::robotics::gazebotransport::SetJointVelocity* set_joint_velocity) {
  clear_payload();
  if (set_joint_velocity) {
    set_has_set_joint_velocity();
    payload_.set_joint_velocity_ = set_joint_velocity;
  }
  // @@protoc_insertion_point(field_set_allocated:mw.internal.robotics.gazebotransport.Packet.set_joint_velocity)
}

// optional .mw.internal.robotics.gazebotransport.GetJointState get_joint_state = 33;
inline bool Packet::has_get_joint_state() const {
  return payload_case() == kGetJointState;
}
inline void Packet::set_has_get_joint_state() {
  _oneof_case_[0] = kGetJointState;
}
inline void Packet::clear_get_joint_state() {
  if (has_get_joint_state()) {
    delete payload_.get_joint_state_;
    clear_has_payload();
  }
}
inline  const ::mw::internal::robotics::gazebotransport::GetJointState& Packet::get_joint_state() const {
  // @@protoc_insertion_point(field_get:mw.internal.robotics.gazebotransport.Packet.get_joint_state)
  return has_get_joint_state()
      ? *payload_.get_joint_state_
      : ::mw::internal::robotics::gazebotransport::GetJointState::default_instance();
}
inline ::mw::internal::robotics::gazebotransport::GetJointState* Packet::mutable_get_joint_state() {
  if (!has_get_joint_state()) {
    clear_payload();
    set_has_get_joint_state();
    payload_.get_joint_state_ = new ::mw::internal::robotics::gazebotransport::GetJointState;
  }
  // @@protoc_insertion_point(field_mutable:mw.internal.robotics.gazebotransport.Packet.get_joint_state)
  return payload_.get_joint_state_;
}
inline ::mw::internal::robotics::gazebotransport::GetJointState* Packet::release_get_joint_state() {
  // @@protoc_insertion_point(field_release:mw.internal.robotics.gazebotransport.Packet.get_joint_state)
  if (has_get_joint_state()) {
    clear_has_payload();
    ::mw::internal::robotics::gazebotransport::GetJointState* temp = payload_.get_joint_state_;
    payload_.get_joint_state_ = NULL;
    return temp;
  } else {
    return NULL;
  }
}
inline void Packet::set_allocated_get_joint_state(::mw::internal::robotics::gazebotransport::GetJointState* get_joint_state) {
  clear_payload();
  if (get_joint_state) {
    set_has_get_joint_state();
    payload_.get_joint_state_ = get_joint_state;
  }
  // @@protoc_insertion_point(field_set_allocated:mw.internal.robotics.gazebotransport.Packet.get_joint_state)
}

// optional .mw.internal.robotics.gazebotransport.JointState joint_state = 34;
inline bool Packet::has_joint_state() const {
  return payload_case() == kJointState;
}
inline void Packet::set_has_joint_state() {
  _oneof_case_[0] = kJointState;
}
inline void Packet::clear_joint_state() {
  if (has_joint_state()) {
    delete payload_.joint_state_;
    clear_has_payload();
  }
}
inline  const ::mw::internal::robotics::gazebotransport::JointState& Packet::joint_state() const {
  // @@protoc_insertion_point(field_get:mw.internal.robotics.gazebotransport.Packet.joint_state)
  return has_joint_state()
      ? *payload_.joint_state_
      : ::mw::internal::robotics::gazebotransport::JointState::default_instance();
}
inline ::mw::internal::robotics::gazebotransport::JointState* Packet::mutable_joint_state() {
  if (!has_joint_state()) {
    clear_payload();
    set_has_joint_state();
    payload_.joint_state_ = new ::mw::internal::robotics::gazebotransport::JointState;
  }
  // @@protoc_insertion_point(field_mutable:mw.internal.robotics.gazebotransport.Packet.joint_state)
  return payload_.joint_state_;
}
inline ::mw::internal::robotics::gazebotransport::JointState* Packet::release_joint_state() {
  // @@protoc_insertion_point(field_release:mw.internal.robotics.gazebotransport.Packet.joint_state)
  if (has_joint_state()) {
    clear_has_payload();
    ::mw::internal::robotics::gazebotransport::JointState* temp = payload_.joint_state_;
    payload_.joint_state_ = NULL;
    return temp;
  } else {
    return NULL;
  }
}
inline void Packet::set_allocated_joint_state(::mw::internal::robotics::gazebotransport::JointState* joint_state) {
  clear_payload();
  if (joint_state) {
    set_has_joint_state();
    payload_.joint_state_ = joint_state;
  }
  // @@protoc_insertion_point(field_set_allocated:mw.internal.robotics.gazebotransport.Packet.joint_state)
}

// optional .mw.internal.robotics.gazebotransport.SetLinkWorldPose set_link_world_pose = 35;
inline bool Packet::has_set_link_world_pose() const {
  return payload_case() == kSetLinkWorldPose;
}
inline void Packet::set_has_set_link_world_pose() {
  _oneof_case_[0] = kSetLinkWorldPose;
}
inline void Packet::clear_set_link_world_pose() {
  if (has_set_link_world_pose()) {
    delete payload_.set_link_world_pose_;
    clear_has_payload();
  }
}
inline  const ::mw::internal::robotics::gazebotransport::SetLinkWorldPose& Packet::set_link_world_pose() const {
  // @@protoc_insertion_point(field_get:mw.internal.robotics.gazebotransport.Packet.set_link_world_pose)
  return has_set_link_world_pose()
      ? *payload_.set_link_world_pose_
      : ::mw::internal::robotics::gazebotransport::SetLinkWorldPose::default_instance();
}
inline ::mw::internal::robotics::gazebotransport::SetLinkWorldPose* Packet::mutable_set_link_world_pose() {
  if (!has_set_link_world_pose()) {
    clear_payload();
    set_has_set_link_world_pose();
    payload_.set_link_world_pose_ = new ::mw::internal::robotics::gazebotransport::SetLinkWorldPose;
  }
  // @@protoc_insertion_point(field_mutable:mw.internal.robotics.gazebotransport.Packet.set_link_world_pose)
  return payload_.set_link_world_pose_;
}
inline ::mw::internal::robotics::gazebotransport::SetLinkWorldPose* Packet::release_set_link_world_pose() {
  // @@protoc_insertion_point(field_release:mw.internal.robotics.gazebotransport.Packet.set_link_world_pose)
  if (has_set_link_world_pose()) {
    clear_has_payload();
    ::mw::internal::robotics::gazebotransport::SetLinkWorldPose* temp = payload_.set_link_world_pose_;
    payload_.set_link_world_pose_ = NULL;
    return temp;
  } else {
    return NULL;
  }
}
inline void Packet::set_allocated_set_link_world_pose(::mw::internal::robotics::gazebotransport::SetLinkWorldPose* set_link_world_pose) {
  clear_payload();
  if (set_link_world_pose) {
    set_has_set_link_world_pose();
    payload_.set_link_world_pose_ = set_link_world_pose;
  }
  // @@protoc_insertion_point(field_set_allocated:mw.internal.robotics.gazebotransport.Packet.set_link_world_pose)
}

// optional .mw.internal.robotics.gazebotransport.SetLinkLinearVelocity set_link_linear_velocity = 36;
inline bool Packet::has_set_link_linear_velocity() const {
  return payload_case() == kSetLinkLinearVelocity;
}
inline void Packet::set_has_set_link_linear_velocity() {
  _oneof_case_[0] = kSetLinkLinearVelocity;
}
inline void Packet::clear_set_link_linear_velocity() {
  if (has_set_link_linear_velocity()) {
    delete payload_.set_link_linear_velocity_;
    clear_has_payload();
  }
}
inline  const ::mw::internal::robotics::gazebotransport::SetLinkLinearVelocity& Packet::set_link_linear_velocity() const {
  // @@protoc_insertion_point(field_get:mw.internal.robotics.gazebotransport.Packet.set_link_linear_velocity)
  return has_set_link_linear_velocity()
      ? *payload_.set_link_linear_velocity_
      : ::mw::internal::robotics::gazebotransport::SetLinkLinearVelocity::default_instance();
}
inline ::mw::internal::robotics::gazebotransport::SetLinkLinearVelocity* Packet::mutable_set_link_linear_velocity() {
  if (!has_set_link_linear_velocity()) {
    clear_payload();
    set_has_set_link_linear_velocity();
    payload_.set_link_linear_velocity_ = new ::mw::internal::robotics::gazebotransport::SetLinkLinearVelocity;
  }
  // @@protoc_insertion_point(field_mutable:mw.internal.robotics.gazebotransport.Packet.set_link_linear_velocity)
  return payload_.set_link_linear_velocity_;
}
inline ::mw::internal::robotics::gazebotransport::SetLinkLinearVelocity* Packet::release_set_link_linear_velocity() {
  // @@protoc_insertion_point(field_release:mw.internal.robotics.gazebotransport.Packet.set_link_linear_velocity)
  if (has_set_link_linear_velocity()) {
    clear_has_payload();
    ::mw::internal::robotics::gazebotransport::SetLinkLinearVelocity* temp = payload_.set_link_linear_velocity_;
    payload_.set_link_linear_velocity_ = NULL;
    return temp;
  } else {
    return NULL;
  }
}
inline void Packet::set_allocated_set_link_linear_velocity(::mw::internal::robotics::gazebotransport::SetLinkLinearVelocity* set_link_linear_velocity) {
  clear_payload();
  if (set_link_linear_velocity) {
    set_has_set_link_linear_velocity();
    payload_.set_link_linear_velocity_ = set_link_linear_velocity;
  }
  // @@protoc_insertion_point(field_set_allocated:mw.internal.robotics.gazebotransport.Packet.set_link_linear_velocity)
}

// optional .mw.internal.robotics.gazebotransport.SetLinkAngularVelocity set_link_angular_velocity = 37;
inline bool Packet::has_set_link_angular_velocity() const {
  return payload_case() == kSetLinkAngularVelocity;
}
inline void Packet::set_has_set_link_angular_velocity() {
  _oneof_case_[0] = kSetLinkAngularVelocity;
}
inline void Packet::clear_set_link_angular_velocity() {
  if (has_set_link_angular_velocity()) {
    delete payload_.set_link_angular_velocity_;
    clear_has_payload();
  }
}
inline  const ::mw::internal::robotics::gazebotransport::SetLinkAngularVelocity& Packet::set_link_angular_velocity() const {
  // @@protoc_insertion_point(field_get:mw.internal.robotics.gazebotransport.Packet.set_link_angular_velocity)
  return has_set_link_angular_velocity()
      ? *payload_.set_link_angular_velocity_
      : ::mw::internal::robotics::gazebotransport::SetLinkAngularVelocity::default_instance();
}
inline ::mw::internal::robotics::gazebotransport::SetLinkAngularVelocity* Packet::mutable_set_link_angular_velocity() {
  if (!has_set_link_angular_velocity()) {
    clear_payload();
    set_has_set_link_angular_velocity();
    payload_.set_link_angular_velocity_ = new ::mw::internal::robotics::gazebotransport::SetLinkAngularVelocity;
  }
  // @@protoc_insertion_point(field_mutable:mw.internal.robotics.gazebotransport.Packet.set_link_angular_velocity)
  return payload_.set_link_angular_velocity_;
}
inline ::mw::internal::robotics::gazebotransport::SetLinkAngularVelocity* Packet::release_set_link_angular_velocity() {
  // @@protoc_insertion_point(field_release:mw.internal.robotics.gazebotransport.Packet.set_link_angular_velocity)
  if (has_set_link_angular_velocity()) {
    clear_has_payload();
    ::mw::internal::robotics::gazebotransport::SetLinkAngularVelocity* temp = payload_.set_link_angular_velocity_;
    payload_.set_link_angular_velocity_ = NULL;
    return temp;
  } else {
    return NULL;
  }
}
inline void Packet::set_allocated_set_link_angular_velocity(::mw::internal::robotics::gazebotransport::SetLinkAngularVelocity* set_link_angular_velocity) {
  clear_payload();
  if (set_link_angular_velocity) {
    set_has_set_link_angular_velocity();
    payload_.set_link_angular_velocity_ = set_link_angular_velocity;
  }
  // @@protoc_insertion_point(field_set_allocated:mw.internal.robotics.gazebotransport.Packet.set_link_angular_velocity)
}

// optional .mw.internal.robotics.gazebotransport.GetLinkState get_link_state = 38;
inline bool Packet::has_get_link_state() const {
  return payload_case() == kGetLinkState;
}
inline void Packet::set_has_get_link_state() {
  _oneof_case_[0] = kGetLinkState;
}
inline void Packet::clear_get_link_state() {
  if (has_get_link_state()) {
    delete payload_.get_link_state_;
    clear_has_payload();
  }
}
inline  const ::mw::internal::robotics::gazebotransport::GetLinkState& Packet::get_link_state() const {
  // @@protoc_insertion_point(field_get:mw.internal.robotics.gazebotransport.Packet.get_link_state)
  return has_get_link_state()
      ? *payload_.get_link_state_
      : ::mw::internal::robotics::gazebotransport::GetLinkState::default_instance();
}
inline ::mw::internal::robotics::gazebotransport::GetLinkState* Packet::mutable_get_link_state() {
  if (!has_get_link_state()) {
    clear_payload();
    set_has_get_link_state();
    payload_.get_link_state_ = new ::mw::internal::robotics::gazebotransport::GetLinkState;
  }
  // @@protoc_insertion_point(field_mutable:mw.internal.robotics.gazebotransport.Packet.get_link_state)
  return payload_.get_link_state_;
}
inline ::mw::internal::robotics::gazebotransport::GetLinkState* Packet::release_get_link_state() {
  // @@protoc_insertion_point(field_release:mw.internal.robotics.gazebotransport.Packet.get_link_state)
  if (has_get_link_state()) {
    clear_has_payload();
    ::mw::internal::robotics::gazebotransport::GetLinkState* temp = payload_.get_link_state_;
    payload_.get_link_state_ = NULL;
    return temp;
  } else {
    return NULL;
  }
}
inline void Packet::set_allocated_get_link_state(::mw::internal::robotics::gazebotransport::GetLinkState* get_link_state) {
  clear_payload();
  if (get_link_state) {
    set_has_get_link_state();
    payload_.get_link_state_ = get_link_state;
  }
  // @@protoc_insertion_point(field_set_allocated:mw.internal.robotics.gazebotransport.Packet.get_link_state)
}

// optional .mw.internal.robotics.gazebotransport.LinkState link_state = 39;
inline bool Packet::has_link_state() const {
  return payload_case() == kLinkState;
}
inline void Packet::set_has_link_state() {
  _oneof_case_[0] = kLinkState;
}
inline void Packet::clear_link_state() {
  if (has_link_state()) {
    delete payload_.link_state_;
    clear_has_payload();
  }
}
inline  const ::mw::internal::robotics::gazebotransport::LinkState& Packet::link_state() const {
  // @@protoc_insertion_point(field_get:mw.internal.robotics.gazebotransport.Packet.link_state)
  return has_link_state()
      ? *payload_.link_state_
      : ::mw::internal::robotics::gazebotransport::LinkState::default_instance();
}
inline ::mw::internal::robotics::gazebotransport::LinkState* Packet::mutable_link_state() {
  if (!has_link_state()) {
    clear_payload();
    set_has_link_state();
    payload_.link_state_ = new ::mw::internal::robotics::gazebotransport::LinkState;
  }
  // @@protoc_insertion_point(field_mutable:mw.internal.robotics.gazebotransport.Packet.link_state)
  return payload_.link_state_;
}
inline ::mw::internal::robotics::gazebotransport::LinkState* Packet::release_link_state() {
  // @@protoc_insertion_point(field_release:mw.internal.robotics.gazebotransport.Packet.link_state)
  if (has_link_state()) {
    clear_has_payload();
    ::mw::internal::robotics::gazebotransport::LinkState* temp = payload_.link_state_;
    payload_.link_state_ = NULL;
    return temp;
  } else {
    return NULL;
  }
}
inline void Packet::set_allocated_link_state(::mw::internal::robotics::gazebotransport::LinkState* link_state) {
  clear_payload();
  if (link_state) {
    set_has_link_state();
    payload_.link_state_ = link_state;
  }
  // @@protoc_insertion_point(field_set_allocated:mw.internal.robotics.gazebotransport.Packet.link_state)
}

// optional .mw.internal.robotics.gazebotransport.Gazebomodel gazebo_model = 40;
inline bool Packet::has_gazebo_model() const {
  return payload_case() == kGazeboModel;
}
inline void Packet::set_has_gazebo_model() {
  _oneof_case_[0] = kGazeboModel;
}
inline void Packet::clear_gazebo_model() {
  if (has_gazebo_model()) {
    delete payload_.gazebo_model_;
    clear_has_payload();
  }
}
inline  const ::mw::internal::robotics::gazebotransport::Gazebomodel& Packet::gazebo_model() const {
  // @@protoc_insertion_point(field_get:mw.internal.robotics.gazebotransport.Packet.gazebo_model)
  return has_gazebo_model()
      ? *payload_.gazebo_model_
      : ::mw::internal::robotics::gazebotransport::Gazebomodel::default_instance();
}
inline ::mw::internal::robotics::gazebotransport::Gazebomodel* Packet::mutable_gazebo_model() {
  if (!has_gazebo_model()) {
    clear_payload();
    set_has_gazebo_model();
    payload_.gazebo_model_ = new ::mw::internal::robotics::gazebotransport::Gazebomodel;
  }
  // @@protoc_insertion_point(field_mutable:mw.internal.robotics.gazebotransport.Packet.gazebo_model)
  return payload_.gazebo_model_;
}
inline ::mw::internal::robotics::gazebotransport::Gazebomodel* Packet::release_gazebo_model() {
  // @@protoc_insertion_point(field_release:mw.internal.robotics.gazebotransport.Packet.gazebo_model)
  if (has_gazebo_model()) {
    clear_has_payload();
    ::mw::internal::robotics::gazebotransport::Gazebomodel* temp = payload_.gazebo_model_;
    payload_.gazebo_model_ = NULL;
    return temp;
  } else {
    return NULL;
  }
}
inline void Packet::set_allocated_gazebo_model(::mw::internal::robotics::gazebotransport::Gazebomodel* gazebo_model) {
  clear_payload();
  if (gazebo_model) {
    set_has_gazebo_model();
    payload_.gazebo_model_ = gazebo_model;
  }
  // @@protoc_insertion_point(field_set_allocated:mw.internal.robotics.gazebotransport.Packet.gazebo_model)
}

// optional .mw.internal.robotics.gazebotransport.GetGazeboModelParam get_gazebo_model_param = 41;
inline bool Packet::has_get_gazebo_model_param() const {
  return payload_case() == kGetGazeboModelParam;
}
inline void Packet::set_has_get_gazebo_model_param() {
  _oneof_case_[0] = kGetGazeboModelParam;
}
inline void Packet::clear_get_gazebo_model_param() {
  if (has_get_gazebo_model_param()) {
    delete payload_.get_gazebo_model_param_;
    clear_has_payload();
  }
}
inline  const ::mw::internal::robotics::gazebotransport::GetGazeboModelParam& Packet::get_gazebo_model_param() const {
  // @@protoc_insertion_point(field_get:mw.internal.robotics.gazebotransport.Packet.get_gazebo_model_param)
  return has_get_gazebo_model_param()
      ? *payload_.get_gazebo_model_param_
      : ::mw::internal::robotics::gazebotransport::GetGazeboModelParam::default_instance();
}
inline ::mw::internal::robotics::gazebotransport::GetGazeboModelParam* Packet::mutable_get_gazebo_model_param() {
  if (!has_get_gazebo_model_param()) {
    clear_payload();
    set_has_get_gazebo_model_param();
    payload_.get_gazebo_model_param_ = new ::mw::internal::robotics::gazebotransport::GetGazeboModelParam;
  }
  // @@protoc_insertion_point(field_mutable:mw.internal.robotics.gazebotransport.Packet.get_gazebo_model_param)
  return payload_.get_gazebo_model_param_;
}
inline ::mw::internal::robotics::gazebotransport::GetGazeboModelParam* Packet::release_get_gazebo_model_param() {
  // @@protoc_insertion_point(field_release:mw.internal.robotics.gazebotransport.Packet.get_gazebo_model_param)
  if (has_get_gazebo_model_param()) {
    clear_has_payload();
    ::mw::internal::robotics::gazebotransport::GetGazeboModelParam* temp = payload_.get_gazebo_model_param_;
    payload_.get_gazebo_model_param_ = NULL;
    return temp;
  } else {
    return NULL;
  }
}
inline void Packet::set_allocated_get_gazebo_model_param(::mw::internal::robotics::gazebotransport::GetGazeboModelParam* get_gazebo_model_param) {
  clear_payload();
  if (get_gazebo_model_param) {
    set_has_get_gazebo_model_param();
    payload_.get_gazebo_model_param_ = get_gazebo_model_param;
  }
  // @@protoc_insertion_point(field_set_allocated:mw.internal.robotics.gazebotransport.Packet.get_gazebo_model_param)
}

// optional .mw.internal.robotics.gazebotransport.GazeboModelSDF gazebo_model_sdf = 42;
inline bool Packet::has_gazebo_model_sdf() const {
  return payload_case() == kGazeboModelSdf;
}
inline void Packet::set_has_gazebo_model_sdf() {
  _oneof_case_[0] = kGazeboModelSdf;
}
inline void Packet::clear_gazebo_model_sdf() {
  if (has_gazebo_model_sdf()) {
    delete payload_.gazebo_model_sdf_;
    clear_has_payload();
  }
}
inline  const ::mw::internal::robotics::gazebotransport::GazeboModelSDF& Packet::gazebo_model_sdf() const {
  // @@protoc_insertion_point(field_get:mw.internal.robotics.gazebotransport.Packet.gazebo_model_sdf)
  return has_gazebo_model_sdf()
      ? *payload_.gazebo_model_sdf_
      : ::mw::internal::robotics::gazebotransport::GazeboModelSDF::default_instance();
}
inline ::mw::internal::robotics::gazebotransport::GazeboModelSDF* Packet::mutable_gazebo_model_sdf() {
  if (!has_gazebo_model_sdf()) {
    clear_payload();
    set_has_gazebo_model_sdf();
    payload_.gazebo_model_sdf_ = new ::mw::internal::robotics::gazebotransport::GazeboModelSDF;
  }
  // @@protoc_insertion_point(field_mutable:mw.internal.robotics.gazebotransport.Packet.gazebo_model_sdf)
  return payload_.gazebo_model_sdf_;
}
inline ::mw::internal::robotics::gazebotransport::GazeboModelSDF* Packet::release_gazebo_model_sdf() {
  // @@protoc_insertion_point(field_release:mw.internal.robotics.gazebotransport.Packet.gazebo_model_sdf)
  if (has_gazebo_model_sdf()) {
    clear_has_payload();
    ::mw::internal::robotics::gazebotransport::GazeboModelSDF* temp = payload_.gazebo_model_sdf_;
    payload_.gazebo_model_sdf_ = NULL;
    return temp;
  } else {
    return NULL;
  }
}
inline void Packet::set_allocated_gazebo_model_sdf(::mw::internal::robotics::gazebotransport::GazeboModelSDF* gazebo_model_sdf) {
  clear_payload();
  if (gazebo_model_sdf) {
    set_has_gazebo_model_sdf();
    payload_.gazebo_model_sdf_ = gazebo_model_sdf;
  }
  // @@protoc_insertion_point(field_set_allocated:mw.internal.robotics.gazebotransport.Packet.gazebo_model_sdf)
}

// optional .mw.internal.robotics.gazebotransport.GetGazeboModelSDF get_gazebo_model_sdf = 43;
inline bool Packet::has_get_gazebo_model_sdf() const {
  return payload_case() == kGetGazeboModelSdf;
}
inline void Packet::set_has_get_gazebo_model_sdf() {
  _oneof_case_[0] = kGetGazeboModelSdf;
}
inline void Packet::clear_get_gazebo_model_sdf() {
  if (has_get_gazebo_model_sdf()) {
    delete payload_.get_gazebo_model_sdf_;
    clear_has_payload();
  }
}
inline  const ::mw::internal::robotics::gazebotransport::GetGazeboModelSDF& Packet::get_gazebo_model_sdf() const {
  // @@protoc_insertion_point(field_get:mw.internal.robotics.gazebotransport.Packet.get_gazebo_model_sdf)
  return has_get_gazebo_model_sdf()
      ? *payload_.get_gazebo_model_sdf_
      : ::mw::internal::robotics::gazebotransport::GetGazeboModelSDF::default_instance();
}
inline ::mw::internal::robotics::gazebotransport::GetGazeboModelSDF* Packet::mutable_get_gazebo_model_sdf() {
  if (!has_get_gazebo_model_sdf()) {
    clear_payload();
    set_has_get_gazebo_model_sdf();
    payload_.get_gazebo_model_sdf_ = new ::mw::internal::robotics::gazebotransport::GetGazeboModelSDF;
  }
  // @@protoc_insertion_point(field_mutable:mw.internal.robotics.gazebotransport.Packet.get_gazebo_model_sdf)
  return payload_.get_gazebo_model_sdf_;
}
inline ::mw::internal::robotics::gazebotransport::GetGazeboModelSDF* Packet::release_get_gazebo_model_sdf() {
  // @@protoc_insertion_point(field_release:mw.internal.robotics.gazebotransport.Packet.get_gazebo_model_sdf)
  if (has_get_gazebo_model_sdf()) {
    clear_has_payload();
    ::mw::internal::robotics::gazebotransport::GetGazeboModelSDF* temp = payload_.get_gazebo_model_sdf_;
    payload_.get_gazebo_model_sdf_ = NULL;
    return temp;
  } else {
    return NULL;
  }
}
inline void Packet::set_allocated_get_gazebo_model_sdf(::mw::internal::robotics::gazebotransport::GetGazeboModelSDF* get_gazebo_model_sdf) {
  clear_payload();
  if (get_gazebo_model_sdf) {
    set_has_get_gazebo_model_sdf();
    payload_.get_gazebo_model_sdf_ = get_gazebo_model_sdf;
  }
  // @@protoc_insertion_point(field_set_allocated:mw.internal.robotics.gazebotransport.Packet.get_gazebo_model_sdf)
}

// optional string error_message = 44;
inline bool Packet::has_error_message() const {
  return (_has_bits_[1] & 0x00000800u) != 0;
}
inline void Packet::set_has_error_message() {
  _has_bits_[1] |= 0x00000800u;
}
inline void Packet::clear_has_error_message() {
  _has_bits_[1] &= ~0x00000800u;
}
inline void Packet::clear_error_message() {
  error_message_.ClearToEmptyNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
  clear_has_error_message();
}
inline const ::std::string& Packet::error_message() const {
  // @@protoc_insertion_point(field_get:mw.internal.robotics.gazebotransport.Packet.error_message)
  return error_message_.GetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline void Packet::set_error_message(const ::std::string& value) {
  set_has_error_message();
  error_message_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), value);
  // @@protoc_insertion_point(field_set:mw.internal.robotics.gazebotransport.Packet.error_message)
}
inline void Packet::set_error_message(const char* value) {
  set_has_error_message();
  error_message_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::string(value));
  // @@protoc_insertion_point(field_set_char:mw.internal.robotics.gazebotransport.Packet.error_message)
}
inline void Packet::set_error_message(const char* value, size_t size) {
  set_has_error_message();
  error_message_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(),
      ::std::string(reinterpret_cast<const char*>(value), size));
  // @@protoc_insertion_point(field_set_pointer:mw.internal.robotics.gazebotransport.Packet.error_message)
}
inline ::std::string* Packet::mutable_error_message() {
  set_has_error_message();
  // @@protoc_insertion_point(field_mutable:mw.internal.robotics.gazebotransport.Packet.error_message)
  return error_message_.MutableNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline ::std::string* Packet::release_error_message() {
  // @@protoc_insertion_point(field_release:mw.internal.robotics.gazebotransport.Packet.error_message)
  clear_has_error_message();
  return error_message_.ReleaseNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline void Packet::set_allocated_error_message(::std::string* error_message) {
  if (error_message != NULL) {
    set_has_error_message();
  } else {
    clear_has_error_message();
  }
  error_message_.SetAllocatedNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), error_message);
  // @@protoc_insertion_point(field_set_allocated:mw.internal.robotics.gazebotransport.Packet.error_message)
}

inline bool Packet::has_payload() const {
  return payload_case() != PAYLOAD_NOT_SET;
}
inline void Packet::clear_has_payload() {
  _oneof_case_[0] = PAYLOAD_NOT_SET;
}
inline Packet::PayloadCase Packet::payload_case() const {
  return Packet::PayloadCase(_oneof_case_[0]);
}
// -------------------------------------------------------------------

// StepSimulation

// required uint32 num_steps = 1;
inline bool StepSimulation::has_num_steps() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void StepSimulation::set_has_num_steps() {
  _has_bits_[0] |= 0x00000001u;
}
inline void StepSimulation::clear_has_num_steps() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void StepSimulation::clear_num_steps() {
  num_steps_ = 0u;
  clear_has_num_steps();
}
inline ::google::protobuf::uint32 StepSimulation::num_steps() const {
  // @@protoc_insertion_point(field_get:mw.internal.robotics.gazebotransport.StepSimulation.num_steps)
  return num_steps_;
}
inline void StepSimulation::set_num_steps(::google::protobuf::uint32 value) {
  set_has_num_steps();
  num_steps_ = value;
  // @@protoc_insertion_point(field_set:mw.internal.robotics.gazebotransport.StepSimulation.num_steps)
}

// -------------------------------------------------------------------

// ResetSimulation

// required .mw.internal.robotics.gazebotransport.ResetSimulation.ResetBehavior behavior = 1;
inline bool ResetSimulation::has_behavior() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void ResetSimulation::set_has_behavior() {
  _has_bits_[0] |= 0x00000001u;
}
inline void ResetSimulation::clear_has_behavior() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void ResetSimulation::clear_behavior() {
  behavior_ = 0;
  clear_has_behavior();
}
inline ::mw::internal::robotics::gazebotransport::ResetSimulation_ResetBehavior ResetSimulation::behavior() const {
  // @@protoc_insertion_point(field_get:mw.internal.robotics.gazebotransport.ResetSimulation.behavior)
  return static_cast< ::mw::internal::robotics::gazebotransport::ResetSimulation_ResetBehavior >(behavior_);
}
inline void ResetSimulation::set_behavior(::mw::internal::robotics::gazebotransport::ResetSimulation_ResetBehavior value) {
  assert(::mw::internal::robotics::gazebotransport::ResetSimulation_ResetBehavior_IsValid(value));
  set_has_behavior();
  behavior_ = value;
  // @@protoc_insertion_point(field_set:mw.internal.robotics.gazebotransport.ResetSimulation.behavior)
}

// -------------------------------------------------------------------

// Image

// required uint32 width = 1;
inline bool Image::has_width() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void Image::set_has_width() {
  _has_bits_[0] |= 0x00000001u;
}
inline void Image::clear_has_width() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void Image::clear_width() {
  width_ = 0u;
  clear_has_width();
}
inline ::google::protobuf::uint32 Image::width() const {
  // @@protoc_insertion_point(field_get:mw.internal.robotics.gazebotransport.Image.width)
  return width_;
}
inline void Image::set_width(::google::protobuf::uint32 value) {
  set_has_width();
  width_ = value;
  // @@protoc_insertion_point(field_set:mw.internal.robotics.gazebotransport.Image.width)
}

// required uint32 height = 2;
inline bool Image::has_height() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void Image::set_has_height() {
  _has_bits_[0] |= 0x00000002u;
}
inline void Image::clear_has_height() {
  _has_bits_[0] &= ~0x00000002u;
}
inline void Image::clear_height() {
  height_ = 0u;
  clear_has_height();
}
inline ::google::protobuf::uint32 Image::height() const {
  // @@protoc_insertion_point(field_get:mw.internal.robotics.gazebotransport.Image.height)
  return height_;
}
inline void Image::set_height(::google::protobuf::uint32 value) {
  set_has_height();
  height_ = value;
  // @@protoc_insertion_point(field_set:mw.internal.robotics.gazebotransport.Image.height)
}

// required bytes data = 3;
inline bool Image::has_data() const {
  return (_has_bits_[0] & 0x00000004u) != 0;
}
inline void Image::set_has_data() {
  _has_bits_[0] |= 0x00000004u;
}
inline void Image::clear_has_data() {
  _has_bits_[0] &= ~0x00000004u;
}
inline void Image::clear_data() {
  data_.ClearToEmptyNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
  clear_has_data();
}
inline const ::std::string& Image::data() const {
  // @@protoc_insertion_point(field_get:mw.internal.robotics.gazebotransport.Image.data)
  return data_.GetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline void Image::set_data(const ::std::string& value) {
  set_has_data();
  data_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), value);
  // @@protoc_insertion_point(field_set:mw.internal.robotics.gazebotransport.Image.data)
}
inline void Image::set_data(const char* value) {
  set_has_data();
  data_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::string(value));
  // @@protoc_insertion_point(field_set_char:mw.internal.robotics.gazebotransport.Image.data)
}
inline void Image::set_data(const void* value, size_t size) {
  set_has_data();
  data_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(),
      ::std::string(reinterpret_cast<const char*>(value), size));
  // @@protoc_insertion_point(field_set_pointer:mw.internal.robotics.gazebotransport.Image.data)
}
inline ::std::string* Image::mutable_data() {
  set_has_data();
  // @@protoc_insertion_point(field_mutable:mw.internal.robotics.gazebotransport.Image.data)
  return data_.MutableNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline ::std::string* Image::release_data() {
  // @@protoc_insertion_point(field_release:mw.internal.robotics.gazebotransport.Image.data)
  clear_has_data();
  return data_.ReleaseNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline void Image::set_allocated_data(::std::string* data) {
  if (data != NULL) {
    set_has_data();
  } else {
    clear_has_data();
  }
  data_.SetAllocatedNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), data);
  // @@protoc_insertion_point(field_set_allocated:mw.internal.robotics.gazebotransport.Image.data)
}

// required string data_type = 4;
inline bool Image::has_data_type() const {
  return (_has_bits_[0] & 0x00000008u) != 0;
}
inline void Image::set_has_data_type() {
  _has_bits_[0] |= 0x00000008u;
}
inline void Image::clear_has_data_type() {
  _has_bits_[0] &= ~0x00000008u;
}
inline void Image::clear_data_type() {
  data_type_.ClearToEmptyNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
  clear_has_data_type();
}
inline const ::std::string& Image::data_type() const {
  // @@protoc_insertion_point(field_get:mw.internal.robotics.gazebotransport.Image.data_type)
  return data_type_.GetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline void Image::set_data_type(const ::std::string& value) {
  set_has_data_type();
  data_type_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), value);
  // @@protoc_insertion_point(field_set:mw.internal.robotics.gazebotransport.Image.data_type)
}
inline void Image::set_data_type(const char* value) {
  set_has_data_type();
  data_type_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::string(value));
  // @@protoc_insertion_point(field_set_char:mw.internal.robotics.gazebotransport.Image.data_type)
}
inline void Image::set_data_type(const char* value, size_t size) {
  set_has_data_type();
  data_type_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(),
      ::std::string(reinterpret_cast<const char*>(value), size));
  // @@protoc_insertion_point(field_set_pointer:mw.internal.robotics.gazebotransport.Image.data_type)
}
inline ::std::string* Image::mutable_data_type() {
  set_has_data_type();
  // @@protoc_insertion_point(field_mutable:mw.internal.robotics.gazebotransport.Image.data_type)
  return data_type_.MutableNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline ::std::string* Image::release_data_type() {
  // @@protoc_insertion_point(field_release:mw.internal.robotics.gazebotransport.Image.data_type)
  clear_has_data_type();
  return data_type_.ReleaseNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline void Image::set_allocated_data_type(::std::string* data_type) {
  if (data_type != NULL) {
    set_has_data_type();
  } else {
    clear_has_data_type();
  }
  data_type_.SetAllocatedNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), data_type);
  // @@protoc_insertion_point(field_set_allocated:mw.internal.robotics.gazebotransport.Image.data_type)
}

// -------------------------------------------------------------------

// RequestImage

// required string topic_name = 1;
inline bool RequestImage::has_topic_name() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void RequestImage::set_has_topic_name() {
  _has_bits_[0] |= 0x00000001u;
}
inline void RequestImage::clear_has_topic_name() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void RequestImage::clear_topic_name() {
  topic_name_.ClearToEmptyNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
  clear_has_topic_name();
}
inline const ::std::string& RequestImage::topic_name() const {
  // @@protoc_insertion_point(field_get:mw.internal.robotics.gazebotransport.RequestImage.topic_name)
  return topic_name_.GetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline void RequestImage::set_topic_name(const ::std::string& value) {
  set_has_topic_name();
  topic_name_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), value);
  // @@protoc_insertion_point(field_set:mw.internal.robotics.gazebotransport.RequestImage.topic_name)
}
inline void RequestImage::set_topic_name(const char* value) {
  set_has_topic_name();
  topic_name_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::string(value));
  // @@protoc_insertion_point(field_set_char:mw.internal.robotics.gazebotransport.RequestImage.topic_name)
}
inline void RequestImage::set_topic_name(const char* value, size_t size) {
  set_has_topic_name();
  topic_name_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(),
      ::std::string(reinterpret_cast<const char*>(value), size));
  // @@protoc_insertion_point(field_set_pointer:mw.internal.robotics.gazebotransport.RequestImage.topic_name)
}
inline ::std::string* RequestImage::mutable_topic_name() {
  set_has_topic_name();
  // @@protoc_insertion_point(field_mutable:mw.internal.robotics.gazebotransport.RequestImage.topic_name)
  return topic_name_.MutableNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline ::std::string* RequestImage::release_topic_name() {
  // @@protoc_insertion_point(field_release:mw.internal.robotics.gazebotransport.RequestImage.topic_name)
  clear_has_topic_name();
  return topic_name_.ReleaseNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline void RequestImage::set_allocated_topic_name(::std::string* topic_name) {
  if (topic_name != NULL) {
    set_has_topic_name();
  } else {
    clear_has_topic_name();
  }
  topic_name_.SetAllocatedNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), topic_name);
  // @@protoc_insertion_point(field_set_allocated:mw.internal.robotics.gazebotransport.RequestImage.topic_name)
}

// -------------------------------------------------------------------

// RequestCoSim

// required string client_id = 1;
inline bool RequestCoSim::has_client_id() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void RequestCoSim::set_has_client_id() {
  _has_bits_[0] |= 0x00000001u;
}
inline void RequestCoSim::clear_has_client_id() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void RequestCoSim::clear_client_id() {
  client_id_.ClearToEmptyNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
  clear_has_client_id();
}
inline const ::std::string& RequestCoSim::client_id() const {
  // @@protoc_insertion_point(field_get:mw.internal.robotics.gazebotransport.RequestCoSim.client_id)
  return client_id_.GetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline void RequestCoSim::set_client_id(const ::std::string& value) {
  set_has_client_id();
  client_id_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), value);
  // @@protoc_insertion_point(field_set:mw.internal.robotics.gazebotransport.RequestCoSim.client_id)
}
inline void RequestCoSim::set_client_id(const char* value) {
  set_has_client_id();
  client_id_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::string(value));
  // @@protoc_insertion_point(field_set_char:mw.internal.robotics.gazebotransport.RequestCoSim.client_id)
}
inline void RequestCoSim::set_client_id(const char* value, size_t size) {
  set_has_client_id();
  client_id_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(),
      ::std::string(reinterpret_cast<const char*>(value), size));
  // @@protoc_insertion_point(field_set_pointer:mw.internal.robotics.gazebotransport.RequestCoSim.client_id)
}
inline ::std::string* RequestCoSim::mutable_client_id() {
  set_has_client_id();
  // @@protoc_insertion_point(field_mutable:mw.internal.robotics.gazebotransport.RequestCoSim.client_id)
  return client_id_.MutableNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline ::std::string* RequestCoSim::release_client_id() {
  // @@protoc_insertion_point(field_release:mw.internal.robotics.gazebotransport.RequestCoSim.client_id)
  clear_has_client_id();
  return client_id_.ReleaseNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline void RequestCoSim::set_allocated_client_id(::std::string* client_id) {
  if (client_id != NULL) {
    set_has_client_id();
  } else {
    clear_has_client_id();
  }
  client_id_.SetAllocatedNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), client_id);
  // @@protoc_insertion_point(field_set_allocated:mw.internal.robotics.gazebotransport.RequestCoSim.client_id)
}

// required double duration = 2;
inline bool RequestCoSim::has_duration() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void RequestCoSim::set_has_duration() {
  _has_bits_[0] |= 0x00000002u;
}
inline void RequestCoSim::clear_has_duration() {
  _has_bits_[0] &= ~0x00000002u;
}
inline void RequestCoSim::clear_duration() {
  duration_ = 0;
  clear_has_duration();
}
inline double RequestCoSim::duration() const {
  // @@protoc_insertion_point(field_get:mw.internal.robotics.gazebotransport.RequestCoSim.duration)
  return duration_;
}
inline void RequestCoSim::set_duration(double value) {
  set_has_duration();
  duration_ = value;
  // @@protoc_insertion_point(field_set:mw.internal.robotics.gazebotransport.RequestCoSim.duration)
}

// -------------------------------------------------------------------

// StopCoSim

// required string client_id = 1;
inline bool StopCoSim::has_client_id() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void StopCoSim::set_has_client_id() {
  _has_bits_[0] |= 0x00000001u;
}
inline void StopCoSim::clear_has_client_id() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void StopCoSim::clear_client_id() {
  client_id_.ClearToEmptyNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
  clear_has_client_id();
}
inline const ::std::string& StopCoSim::client_id() const {
  // @@protoc_insertion_point(field_get:mw.internal.robotics.gazebotransport.StopCoSim.client_id)
  return client_id_.GetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline void StopCoSim::set_client_id(const ::std::string& value) {
  set_has_client_id();
  client_id_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), value);
  // @@protoc_insertion_point(field_set:mw.internal.robotics.gazebotransport.StopCoSim.client_id)
}
inline void StopCoSim::set_client_id(const char* value) {
  set_has_client_id();
  client_id_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::string(value));
  // @@protoc_insertion_point(field_set_char:mw.internal.robotics.gazebotransport.StopCoSim.client_id)
}
inline void StopCoSim::set_client_id(const char* value, size_t size) {
  set_has_client_id();
  client_id_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(),
      ::std::string(reinterpret_cast<const char*>(value), size));
  // @@protoc_insertion_point(field_set_pointer:mw.internal.robotics.gazebotransport.StopCoSim.client_id)
}
inline ::std::string* StopCoSim::mutable_client_id() {
  set_has_client_id();
  // @@protoc_insertion_point(field_mutable:mw.internal.robotics.gazebotransport.StopCoSim.client_id)
  return client_id_.MutableNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline ::std::string* StopCoSim::release_client_id() {
  // @@protoc_insertion_point(field_release:mw.internal.robotics.gazebotransport.StopCoSim.client_id)
  clear_has_client_id();
  return client_id_.ReleaseNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline void StopCoSim::set_allocated_client_id(::std::string* client_id) {
  if (client_id != NULL) {
    set_has_client_id();
  } else {
    clear_has_client_id();
  }
  client_id_.SetAllocatedNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), client_id);
  // @@protoc_insertion_point(field_set_allocated:mw.internal.robotics.gazebotransport.StopCoSim.client_id)
}

// -------------------------------------------------------------------

// GetGroundTruthWorldPose

// required string model_name = 1;
inline bool GetGroundTruthWorldPose::has_model_name() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void GetGroundTruthWorldPose::set_has_model_name() {
  _has_bits_[0] |= 0x00000001u;
}
inline void GetGroundTruthWorldPose::clear_has_model_name() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void GetGroundTruthWorldPose::clear_model_name() {
  model_name_.ClearToEmptyNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
  clear_has_model_name();
}
inline const ::std::string& GetGroundTruthWorldPose::model_name() const {
  // @@protoc_insertion_point(field_get:mw.internal.robotics.gazebotransport.GetGroundTruthWorldPose.model_name)
  return model_name_.GetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline void GetGroundTruthWorldPose::set_model_name(const ::std::string& value) {
  set_has_model_name();
  model_name_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), value);
  // @@protoc_insertion_point(field_set:mw.internal.robotics.gazebotransport.GetGroundTruthWorldPose.model_name)
}
inline void GetGroundTruthWorldPose::set_model_name(const char* value) {
  set_has_model_name();
  model_name_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::string(value));
  // @@protoc_insertion_point(field_set_char:mw.internal.robotics.gazebotransport.GetGroundTruthWorldPose.model_name)
}
inline void GetGroundTruthWorldPose::set_model_name(const char* value, size_t size) {
  set_has_model_name();
  model_name_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(),
      ::std::string(reinterpret_cast<const char*>(value), size));
  // @@protoc_insertion_point(field_set_pointer:mw.internal.robotics.gazebotransport.GetGroundTruthWorldPose.model_name)
}
inline ::std::string* GetGroundTruthWorldPose::mutable_model_name() {
  set_has_model_name();
  // @@protoc_insertion_point(field_mutable:mw.internal.robotics.gazebotransport.GetGroundTruthWorldPose.model_name)
  return model_name_.MutableNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline ::std::string* GetGroundTruthWorldPose::release_model_name() {
  // @@protoc_insertion_point(field_release:mw.internal.robotics.gazebotransport.GetGroundTruthWorldPose.model_name)
  clear_has_model_name();
  return model_name_.ReleaseNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline void GetGroundTruthWorldPose::set_allocated_model_name(::std::string* model_name) {
  if (model_name != NULL) {
    set_has_model_name();
  } else {
    clear_has_model_name();
  }
  model_name_.SetAllocatedNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), model_name);
  // @@protoc_insertion_point(field_set_allocated:mw.internal.robotics.gazebotransport.GetGroundTruthWorldPose.model_name)
}

// required string link_name = 2;
inline bool GetGroundTruthWorldPose::has_link_name() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void GetGroundTruthWorldPose::set_has_link_name() {
  _has_bits_[0] |= 0x00000002u;
}
inline void GetGroundTruthWorldPose::clear_has_link_name() {
  _has_bits_[0] &= ~0x00000002u;
}
inline void GetGroundTruthWorldPose::clear_link_name() {
  link_name_.ClearToEmptyNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
  clear_has_link_name();
}
inline const ::std::string& GetGroundTruthWorldPose::link_name() const {
  // @@protoc_insertion_point(field_get:mw.internal.robotics.gazebotransport.GetGroundTruthWorldPose.link_name)
  return link_name_.GetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline void GetGroundTruthWorldPose::set_link_name(const ::std::string& value) {
  set_has_link_name();
  link_name_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), value);
  // @@protoc_insertion_point(field_set:mw.internal.robotics.gazebotransport.GetGroundTruthWorldPose.link_name)
}
inline void GetGroundTruthWorldPose::set_link_name(const char* value) {
  set_has_link_name();
  link_name_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::string(value));
  // @@protoc_insertion_point(field_set_char:mw.internal.robotics.gazebotransport.GetGroundTruthWorldPose.link_name)
}
inline void GetGroundTruthWorldPose::set_link_name(const char* value, size_t size) {
  set_has_link_name();
  link_name_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(),
      ::std::string(reinterpret_cast<const char*>(value), size));
  // @@protoc_insertion_point(field_set_pointer:mw.internal.robotics.gazebotransport.GetGroundTruthWorldPose.link_name)
}
inline ::std::string* GetGroundTruthWorldPose::mutable_link_name() {
  set_has_link_name();
  // @@protoc_insertion_point(field_mutable:mw.internal.robotics.gazebotransport.GetGroundTruthWorldPose.link_name)
  return link_name_.MutableNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline ::std::string* GetGroundTruthWorldPose::release_link_name() {
  // @@protoc_insertion_point(field_release:mw.internal.robotics.gazebotransport.GetGroundTruthWorldPose.link_name)
  clear_has_link_name();
  return link_name_.ReleaseNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline void GetGroundTruthWorldPose::set_allocated_link_name(::std::string* link_name) {
  if (link_name != NULL) {
    set_has_link_name();
  } else {
    clear_has_link_name();
  }
  link_name_.SetAllocatedNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), link_name);
  // @@protoc_insertion_point(field_set_allocated:mw.internal.robotics.gazebotransport.GetGroundTruthWorldPose.link_name)
}

// -------------------------------------------------------------------

// Point

// required double x = 1;
inline bool Point::has_x() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void Point::set_has_x() {
  _has_bits_[0] |= 0x00000001u;
}
inline void Point::clear_has_x() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void Point::clear_x() {
  x_ = 0;
  clear_has_x();
}
inline double Point::x() const {
  // @@protoc_insertion_point(field_get:mw.internal.robotics.gazebotransport.Point.x)
  return x_;
}
inline void Point::set_x(double value) {
  set_has_x();
  x_ = value;
  // @@protoc_insertion_point(field_set:mw.internal.robotics.gazebotransport.Point.x)
}

// required double y = 2;
inline bool Point::has_y() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void Point::set_has_y() {
  _has_bits_[0] |= 0x00000002u;
}
inline void Point::clear_has_y() {
  _has_bits_[0] &= ~0x00000002u;
}
inline void Point::clear_y() {
  y_ = 0;
  clear_has_y();
}
inline double Point::y() const {
  // @@protoc_insertion_point(field_get:mw.internal.robotics.gazebotransport.Point.y)
  return y_;
}
inline void Point::set_y(double value) {
  set_has_y();
  y_ = value;
  // @@protoc_insertion_point(field_set:mw.internal.robotics.gazebotransport.Point.y)
}

// required double z = 3;
inline bool Point::has_z() const {
  return (_has_bits_[0] & 0x00000004u) != 0;
}
inline void Point::set_has_z() {
  _has_bits_[0] |= 0x00000004u;
}
inline void Point::clear_has_z() {
  _has_bits_[0] &= ~0x00000004u;
}
inline void Point::clear_z() {
  z_ = 0;
  clear_has_z();
}
inline double Point::z() const {
  // @@protoc_insertion_point(field_get:mw.internal.robotics.gazebotransport.Point.z)
  return z_;
}
inline void Point::set_z(double value) {
  set_has_z();
  z_ = value;
  // @@protoc_insertion_point(field_set:mw.internal.robotics.gazebotransport.Point.z)
}

// -------------------------------------------------------------------

// Quaternion

// required double x = 1;
inline bool Quaternion::has_x() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void Quaternion::set_has_x() {
  _has_bits_[0] |= 0x00000001u;
}
inline void Quaternion::clear_has_x() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void Quaternion::clear_x() {
  x_ = 0;
  clear_has_x();
}
inline double Quaternion::x() const {
  // @@protoc_insertion_point(field_get:mw.internal.robotics.gazebotransport.Quaternion.x)
  return x_;
}
inline void Quaternion::set_x(double value) {
  set_has_x();
  x_ = value;
  // @@protoc_insertion_point(field_set:mw.internal.robotics.gazebotransport.Quaternion.x)
}

// required double y = 2;
inline bool Quaternion::has_y() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void Quaternion::set_has_y() {
  _has_bits_[0] |= 0x00000002u;
}
inline void Quaternion::clear_has_y() {
  _has_bits_[0] &= ~0x00000002u;
}
inline void Quaternion::clear_y() {
  y_ = 0;
  clear_has_y();
}
inline double Quaternion::y() const {
  // @@protoc_insertion_point(field_get:mw.internal.robotics.gazebotransport.Quaternion.y)
  return y_;
}
inline void Quaternion::set_y(double value) {
  set_has_y();
  y_ = value;
  // @@protoc_insertion_point(field_set:mw.internal.robotics.gazebotransport.Quaternion.y)
}

// required double z = 3;
inline bool Quaternion::has_z() const {
  return (_has_bits_[0] & 0x00000004u) != 0;
}
inline void Quaternion::set_has_z() {
  _has_bits_[0] |= 0x00000004u;
}
inline void Quaternion::clear_has_z() {
  _has_bits_[0] &= ~0x00000004u;
}
inline void Quaternion::clear_z() {
  z_ = 0;
  clear_has_z();
}
inline double Quaternion::z() const {
  // @@protoc_insertion_point(field_get:mw.internal.robotics.gazebotransport.Quaternion.z)
  return z_;
}
inline void Quaternion::set_z(double value) {
  set_has_z();
  z_ = value;
  // @@protoc_insertion_point(field_set:mw.internal.robotics.gazebotransport.Quaternion.z)
}

// required double w = 4;
inline bool Quaternion::has_w() const {
  return (_has_bits_[0] & 0x00000008u) != 0;
}
inline void Quaternion::set_has_w() {
  _has_bits_[0] |= 0x00000008u;
}
inline void Quaternion::clear_has_w() {
  _has_bits_[0] &= ~0x00000008u;
}
inline void Quaternion::clear_w() {
  w_ = 0;
  clear_has_w();
}
inline double Quaternion::w() const {
  // @@protoc_insertion_point(field_get:mw.internal.robotics.gazebotransport.Quaternion.w)
  return w_;
}
inline void Quaternion::set_w(double value) {
  set_has_w();
  w_ = value;
  // @@protoc_insertion_point(field_set:mw.internal.robotics.gazebotransport.Quaternion.w)
}

// -------------------------------------------------------------------

// Pose

// required .mw.internal.robotics.gazebotransport.Point position = 1;
inline bool Pose::has_position() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void Pose::set_has_position() {
  _has_bits_[0] |= 0x00000001u;
}
inline void Pose::clear_has_position() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void Pose::clear_position() {
  if (position_ != NULL) position_->::mw::internal::robotics::gazebotransport::Point::Clear();
  clear_has_position();
}
inline const ::mw::internal::robotics::gazebotransport::Point& Pose::position() const {
  // @@protoc_insertion_point(field_get:mw.internal.robotics.gazebotransport.Pose.position)
  return position_ != NULL ? *position_ : *default_instance_->position_;
}
inline ::mw::internal::robotics::gazebotransport::Point* Pose::mutable_position() {
  set_has_position();
  if (position_ == NULL) {
    position_ = new ::mw::internal::robotics::gazebotransport::Point;
  }
  // @@protoc_insertion_point(field_mutable:mw.internal.robotics.gazebotransport.Pose.position)
  return position_;
}
inline ::mw::internal::robotics::gazebotransport::Point* Pose::release_position() {
  // @@protoc_insertion_point(field_release:mw.internal.robotics.gazebotransport.Pose.position)
  clear_has_position();
  ::mw::internal::robotics::gazebotransport::Point* temp = position_;
  position_ = NULL;
  return temp;
}
inline void Pose::set_allocated_position(::mw::internal::robotics::gazebotransport::Point* position) {
  delete position_;
  position_ = position;
  if (position) {
    set_has_position();
  } else {
    clear_has_position();
  }
  // @@protoc_insertion_point(field_set_allocated:mw.internal.robotics.gazebotransport.Pose.position)
}

// required .mw.internal.robotics.gazebotransport.Quaternion orientation = 2;
inline bool Pose::has_orientation() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void Pose::set_has_orientation() {
  _has_bits_[0] |= 0x00000002u;
}
inline void Pose::clear_has_orientation() {
  _has_bits_[0] &= ~0x00000002u;
}
inline void Pose::clear_orientation() {
  if (orientation_ != NULL) orientation_->::mw::internal::robotics::gazebotransport::Quaternion::Clear();
  clear_has_orientation();
}
inline const ::mw::internal::robotics::gazebotransport::Quaternion& Pose::orientation() const {
  // @@protoc_insertion_point(field_get:mw.internal.robotics.gazebotransport.Pose.orientation)
  return orientation_ != NULL ? *orientation_ : *default_instance_->orientation_;
}
inline ::mw::internal::robotics::gazebotransport::Quaternion* Pose::mutable_orientation() {
  set_has_orientation();
  if (orientation_ == NULL) {
    orientation_ = new ::mw::internal::robotics::gazebotransport::Quaternion;
  }
  // @@protoc_insertion_point(field_mutable:mw.internal.robotics.gazebotransport.Pose.orientation)
  return orientation_;
}
inline ::mw::internal::robotics::gazebotransport::Quaternion* Pose::release_orientation() {
  // @@protoc_insertion_point(field_release:mw.internal.robotics.gazebotransport.Pose.orientation)
  clear_has_orientation();
  ::mw::internal::robotics::gazebotransport::Quaternion* temp = orientation_;
  orientation_ = NULL;
  return temp;
}
inline void Pose::set_allocated_orientation(::mw::internal::robotics::gazebotransport::Quaternion* orientation) {
  delete orientation_;
  orientation_ = orientation;
  if (orientation) {
    set_has_orientation();
  } else {
    clear_has_orientation();
  }
  // @@protoc_insertion_point(field_set_allocated:mw.internal.robotics.gazebotransport.Pose.orientation)
}

// -------------------------------------------------------------------

// StopSimulation

// required bool stop_scene = 1;
inline bool StopSimulation::has_stop_scene() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void StopSimulation::set_has_stop_scene() {
  _has_bits_[0] |= 0x00000001u;
}
inline void StopSimulation::clear_has_stop_scene() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void StopSimulation::clear_stop_scene() {
  stop_scene_ = false;
  clear_has_stop_scene();
}
inline bool StopSimulation::stop_scene() const {
  // @@protoc_insertion_point(field_get:mw.internal.robotics.gazebotransport.StopSimulation.stop_scene)
  return stop_scene_;
}
inline void StopSimulation::set_stop_scene(bool value) {
  set_has_stop_scene();
  stop_scene_ = value;
  // @@protoc_insertion_point(field_set:mw.internal.robotics.gazebotransport.StopSimulation.stop_scene)
}

// -------------------------------------------------------------------

// LaserData

// required double angle_min = 1;
inline bool LaserData::has_angle_min() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void LaserData::set_has_angle_min() {
  _has_bits_[0] |= 0x00000001u;
}
inline void LaserData::clear_has_angle_min() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void LaserData::clear_angle_min() {
  angle_min_ = 0;
  clear_has_angle_min();
}
inline double LaserData::angle_min() const {
  // @@protoc_insertion_point(field_get:mw.internal.robotics.gazebotransport.LaserData.angle_min)
  return angle_min_;
}
inline void LaserData::set_angle_min(double value) {
  set_has_angle_min();
  angle_min_ = value;
  // @@protoc_insertion_point(field_set:mw.internal.robotics.gazebotransport.LaserData.angle_min)
}

// required double angle_max = 2;
inline bool LaserData::has_angle_max() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void LaserData::set_has_angle_max() {
  _has_bits_[0] |= 0x00000002u;
}
inline void LaserData::clear_has_angle_max() {
  _has_bits_[0] &= ~0x00000002u;
}
inline void LaserData::clear_angle_max() {
  angle_max_ = 0;
  clear_has_angle_max();
}
inline double LaserData::angle_max() const {
  // @@protoc_insertion_point(field_get:mw.internal.robotics.gazebotransport.LaserData.angle_max)
  return angle_max_;
}
inline void LaserData::set_angle_max(double value) {
  set_has_angle_max();
  angle_max_ = value;
  // @@protoc_insertion_point(field_set:mw.internal.robotics.gazebotransport.LaserData.angle_max)
}

// required double angle_step = 3;
inline bool LaserData::has_angle_step() const {
  return (_has_bits_[0] & 0x00000004u) != 0;
}
inline void LaserData::set_has_angle_step() {
  _has_bits_[0] |= 0x00000004u;
}
inline void LaserData::clear_has_angle_step() {
  _has_bits_[0] &= ~0x00000004u;
}
inline void LaserData::clear_angle_step() {
  angle_step_ = 0;
  clear_has_angle_step();
}
inline double LaserData::angle_step() const {
  // @@protoc_insertion_point(field_get:mw.internal.robotics.gazebotransport.LaserData.angle_step)
  return angle_step_;
}
inline void LaserData::set_angle_step(double value) {
  set_has_angle_step();
  angle_step_ = value;
  // @@protoc_insertion_point(field_set:mw.internal.robotics.gazebotransport.LaserData.angle_step)
}

// required double range_min = 4;
inline bool LaserData::has_range_min() const {
  return (_has_bits_[0] & 0x00000008u) != 0;
}
inline void LaserData::set_has_range_min() {
  _has_bits_[0] |= 0x00000008u;
}
inline void LaserData::clear_has_range_min() {
  _has_bits_[0] &= ~0x00000008u;
}
inline void LaserData::clear_range_min() {
  range_min_ = 0;
  clear_has_range_min();
}
inline double LaserData::range_min() const {
  // @@protoc_insertion_point(field_get:mw.internal.robotics.gazebotransport.LaserData.range_min)
  return range_min_;
}
inline void LaserData::set_range_min(double value) {
  set_has_range_min();
  range_min_ = value;
  // @@protoc_insertion_point(field_set:mw.internal.robotics.gazebotransport.LaserData.range_min)
}

// required double range_max = 5;
inline bool LaserData::has_range_max() const {
  return (_has_bits_[0] & 0x00000010u) != 0;
}
inline void LaserData::set_has_range_max() {
  _has_bits_[0] |= 0x00000010u;
}
inline void LaserData::clear_has_range_max() {
  _has_bits_[0] &= ~0x00000010u;
}
inline void LaserData::clear_range_max() {
  range_max_ = 0;
  clear_has_range_max();
}
inline double LaserData::range_max() const {
  // @@protoc_insertion_point(field_get:mw.internal.robotics.gazebotransport.LaserData.range_max)
  return range_max_;
}
inline void LaserData::set_range_max(double value) {
  set_has_range_max();
  range_max_ = value;
  // @@protoc_insertion_point(field_set:mw.internal.robotics.gazebotransport.LaserData.range_max)
}

// required double count = 6;
inline bool LaserData::has_count() const {
  return (_has_bits_[0] & 0x00000020u) != 0;
}
inline void LaserData::set_has_count() {
  _has_bits_[0] |= 0x00000020u;
}
inline void LaserData::clear_has_count() {
  _has_bits_[0] &= ~0x00000020u;
}
inline void LaserData::clear_count() {
  count_ = 0;
  clear_has_count();
}
inline double LaserData::count() const {
  // @@protoc_insertion_point(field_get:mw.internal.robotics.gazebotransport.LaserData.count)
  return count_;
}
inline void LaserData::set_count(double value) {
  set_has_count();
  count_ = value;
  // @@protoc_insertion_point(field_set:mw.internal.robotics.gazebotransport.LaserData.count)
}

// required double vertical_angle_min = 7;
inline bool LaserData::has_vertical_angle_min() const {
  return (_has_bits_[0] & 0x00000040u) != 0;
}
inline void LaserData::set_has_vertical_angle_min() {
  _has_bits_[0] |= 0x00000040u;
}
inline void LaserData::clear_has_vertical_angle_min() {
  _has_bits_[0] &= ~0x00000040u;
}
inline void LaserData::clear_vertical_angle_min() {
  vertical_angle_min_ = 0;
  clear_has_vertical_angle_min();
}
inline double LaserData::vertical_angle_min() const {
  // @@protoc_insertion_point(field_get:mw.internal.robotics.gazebotransport.LaserData.vertical_angle_min)
  return vertical_angle_min_;
}
inline void LaserData::set_vertical_angle_min(double value) {
  set_has_vertical_angle_min();
  vertical_angle_min_ = value;
  // @@protoc_insertion_point(field_set:mw.internal.robotics.gazebotransport.LaserData.vertical_angle_min)
}

// required double vertical_angle_max = 8;
inline bool LaserData::has_vertical_angle_max() const {
  return (_has_bits_[0] & 0x00000080u) != 0;
}
inline void LaserData::set_has_vertical_angle_max() {
  _has_bits_[0] |= 0x00000080u;
}
inline void LaserData::clear_has_vertical_angle_max() {
  _has_bits_[0] &= ~0x00000080u;
}
inline void LaserData::clear_vertical_angle_max() {
  vertical_angle_max_ = 0;
  clear_has_vertical_angle_max();
}
inline double LaserData::vertical_angle_max() const {
  // @@protoc_insertion_point(field_get:mw.internal.robotics.gazebotransport.LaserData.vertical_angle_max)
  return vertical_angle_max_;
}
inline void LaserData::set_vertical_angle_max(double value) {
  set_has_vertical_angle_max();
  vertical_angle_max_ = value;
  // @@protoc_insertion_point(field_set:mw.internal.robotics.gazebotransport.LaserData.vertical_angle_max)
}

// required double vertical_angle_step = 9;
inline bool LaserData::has_vertical_angle_step() const {
  return (_has_bits_[0] & 0x00000100u) != 0;
}
inline void LaserData::set_has_vertical_angle_step() {
  _has_bits_[0] |= 0x00000100u;
}
inline void LaserData::clear_has_vertical_angle_step() {
  _has_bits_[0] &= ~0x00000100u;
}
inline void LaserData::clear_vertical_angle_step() {
  vertical_angle_step_ = 0;
  clear_has_vertical_angle_step();
}
inline double LaserData::vertical_angle_step() const {
  // @@protoc_insertion_point(field_get:mw.internal.robotics.gazebotransport.LaserData.vertical_angle_step)
  return vertical_angle_step_;
}
inline void LaserData::set_vertical_angle_step(double value) {
  set_has_vertical_angle_step();
  vertical_angle_step_ = value;
  // @@protoc_insertion_point(field_set:mw.internal.robotics.gazebotransport.LaserData.vertical_angle_step)
}

// repeated double range = 10;
inline int LaserData::range_size() const {
  return range_.size();
}
inline void LaserData::clear_range() {
  range_.Clear();
}
inline double LaserData::range(int index) const {
  // @@protoc_insertion_point(field_get:mw.internal.robotics.gazebotransport.LaserData.range)
  return range_.Get(index);
}
inline void LaserData::set_range(int index, double value) {
  range_.Set(index, value);
  // @@protoc_insertion_point(field_set:mw.internal.robotics.gazebotransport.LaserData.range)
}
inline void LaserData::add_range(double value) {
  range_.Add(value);
  // @@protoc_insertion_point(field_add:mw.internal.robotics.gazebotransport.LaserData.range)
}
inline const ::google::protobuf::RepeatedField< double >&
LaserData::range() const {
  // @@protoc_insertion_point(field_list:mw.internal.robotics.gazebotransport.LaserData.range)
  return range_;
}
inline ::google::protobuf::RepeatedField< double >*
LaserData::mutable_range() {
  // @@protoc_insertion_point(field_mutable_list:mw.internal.robotics.gazebotransport.LaserData.range)
  return &range_;
}

// repeated double intensities = 11;
inline int LaserData::intensities_size() const {
  return intensities_.size();
}
inline void LaserData::clear_intensities() {
  intensities_.Clear();
}
inline double LaserData::intensities(int index) const {
  // @@protoc_insertion_point(field_get:mw.internal.robotics.gazebotransport.LaserData.intensities)
  return intensities_.Get(index);
}
inline void LaserData::set_intensities(int index, double value) {
  intensities_.Set(index, value);
  // @@protoc_insertion_point(field_set:mw.internal.robotics.gazebotransport.LaserData.intensities)
}
inline void LaserData::add_intensities(double value) {
  intensities_.Add(value);
  // @@protoc_insertion_point(field_add:mw.internal.robotics.gazebotransport.LaserData.intensities)
}
inline const ::google::protobuf::RepeatedField< double >&
LaserData::intensities() const {
  // @@protoc_insertion_point(field_list:mw.internal.robotics.gazebotransport.LaserData.intensities)
  return intensities_;
}
inline ::google::protobuf::RepeatedField< double >*
LaserData::mutable_intensities() {
  // @@protoc_insertion_point(field_mutable_list:mw.internal.robotics.gazebotransport.LaserData.intensities)
  return &intensities_;
}

// -------------------------------------------------------------------

// RequestLaser

// required string topic_name = 1;
inline bool RequestLaser::has_topic_name() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void RequestLaser::set_has_topic_name() {
  _has_bits_[0] |= 0x00000001u;
}
inline void RequestLaser::clear_has_topic_name() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void RequestLaser::clear_topic_name() {
  topic_name_.ClearToEmptyNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
  clear_has_topic_name();
}
inline const ::std::string& RequestLaser::topic_name() const {
  // @@protoc_insertion_point(field_get:mw.internal.robotics.gazebotransport.RequestLaser.topic_name)
  return topic_name_.GetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline void RequestLaser::set_topic_name(const ::std::string& value) {
  set_has_topic_name();
  topic_name_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), value);
  // @@protoc_insertion_point(field_set:mw.internal.robotics.gazebotransport.RequestLaser.topic_name)
}
inline void RequestLaser::set_topic_name(const char* value) {
  set_has_topic_name();
  topic_name_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::string(value));
  // @@protoc_insertion_point(field_set_char:mw.internal.robotics.gazebotransport.RequestLaser.topic_name)
}
inline void RequestLaser::set_topic_name(const char* value, size_t size) {
  set_has_topic_name();
  topic_name_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(),
      ::std::string(reinterpret_cast<const char*>(value), size));
  // @@protoc_insertion_point(field_set_pointer:mw.internal.robotics.gazebotransport.RequestLaser.topic_name)
}
inline ::std::string* RequestLaser::mutable_topic_name() {
  set_has_topic_name();
  // @@protoc_insertion_point(field_mutable:mw.internal.robotics.gazebotransport.RequestLaser.topic_name)
  return topic_name_.MutableNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline ::std::string* RequestLaser::release_topic_name() {
  // @@protoc_insertion_point(field_release:mw.internal.robotics.gazebotransport.RequestLaser.topic_name)
  clear_has_topic_name();
  return topic_name_.ReleaseNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline void RequestLaser::set_allocated_topic_name(::std::string* topic_name) {
  if (topic_name != NULL) {
    set_has_topic_name();
  } else {
    clear_has_topic_name();
  }
  topic_name_.SetAllocatedNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), topic_name);
  // @@protoc_insertion_point(field_set_allocated:mw.internal.robotics.gazebotransport.RequestLaser.topic_name)
}

// -------------------------------------------------------------------

// ImuData

// required .mw.internal.robotics.gazebotransport.Point linear_acceleration = 1;
inline bool ImuData::has_linear_acceleration() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void ImuData::set_has_linear_acceleration() {
  _has_bits_[0] |= 0x00000001u;
}
inline void ImuData::clear_has_linear_acceleration() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void ImuData::clear_linear_acceleration() {
  if (linear_acceleration_ != NULL) linear_acceleration_->::mw::internal::robotics::gazebotransport::Point::Clear();
  clear_has_linear_acceleration();
}
inline const ::mw::internal::robotics::gazebotransport::Point& ImuData::linear_acceleration() const {
  // @@protoc_insertion_point(field_get:mw.internal.robotics.gazebotransport.ImuData.linear_acceleration)
  return linear_acceleration_ != NULL ? *linear_acceleration_ : *default_instance_->linear_acceleration_;
}
inline ::mw::internal::robotics::gazebotransport::Point* ImuData::mutable_linear_acceleration() {
  set_has_linear_acceleration();
  if (linear_acceleration_ == NULL) {
    linear_acceleration_ = new ::mw::internal::robotics::gazebotransport::Point;
  }
  // @@protoc_insertion_point(field_mutable:mw.internal.robotics.gazebotransport.ImuData.linear_acceleration)
  return linear_acceleration_;
}
inline ::mw::internal::robotics::gazebotransport::Point* ImuData::release_linear_acceleration() {
  // @@protoc_insertion_point(field_release:mw.internal.robotics.gazebotransport.ImuData.linear_acceleration)
  clear_has_linear_acceleration();
  ::mw::internal::robotics::gazebotransport::Point* temp = linear_acceleration_;
  linear_acceleration_ = NULL;
  return temp;
}
inline void ImuData::set_allocated_linear_acceleration(::mw::internal::robotics::gazebotransport::Point* linear_acceleration) {
  delete linear_acceleration_;
  linear_acceleration_ = linear_acceleration;
  if (linear_acceleration) {
    set_has_linear_acceleration();
  } else {
    clear_has_linear_acceleration();
  }
  // @@protoc_insertion_point(field_set_allocated:mw.internal.robotics.gazebotransport.ImuData.linear_acceleration)
}

// required .mw.internal.robotics.gazebotransport.Point angular_velocity = 2;
inline bool ImuData::has_angular_velocity() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void ImuData::set_has_angular_velocity() {
  _has_bits_[0] |= 0x00000002u;
}
inline void ImuData::clear_has_angular_velocity() {
  _has_bits_[0] &= ~0x00000002u;
}
inline void ImuData::clear_angular_velocity() {
  if (angular_velocity_ != NULL) angular_velocity_->::mw::internal::robotics::gazebotransport::Point::Clear();
  clear_has_angular_velocity();
}
inline const ::mw::internal::robotics::gazebotransport::Point& ImuData::angular_velocity() const {
  // @@protoc_insertion_point(field_get:mw.internal.robotics.gazebotransport.ImuData.angular_velocity)
  return angular_velocity_ != NULL ? *angular_velocity_ : *default_instance_->angular_velocity_;
}
inline ::mw::internal::robotics::gazebotransport::Point* ImuData::mutable_angular_velocity() {
  set_has_angular_velocity();
  if (angular_velocity_ == NULL) {
    angular_velocity_ = new ::mw::internal::robotics::gazebotransport::Point;
  }
  // @@protoc_insertion_point(field_mutable:mw.internal.robotics.gazebotransport.ImuData.angular_velocity)
  return angular_velocity_;
}
inline ::mw::internal::robotics::gazebotransport::Point* ImuData::release_angular_velocity() {
  // @@protoc_insertion_point(field_release:mw.internal.robotics.gazebotransport.ImuData.angular_velocity)
  clear_has_angular_velocity();
  ::mw::internal::robotics::gazebotransport::Point* temp = angular_velocity_;
  angular_velocity_ = NULL;
  return temp;
}
inline void ImuData::set_allocated_angular_velocity(::mw::internal::robotics::gazebotransport::Point* angular_velocity) {
  delete angular_velocity_;
  angular_velocity_ = angular_velocity;
  if (angular_velocity) {
    set_has_angular_velocity();
  } else {
    clear_has_angular_velocity();
  }
  // @@protoc_insertion_point(field_set_allocated:mw.internal.robotics.gazebotransport.ImuData.angular_velocity)
}

// required .mw.internal.robotics.gazebotransport.Quaternion orientation = 3;
inline bool ImuData::has_orientation() const {
  return (_has_bits_[0] & 0x00000004u) != 0;
}
inline void ImuData::set_has_orientation() {
  _has_bits_[0] |= 0x00000004u;
}
inline void ImuData::clear_has_orientation() {
  _has_bits_[0] &= ~0x00000004u;
}
inline void ImuData::clear_orientation() {
  if (orientation_ != NULL) orientation_->::mw::internal::robotics::gazebotransport::Quaternion::Clear();
  clear_has_orientation();
}
inline const ::mw::internal::robotics::gazebotransport::Quaternion& ImuData::orientation() const {
  // @@protoc_insertion_point(field_get:mw.internal.robotics.gazebotransport.ImuData.orientation)
  return orientation_ != NULL ? *orientation_ : *default_instance_->orientation_;
}
inline ::mw::internal::robotics::gazebotransport::Quaternion* ImuData::mutable_orientation() {
  set_has_orientation();
  if (orientation_ == NULL) {
    orientation_ = new ::mw::internal::robotics::gazebotransport::Quaternion;
  }
  // @@protoc_insertion_point(field_mutable:mw.internal.robotics.gazebotransport.ImuData.orientation)
  return orientation_;
}
inline ::mw::internal::robotics::gazebotransport::Quaternion* ImuData::release_orientation() {
  // @@protoc_insertion_point(field_release:mw.internal.robotics.gazebotransport.ImuData.orientation)
  clear_has_orientation();
  ::mw::internal::robotics::gazebotransport::Quaternion* temp = orientation_;
  orientation_ = NULL;
  return temp;
}
inline void ImuData::set_allocated_orientation(::mw::internal::robotics::gazebotransport::Quaternion* orientation) {
  delete orientation_;
  orientation_ = orientation;
  if (orientation) {
    set_has_orientation();
  } else {
    clear_has_orientation();
  }
  // @@protoc_insertion_point(field_set_allocated:mw.internal.robotics.gazebotransport.ImuData.orientation)
}

// -------------------------------------------------------------------

// RequestImu

// required string topic_name = 1;
inline bool RequestImu::has_topic_name() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void RequestImu::set_has_topic_name() {
  _has_bits_[0] |= 0x00000001u;
}
inline void RequestImu::clear_has_topic_name() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void RequestImu::clear_topic_name() {
  topic_name_.ClearToEmptyNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
  clear_has_topic_name();
}
inline const ::std::string& RequestImu::topic_name() const {
  // @@protoc_insertion_point(field_get:mw.internal.robotics.gazebotransport.RequestImu.topic_name)
  return topic_name_.GetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline void RequestImu::set_topic_name(const ::std::string& value) {
  set_has_topic_name();
  topic_name_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), value);
  // @@protoc_insertion_point(field_set:mw.internal.robotics.gazebotransport.RequestImu.topic_name)
}
inline void RequestImu::set_topic_name(const char* value) {
  set_has_topic_name();
  topic_name_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::string(value));
  // @@protoc_insertion_point(field_set_char:mw.internal.robotics.gazebotransport.RequestImu.topic_name)
}
inline void RequestImu::set_topic_name(const char* value, size_t size) {
  set_has_topic_name();
  topic_name_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(),
      ::std::string(reinterpret_cast<const char*>(value), size));
  // @@protoc_insertion_point(field_set_pointer:mw.internal.robotics.gazebotransport.RequestImu.topic_name)
}
inline ::std::string* RequestImu::mutable_topic_name() {
  set_has_topic_name();
  // @@protoc_insertion_point(field_mutable:mw.internal.robotics.gazebotransport.RequestImu.topic_name)
  return topic_name_.MutableNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline ::std::string* RequestImu::release_topic_name() {
  // @@protoc_insertion_point(field_release:mw.internal.robotics.gazebotransport.RequestImu.topic_name)
  clear_has_topic_name();
  return topic_name_.ReleaseNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline void RequestImu::set_allocated_topic_name(::std::string* topic_name) {
  if (topic_name != NULL) {
    set_has_topic_name();
  } else {
    clear_has_topic_name();
  }
  topic_name_.SetAllocatedNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), topic_name);
  // @@protoc_insertion_point(field_set_allocated:mw.internal.robotics.gazebotransport.RequestImu.topic_name)
}

// -------------------------------------------------------------------

// SubscribeImage

// required string topic_name = 1;
inline bool SubscribeImage::has_topic_name() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void SubscribeImage::set_has_topic_name() {
  _has_bits_[0] |= 0x00000001u;
}
inline void SubscribeImage::clear_has_topic_name() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void SubscribeImage::clear_topic_name() {
  topic_name_.ClearToEmptyNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
  clear_has_topic_name();
}
inline const ::std::string& SubscribeImage::topic_name() const {
  // @@protoc_insertion_point(field_get:mw.internal.robotics.gazebotransport.SubscribeImage.topic_name)
  return topic_name_.GetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline void SubscribeImage::set_topic_name(const ::std::string& value) {
  set_has_topic_name();
  topic_name_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), value);
  // @@protoc_insertion_point(field_set:mw.internal.robotics.gazebotransport.SubscribeImage.topic_name)
}
inline void SubscribeImage::set_topic_name(const char* value) {
  set_has_topic_name();
  topic_name_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::string(value));
  // @@protoc_insertion_point(field_set_char:mw.internal.robotics.gazebotransport.SubscribeImage.topic_name)
}
inline void SubscribeImage::set_topic_name(const char* value, size_t size) {
  set_has_topic_name();
  topic_name_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(),
      ::std::string(reinterpret_cast<const char*>(value), size));
  // @@protoc_insertion_point(field_set_pointer:mw.internal.robotics.gazebotransport.SubscribeImage.topic_name)
}
inline ::std::string* SubscribeImage::mutable_topic_name() {
  set_has_topic_name();
  // @@protoc_insertion_point(field_mutable:mw.internal.robotics.gazebotransport.SubscribeImage.topic_name)
  return topic_name_.MutableNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline ::std::string* SubscribeImage::release_topic_name() {
  // @@protoc_insertion_point(field_release:mw.internal.robotics.gazebotransport.SubscribeImage.topic_name)
  clear_has_topic_name();
  return topic_name_.ReleaseNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline void SubscribeImage::set_allocated_topic_name(::std::string* topic_name) {
  if (topic_name != NULL) {
    set_has_topic_name();
  } else {
    clear_has_topic_name();
  }
  topic_name_.SetAllocatedNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), topic_name);
  // @@protoc_insertion_point(field_set_allocated:mw.internal.robotics.gazebotransport.SubscribeImage.topic_name)
}

// -------------------------------------------------------------------

// SubscribeLaser

// required string topic_name = 1;
inline bool SubscribeLaser::has_topic_name() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void SubscribeLaser::set_has_topic_name() {
  _has_bits_[0] |= 0x00000001u;
}
inline void SubscribeLaser::clear_has_topic_name() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void SubscribeLaser::clear_topic_name() {
  topic_name_.ClearToEmptyNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
  clear_has_topic_name();
}
inline const ::std::string& SubscribeLaser::topic_name() const {
  // @@protoc_insertion_point(field_get:mw.internal.robotics.gazebotransport.SubscribeLaser.topic_name)
  return topic_name_.GetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline void SubscribeLaser::set_topic_name(const ::std::string& value) {
  set_has_topic_name();
  topic_name_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), value);
  // @@protoc_insertion_point(field_set:mw.internal.robotics.gazebotransport.SubscribeLaser.topic_name)
}
inline void SubscribeLaser::set_topic_name(const char* value) {
  set_has_topic_name();
  topic_name_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::string(value));
  // @@protoc_insertion_point(field_set_char:mw.internal.robotics.gazebotransport.SubscribeLaser.topic_name)
}
inline void SubscribeLaser::set_topic_name(const char* value, size_t size) {
  set_has_topic_name();
  topic_name_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(),
      ::std::string(reinterpret_cast<const char*>(value), size));
  // @@protoc_insertion_point(field_set_pointer:mw.internal.robotics.gazebotransport.SubscribeLaser.topic_name)
}
inline ::std::string* SubscribeLaser::mutable_topic_name() {
  set_has_topic_name();
  // @@protoc_insertion_point(field_mutable:mw.internal.robotics.gazebotransport.SubscribeLaser.topic_name)
  return topic_name_.MutableNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline ::std::string* SubscribeLaser::release_topic_name() {
  // @@protoc_insertion_point(field_release:mw.internal.robotics.gazebotransport.SubscribeLaser.topic_name)
  clear_has_topic_name();
  return topic_name_.ReleaseNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline void SubscribeLaser::set_allocated_topic_name(::std::string* topic_name) {
  if (topic_name != NULL) {
    set_has_topic_name();
  } else {
    clear_has_topic_name();
  }
  topic_name_.SetAllocatedNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), topic_name);
  // @@protoc_insertion_point(field_set_allocated:mw.internal.robotics.gazebotransport.SubscribeLaser.topic_name)
}

// -------------------------------------------------------------------

// SubscribeImu

// required string topic_name = 1;
inline bool SubscribeImu::has_topic_name() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void SubscribeImu::set_has_topic_name() {
  _has_bits_[0] |= 0x00000001u;
}
inline void SubscribeImu::clear_has_topic_name() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void SubscribeImu::clear_topic_name() {
  topic_name_.ClearToEmptyNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
  clear_has_topic_name();
}
inline const ::std::string& SubscribeImu::topic_name() const {
  // @@protoc_insertion_point(field_get:mw.internal.robotics.gazebotransport.SubscribeImu.topic_name)
  return topic_name_.GetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline void SubscribeImu::set_topic_name(const ::std::string& value) {
  set_has_topic_name();
  topic_name_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), value);
  // @@protoc_insertion_point(field_set:mw.internal.robotics.gazebotransport.SubscribeImu.topic_name)
}
inline void SubscribeImu::set_topic_name(const char* value) {
  set_has_topic_name();
  topic_name_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::string(value));
  // @@protoc_insertion_point(field_set_char:mw.internal.robotics.gazebotransport.SubscribeImu.topic_name)
}
inline void SubscribeImu::set_topic_name(const char* value, size_t size) {
  set_has_topic_name();
  topic_name_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(),
      ::std::string(reinterpret_cast<const char*>(value), size));
  // @@protoc_insertion_point(field_set_pointer:mw.internal.robotics.gazebotransport.SubscribeImu.topic_name)
}
inline ::std::string* SubscribeImu::mutable_topic_name() {
  set_has_topic_name();
  // @@protoc_insertion_point(field_mutable:mw.internal.robotics.gazebotransport.SubscribeImu.topic_name)
  return topic_name_.MutableNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline ::std::string* SubscribeImu::release_topic_name() {
  // @@protoc_insertion_point(field_release:mw.internal.robotics.gazebotransport.SubscribeImu.topic_name)
  clear_has_topic_name();
  return topic_name_.ReleaseNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline void SubscribeImu::set_allocated_topic_name(::std::string* topic_name) {
  if (topic_name != NULL) {
    set_has_topic_name();
  } else {
    clear_has_topic_name();
  }
  topic_name_.SetAllocatedNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), topic_name);
  // @@protoc_insertion_point(field_set_allocated:mw.internal.robotics.gazebotransport.SubscribeImu.topic_name)
}

// -------------------------------------------------------------------

// ApplyLinkWrench

// required string model_name = 1;
inline bool ApplyLinkWrench::has_model_name() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void ApplyLinkWrench::set_has_model_name() {
  _has_bits_[0] |= 0x00000001u;
}
inline void ApplyLinkWrench::clear_has_model_name() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void ApplyLinkWrench::clear_model_name() {
  model_name_.ClearToEmptyNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
  clear_has_model_name();
}
inline const ::std::string& ApplyLinkWrench::model_name() const {
  // @@protoc_insertion_point(field_get:mw.internal.robotics.gazebotransport.ApplyLinkWrench.model_name)
  return model_name_.GetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline void ApplyLinkWrench::set_model_name(const ::std::string& value) {
  set_has_model_name();
  model_name_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), value);
  // @@protoc_insertion_point(field_set:mw.internal.robotics.gazebotransport.ApplyLinkWrench.model_name)
}
inline void ApplyLinkWrench::set_model_name(const char* value) {
  set_has_model_name();
  model_name_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::string(value));
  // @@protoc_insertion_point(field_set_char:mw.internal.robotics.gazebotransport.ApplyLinkWrench.model_name)
}
inline void ApplyLinkWrench::set_model_name(const char* value, size_t size) {
  set_has_model_name();
  model_name_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(),
      ::std::string(reinterpret_cast<const char*>(value), size));
  // @@protoc_insertion_point(field_set_pointer:mw.internal.robotics.gazebotransport.ApplyLinkWrench.model_name)
}
inline ::std::string* ApplyLinkWrench::mutable_model_name() {
  set_has_model_name();
  // @@protoc_insertion_point(field_mutable:mw.internal.robotics.gazebotransport.ApplyLinkWrench.model_name)
  return model_name_.MutableNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline ::std::string* ApplyLinkWrench::release_model_name() {
  // @@protoc_insertion_point(field_release:mw.internal.robotics.gazebotransport.ApplyLinkWrench.model_name)
  clear_has_model_name();
  return model_name_.ReleaseNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline void ApplyLinkWrench::set_allocated_model_name(::std::string* model_name) {
  if (model_name != NULL) {
    set_has_model_name();
  } else {
    clear_has_model_name();
  }
  model_name_.SetAllocatedNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), model_name);
  // @@protoc_insertion_point(field_set_allocated:mw.internal.robotics.gazebotransport.ApplyLinkWrench.model_name)
}

// required string link_name = 2;
inline bool ApplyLinkWrench::has_link_name() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void ApplyLinkWrench::set_has_link_name() {
  _has_bits_[0] |= 0x00000002u;
}
inline void ApplyLinkWrench::clear_has_link_name() {
  _has_bits_[0] &= ~0x00000002u;
}
inline void ApplyLinkWrench::clear_link_name() {
  link_name_.ClearToEmptyNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
  clear_has_link_name();
}
inline const ::std::string& ApplyLinkWrench::link_name() const {
  // @@protoc_insertion_point(field_get:mw.internal.robotics.gazebotransport.ApplyLinkWrench.link_name)
  return link_name_.GetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline void ApplyLinkWrench::set_link_name(const ::std::string& value) {
  set_has_link_name();
  link_name_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), value);
  // @@protoc_insertion_point(field_set:mw.internal.robotics.gazebotransport.ApplyLinkWrench.link_name)
}
inline void ApplyLinkWrench::set_link_name(const char* value) {
  set_has_link_name();
  link_name_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::string(value));
  // @@protoc_insertion_point(field_set_char:mw.internal.robotics.gazebotransport.ApplyLinkWrench.link_name)
}
inline void ApplyLinkWrench::set_link_name(const char* value, size_t size) {
  set_has_link_name();
  link_name_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(),
      ::std::string(reinterpret_cast<const char*>(value), size));
  // @@protoc_insertion_point(field_set_pointer:mw.internal.robotics.gazebotransport.ApplyLinkWrench.link_name)
}
inline ::std::string* ApplyLinkWrench::mutable_link_name() {
  set_has_link_name();
  // @@protoc_insertion_point(field_mutable:mw.internal.robotics.gazebotransport.ApplyLinkWrench.link_name)
  return link_name_.MutableNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline ::std::string* ApplyLinkWrench::release_link_name() {
  // @@protoc_insertion_point(field_release:mw.internal.robotics.gazebotransport.ApplyLinkWrench.link_name)
  clear_has_link_name();
  return link_name_.ReleaseNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline void ApplyLinkWrench::set_allocated_link_name(::std::string* link_name) {
  if (link_name != NULL) {
    set_has_link_name();
  } else {
    clear_has_link_name();
  }
  link_name_.SetAllocatedNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), link_name);
  // @@protoc_insertion_point(field_set_allocated:mw.internal.robotics.gazebotransport.ApplyLinkWrench.link_name)
}

// required string force_type = 3;
inline bool ApplyLinkWrench::has_force_type() const {
  return (_has_bits_[0] & 0x00000004u) != 0;
}
inline void ApplyLinkWrench::set_has_force_type() {
  _has_bits_[0] |= 0x00000004u;
}
inline void ApplyLinkWrench::clear_has_force_type() {
  _has_bits_[0] &= ~0x00000004u;
}
inline void ApplyLinkWrench::clear_force_type() {
  force_type_.ClearToEmptyNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
  clear_has_force_type();
}
inline const ::std::string& ApplyLinkWrench::force_type() const {
  // @@protoc_insertion_point(field_get:mw.internal.robotics.gazebotransport.ApplyLinkWrench.force_type)
  return force_type_.GetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline void ApplyLinkWrench::set_force_type(const ::std::string& value) {
  set_has_force_type();
  force_type_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), value);
  // @@protoc_insertion_point(field_set:mw.internal.robotics.gazebotransport.ApplyLinkWrench.force_type)
}
inline void ApplyLinkWrench::set_force_type(const char* value) {
  set_has_force_type();
  force_type_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::string(value));
  // @@protoc_insertion_point(field_set_char:mw.internal.robotics.gazebotransport.ApplyLinkWrench.force_type)
}
inline void ApplyLinkWrench::set_force_type(const char* value, size_t size) {
  set_has_force_type();
  force_type_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(),
      ::std::string(reinterpret_cast<const char*>(value), size));
  // @@protoc_insertion_point(field_set_pointer:mw.internal.robotics.gazebotransport.ApplyLinkWrench.force_type)
}
inline ::std::string* ApplyLinkWrench::mutable_force_type() {
  set_has_force_type();
  // @@protoc_insertion_point(field_mutable:mw.internal.robotics.gazebotransport.ApplyLinkWrench.force_type)
  return force_type_.MutableNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline ::std::string* ApplyLinkWrench::release_force_type() {
  // @@protoc_insertion_point(field_release:mw.internal.robotics.gazebotransport.ApplyLinkWrench.force_type)
  clear_has_force_type();
  return force_type_.ReleaseNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline void ApplyLinkWrench::set_allocated_force_type(::std::string* force_type) {
  if (force_type != NULL) {
    set_has_force_type();
  } else {
    clear_has_force_type();
  }
  force_type_.SetAllocatedNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), force_type);
  // @@protoc_insertion_point(field_set_allocated:mw.internal.robotics.gazebotransport.ApplyLinkWrench.force_type)
}

// required double fx = 4;
inline bool ApplyLinkWrench::has_fx() const {
  return (_has_bits_[0] & 0x00000008u) != 0;
}
inline void ApplyLinkWrench::set_has_fx() {
  _has_bits_[0] |= 0x00000008u;
}
inline void ApplyLinkWrench::clear_has_fx() {
  _has_bits_[0] &= ~0x00000008u;
}
inline void ApplyLinkWrench::clear_fx() {
  fx_ = 0;
  clear_has_fx();
}
inline double ApplyLinkWrench::fx() const {
  // @@protoc_insertion_point(field_get:mw.internal.robotics.gazebotransport.ApplyLinkWrench.fx)
  return fx_;
}
inline void ApplyLinkWrench::set_fx(double value) {
  set_has_fx();
  fx_ = value;
  // @@protoc_insertion_point(field_set:mw.internal.robotics.gazebotransport.ApplyLinkWrench.fx)
}

// required double fy = 5;
inline bool ApplyLinkWrench::has_fy() const {
  return (_has_bits_[0] & 0x00000010u) != 0;
}
inline void ApplyLinkWrench::set_has_fy() {
  _has_bits_[0] |= 0x00000010u;
}
inline void ApplyLinkWrench::clear_has_fy() {
  _has_bits_[0] &= ~0x00000010u;
}
inline void ApplyLinkWrench::clear_fy() {
  fy_ = 0;
  clear_has_fy();
}
inline double ApplyLinkWrench::fy() const {
  // @@protoc_insertion_point(field_get:mw.internal.robotics.gazebotransport.ApplyLinkWrench.fy)
  return fy_;
}
inline void ApplyLinkWrench::set_fy(double value) {
  set_has_fy();
  fy_ = value;
  // @@protoc_insertion_point(field_set:mw.internal.robotics.gazebotransport.ApplyLinkWrench.fy)
}

// required double fz = 6;
inline bool ApplyLinkWrench::has_fz() const {
  return (_has_bits_[0] & 0x00000020u) != 0;
}
inline void ApplyLinkWrench::set_has_fz() {
  _has_bits_[0] |= 0x00000020u;
}
inline void ApplyLinkWrench::clear_has_fz() {
  _has_bits_[0] &= ~0x00000020u;
}
inline void ApplyLinkWrench::clear_fz() {
  fz_ = 0;
  clear_has_fz();
}
inline double ApplyLinkWrench::fz() const {
  // @@protoc_insertion_point(field_get:mw.internal.robotics.gazebotransport.ApplyLinkWrench.fz)
  return fz_;
}
inline void ApplyLinkWrench::set_fz(double value) {
  set_has_fz();
  fz_ = value;
  // @@protoc_insertion_point(field_set:mw.internal.robotics.gazebotransport.ApplyLinkWrench.fz)
}

// required string torque_type = 7;
inline bool ApplyLinkWrench::has_torque_type() const {
  return (_has_bits_[0] & 0x00000040u) != 0;
}
inline void ApplyLinkWrench::set_has_torque_type() {
  _has_bits_[0] |= 0x00000040u;
}
inline void ApplyLinkWrench::clear_has_torque_type() {
  _has_bits_[0] &= ~0x00000040u;
}
inline void ApplyLinkWrench::clear_torque_type() {
  torque_type_.ClearToEmptyNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
  clear_has_torque_type();
}
inline const ::std::string& ApplyLinkWrench::torque_type() const {
  // @@protoc_insertion_point(field_get:mw.internal.robotics.gazebotransport.ApplyLinkWrench.torque_type)
  return torque_type_.GetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline void ApplyLinkWrench::set_torque_type(const ::std::string& value) {
  set_has_torque_type();
  torque_type_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), value);
  // @@protoc_insertion_point(field_set:mw.internal.robotics.gazebotransport.ApplyLinkWrench.torque_type)
}
inline void ApplyLinkWrench::set_torque_type(const char* value) {
  set_has_torque_type();
  torque_type_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::string(value));
  // @@protoc_insertion_point(field_set_char:mw.internal.robotics.gazebotransport.ApplyLinkWrench.torque_type)
}
inline void ApplyLinkWrench::set_torque_type(const char* value, size_t size) {
  set_has_torque_type();
  torque_type_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(),
      ::std::string(reinterpret_cast<const char*>(value), size));
  // @@protoc_insertion_point(field_set_pointer:mw.internal.robotics.gazebotransport.ApplyLinkWrench.torque_type)
}
inline ::std::string* ApplyLinkWrench::mutable_torque_type() {
  set_has_torque_type();
  // @@protoc_insertion_point(field_mutable:mw.internal.robotics.gazebotransport.ApplyLinkWrench.torque_type)
  return torque_type_.MutableNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline ::std::string* ApplyLinkWrench::release_torque_type() {
  // @@protoc_insertion_point(field_release:mw.internal.robotics.gazebotransport.ApplyLinkWrench.torque_type)
  clear_has_torque_type();
  return torque_type_.ReleaseNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline void ApplyLinkWrench::set_allocated_torque_type(::std::string* torque_type) {
  if (torque_type != NULL) {
    set_has_torque_type();
  } else {
    clear_has_torque_type();
  }
  torque_type_.SetAllocatedNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), torque_type);
  // @@protoc_insertion_point(field_set_allocated:mw.internal.robotics.gazebotransport.ApplyLinkWrench.torque_type)
}

// required double tx = 8;
inline bool ApplyLinkWrench::has_tx() const {
  return (_has_bits_[0] & 0x00000080u) != 0;
}
inline void ApplyLinkWrench::set_has_tx() {
  _has_bits_[0] |= 0x00000080u;
}
inline void ApplyLinkWrench::clear_has_tx() {
  _has_bits_[0] &= ~0x00000080u;
}
inline void ApplyLinkWrench::clear_tx() {
  tx_ = 0;
  clear_has_tx();
}
inline double ApplyLinkWrench::tx() const {
  // @@protoc_insertion_point(field_get:mw.internal.robotics.gazebotransport.ApplyLinkWrench.tx)
  return tx_;
}
inline void ApplyLinkWrench::set_tx(double value) {
  set_has_tx();
  tx_ = value;
  // @@protoc_insertion_point(field_set:mw.internal.robotics.gazebotransport.ApplyLinkWrench.tx)
}

// required double ty = 9;
inline bool ApplyLinkWrench::has_ty() const {
  return (_has_bits_[0] & 0x00000100u) != 0;
}
inline void ApplyLinkWrench::set_has_ty() {
  _has_bits_[0] |= 0x00000100u;
}
inline void ApplyLinkWrench::clear_has_ty() {
  _has_bits_[0] &= ~0x00000100u;
}
inline void ApplyLinkWrench::clear_ty() {
  ty_ = 0;
  clear_has_ty();
}
inline double ApplyLinkWrench::ty() const {
  // @@protoc_insertion_point(field_get:mw.internal.robotics.gazebotransport.ApplyLinkWrench.ty)
  return ty_;
}
inline void ApplyLinkWrench::set_ty(double value) {
  set_has_ty();
  ty_ = value;
  // @@protoc_insertion_point(field_set:mw.internal.robotics.gazebotransport.ApplyLinkWrench.ty)
}

// required double tz = 10;
inline bool ApplyLinkWrench::has_tz() const {
  return (_has_bits_[0] & 0x00000200u) != 0;
}
inline void ApplyLinkWrench::set_has_tz() {
  _has_bits_[0] |= 0x00000200u;
}
inline void ApplyLinkWrench::clear_has_tz() {
  _has_bits_[0] &= ~0x00000200u;
}
inline void ApplyLinkWrench::clear_tz() {
  tz_ = 0;
  clear_has_tz();
}
inline double ApplyLinkWrench::tz() const {
  // @@protoc_insertion_point(field_get:mw.internal.robotics.gazebotransport.ApplyLinkWrench.tz)
  return tz_;
}
inline void ApplyLinkWrench::set_tz(double value) {
  set_has_tz();
  tz_ = value;
  // @@protoc_insertion_point(field_set:mw.internal.robotics.gazebotransport.ApplyLinkWrench.tz)
}

// required .mw.internal.robotics.gazebotransport.Time duration = 11;
inline bool ApplyLinkWrench::has_duration() const {
  return (_has_bits_[0] & 0x00000400u) != 0;
}
inline void ApplyLinkWrench::set_has_duration() {
  _has_bits_[0] |= 0x00000400u;
}
inline void ApplyLinkWrench::clear_has_duration() {
  _has_bits_[0] &= ~0x00000400u;
}
inline void ApplyLinkWrench::clear_duration() {
  if (duration_ != NULL) duration_->::mw::internal::robotics::gazebotransport::Time::Clear();
  clear_has_duration();
}
inline const ::mw::internal::robotics::gazebotransport::Time& ApplyLinkWrench::duration() const {
  // @@protoc_insertion_point(field_get:mw.internal.robotics.gazebotransport.ApplyLinkWrench.duration)
  return duration_ != NULL ? *duration_ : *default_instance_->duration_;
}
inline ::mw::internal::robotics::gazebotransport::Time* ApplyLinkWrench::mutable_duration() {
  set_has_duration();
  if (duration_ == NULL) {
    duration_ = new ::mw::internal::robotics::gazebotransport::Time;
  }
  // @@protoc_insertion_point(field_mutable:mw.internal.robotics.gazebotransport.ApplyLinkWrench.duration)
  return duration_;
}
inline ::mw::internal::robotics::gazebotransport::Time* ApplyLinkWrench::release_duration() {
  // @@protoc_insertion_point(field_release:mw.internal.robotics.gazebotransport.ApplyLinkWrench.duration)
  clear_has_duration();
  ::mw::internal::robotics::gazebotransport::Time* temp = duration_;
  duration_ = NULL;
  return temp;
}
inline void ApplyLinkWrench::set_allocated_duration(::mw::internal::robotics::gazebotransport::Time* duration) {
  delete duration_;
  duration_ = duration;
  if (duration) {
    set_has_duration();
  } else {
    clear_has_duration();
  }
  // @@protoc_insertion_point(field_set_allocated:mw.internal.robotics.gazebotransport.ApplyLinkWrench.duration)
}

// -------------------------------------------------------------------

// ApplyJointTorque

// required string model_name = 1;
inline bool ApplyJointTorque::has_model_name() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void ApplyJointTorque::set_has_model_name() {
  _has_bits_[0] |= 0x00000001u;
}
inline void ApplyJointTorque::clear_has_model_name() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void ApplyJointTorque::clear_model_name() {
  model_name_.ClearToEmptyNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
  clear_has_model_name();
}
inline const ::std::string& ApplyJointTorque::model_name() const {
  // @@protoc_insertion_point(field_get:mw.internal.robotics.gazebotransport.ApplyJointTorque.model_name)
  return model_name_.GetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline void ApplyJointTorque::set_model_name(const ::std::string& value) {
  set_has_model_name();
  model_name_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), value);
  // @@protoc_insertion_point(field_set:mw.internal.robotics.gazebotransport.ApplyJointTorque.model_name)
}
inline void ApplyJointTorque::set_model_name(const char* value) {
  set_has_model_name();
  model_name_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::string(value));
  // @@protoc_insertion_point(field_set_char:mw.internal.robotics.gazebotransport.ApplyJointTorque.model_name)
}
inline void ApplyJointTorque::set_model_name(const char* value, size_t size) {
  set_has_model_name();
  model_name_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(),
      ::std::string(reinterpret_cast<const char*>(value), size));
  // @@protoc_insertion_point(field_set_pointer:mw.internal.robotics.gazebotransport.ApplyJointTorque.model_name)
}
inline ::std::string* ApplyJointTorque::mutable_model_name() {
  set_has_model_name();
  // @@protoc_insertion_point(field_mutable:mw.internal.robotics.gazebotransport.ApplyJointTorque.model_name)
  return model_name_.MutableNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline ::std::string* ApplyJointTorque::release_model_name() {
  // @@protoc_insertion_point(field_release:mw.internal.robotics.gazebotransport.ApplyJointTorque.model_name)
  clear_has_model_name();
  return model_name_.ReleaseNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline void ApplyJointTorque::set_allocated_model_name(::std::string* model_name) {
  if (model_name != NULL) {
    set_has_model_name();
  } else {
    clear_has_model_name();
  }
  model_name_.SetAllocatedNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), model_name);
  // @@protoc_insertion_point(field_set_allocated:mw.internal.robotics.gazebotransport.ApplyJointTorque.model_name)
}

// required string joint_name = 2;
inline bool ApplyJointTorque::has_joint_name() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void ApplyJointTorque::set_has_joint_name() {
  _has_bits_[0] |= 0x00000002u;
}
inline void ApplyJointTorque::clear_has_joint_name() {
  _has_bits_[0] &= ~0x00000002u;
}
inline void ApplyJointTorque::clear_joint_name() {
  joint_name_.ClearToEmptyNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
  clear_has_joint_name();
}
inline const ::std::string& ApplyJointTorque::joint_name() const {
  // @@protoc_insertion_point(field_get:mw.internal.robotics.gazebotransport.ApplyJointTorque.joint_name)
  return joint_name_.GetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline void ApplyJointTorque::set_joint_name(const ::std::string& value) {
  set_has_joint_name();
  joint_name_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), value);
  // @@protoc_insertion_point(field_set:mw.internal.robotics.gazebotransport.ApplyJointTorque.joint_name)
}
inline void ApplyJointTorque::set_joint_name(const char* value) {
  set_has_joint_name();
  joint_name_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::string(value));
  // @@protoc_insertion_point(field_set_char:mw.internal.robotics.gazebotransport.ApplyJointTorque.joint_name)
}
inline void ApplyJointTorque::set_joint_name(const char* value, size_t size) {
  set_has_joint_name();
  joint_name_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(),
      ::std::string(reinterpret_cast<const char*>(value), size));
  // @@protoc_insertion_point(field_set_pointer:mw.internal.robotics.gazebotransport.ApplyJointTorque.joint_name)
}
inline ::std::string* ApplyJointTorque::mutable_joint_name() {
  set_has_joint_name();
  // @@protoc_insertion_point(field_mutable:mw.internal.robotics.gazebotransport.ApplyJointTorque.joint_name)
  return joint_name_.MutableNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline ::std::string* ApplyJointTorque::release_joint_name() {
  // @@protoc_insertion_point(field_release:mw.internal.robotics.gazebotransport.ApplyJointTorque.joint_name)
  clear_has_joint_name();
  return joint_name_.ReleaseNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline void ApplyJointTorque::set_allocated_joint_name(::std::string* joint_name) {
  if (joint_name != NULL) {
    set_has_joint_name();
  } else {
    clear_has_joint_name();
  }
  joint_name_.SetAllocatedNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), joint_name);
  // @@protoc_insertion_point(field_set_allocated:mw.internal.robotics.gazebotransport.ApplyJointTorque.joint_name)
}

// required uint32 index = 3;
inline bool ApplyJointTorque::has_index() const {
  return (_has_bits_[0] & 0x00000004u) != 0;
}
inline void ApplyJointTorque::set_has_index() {
  _has_bits_[0] |= 0x00000004u;
}
inline void ApplyJointTorque::clear_has_index() {
  _has_bits_[0] &= ~0x00000004u;
}
inline void ApplyJointTorque::clear_index() {
  index_ = 0u;
  clear_has_index();
}
inline ::google::protobuf::uint32 ApplyJointTorque::index() const {
  // @@protoc_insertion_point(field_get:mw.internal.robotics.gazebotransport.ApplyJointTorque.index)
  return index_;
}
inline void ApplyJointTorque::set_index(::google::protobuf::uint32 value) {
  set_has_index();
  index_ = value;
  // @@protoc_insertion_point(field_set:mw.internal.robotics.gazebotransport.ApplyJointTorque.index)
}

// required double effort = 4;
inline bool ApplyJointTorque::has_effort() const {
  return (_has_bits_[0] & 0x00000008u) != 0;
}
inline void ApplyJointTorque::set_has_effort() {
  _has_bits_[0] |= 0x00000008u;
}
inline void ApplyJointTorque::clear_has_effort() {
  _has_bits_[0] &= ~0x00000008u;
}
inline void ApplyJointTorque::clear_effort() {
  effort_ = 0;
  clear_has_effort();
}
inline double ApplyJointTorque::effort() const {
  // @@protoc_insertion_point(field_get:mw.internal.robotics.gazebotransport.ApplyJointTorque.effort)
  return effort_;
}
inline void ApplyJointTorque::set_effort(double value) {
  set_has_effort();
  effort_ = value;
  // @@protoc_insertion_point(field_set:mw.internal.robotics.gazebotransport.ApplyJointTorque.effort)
}

// required .mw.internal.robotics.gazebotransport.Time duration = 5;
inline bool ApplyJointTorque::has_duration() const {
  return (_has_bits_[0] & 0x00000010u) != 0;
}
inline void ApplyJointTorque::set_has_duration() {
  _has_bits_[0] |= 0x00000010u;
}
inline void ApplyJointTorque::clear_has_duration() {
  _has_bits_[0] &= ~0x00000010u;
}
inline void ApplyJointTorque::clear_duration() {
  if (duration_ != NULL) duration_->::mw::internal::robotics::gazebotransport::Time::Clear();
  clear_has_duration();
}
inline const ::mw::internal::robotics::gazebotransport::Time& ApplyJointTorque::duration() const {
  // @@protoc_insertion_point(field_get:mw.internal.robotics.gazebotransport.ApplyJointTorque.duration)
  return duration_ != NULL ? *duration_ : *default_instance_->duration_;
}
inline ::mw::internal::robotics::gazebotransport::Time* ApplyJointTorque::mutable_duration() {
  set_has_duration();
  if (duration_ == NULL) {
    duration_ = new ::mw::internal::robotics::gazebotransport::Time;
  }
  // @@protoc_insertion_point(field_mutable:mw.internal.robotics.gazebotransport.ApplyJointTorque.duration)
  return duration_;
}
inline ::mw::internal::robotics::gazebotransport::Time* ApplyJointTorque::release_duration() {
  // @@protoc_insertion_point(field_release:mw.internal.robotics.gazebotransport.ApplyJointTorque.duration)
  clear_has_duration();
  ::mw::internal::robotics::gazebotransport::Time* temp = duration_;
  duration_ = NULL;
  return temp;
}
inline void ApplyJointTorque::set_allocated_duration(::mw::internal::robotics::gazebotransport::Time* duration) {
  delete duration_;
  duration_ = duration;
  if (duration) {
    set_has_duration();
  } else {
    clear_has_duration();
  }
  // @@protoc_insertion_point(field_set_allocated:mw.internal.robotics.gazebotransport.ApplyJointTorque.duration)
}

// -------------------------------------------------------------------

// GetPose

// required string model_name = 1;
inline bool GetPose::has_model_name() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void GetPose::set_has_model_name() {
  _has_bits_[0] |= 0x00000001u;
}
inline void GetPose::clear_has_model_name() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void GetPose::clear_model_name() {
  model_name_.ClearToEmptyNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
  clear_has_model_name();
}
inline const ::std::string& GetPose::model_name() const {
  // @@protoc_insertion_point(field_get:mw.internal.robotics.gazebotransport.GetPose.model_name)
  return model_name_.GetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline void GetPose::set_model_name(const ::std::string& value) {
  set_has_model_name();
  model_name_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), value);
  // @@protoc_insertion_point(field_set:mw.internal.robotics.gazebotransport.GetPose.model_name)
}
inline void GetPose::set_model_name(const char* value) {
  set_has_model_name();
  model_name_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::string(value));
  // @@protoc_insertion_point(field_set_char:mw.internal.robotics.gazebotransport.GetPose.model_name)
}
inline void GetPose::set_model_name(const char* value, size_t size) {
  set_has_model_name();
  model_name_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(),
      ::std::string(reinterpret_cast<const char*>(value), size));
  // @@protoc_insertion_point(field_set_pointer:mw.internal.robotics.gazebotransport.GetPose.model_name)
}
inline ::std::string* GetPose::mutable_model_name() {
  set_has_model_name();
  // @@protoc_insertion_point(field_mutable:mw.internal.robotics.gazebotransport.GetPose.model_name)
  return model_name_.MutableNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline ::std::string* GetPose::release_model_name() {
  // @@protoc_insertion_point(field_release:mw.internal.robotics.gazebotransport.GetPose.model_name)
  clear_has_model_name();
  return model_name_.ReleaseNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline void GetPose::set_allocated_model_name(::std::string* model_name) {
  if (model_name != NULL) {
    set_has_model_name();
  } else {
    clear_has_model_name();
  }
  model_name_.SetAllocatedNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), model_name);
  // @@protoc_insertion_point(field_set_allocated:mw.internal.robotics.gazebotransport.GetPose.model_name)
}

// -------------------------------------------------------------------

// GetTopicList

// required string topic_name = 1;
inline bool GetTopicList::has_topic_name() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void GetTopicList::set_has_topic_name() {
  _has_bits_[0] |= 0x00000001u;
}
inline void GetTopicList::clear_has_topic_name() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void GetTopicList::clear_topic_name() {
  topic_name_.ClearToEmptyNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
  clear_has_topic_name();
}
inline const ::std::string& GetTopicList::topic_name() const {
  // @@protoc_insertion_point(field_get:mw.internal.robotics.gazebotransport.GetTopicList.topic_name)
  return topic_name_.GetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline void GetTopicList::set_topic_name(const ::std::string& value) {
  set_has_topic_name();
  topic_name_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), value);
  // @@protoc_insertion_point(field_set:mw.internal.robotics.gazebotransport.GetTopicList.topic_name)
}
inline void GetTopicList::set_topic_name(const char* value) {
  set_has_topic_name();
  topic_name_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::string(value));
  // @@protoc_insertion_point(field_set_char:mw.internal.robotics.gazebotransport.GetTopicList.topic_name)
}
inline void GetTopicList::set_topic_name(const char* value, size_t size) {
  set_has_topic_name();
  topic_name_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(),
      ::std::string(reinterpret_cast<const char*>(value), size));
  // @@protoc_insertion_point(field_set_pointer:mw.internal.robotics.gazebotransport.GetTopicList.topic_name)
}
inline ::std::string* GetTopicList::mutable_topic_name() {
  set_has_topic_name();
  // @@protoc_insertion_point(field_mutable:mw.internal.robotics.gazebotransport.GetTopicList.topic_name)
  return topic_name_.MutableNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline ::std::string* GetTopicList::release_topic_name() {
  // @@protoc_insertion_point(field_release:mw.internal.robotics.gazebotransport.GetTopicList.topic_name)
  clear_has_topic_name();
  return topic_name_.ReleaseNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline void GetTopicList::set_allocated_topic_name(::std::string* topic_name) {
  if (topic_name != NULL) {
    set_has_topic_name();
  } else {
    clear_has_topic_name();
  }
  topic_name_.SetAllocatedNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), topic_name);
  // @@protoc_insertion_point(field_set_allocated:mw.internal.robotics.gazebotransport.GetTopicList.topic_name)
}

// -------------------------------------------------------------------

// TopicList_TopicInfo

// required string name = 1;
inline bool TopicList_TopicInfo::has_name() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void TopicList_TopicInfo::set_has_name() {
  _has_bits_[0] |= 0x00000001u;
}
inline void TopicList_TopicInfo::clear_has_name() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void TopicList_TopicInfo::clear_name() {
  name_.ClearToEmptyNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
  clear_has_name();
}
inline const ::std::string& TopicList_TopicInfo::name() const {
  // @@protoc_insertion_point(field_get:mw.internal.robotics.gazebotransport.TopicList.TopicInfo.name)
  return name_.GetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline void TopicList_TopicInfo::set_name(const ::std::string& value) {
  set_has_name();
  name_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), value);
  // @@protoc_insertion_point(field_set:mw.internal.robotics.gazebotransport.TopicList.TopicInfo.name)
}
inline void TopicList_TopicInfo::set_name(const char* value) {
  set_has_name();
  name_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::string(value));
  // @@protoc_insertion_point(field_set_char:mw.internal.robotics.gazebotransport.TopicList.TopicInfo.name)
}
inline void TopicList_TopicInfo::set_name(const char* value, size_t size) {
  set_has_name();
  name_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(),
      ::std::string(reinterpret_cast<const char*>(value), size));
  // @@protoc_insertion_point(field_set_pointer:mw.internal.robotics.gazebotransport.TopicList.TopicInfo.name)
}
inline ::std::string* TopicList_TopicInfo::mutable_name() {
  set_has_name();
  // @@protoc_insertion_point(field_mutable:mw.internal.robotics.gazebotransport.TopicList.TopicInfo.name)
  return name_.MutableNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline ::std::string* TopicList_TopicInfo::release_name() {
  // @@protoc_insertion_point(field_release:mw.internal.robotics.gazebotransport.TopicList.TopicInfo.name)
  clear_has_name();
  return name_.ReleaseNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline void TopicList_TopicInfo::set_allocated_name(::std::string* name) {
  if (name != NULL) {
    set_has_name();
  } else {
    clear_has_name();
  }
  name_.SetAllocatedNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), name);
  // @@protoc_insertion_point(field_set_allocated:mw.internal.robotics.gazebotransport.TopicList.TopicInfo.name)
}

// required string type = 2;
inline bool TopicList_TopicInfo::has_type() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void TopicList_TopicInfo::set_has_type() {
  _has_bits_[0] |= 0x00000002u;
}
inline void TopicList_TopicInfo::clear_has_type() {
  _has_bits_[0] &= ~0x00000002u;
}
inline void TopicList_TopicInfo::clear_type() {
  type_.ClearToEmptyNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
  clear_has_type();
}
inline const ::std::string& TopicList_TopicInfo::type() const {
  // @@protoc_insertion_point(field_get:mw.internal.robotics.gazebotransport.TopicList.TopicInfo.type)
  return type_.GetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline void TopicList_TopicInfo::set_type(const ::std::string& value) {
  set_has_type();
  type_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), value);
  // @@protoc_insertion_point(field_set:mw.internal.robotics.gazebotransport.TopicList.TopicInfo.type)
}
inline void TopicList_TopicInfo::set_type(const char* value) {
  set_has_type();
  type_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::string(value));
  // @@protoc_insertion_point(field_set_char:mw.internal.robotics.gazebotransport.TopicList.TopicInfo.type)
}
inline void TopicList_TopicInfo::set_type(const char* value, size_t size) {
  set_has_type();
  type_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(),
      ::std::string(reinterpret_cast<const char*>(value), size));
  // @@protoc_insertion_point(field_set_pointer:mw.internal.robotics.gazebotransport.TopicList.TopicInfo.type)
}
inline ::std::string* TopicList_TopicInfo::mutable_type() {
  set_has_type();
  // @@protoc_insertion_point(field_mutable:mw.internal.robotics.gazebotransport.TopicList.TopicInfo.type)
  return type_.MutableNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline ::std::string* TopicList_TopicInfo::release_type() {
  // @@protoc_insertion_point(field_release:mw.internal.robotics.gazebotransport.TopicList.TopicInfo.type)
  clear_has_type();
  return type_.ReleaseNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline void TopicList_TopicInfo::set_allocated_type(::std::string* type) {
  if (type != NULL) {
    set_has_type();
  } else {
    clear_has_type();
  }
  type_.SetAllocatedNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), type);
  // @@protoc_insertion_point(field_set_allocated:mw.internal.robotics.gazebotransport.TopicList.TopicInfo.type)
}

// -------------------------------------------------------------------

// TopicList

// repeated .mw.internal.robotics.gazebotransport.TopicList.TopicInfo data = 1;
inline int TopicList::data_size() const {
  return data_.size();
}
inline void TopicList::clear_data() {
  data_.Clear();
}
inline const ::mw::internal::robotics::gazebotransport::TopicList_TopicInfo& TopicList::data(int index) const {
  // @@protoc_insertion_point(field_get:mw.internal.robotics.gazebotransport.TopicList.data)
  return data_.Get(index);
}
inline ::mw::internal::robotics::gazebotransport::TopicList_TopicInfo* TopicList::mutable_data(int index) {
  // @@protoc_insertion_point(field_mutable:mw.internal.robotics.gazebotransport.TopicList.data)
  return data_.Mutable(index);
}
inline ::mw::internal::robotics::gazebotransport::TopicList_TopicInfo* TopicList::add_data() {
  // @@protoc_insertion_point(field_add:mw.internal.robotics.gazebotransport.TopicList.data)
  return data_.Add();
}
inline ::google::protobuf::RepeatedPtrField< ::mw::internal::robotics::gazebotransport::TopicList_TopicInfo >*
TopicList::mutable_data() {
  // @@protoc_insertion_point(field_mutable_list:mw.internal.robotics.gazebotransport.TopicList.data)
  return &data_;
}
inline const ::google::protobuf::RepeatedPtrField< ::mw::internal::robotics::gazebotransport::TopicList_TopicInfo >&
TopicList::data() const {
  // @@protoc_insertion_point(field_list:mw.internal.robotics.gazebotransport.TopicList.data)
  return data_;
}

// -------------------------------------------------------------------

// GetModelInfo

// required string topic_name = 1;
inline bool GetModelInfo::has_topic_name() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void GetModelInfo::set_has_topic_name() {
  _has_bits_[0] |= 0x00000001u;
}
inline void GetModelInfo::clear_has_topic_name() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void GetModelInfo::clear_topic_name() {
  topic_name_.ClearToEmptyNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
  clear_has_topic_name();
}
inline const ::std::string& GetModelInfo::topic_name() const {
  // @@protoc_insertion_point(field_get:mw.internal.robotics.gazebotransport.GetModelInfo.topic_name)
  return topic_name_.GetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline void GetModelInfo::set_topic_name(const ::std::string& value) {
  set_has_topic_name();
  topic_name_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), value);
  // @@protoc_insertion_point(field_set:mw.internal.robotics.gazebotransport.GetModelInfo.topic_name)
}
inline void GetModelInfo::set_topic_name(const char* value) {
  set_has_topic_name();
  topic_name_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::string(value));
  // @@protoc_insertion_point(field_set_char:mw.internal.robotics.gazebotransport.GetModelInfo.topic_name)
}
inline void GetModelInfo::set_topic_name(const char* value, size_t size) {
  set_has_topic_name();
  topic_name_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(),
      ::std::string(reinterpret_cast<const char*>(value), size));
  // @@protoc_insertion_point(field_set_pointer:mw.internal.robotics.gazebotransport.GetModelInfo.topic_name)
}
inline ::std::string* GetModelInfo::mutable_topic_name() {
  set_has_topic_name();
  // @@protoc_insertion_point(field_mutable:mw.internal.robotics.gazebotransport.GetModelInfo.topic_name)
  return topic_name_.MutableNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline ::std::string* GetModelInfo::release_topic_name() {
  // @@protoc_insertion_point(field_release:mw.internal.robotics.gazebotransport.GetModelInfo.topic_name)
  clear_has_topic_name();
  return topic_name_.ReleaseNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline void GetModelInfo::set_allocated_topic_name(::std::string* topic_name) {
  if (topic_name != NULL) {
    set_has_topic_name();
  } else {
    clear_has_topic_name();
  }
  topic_name_.SetAllocatedNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), topic_name);
  // @@protoc_insertion_point(field_set_allocated:mw.internal.robotics.gazebotransport.GetModelInfo.topic_name)
}

// -------------------------------------------------------------------

// ModelInfo_LINKS

// repeated string link_name = 1;
inline int ModelInfo_LINKS::link_name_size() const {
  return link_name_.size();
}
inline void ModelInfo_LINKS::clear_link_name() {
  link_name_.Clear();
}
inline const ::std::string& ModelInfo_LINKS::link_name(int index) const {
  // @@protoc_insertion_point(field_get:mw.internal.robotics.gazebotransport.ModelInfo.LINKS.link_name)
  return link_name_.Get(index);
}
inline ::std::string* ModelInfo_LINKS::mutable_link_name(int index) {
  // @@protoc_insertion_point(field_mutable:mw.internal.robotics.gazebotransport.ModelInfo.LINKS.link_name)
  return link_name_.Mutable(index);
}
inline void ModelInfo_LINKS::set_link_name(int index, const ::std::string& value) {
  // @@protoc_insertion_point(field_set:mw.internal.robotics.gazebotransport.ModelInfo.LINKS.link_name)
  link_name_.Mutable(index)->assign(value);
}
inline void ModelInfo_LINKS::set_link_name(int index, const char* value) {
  link_name_.Mutable(index)->assign(value);
  // @@protoc_insertion_point(field_set_char:mw.internal.robotics.gazebotransport.ModelInfo.LINKS.link_name)
}
inline void ModelInfo_LINKS::set_link_name(int index, const char* value, size_t size) {
  link_name_.Mutable(index)->assign(
    reinterpret_cast<const char*>(value), size);
  // @@protoc_insertion_point(field_set_pointer:mw.internal.robotics.gazebotransport.ModelInfo.LINKS.link_name)
}
inline ::std::string* ModelInfo_LINKS::add_link_name() {
  // @@protoc_insertion_point(field_add_mutable:mw.internal.robotics.gazebotransport.ModelInfo.LINKS.link_name)
  return link_name_.Add();
}
inline void ModelInfo_LINKS::add_link_name(const ::std::string& value) {
  link_name_.Add()->assign(value);
  // @@protoc_insertion_point(field_add:mw.internal.robotics.gazebotransport.ModelInfo.LINKS.link_name)
}
inline void ModelInfo_LINKS::add_link_name(const char* value) {
  link_name_.Add()->assign(value);
  // @@protoc_insertion_point(field_add_char:mw.internal.robotics.gazebotransport.ModelInfo.LINKS.link_name)
}
inline void ModelInfo_LINKS::add_link_name(const char* value, size_t size) {
  link_name_.Add()->assign(reinterpret_cast<const char*>(value), size);
  // @@protoc_insertion_point(field_add_pointer:mw.internal.robotics.gazebotransport.ModelInfo.LINKS.link_name)
}
inline const ::google::protobuf::RepeatedPtrField< ::std::string>&
ModelInfo_LINKS::link_name() const {
  // @@protoc_insertion_point(field_list:mw.internal.robotics.gazebotransport.ModelInfo.LINKS.link_name)
  return link_name_;
}
inline ::google::protobuf::RepeatedPtrField< ::std::string>*
ModelInfo_LINKS::mutable_link_name() {
  // @@protoc_insertion_point(field_mutable_list:mw.internal.robotics.gazebotransport.ModelInfo.LINKS.link_name)
  return &link_name_;
}

// -------------------------------------------------------------------

// ModelInfo_JOINTS

// repeated string joint_name = 1;
inline int ModelInfo_JOINTS::joint_name_size() const {
  return joint_name_.size();
}
inline void ModelInfo_JOINTS::clear_joint_name() {
  joint_name_.Clear();
}
inline const ::std::string& ModelInfo_JOINTS::joint_name(int index) const {
  // @@protoc_insertion_point(field_get:mw.internal.robotics.gazebotransport.ModelInfo.JOINTS.joint_name)
  return joint_name_.Get(index);
}
inline ::std::string* ModelInfo_JOINTS::mutable_joint_name(int index) {
  // @@protoc_insertion_point(field_mutable:mw.internal.robotics.gazebotransport.ModelInfo.JOINTS.joint_name)
  return joint_name_.Mutable(index);
}
inline void ModelInfo_JOINTS::set_joint_name(int index, const ::std::string& value) {
  // @@protoc_insertion_point(field_set:mw.internal.robotics.gazebotransport.ModelInfo.JOINTS.joint_name)
  joint_name_.Mutable(index)->assign(value);
}
inline void ModelInfo_JOINTS::set_joint_name(int index, const char* value) {
  joint_name_.Mutable(index)->assign(value);
  // @@protoc_insertion_point(field_set_char:mw.internal.robotics.gazebotransport.ModelInfo.JOINTS.joint_name)
}
inline void ModelInfo_JOINTS::set_joint_name(int index, const char* value, size_t size) {
  joint_name_.Mutable(index)->assign(
    reinterpret_cast<const char*>(value), size);
  // @@protoc_insertion_point(field_set_pointer:mw.internal.robotics.gazebotransport.ModelInfo.JOINTS.joint_name)
}
inline ::std::string* ModelInfo_JOINTS::add_joint_name() {
  // @@protoc_insertion_point(field_add_mutable:mw.internal.robotics.gazebotransport.ModelInfo.JOINTS.joint_name)
  return joint_name_.Add();
}
inline void ModelInfo_JOINTS::add_joint_name(const ::std::string& value) {
  joint_name_.Add()->assign(value);
  // @@protoc_insertion_point(field_add:mw.internal.robotics.gazebotransport.ModelInfo.JOINTS.joint_name)
}
inline void ModelInfo_JOINTS::add_joint_name(const char* value) {
  joint_name_.Add()->assign(value);
  // @@protoc_insertion_point(field_add_char:mw.internal.robotics.gazebotransport.ModelInfo.JOINTS.joint_name)
}
inline void ModelInfo_JOINTS::add_joint_name(const char* value, size_t size) {
  joint_name_.Add()->assign(reinterpret_cast<const char*>(value), size);
  // @@protoc_insertion_point(field_add_pointer:mw.internal.robotics.gazebotransport.ModelInfo.JOINTS.joint_name)
}
inline const ::google::protobuf::RepeatedPtrField< ::std::string>&
ModelInfo_JOINTS::joint_name() const {
  // @@protoc_insertion_point(field_list:mw.internal.robotics.gazebotransport.ModelInfo.JOINTS.joint_name)
  return joint_name_;
}
inline ::google::protobuf::RepeatedPtrField< ::std::string>*
ModelInfo_JOINTS::mutable_joint_name() {
  // @@protoc_insertion_point(field_mutable_list:mw.internal.robotics.gazebotransport.ModelInfo.JOINTS.joint_name)
  return &joint_name_;
}

// -------------------------------------------------------------------

// ModelInfo_Model

// required string model_name = 1;
inline bool ModelInfo_Model::has_model_name() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void ModelInfo_Model::set_has_model_name() {
  _has_bits_[0] |= 0x00000001u;
}
inline void ModelInfo_Model::clear_has_model_name() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void ModelInfo_Model::clear_model_name() {
  model_name_.ClearToEmptyNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
  clear_has_model_name();
}
inline const ::std::string& ModelInfo_Model::model_name() const {
  // @@protoc_insertion_point(field_get:mw.internal.robotics.gazebotransport.ModelInfo.Model.model_name)
  return model_name_.GetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline void ModelInfo_Model::set_model_name(const ::std::string& value) {
  set_has_model_name();
  model_name_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), value);
  // @@protoc_insertion_point(field_set:mw.internal.robotics.gazebotransport.ModelInfo.Model.model_name)
}
inline void ModelInfo_Model::set_model_name(const char* value) {
  set_has_model_name();
  model_name_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::string(value));
  // @@protoc_insertion_point(field_set_char:mw.internal.robotics.gazebotransport.ModelInfo.Model.model_name)
}
inline void ModelInfo_Model::set_model_name(const char* value, size_t size) {
  set_has_model_name();
  model_name_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(),
      ::std::string(reinterpret_cast<const char*>(value), size));
  // @@protoc_insertion_point(field_set_pointer:mw.internal.robotics.gazebotransport.ModelInfo.Model.model_name)
}
inline ::std::string* ModelInfo_Model::mutable_model_name() {
  set_has_model_name();
  // @@protoc_insertion_point(field_mutable:mw.internal.robotics.gazebotransport.ModelInfo.Model.model_name)
  return model_name_.MutableNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline ::std::string* ModelInfo_Model::release_model_name() {
  // @@protoc_insertion_point(field_release:mw.internal.robotics.gazebotransport.ModelInfo.Model.model_name)
  clear_has_model_name();
  return model_name_.ReleaseNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline void ModelInfo_Model::set_allocated_model_name(::std::string* model_name) {
  if (model_name != NULL) {
    set_has_model_name();
  } else {
    clear_has_model_name();
  }
  model_name_.SetAllocatedNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), model_name);
  // @@protoc_insertion_point(field_set_allocated:mw.internal.robotics.gazebotransport.ModelInfo.Model.model_name)
}

// optional .mw.internal.robotics.gazebotransport.ModelInfo.LINKS links = 2;
inline bool ModelInfo_Model::has_links() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void ModelInfo_Model::set_has_links() {
  _has_bits_[0] |= 0x00000002u;
}
inline void ModelInfo_Model::clear_has_links() {
  _has_bits_[0] &= ~0x00000002u;
}
inline void ModelInfo_Model::clear_links() {
  if (links_ != NULL) links_->::mw::internal::robotics::gazebotransport::ModelInfo_LINKS::Clear();
  clear_has_links();
}
inline const ::mw::internal::robotics::gazebotransport::ModelInfo_LINKS& ModelInfo_Model::links() const {
  // @@protoc_insertion_point(field_get:mw.internal.robotics.gazebotransport.ModelInfo.Model.links)
  return links_ != NULL ? *links_ : *default_instance_->links_;
}
inline ::mw::internal::robotics::gazebotransport::ModelInfo_LINKS* ModelInfo_Model::mutable_links() {
  set_has_links();
  if (links_ == NULL) {
    links_ = new ::mw::internal::robotics::gazebotransport::ModelInfo_LINKS;
  }
  // @@protoc_insertion_point(field_mutable:mw.internal.robotics.gazebotransport.ModelInfo.Model.links)
  return links_;
}
inline ::mw::internal::robotics::gazebotransport::ModelInfo_LINKS* ModelInfo_Model::release_links() {
  // @@protoc_insertion_point(field_release:mw.internal.robotics.gazebotransport.ModelInfo.Model.links)
  clear_has_links();
  ::mw::internal::robotics::gazebotransport::ModelInfo_LINKS* temp = links_;
  links_ = NULL;
  return temp;
}
inline void ModelInfo_Model::set_allocated_links(::mw::internal::robotics::gazebotransport::ModelInfo_LINKS* links) {
  delete links_;
  links_ = links;
  if (links) {
    set_has_links();
  } else {
    clear_has_links();
  }
  // @@protoc_insertion_point(field_set_allocated:mw.internal.robotics.gazebotransport.ModelInfo.Model.links)
}

// optional .mw.internal.robotics.gazebotransport.ModelInfo.JOINTS joints = 3;
inline bool ModelInfo_Model::has_joints() const {
  return (_has_bits_[0] & 0x00000004u) != 0;
}
inline void ModelInfo_Model::set_has_joints() {
  _has_bits_[0] |= 0x00000004u;
}
inline void ModelInfo_Model::clear_has_joints() {
  _has_bits_[0] &= ~0x00000004u;
}
inline void ModelInfo_Model::clear_joints() {
  if (joints_ != NULL) joints_->::mw::internal::robotics::gazebotransport::ModelInfo_JOINTS::Clear();
  clear_has_joints();
}
inline const ::mw::internal::robotics::gazebotransport::ModelInfo_JOINTS& ModelInfo_Model::joints() const {
  // @@protoc_insertion_point(field_get:mw.internal.robotics.gazebotransport.ModelInfo.Model.joints)
  return joints_ != NULL ? *joints_ : *default_instance_->joints_;
}
inline ::mw::internal::robotics::gazebotransport::ModelInfo_JOINTS* ModelInfo_Model::mutable_joints() {
  set_has_joints();
  if (joints_ == NULL) {
    joints_ = new ::mw::internal::robotics::gazebotransport::ModelInfo_JOINTS;
  }
  // @@protoc_insertion_point(field_mutable:mw.internal.robotics.gazebotransport.ModelInfo.Model.joints)
  return joints_;
}
inline ::mw::internal::robotics::gazebotransport::ModelInfo_JOINTS* ModelInfo_Model::release_joints() {
  // @@protoc_insertion_point(field_release:mw.internal.robotics.gazebotransport.ModelInfo.Model.joints)
  clear_has_joints();
  ::mw::internal::robotics::gazebotransport::ModelInfo_JOINTS* temp = joints_;
  joints_ = NULL;
  return temp;
}
inline void ModelInfo_Model::set_allocated_joints(::mw::internal::robotics::gazebotransport::ModelInfo_JOINTS* joints) {
  delete joints_;
  joints_ = joints;
  if (joints) {
    set_has_joints();
  } else {
    clear_has_joints();
  }
  // @@protoc_insertion_point(field_set_allocated:mw.internal.robotics.gazebotransport.ModelInfo.Model.joints)
}

// -------------------------------------------------------------------

// ModelInfo

// repeated .mw.internal.robotics.gazebotransport.ModelInfo.Model model_data = 1;
inline int ModelInfo::model_data_size() const {
  return model_data_.size();
}
inline void ModelInfo::clear_model_data() {
  model_data_.Clear();
}
inline const ::mw::internal::robotics::gazebotransport::ModelInfo_Model& ModelInfo::model_data(int index) const {
  // @@protoc_insertion_point(field_get:mw.internal.robotics.gazebotransport.ModelInfo.model_data)
  return model_data_.Get(index);
}
inline ::mw::internal::robotics::gazebotransport::ModelInfo_Model* ModelInfo::mutable_model_data(int index) {
  // @@protoc_insertion_point(field_mutable:mw.internal.robotics.gazebotransport.ModelInfo.model_data)
  return model_data_.Mutable(index);
}
inline ::mw::internal::robotics::gazebotransport::ModelInfo_Model* ModelInfo::add_model_data() {
  // @@protoc_insertion_point(field_add:mw.internal.robotics.gazebotransport.ModelInfo.model_data)
  return model_data_.Add();
}
inline ::google::protobuf::RepeatedPtrField< ::mw::internal::robotics::gazebotransport::ModelInfo_Model >*
ModelInfo::mutable_model_data() {
  // @@protoc_insertion_point(field_mutable_list:mw.internal.robotics.gazebotransport.ModelInfo.model_data)
  return &model_data_;
}
inline const ::google::protobuf::RepeatedPtrField< ::mw::internal::robotics::gazebotransport::ModelInfo_Model >&
ModelInfo::model_data() const {
  // @@protoc_insertion_point(field_list:mw.internal.robotics.gazebotransport.ModelInfo.model_data)
  return model_data_;
}

// -------------------------------------------------------------------

// MaxStepSize

// required .mw.internal.robotics.gazebotransport.MaxStepSize.TYPE type = 1;
inline bool MaxStepSize::has_type() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void MaxStepSize::set_has_type() {
  _has_bits_[0] |= 0x00000001u;
}
inline void MaxStepSize::clear_has_type() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void MaxStepSize::clear_type() {
  type_ = 0;
  clear_has_type();
}
inline ::mw::internal::robotics::gazebotransport::MaxStepSize_TYPE MaxStepSize::type() const {
  // @@protoc_insertion_point(field_get:mw.internal.robotics.gazebotransport.MaxStepSize.type)
  return static_cast< ::mw::internal::robotics::gazebotransport::MaxStepSize_TYPE >(type_);
}
inline void MaxStepSize::set_type(::mw::internal::robotics::gazebotransport::MaxStepSize_TYPE value) {
  assert(::mw::internal::robotics::gazebotransport::MaxStepSize_TYPE_IsValid(value));
  set_has_type();
  type_ = value;
  // @@protoc_insertion_point(field_set:mw.internal.robotics.gazebotransport.MaxStepSize.type)
}

// required double size = 2;
inline bool MaxStepSize::has_size() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void MaxStepSize::set_has_size() {
  _has_bits_[0] |= 0x00000002u;
}
inline void MaxStepSize::clear_has_size() {
  _has_bits_[0] &= ~0x00000002u;
}
inline void MaxStepSize::clear_size() {
  size_ = 0;
  clear_has_size();
}
inline double MaxStepSize::size() const {
  // @@protoc_insertion_point(field_get:mw.internal.robotics.gazebotransport.MaxStepSize.size)
  return size_;
}
inline void MaxStepSize::set_size(double value) {
  set_has_size();
  size_ = value;
  // @@protoc_insertion_point(field_set:mw.internal.robotics.gazebotransport.MaxStepSize.size)
}

// -------------------------------------------------------------------

// InitCustomPublisher

// required string topic_name = 1;
inline bool InitCustomPublisher::has_topic_name() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void InitCustomPublisher::set_has_topic_name() {
  _has_bits_[0] |= 0x00000001u;
}
inline void InitCustomPublisher::clear_has_topic_name() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void InitCustomPublisher::clear_topic_name() {
  topic_name_.ClearToEmptyNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
  clear_has_topic_name();
}
inline const ::std::string& InitCustomPublisher::topic_name() const {
  // @@protoc_insertion_point(field_get:mw.internal.robotics.gazebotransport.InitCustomPublisher.topic_name)
  return topic_name_.GetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline void InitCustomPublisher::set_topic_name(const ::std::string& value) {
  set_has_topic_name();
  topic_name_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), value);
  // @@protoc_insertion_point(field_set:mw.internal.robotics.gazebotransport.InitCustomPublisher.topic_name)
}
inline void InitCustomPublisher::set_topic_name(const char* value) {
  set_has_topic_name();
  topic_name_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::string(value));
  // @@protoc_insertion_point(field_set_char:mw.internal.robotics.gazebotransport.InitCustomPublisher.topic_name)
}
inline void InitCustomPublisher::set_topic_name(const char* value, size_t size) {
  set_has_topic_name();
  topic_name_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(),
      ::std::string(reinterpret_cast<const char*>(value), size));
  // @@protoc_insertion_point(field_set_pointer:mw.internal.robotics.gazebotransport.InitCustomPublisher.topic_name)
}
inline ::std::string* InitCustomPublisher::mutable_topic_name() {
  set_has_topic_name();
  // @@protoc_insertion_point(field_mutable:mw.internal.robotics.gazebotransport.InitCustomPublisher.topic_name)
  return topic_name_.MutableNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline ::std::string* InitCustomPublisher::release_topic_name() {
  // @@protoc_insertion_point(field_release:mw.internal.robotics.gazebotransport.InitCustomPublisher.topic_name)
  clear_has_topic_name();
  return topic_name_.ReleaseNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline void InitCustomPublisher::set_allocated_topic_name(::std::string* topic_name) {
  if (topic_name != NULL) {
    set_has_topic_name();
  } else {
    clear_has_topic_name();
  }
  topic_name_.SetAllocatedNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), topic_name);
  // @@protoc_insertion_point(field_set_allocated:mw.internal.robotics.gazebotransport.InitCustomPublisher.topic_name)
}

// required string message_type = 2;
inline bool InitCustomPublisher::has_message_type() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void InitCustomPublisher::set_has_message_type() {
  _has_bits_[0] |= 0x00000002u;
}
inline void InitCustomPublisher::clear_has_message_type() {
  _has_bits_[0] &= ~0x00000002u;
}
inline void InitCustomPublisher::clear_message_type() {
  message_type_.ClearToEmptyNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
  clear_has_message_type();
}
inline const ::std::string& InitCustomPublisher::message_type() const {
  // @@protoc_insertion_point(field_get:mw.internal.robotics.gazebotransport.InitCustomPublisher.message_type)
  return message_type_.GetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline void InitCustomPublisher::set_message_type(const ::std::string& value) {
  set_has_message_type();
  message_type_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), value);
  // @@protoc_insertion_point(field_set:mw.internal.robotics.gazebotransport.InitCustomPublisher.message_type)
}
inline void InitCustomPublisher::set_message_type(const char* value) {
  set_has_message_type();
  message_type_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::string(value));
  // @@protoc_insertion_point(field_set_char:mw.internal.robotics.gazebotransport.InitCustomPublisher.message_type)
}
inline void InitCustomPublisher::set_message_type(const char* value, size_t size) {
  set_has_message_type();
  message_type_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(),
      ::std::string(reinterpret_cast<const char*>(value), size));
  // @@protoc_insertion_point(field_set_pointer:mw.internal.robotics.gazebotransport.InitCustomPublisher.message_type)
}
inline ::std::string* InitCustomPublisher::mutable_message_type() {
  set_has_message_type();
  // @@protoc_insertion_point(field_mutable:mw.internal.robotics.gazebotransport.InitCustomPublisher.message_type)
  return message_type_.MutableNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline ::std::string* InitCustomPublisher::release_message_type() {
  // @@protoc_insertion_point(field_release:mw.internal.robotics.gazebotransport.InitCustomPublisher.message_type)
  clear_has_message_type();
  return message_type_.ReleaseNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline void InitCustomPublisher::set_allocated_message_type(::std::string* message_type) {
  if (message_type != NULL) {
    set_has_message_type();
  } else {
    clear_has_message_type();
  }
  message_type_.SetAllocatedNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), message_type);
  // @@protoc_insertion_point(field_set_allocated:mw.internal.robotics.gazebotransport.InitCustomPublisher.message_type)
}

// -------------------------------------------------------------------

// InitCustomSubscriber

// required string topic_name = 1;
inline bool InitCustomSubscriber::has_topic_name() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void InitCustomSubscriber::set_has_topic_name() {
  _has_bits_[0] |= 0x00000001u;
}
inline void InitCustomSubscriber::clear_has_topic_name() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void InitCustomSubscriber::clear_topic_name() {
  topic_name_.ClearToEmptyNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
  clear_has_topic_name();
}
inline const ::std::string& InitCustomSubscriber::topic_name() const {
  // @@protoc_insertion_point(field_get:mw.internal.robotics.gazebotransport.InitCustomSubscriber.topic_name)
  return topic_name_.GetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline void InitCustomSubscriber::set_topic_name(const ::std::string& value) {
  set_has_topic_name();
  topic_name_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), value);
  // @@protoc_insertion_point(field_set:mw.internal.robotics.gazebotransport.InitCustomSubscriber.topic_name)
}
inline void InitCustomSubscriber::set_topic_name(const char* value) {
  set_has_topic_name();
  topic_name_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::string(value));
  // @@protoc_insertion_point(field_set_char:mw.internal.robotics.gazebotransport.InitCustomSubscriber.topic_name)
}
inline void InitCustomSubscriber::set_topic_name(const char* value, size_t size) {
  set_has_topic_name();
  topic_name_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(),
      ::std::string(reinterpret_cast<const char*>(value), size));
  // @@protoc_insertion_point(field_set_pointer:mw.internal.robotics.gazebotransport.InitCustomSubscriber.topic_name)
}
inline ::std::string* InitCustomSubscriber::mutable_topic_name() {
  set_has_topic_name();
  // @@protoc_insertion_point(field_mutable:mw.internal.robotics.gazebotransport.InitCustomSubscriber.topic_name)
  return topic_name_.MutableNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline ::std::string* InitCustomSubscriber::release_topic_name() {
  // @@protoc_insertion_point(field_release:mw.internal.robotics.gazebotransport.InitCustomSubscriber.topic_name)
  clear_has_topic_name();
  return topic_name_.ReleaseNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline void InitCustomSubscriber::set_allocated_topic_name(::std::string* topic_name) {
  if (topic_name != NULL) {
    set_has_topic_name();
  } else {
    clear_has_topic_name();
  }
  topic_name_.SetAllocatedNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), topic_name);
  // @@protoc_insertion_point(field_set_allocated:mw.internal.robotics.gazebotransport.InitCustomSubscriber.topic_name)
}

// required string message_type = 2;
inline bool InitCustomSubscriber::has_message_type() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void InitCustomSubscriber::set_has_message_type() {
  _has_bits_[0] |= 0x00000002u;
}
inline void InitCustomSubscriber::clear_has_message_type() {
  _has_bits_[0] &= ~0x00000002u;
}
inline void InitCustomSubscriber::clear_message_type() {
  message_type_.ClearToEmptyNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
  clear_has_message_type();
}
inline const ::std::string& InitCustomSubscriber::message_type() const {
  // @@protoc_insertion_point(field_get:mw.internal.robotics.gazebotransport.InitCustomSubscriber.message_type)
  return message_type_.GetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline void InitCustomSubscriber::set_message_type(const ::std::string& value) {
  set_has_message_type();
  message_type_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), value);
  // @@protoc_insertion_point(field_set:mw.internal.robotics.gazebotransport.InitCustomSubscriber.message_type)
}
inline void InitCustomSubscriber::set_message_type(const char* value) {
  set_has_message_type();
  message_type_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::string(value));
  // @@protoc_insertion_point(field_set_char:mw.internal.robotics.gazebotransport.InitCustomSubscriber.message_type)
}
inline void InitCustomSubscriber::set_message_type(const char* value, size_t size) {
  set_has_message_type();
  message_type_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(),
      ::std::string(reinterpret_cast<const char*>(value), size));
  // @@protoc_insertion_point(field_set_pointer:mw.internal.robotics.gazebotransport.InitCustomSubscriber.message_type)
}
inline ::std::string* InitCustomSubscriber::mutable_message_type() {
  set_has_message_type();
  // @@protoc_insertion_point(field_mutable:mw.internal.robotics.gazebotransport.InitCustomSubscriber.message_type)
  return message_type_.MutableNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline ::std::string* InitCustomSubscriber::release_message_type() {
  // @@protoc_insertion_point(field_release:mw.internal.robotics.gazebotransport.InitCustomSubscriber.message_type)
  clear_has_message_type();
  return message_type_.ReleaseNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline void InitCustomSubscriber::set_allocated_message_type(::std::string* message_type) {
  if (message_type != NULL) {
    set_has_message_type();
  } else {
    clear_has_message_type();
  }
  message_type_.SetAllocatedNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), message_type);
  // @@protoc_insertion_point(field_set_allocated:mw.internal.robotics.gazebotransport.InitCustomSubscriber.message_type)
}

// -------------------------------------------------------------------

// CustomMessageSupport

// required string topic_name = 1;
inline bool CustomMessageSupport::has_topic_name() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void CustomMessageSupport::set_has_topic_name() {
  _has_bits_[0] |= 0x00000001u;
}
inline void CustomMessageSupport::clear_has_topic_name() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void CustomMessageSupport::clear_topic_name() {
  topic_name_.ClearToEmptyNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
  clear_has_topic_name();
}
inline const ::std::string& CustomMessageSupport::topic_name() const {
  // @@protoc_insertion_point(field_get:mw.internal.robotics.gazebotransport.CustomMessageSupport.topic_name)
  return topic_name_.GetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline void CustomMessageSupport::set_topic_name(const ::std::string& value) {
  set_has_topic_name();
  topic_name_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), value);
  // @@protoc_insertion_point(field_set:mw.internal.robotics.gazebotransport.CustomMessageSupport.topic_name)
}
inline void CustomMessageSupport::set_topic_name(const char* value) {
  set_has_topic_name();
  topic_name_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::string(value));
  // @@protoc_insertion_point(field_set_char:mw.internal.robotics.gazebotransport.CustomMessageSupport.topic_name)
}
inline void CustomMessageSupport::set_topic_name(const char* value, size_t size) {
  set_has_topic_name();
  topic_name_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(),
      ::std::string(reinterpret_cast<const char*>(value), size));
  // @@protoc_insertion_point(field_set_pointer:mw.internal.robotics.gazebotransport.CustomMessageSupport.topic_name)
}
inline ::std::string* CustomMessageSupport::mutable_topic_name() {
  set_has_topic_name();
  // @@protoc_insertion_point(field_mutable:mw.internal.robotics.gazebotransport.CustomMessageSupport.topic_name)
  return topic_name_.MutableNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline ::std::string* CustomMessageSupport::release_topic_name() {
  // @@protoc_insertion_point(field_release:mw.internal.robotics.gazebotransport.CustomMessageSupport.topic_name)
  clear_has_topic_name();
  return topic_name_.ReleaseNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline void CustomMessageSupport::set_allocated_topic_name(::std::string* topic_name) {
  if (topic_name != NULL) {
    set_has_topic_name();
  } else {
    clear_has_topic_name();
  }
  topic_name_.SetAllocatedNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), topic_name);
  // @@protoc_insertion_point(field_set_allocated:mw.internal.robotics.gazebotransport.CustomMessageSupport.topic_name)
}

// required string message_type = 2;
inline bool CustomMessageSupport::has_message_type() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void CustomMessageSupport::set_has_message_type() {
  _has_bits_[0] |= 0x00000002u;
}
inline void CustomMessageSupport::clear_has_message_type() {
  _has_bits_[0] &= ~0x00000002u;
}
inline void CustomMessageSupport::clear_message_type() {
  message_type_.ClearToEmptyNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
  clear_has_message_type();
}
inline const ::std::string& CustomMessageSupport::message_type() const {
  // @@protoc_insertion_point(field_get:mw.internal.robotics.gazebotransport.CustomMessageSupport.message_type)
  return message_type_.GetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline void CustomMessageSupport::set_message_type(const ::std::string& value) {
  set_has_message_type();
  message_type_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), value);
  // @@protoc_insertion_point(field_set:mw.internal.robotics.gazebotransport.CustomMessageSupport.message_type)
}
inline void CustomMessageSupport::set_message_type(const char* value) {
  set_has_message_type();
  message_type_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::string(value));
  // @@protoc_insertion_point(field_set_char:mw.internal.robotics.gazebotransport.CustomMessageSupport.message_type)
}
inline void CustomMessageSupport::set_message_type(const char* value, size_t size) {
  set_has_message_type();
  message_type_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(),
      ::std::string(reinterpret_cast<const char*>(value), size));
  // @@protoc_insertion_point(field_set_pointer:mw.internal.robotics.gazebotransport.CustomMessageSupport.message_type)
}
inline ::std::string* CustomMessageSupport::mutable_message_type() {
  set_has_message_type();
  // @@protoc_insertion_point(field_mutable:mw.internal.robotics.gazebotransport.CustomMessageSupport.message_type)
  return message_type_.MutableNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline ::std::string* CustomMessageSupport::release_message_type() {
  // @@protoc_insertion_point(field_release:mw.internal.robotics.gazebotransport.CustomMessageSupport.message_type)
  clear_has_message_type();
  return message_type_.ReleaseNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline void CustomMessageSupport::set_allocated_message_type(::std::string* message_type) {
  if (message_type != NULL) {
    set_has_message_type();
  } else {
    clear_has_message_type();
  }
  message_type_.SetAllocatedNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), message_type);
  // @@protoc_insertion_point(field_set_allocated:mw.internal.robotics.gazebotransport.CustomMessageSupport.message_type)
}

// required bytes data = 3;
inline bool CustomMessageSupport::has_data() const {
  return (_has_bits_[0] & 0x00000004u) != 0;
}
inline void CustomMessageSupport::set_has_data() {
  _has_bits_[0] |= 0x00000004u;
}
inline void CustomMessageSupport::clear_has_data() {
  _has_bits_[0] &= ~0x00000004u;
}
inline void CustomMessageSupport::clear_data() {
  data_.ClearToEmptyNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
  clear_has_data();
}
inline const ::std::string& CustomMessageSupport::data() const {
  // @@protoc_insertion_point(field_get:mw.internal.robotics.gazebotransport.CustomMessageSupport.data)
  return data_.GetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline void CustomMessageSupport::set_data(const ::std::string& value) {
  set_has_data();
  data_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), value);
  // @@protoc_insertion_point(field_set:mw.internal.robotics.gazebotransport.CustomMessageSupport.data)
}
inline void CustomMessageSupport::set_data(const char* value) {
  set_has_data();
  data_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::string(value));
  // @@protoc_insertion_point(field_set_char:mw.internal.robotics.gazebotransport.CustomMessageSupport.data)
}
inline void CustomMessageSupport::set_data(const void* value, size_t size) {
  set_has_data();
  data_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(),
      ::std::string(reinterpret_cast<const char*>(value), size));
  // @@protoc_insertion_point(field_set_pointer:mw.internal.robotics.gazebotransport.CustomMessageSupport.data)
}
inline ::std::string* CustomMessageSupport::mutable_data() {
  set_has_data();
  // @@protoc_insertion_point(field_mutable:mw.internal.robotics.gazebotransport.CustomMessageSupport.data)
  return data_.MutableNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline ::std::string* CustomMessageSupport::release_data() {
  // @@protoc_insertion_point(field_release:mw.internal.robotics.gazebotransport.CustomMessageSupport.data)
  clear_has_data();
  return data_.ReleaseNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline void CustomMessageSupport::set_allocated_data(::std::string* data) {
  if (data != NULL) {
    set_has_data();
  } else {
    clear_has_data();
  }
  data_.SetAllocatedNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), data);
  // @@protoc_insertion_point(field_set_allocated:mw.internal.robotics.gazebotransport.CustomMessageSupport.data)
}

// optional bool is_new = 4;
inline bool CustomMessageSupport::has_is_new() const {
  return (_has_bits_[0] & 0x00000008u) != 0;
}
inline void CustomMessageSupport::set_has_is_new() {
  _has_bits_[0] |= 0x00000008u;
}
inline void CustomMessageSupport::clear_has_is_new() {
  _has_bits_[0] &= ~0x00000008u;
}
inline void CustomMessageSupport::clear_is_new() {
  is_new_ = false;
  clear_has_is_new();
}
inline bool CustomMessageSupport::is_new() const {
  // @@protoc_insertion_point(field_get:mw.internal.robotics.gazebotransport.CustomMessageSupport.is_new)
  return is_new_;
}
inline void CustomMessageSupport::set_is_new(bool value) {
  set_has_is_new();
  is_new_ = value;
  // @@protoc_insertion_point(field_set:mw.internal.robotics.gazebotransport.CustomMessageSupport.is_new)
}

// -------------------------------------------------------------------

// RequestCustomMessageSupport

// required string topic_name = 1;
inline bool RequestCustomMessageSupport::has_topic_name() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void RequestCustomMessageSupport::set_has_topic_name() {
  _has_bits_[0] |= 0x00000001u;
}
inline void RequestCustomMessageSupport::clear_has_topic_name() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void RequestCustomMessageSupport::clear_topic_name() {
  topic_name_.ClearToEmptyNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
  clear_has_topic_name();
}
inline const ::std::string& RequestCustomMessageSupport::topic_name() const {
  // @@protoc_insertion_point(field_get:mw.internal.robotics.gazebotransport.RequestCustomMessageSupport.topic_name)
  return topic_name_.GetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline void RequestCustomMessageSupport::set_topic_name(const ::std::string& value) {
  set_has_topic_name();
  topic_name_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), value);
  // @@protoc_insertion_point(field_set:mw.internal.robotics.gazebotransport.RequestCustomMessageSupport.topic_name)
}
inline void RequestCustomMessageSupport::set_topic_name(const char* value) {
  set_has_topic_name();
  topic_name_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::string(value));
  // @@protoc_insertion_point(field_set_char:mw.internal.robotics.gazebotransport.RequestCustomMessageSupport.topic_name)
}
inline void RequestCustomMessageSupport::set_topic_name(const char* value, size_t size) {
  set_has_topic_name();
  topic_name_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(),
      ::std::string(reinterpret_cast<const char*>(value), size));
  // @@protoc_insertion_point(field_set_pointer:mw.internal.robotics.gazebotransport.RequestCustomMessageSupport.topic_name)
}
inline ::std::string* RequestCustomMessageSupport::mutable_topic_name() {
  set_has_topic_name();
  // @@protoc_insertion_point(field_mutable:mw.internal.robotics.gazebotransport.RequestCustomMessageSupport.topic_name)
  return topic_name_.MutableNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline ::std::string* RequestCustomMessageSupport::release_topic_name() {
  // @@protoc_insertion_point(field_release:mw.internal.robotics.gazebotransport.RequestCustomMessageSupport.topic_name)
  clear_has_topic_name();
  return topic_name_.ReleaseNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline void RequestCustomMessageSupport::set_allocated_topic_name(::std::string* topic_name) {
  if (topic_name != NULL) {
    set_has_topic_name();
  } else {
    clear_has_topic_name();
  }
  topic_name_.SetAllocatedNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), topic_name);
  // @@protoc_insertion_point(field_set_allocated:mw.internal.robotics.gazebotransport.RequestCustomMessageSupport.topic_name)
}

// required string message_type = 2;
inline bool RequestCustomMessageSupport::has_message_type() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void RequestCustomMessageSupport::set_has_message_type() {
  _has_bits_[0] |= 0x00000002u;
}
inline void RequestCustomMessageSupport::clear_has_message_type() {
  _has_bits_[0] &= ~0x00000002u;
}
inline void RequestCustomMessageSupport::clear_message_type() {
  message_type_.ClearToEmptyNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
  clear_has_message_type();
}
inline const ::std::string& RequestCustomMessageSupport::message_type() const {
  // @@protoc_insertion_point(field_get:mw.internal.robotics.gazebotransport.RequestCustomMessageSupport.message_type)
  return message_type_.GetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline void RequestCustomMessageSupport::set_message_type(const ::std::string& value) {
  set_has_message_type();
  message_type_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), value);
  // @@protoc_insertion_point(field_set:mw.internal.robotics.gazebotransport.RequestCustomMessageSupport.message_type)
}
inline void RequestCustomMessageSupport::set_message_type(const char* value) {
  set_has_message_type();
  message_type_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::string(value));
  // @@protoc_insertion_point(field_set_char:mw.internal.robotics.gazebotransport.RequestCustomMessageSupport.message_type)
}
inline void RequestCustomMessageSupport::set_message_type(const char* value, size_t size) {
  set_has_message_type();
  message_type_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(),
      ::std::string(reinterpret_cast<const char*>(value), size));
  // @@protoc_insertion_point(field_set_pointer:mw.internal.robotics.gazebotransport.RequestCustomMessageSupport.message_type)
}
inline ::std::string* RequestCustomMessageSupport::mutable_message_type() {
  set_has_message_type();
  // @@protoc_insertion_point(field_mutable:mw.internal.robotics.gazebotransport.RequestCustomMessageSupport.message_type)
  return message_type_.MutableNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline ::std::string* RequestCustomMessageSupport::release_message_type() {
  // @@protoc_insertion_point(field_release:mw.internal.robotics.gazebotransport.RequestCustomMessageSupport.message_type)
  clear_has_message_type();
  return message_type_.ReleaseNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline void RequestCustomMessageSupport::set_allocated_message_type(::std::string* message_type) {
  if (message_type != NULL) {
    set_has_message_type();
  } else {
    clear_has_message_type();
  }
  message_type_.SetAllocatedNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), message_type);
  // @@protoc_insertion_point(field_set_allocated:mw.internal.robotics.gazebotransport.RequestCustomMessageSupport.message_type)
}

// -------------------------------------------------------------------

// SetJointPosition

// required string model_name = 1;
inline bool SetJointPosition::has_model_name() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void SetJointPosition::set_has_model_name() {
  _has_bits_[0] |= 0x00000001u;
}
inline void SetJointPosition::clear_has_model_name() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void SetJointPosition::clear_model_name() {
  model_name_.ClearToEmptyNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
  clear_has_model_name();
}
inline const ::std::string& SetJointPosition::model_name() const {
  // @@protoc_insertion_point(field_get:mw.internal.robotics.gazebotransport.SetJointPosition.model_name)
  return model_name_.GetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline void SetJointPosition::set_model_name(const ::std::string& value) {
  set_has_model_name();
  model_name_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), value);
  // @@protoc_insertion_point(field_set:mw.internal.robotics.gazebotransport.SetJointPosition.model_name)
}
inline void SetJointPosition::set_model_name(const char* value) {
  set_has_model_name();
  model_name_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::string(value));
  // @@protoc_insertion_point(field_set_char:mw.internal.robotics.gazebotransport.SetJointPosition.model_name)
}
inline void SetJointPosition::set_model_name(const char* value, size_t size) {
  set_has_model_name();
  model_name_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(),
      ::std::string(reinterpret_cast<const char*>(value), size));
  // @@protoc_insertion_point(field_set_pointer:mw.internal.robotics.gazebotransport.SetJointPosition.model_name)
}
inline ::std::string* SetJointPosition::mutable_model_name() {
  set_has_model_name();
  // @@protoc_insertion_point(field_mutable:mw.internal.robotics.gazebotransport.SetJointPosition.model_name)
  return model_name_.MutableNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline ::std::string* SetJointPosition::release_model_name() {
  // @@protoc_insertion_point(field_release:mw.internal.robotics.gazebotransport.SetJointPosition.model_name)
  clear_has_model_name();
  return model_name_.ReleaseNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline void SetJointPosition::set_allocated_model_name(::std::string* model_name) {
  if (model_name != NULL) {
    set_has_model_name();
  } else {
    clear_has_model_name();
  }
  model_name_.SetAllocatedNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), model_name);
  // @@protoc_insertion_point(field_set_allocated:mw.internal.robotics.gazebotransport.SetJointPosition.model_name)
}

// required string joint_name = 2;
inline bool SetJointPosition::has_joint_name() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void SetJointPosition::set_has_joint_name() {
  _has_bits_[0] |= 0x00000002u;
}
inline void SetJointPosition::clear_has_joint_name() {
  _has_bits_[0] &= ~0x00000002u;
}
inline void SetJointPosition::clear_joint_name() {
  joint_name_.ClearToEmptyNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
  clear_has_joint_name();
}
inline const ::std::string& SetJointPosition::joint_name() const {
  // @@protoc_insertion_point(field_get:mw.internal.robotics.gazebotransport.SetJointPosition.joint_name)
  return joint_name_.GetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline void SetJointPosition::set_joint_name(const ::std::string& value) {
  set_has_joint_name();
  joint_name_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), value);
  // @@protoc_insertion_point(field_set:mw.internal.robotics.gazebotransport.SetJointPosition.joint_name)
}
inline void SetJointPosition::set_joint_name(const char* value) {
  set_has_joint_name();
  joint_name_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::string(value));
  // @@protoc_insertion_point(field_set_char:mw.internal.robotics.gazebotransport.SetJointPosition.joint_name)
}
inline void SetJointPosition::set_joint_name(const char* value, size_t size) {
  set_has_joint_name();
  joint_name_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(),
      ::std::string(reinterpret_cast<const char*>(value), size));
  // @@protoc_insertion_point(field_set_pointer:mw.internal.robotics.gazebotransport.SetJointPosition.joint_name)
}
inline ::std::string* SetJointPosition::mutable_joint_name() {
  set_has_joint_name();
  // @@protoc_insertion_point(field_mutable:mw.internal.robotics.gazebotransport.SetJointPosition.joint_name)
  return joint_name_.MutableNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline ::std::string* SetJointPosition::release_joint_name() {
  // @@protoc_insertion_point(field_release:mw.internal.robotics.gazebotransport.SetJointPosition.joint_name)
  clear_has_joint_name();
  return joint_name_.ReleaseNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline void SetJointPosition::set_allocated_joint_name(::std::string* joint_name) {
  if (joint_name != NULL) {
    set_has_joint_name();
  } else {
    clear_has_joint_name();
  }
  joint_name_.SetAllocatedNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), joint_name);
  // @@protoc_insertion_point(field_set_allocated:mw.internal.robotics.gazebotransport.SetJointPosition.joint_name)
}

// required uint32 index = 3;
inline bool SetJointPosition::has_index() const {
  return (_has_bits_[0] & 0x00000004u) != 0;
}
inline void SetJointPosition::set_has_index() {
  _has_bits_[0] |= 0x00000004u;
}
inline void SetJointPosition::clear_has_index() {
  _has_bits_[0] &= ~0x00000004u;
}
inline void SetJointPosition::clear_index() {
  index_ = 0u;
  clear_has_index();
}
inline ::google::protobuf::uint32 SetJointPosition::index() const {
  // @@protoc_insertion_point(field_get:mw.internal.robotics.gazebotransport.SetJointPosition.index)
  return index_;
}
inline void SetJointPosition::set_index(::google::protobuf::uint32 value) {
  set_has_index();
  index_ = value;
  // @@protoc_insertion_point(field_set:mw.internal.robotics.gazebotransport.SetJointPosition.index)
}

// required double position = 4;
inline bool SetJointPosition::has_position() const {
  return (_has_bits_[0] & 0x00000008u) != 0;
}
inline void SetJointPosition::set_has_position() {
  _has_bits_[0] |= 0x00000008u;
}
inline void SetJointPosition::clear_has_position() {
  _has_bits_[0] &= ~0x00000008u;
}
inline void SetJointPosition::clear_position() {
  position_ = 0;
  clear_has_position();
}
inline double SetJointPosition::position() const {
  // @@protoc_insertion_point(field_get:mw.internal.robotics.gazebotransport.SetJointPosition.position)
  return position_;
}
inline void SetJointPosition::set_position(double value) {
  set_has_position();
  position_ = value;
  // @@protoc_insertion_point(field_set:mw.internal.robotics.gazebotransport.SetJointPosition.position)
}

// required .mw.internal.robotics.gazebotransport.Time duration = 5;
inline bool SetJointPosition::has_duration() const {
  return (_has_bits_[0] & 0x00000010u) != 0;
}
inline void SetJointPosition::set_has_duration() {
  _has_bits_[0] |= 0x00000010u;
}
inline void SetJointPosition::clear_has_duration() {
  _has_bits_[0] &= ~0x00000010u;
}
inline void SetJointPosition::clear_duration() {
  if (duration_ != NULL) duration_->::mw::internal::robotics::gazebotransport::Time::Clear();
  clear_has_duration();
}
inline const ::mw::internal::robotics::gazebotransport::Time& SetJointPosition::duration() const {
  // @@protoc_insertion_point(field_get:mw.internal.robotics.gazebotransport.SetJointPosition.duration)
  return duration_ != NULL ? *duration_ : *default_instance_->duration_;
}
inline ::mw::internal::robotics::gazebotransport::Time* SetJointPosition::mutable_duration() {
  set_has_duration();
  if (duration_ == NULL) {
    duration_ = new ::mw::internal::robotics::gazebotransport::Time;
  }
  // @@protoc_insertion_point(field_mutable:mw.internal.robotics.gazebotransport.SetJointPosition.duration)
  return duration_;
}
inline ::mw::internal::robotics::gazebotransport::Time* SetJointPosition::release_duration() {
  // @@protoc_insertion_point(field_release:mw.internal.robotics.gazebotransport.SetJointPosition.duration)
  clear_has_duration();
  ::mw::internal::robotics::gazebotransport::Time* temp = duration_;
  duration_ = NULL;
  return temp;
}
inline void SetJointPosition::set_allocated_duration(::mw::internal::robotics::gazebotransport::Time* duration) {
  delete duration_;
  duration_ = duration;
  if (duration) {
    set_has_duration();
  } else {
    clear_has_duration();
  }
  // @@protoc_insertion_point(field_set_allocated:mw.internal.robotics.gazebotransport.SetJointPosition.duration)
}

// -------------------------------------------------------------------

// SetJointVelocity

// required string model_name = 1;
inline bool SetJointVelocity::has_model_name() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void SetJointVelocity::set_has_model_name() {
  _has_bits_[0] |= 0x00000001u;
}
inline void SetJointVelocity::clear_has_model_name() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void SetJointVelocity::clear_model_name() {
  model_name_.ClearToEmptyNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
  clear_has_model_name();
}
inline const ::std::string& SetJointVelocity::model_name() const {
  // @@protoc_insertion_point(field_get:mw.internal.robotics.gazebotransport.SetJointVelocity.model_name)
  return model_name_.GetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline void SetJointVelocity::set_model_name(const ::std::string& value) {
  set_has_model_name();
  model_name_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), value);
  // @@protoc_insertion_point(field_set:mw.internal.robotics.gazebotransport.SetJointVelocity.model_name)
}
inline void SetJointVelocity::set_model_name(const char* value) {
  set_has_model_name();
  model_name_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::string(value));
  // @@protoc_insertion_point(field_set_char:mw.internal.robotics.gazebotransport.SetJointVelocity.model_name)
}
inline void SetJointVelocity::set_model_name(const char* value, size_t size) {
  set_has_model_name();
  model_name_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(),
      ::std::string(reinterpret_cast<const char*>(value), size));
  // @@protoc_insertion_point(field_set_pointer:mw.internal.robotics.gazebotransport.SetJointVelocity.model_name)
}
inline ::std::string* SetJointVelocity::mutable_model_name() {
  set_has_model_name();
  // @@protoc_insertion_point(field_mutable:mw.internal.robotics.gazebotransport.SetJointVelocity.model_name)
  return model_name_.MutableNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline ::std::string* SetJointVelocity::release_model_name() {
  // @@protoc_insertion_point(field_release:mw.internal.robotics.gazebotransport.SetJointVelocity.model_name)
  clear_has_model_name();
  return model_name_.ReleaseNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline void SetJointVelocity::set_allocated_model_name(::std::string* model_name) {
  if (model_name != NULL) {
    set_has_model_name();
  } else {
    clear_has_model_name();
  }
  model_name_.SetAllocatedNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), model_name);
  // @@protoc_insertion_point(field_set_allocated:mw.internal.robotics.gazebotransport.SetJointVelocity.model_name)
}

// required string joint_name = 2;
inline bool SetJointVelocity::has_joint_name() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void SetJointVelocity::set_has_joint_name() {
  _has_bits_[0] |= 0x00000002u;
}
inline void SetJointVelocity::clear_has_joint_name() {
  _has_bits_[0] &= ~0x00000002u;
}
inline void SetJointVelocity::clear_joint_name() {
  joint_name_.ClearToEmptyNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
  clear_has_joint_name();
}
inline const ::std::string& SetJointVelocity::joint_name() const {
  // @@protoc_insertion_point(field_get:mw.internal.robotics.gazebotransport.SetJointVelocity.joint_name)
  return joint_name_.GetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline void SetJointVelocity::set_joint_name(const ::std::string& value) {
  set_has_joint_name();
  joint_name_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), value);
  // @@protoc_insertion_point(field_set:mw.internal.robotics.gazebotransport.SetJointVelocity.joint_name)
}
inline void SetJointVelocity::set_joint_name(const char* value) {
  set_has_joint_name();
  joint_name_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::string(value));
  // @@protoc_insertion_point(field_set_char:mw.internal.robotics.gazebotransport.SetJointVelocity.joint_name)
}
inline void SetJointVelocity::set_joint_name(const char* value, size_t size) {
  set_has_joint_name();
  joint_name_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(),
      ::std::string(reinterpret_cast<const char*>(value), size));
  // @@protoc_insertion_point(field_set_pointer:mw.internal.robotics.gazebotransport.SetJointVelocity.joint_name)
}
inline ::std::string* SetJointVelocity::mutable_joint_name() {
  set_has_joint_name();
  // @@protoc_insertion_point(field_mutable:mw.internal.robotics.gazebotransport.SetJointVelocity.joint_name)
  return joint_name_.MutableNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline ::std::string* SetJointVelocity::release_joint_name() {
  // @@protoc_insertion_point(field_release:mw.internal.robotics.gazebotransport.SetJointVelocity.joint_name)
  clear_has_joint_name();
  return joint_name_.ReleaseNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline void SetJointVelocity::set_allocated_joint_name(::std::string* joint_name) {
  if (joint_name != NULL) {
    set_has_joint_name();
  } else {
    clear_has_joint_name();
  }
  joint_name_.SetAllocatedNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), joint_name);
  // @@protoc_insertion_point(field_set_allocated:mw.internal.robotics.gazebotransport.SetJointVelocity.joint_name)
}

// required uint32 index = 3;
inline bool SetJointVelocity::has_index() const {
  return (_has_bits_[0] & 0x00000004u) != 0;
}
inline void SetJointVelocity::set_has_index() {
  _has_bits_[0] |= 0x00000004u;
}
inline void SetJointVelocity::clear_has_index() {
  _has_bits_[0] &= ~0x00000004u;
}
inline void SetJointVelocity::clear_index() {
  index_ = 0u;
  clear_has_index();
}
inline ::google::protobuf::uint32 SetJointVelocity::index() const {
  // @@protoc_insertion_point(field_get:mw.internal.robotics.gazebotransport.SetJointVelocity.index)
  return index_;
}
inline void SetJointVelocity::set_index(::google::protobuf::uint32 value) {
  set_has_index();
  index_ = value;
  // @@protoc_insertion_point(field_set:mw.internal.robotics.gazebotransport.SetJointVelocity.index)
}

// required double velocity = 4;
inline bool SetJointVelocity::has_velocity() const {
  return (_has_bits_[0] & 0x00000008u) != 0;
}
inline void SetJointVelocity::set_has_velocity() {
  _has_bits_[0] |= 0x00000008u;
}
inline void SetJointVelocity::clear_has_velocity() {
  _has_bits_[0] &= ~0x00000008u;
}
inline void SetJointVelocity::clear_velocity() {
  velocity_ = 0;
  clear_has_velocity();
}
inline double SetJointVelocity::velocity() const {
  // @@protoc_insertion_point(field_get:mw.internal.robotics.gazebotransport.SetJointVelocity.velocity)
  return velocity_;
}
inline void SetJointVelocity::set_velocity(double value) {
  set_has_velocity();
  velocity_ = value;
  // @@protoc_insertion_point(field_set:mw.internal.robotics.gazebotransport.SetJointVelocity.velocity)
}

// required .mw.internal.robotics.gazebotransport.Time duration = 5;
inline bool SetJointVelocity::has_duration() const {
  return (_has_bits_[0] & 0x00000010u) != 0;
}
inline void SetJointVelocity::set_has_duration() {
  _has_bits_[0] |= 0x00000010u;
}
inline void SetJointVelocity::clear_has_duration() {
  _has_bits_[0] &= ~0x00000010u;
}
inline void SetJointVelocity::clear_duration() {
  if (duration_ != NULL) duration_->::mw::internal::robotics::gazebotransport::Time::Clear();
  clear_has_duration();
}
inline const ::mw::internal::robotics::gazebotransport::Time& SetJointVelocity::duration() const {
  // @@protoc_insertion_point(field_get:mw.internal.robotics.gazebotransport.SetJointVelocity.duration)
  return duration_ != NULL ? *duration_ : *default_instance_->duration_;
}
inline ::mw::internal::robotics::gazebotransport::Time* SetJointVelocity::mutable_duration() {
  set_has_duration();
  if (duration_ == NULL) {
    duration_ = new ::mw::internal::robotics::gazebotransport::Time;
  }
  // @@protoc_insertion_point(field_mutable:mw.internal.robotics.gazebotransport.SetJointVelocity.duration)
  return duration_;
}
inline ::mw::internal::robotics::gazebotransport::Time* SetJointVelocity::release_duration() {
  // @@protoc_insertion_point(field_release:mw.internal.robotics.gazebotransport.SetJointVelocity.duration)
  clear_has_duration();
  ::mw::internal::robotics::gazebotransport::Time* temp = duration_;
  duration_ = NULL;
  return temp;
}
inline void SetJointVelocity::set_allocated_duration(::mw::internal::robotics::gazebotransport::Time* duration) {
  delete duration_;
  duration_ = duration;
  if (duration) {
    set_has_duration();
  } else {
    clear_has_duration();
  }
  // @@protoc_insertion_point(field_set_allocated:mw.internal.robotics.gazebotransport.SetJointVelocity.duration)
}

// -------------------------------------------------------------------

// GetJointState

// required string model_name = 1;
inline bool GetJointState::has_model_name() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void GetJointState::set_has_model_name() {
  _has_bits_[0] |= 0x00000001u;
}
inline void GetJointState::clear_has_model_name() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void GetJointState::clear_model_name() {
  model_name_.ClearToEmptyNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
  clear_has_model_name();
}
inline const ::std::string& GetJointState::model_name() const {
  // @@protoc_insertion_point(field_get:mw.internal.robotics.gazebotransport.GetJointState.model_name)
  return model_name_.GetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline void GetJointState::set_model_name(const ::std::string& value) {
  set_has_model_name();
  model_name_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), value);
  // @@protoc_insertion_point(field_set:mw.internal.robotics.gazebotransport.GetJointState.model_name)
}
inline void GetJointState::set_model_name(const char* value) {
  set_has_model_name();
  model_name_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::string(value));
  // @@protoc_insertion_point(field_set_char:mw.internal.robotics.gazebotransport.GetJointState.model_name)
}
inline void GetJointState::set_model_name(const char* value, size_t size) {
  set_has_model_name();
  model_name_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(),
      ::std::string(reinterpret_cast<const char*>(value), size));
  // @@protoc_insertion_point(field_set_pointer:mw.internal.robotics.gazebotransport.GetJointState.model_name)
}
inline ::std::string* GetJointState::mutable_model_name() {
  set_has_model_name();
  // @@protoc_insertion_point(field_mutable:mw.internal.robotics.gazebotransport.GetJointState.model_name)
  return model_name_.MutableNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline ::std::string* GetJointState::release_model_name() {
  // @@protoc_insertion_point(field_release:mw.internal.robotics.gazebotransport.GetJointState.model_name)
  clear_has_model_name();
  return model_name_.ReleaseNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline void GetJointState::set_allocated_model_name(::std::string* model_name) {
  if (model_name != NULL) {
    set_has_model_name();
  } else {
    clear_has_model_name();
  }
  model_name_.SetAllocatedNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), model_name);
  // @@protoc_insertion_point(field_set_allocated:mw.internal.robotics.gazebotransport.GetJointState.model_name)
}

// required string joint_name = 2;
inline bool GetJointState::has_joint_name() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void GetJointState::set_has_joint_name() {
  _has_bits_[0] |= 0x00000002u;
}
inline void GetJointState::clear_has_joint_name() {
  _has_bits_[0] &= ~0x00000002u;
}
inline void GetJointState::clear_joint_name() {
  joint_name_.ClearToEmptyNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
  clear_has_joint_name();
}
inline const ::std::string& GetJointState::joint_name() const {
  // @@protoc_insertion_point(field_get:mw.internal.robotics.gazebotransport.GetJointState.joint_name)
  return joint_name_.GetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline void GetJointState::set_joint_name(const ::std::string& value) {
  set_has_joint_name();
  joint_name_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), value);
  // @@protoc_insertion_point(field_set:mw.internal.robotics.gazebotransport.GetJointState.joint_name)
}
inline void GetJointState::set_joint_name(const char* value) {
  set_has_joint_name();
  joint_name_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::string(value));
  // @@protoc_insertion_point(field_set_char:mw.internal.robotics.gazebotransport.GetJointState.joint_name)
}
inline void GetJointState::set_joint_name(const char* value, size_t size) {
  set_has_joint_name();
  joint_name_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(),
      ::std::string(reinterpret_cast<const char*>(value), size));
  // @@protoc_insertion_point(field_set_pointer:mw.internal.robotics.gazebotransport.GetJointState.joint_name)
}
inline ::std::string* GetJointState::mutable_joint_name() {
  set_has_joint_name();
  // @@protoc_insertion_point(field_mutable:mw.internal.robotics.gazebotransport.GetJointState.joint_name)
  return joint_name_.MutableNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline ::std::string* GetJointState::release_joint_name() {
  // @@protoc_insertion_point(field_release:mw.internal.robotics.gazebotransport.GetJointState.joint_name)
  clear_has_joint_name();
  return joint_name_.ReleaseNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline void GetJointState::set_allocated_joint_name(::std::string* joint_name) {
  if (joint_name != NULL) {
    set_has_joint_name();
  } else {
    clear_has_joint_name();
  }
  joint_name_.SetAllocatedNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), joint_name);
  // @@protoc_insertion_point(field_set_allocated:mw.internal.robotics.gazebotransport.GetJointState.joint_name)
}

// -------------------------------------------------------------------

// Axis

// required .mw.internal.robotics.gazebotransport.Point xyz = 1;
inline bool Axis::has_xyz() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void Axis::set_has_xyz() {
  _has_bits_[0] |= 0x00000001u;
}
inline void Axis::clear_has_xyz() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void Axis::clear_xyz() {
  if (xyz_ != NULL) xyz_->::mw::internal::robotics::gazebotransport::Point::Clear();
  clear_has_xyz();
}
inline const ::mw::internal::robotics::gazebotransport::Point& Axis::xyz() const {
  // @@protoc_insertion_point(field_get:mw.internal.robotics.gazebotransport.Axis.xyz)
  return xyz_ != NULL ? *xyz_ : *default_instance_->xyz_;
}
inline ::mw::internal::robotics::gazebotransport::Point* Axis::mutable_xyz() {
  set_has_xyz();
  if (xyz_ == NULL) {
    xyz_ = new ::mw::internal::robotics::gazebotransport::Point;
  }
  // @@protoc_insertion_point(field_mutable:mw.internal.robotics.gazebotransport.Axis.xyz)
  return xyz_;
}
inline ::mw::internal::robotics::gazebotransport::Point* Axis::release_xyz() {
  // @@protoc_insertion_point(field_release:mw.internal.robotics.gazebotransport.Axis.xyz)
  clear_has_xyz();
  ::mw::internal::robotics::gazebotransport::Point* temp = xyz_;
  xyz_ = NULL;
  return temp;
}
inline void Axis::set_allocated_xyz(::mw::internal::robotics::gazebotransport::Point* xyz) {
  delete xyz_;
  xyz_ = xyz;
  if (xyz) {
    set_has_xyz();
  } else {
    clear_has_xyz();
  }
  // @@protoc_insertion_point(field_set_allocated:mw.internal.robotics.gazebotransport.Axis.xyz)
}

// required double limit_lower = 2;
inline bool Axis::has_limit_lower() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void Axis::set_has_limit_lower() {
  _has_bits_[0] |= 0x00000002u;
}
inline void Axis::clear_has_limit_lower() {
  _has_bits_[0] &= ~0x00000002u;
}
inline void Axis::clear_limit_lower() {
  limit_lower_ = 0;
  clear_has_limit_lower();
}
inline double Axis::limit_lower() const {
  // @@protoc_insertion_point(field_get:mw.internal.robotics.gazebotransport.Axis.limit_lower)
  return limit_lower_;
}
inline void Axis::set_limit_lower(double value) {
  set_has_limit_lower();
  limit_lower_ = value;
  // @@protoc_insertion_point(field_set:mw.internal.robotics.gazebotransport.Axis.limit_lower)
}

// required double limit_upper = 3;
inline bool Axis::has_limit_upper() const {
  return (_has_bits_[0] & 0x00000004u) != 0;
}
inline void Axis::set_has_limit_upper() {
  _has_bits_[0] |= 0x00000004u;
}
inline void Axis::clear_has_limit_upper() {
  _has_bits_[0] &= ~0x00000004u;
}
inline void Axis::clear_limit_upper() {
  limit_upper_ = 0;
  clear_has_limit_upper();
}
inline double Axis::limit_upper() const {
  // @@protoc_insertion_point(field_get:mw.internal.robotics.gazebotransport.Axis.limit_upper)
  return limit_upper_;
}
inline void Axis::set_limit_upper(double value) {
  set_has_limit_upper();
  limit_upper_ = value;
  // @@protoc_insertion_point(field_set:mw.internal.robotics.gazebotransport.Axis.limit_upper)
}

// required double limit_effort = 4;
inline bool Axis::has_limit_effort() const {
  return (_has_bits_[0] & 0x00000008u) != 0;
}
inline void Axis::set_has_limit_effort() {
  _has_bits_[0] |= 0x00000008u;
}
inline void Axis::clear_has_limit_effort() {
  _has_bits_[0] &= ~0x00000008u;
}
inline void Axis::clear_limit_effort() {
  limit_effort_ = 0;
  clear_has_limit_effort();
}
inline double Axis::limit_effort() const {
  // @@protoc_insertion_point(field_get:mw.internal.robotics.gazebotransport.Axis.limit_effort)
  return limit_effort_;
}
inline void Axis::set_limit_effort(double value) {
  set_has_limit_effort();
  limit_effort_ = value;
  // @@protoc_insertion_point(field_set:mw.internal.robotics.gazebotransport.Axis.limit_effort)
}

// required double limit_velocity = 5;
inline bool Axis::has_limit_velocity() const {
  return (_has_bits_[0] & 0x00000010u) != 0;
}
inline void Axis::set_has_limit_velocity() {
  _has_bits_[0] |= 0x00000010u;
}
inline void Axis::clear_has_limit_velocity() {
  _has_bits_[0] &= ~0x00000010u;
}
inline void Axis::clear_limit_velocity() {
  limit_velocity_ = 0;
  clear_has_limit_velocity();
}
inline double Axis::limit_velocity() const {
  // @@protoc_insertion_point(field_get:mw.internal.robotics.gazebotransport.Axis.limit_velocity)
  return limit_velocity_;
}
inline void Axis::set_limit_velocity(double value) {
  set_has_limit_velocity();
  limit_velocity_ = value;
  // @@protoc_insertion_point(field_set:mw.internal.robotics.gazebotransport.Axis.limit_velocity)
}

// required double damping = 6;
inline bool Axis::has_damping() const {
  return (_has_bits_[0] & 0x00000020u) != 0;
}
inline void Axis::set_has_damping() {
  _has_bits_[0] |= 0x00000020u;
}
inline void Axis::clear_has_damping() {
  _has_bits_[0] &= ~0x00000020u;
}
inline void Axis::clear_damping() {
  damping_ = 0;
  clear_has_damping();
}
inline double Axis::damping() const {
  // @@protoc_insertion_point(field_get:mw.internal.robotics.gazebotransport.Axis.damping)
  return damping_;
}
inline void Axis::set_damping(double value) {
  set_has_damping();
  damping_ = value;
  // @@protoc_insertion_point(field_set:mw.internal.robotics.gazebotransport.Axis.damping)
}

// required double friction = 7;
inline bool Axis::has_friction() const {
  return (_has_bits_[0] & 0x00000040u) != 0;
}
inline void Axis::set_has_friction() {
  _has_bits_[0] |= 0x00000040u;
}
inline void Axis::clear_has_friction() {
  _has_bits_[0] &= ~0x00000040u;
}
inline void Axis::clear_friction() {
  friction_ = 0;
  clear_has_friction();
}
inline double Axis::friction() const {
  // @@protoc_insertion_point(field_get:mw.internal.robotics.gazebotransport.Axis.friction)
  return friction_;
}
inline void Axis::set_friction(double value) {
  set_has_friction();
  friction_ = value;
  // @@protoc_insertion_point(field_set:mw.internal.robotics.gazebotransport.Axis.friction)
}

// required bool use_parent_model_frame = 8;
inline bool Axis::has_use_parent_model_frame() const {
  return (_has_bits_[0] & 0x00000080u) != 0;
}
inline void Axis::set_has_use_parent_model_frame() {
  _has_bits_[0] |= 0x00000080u;
}
inline void Axis::clear_has_use_parent_model_frame() {
  _has_bits_[0] &= ~0x00000080u;
}
inline void Axis::clear_use_parent_model_frame() {
  use_parent_model_frame_ = false;
  clear_has_use_parent_model_frame();
}
inline bool Axis::use_parent_model_frame() const {
  // @@protoc_insertion_point(field_get:mw.internal.robotics.gazebotransport.Axis.use_parent_model_frame)
  return use_parent_model_frame_;
}
inline void Axis::set_use_parent_model_frame(bool value) {
  set_has_use_parent_model_frame();
  use_parent_model_frame_ = value;
  // @@protoc_insertion_point(field_set:mw.internal.robotics.gazebotransport.Axis.use_parent_model_frame)
}

// -------------------------------------------------------------------

// JointState

// required string model_name = 1;
inline bool JointState::has_model_name() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void JointState::set_has_model_name() {
  _has_bits_[0] |= 0x00000001u;
}
inline void JointState::clear_has_model_name() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void JointState::clear_model_name() {
  model_name_.ClearToEmptyNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
  clear_has_model_name();
}
inline const ::std::string& JointState::model_name() const {
  // @@protoc_insertion_point(field_get:mw.internal.robotics.gazebotransport.JointState.model_name)
  return model_name_.GetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline void JointState::set_model_name(const ::std::string& value) {
  set_has_model_name();
  model_name_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), value);
  // @@protoc_insertion_point(field_set:mw.internal.robotics.gazebotransport.JointState.model_name)
}
inline void JointState::set_model_name(const char* value) {
  set_has_model_name();
  model_name_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::string(value));
  // @@protoc_insertion_point(field_set_char:mw.internal.robotics.gazebotransport.JointState.model_name)
}
inline void JointState::set_model_name(const char* value, size_t size) {
  set_has_model_name();
  model_name_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(),
      ::std::string(reinterpret_cast<const char*>(value), size));
  // @@protoc_insertion_point(field_set_pointer:mw.internal.robotics.gazebotransport.JointState.model_name)
}
inline ::std::string* JointState::mutable_model_name() {
  set_has_model_name();
  // @@protoc_insertion_point(field_mutable:mw.internal.robotics.gazebotransport.JointState.model_name)
  return model_name_.MutableNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline ::std::string* JointState::release_model_name() {
  // @@protoc_insertion_point(field_release:mw.internal.robotics.gazebotransport.JointState.model_name)
  clear_has_model_name();
  return model_name_.ReleaseNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline void JointState::set_allocated_model_name(::std::string* model_name) {
  if (model_name != NULL) {
    set_has_model_name();
  } else {
    clear_has_model_name();
  }
  model_name_.SetAllocatedNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), model_name);
  // @@protoc_insertion_point(field_set_allocated:mw.internal.robotics.gazebotransport.JointState.model_name)
}

// required string joint_name = 2;
inline bool JointState::has_joint_name() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void JointState::set_has_joint_name() {
  _has_bits_[0] |= 0x00000002u;
}
inline void JointState::clear_has_joint_name() {
  _has_bits_[0] &= ~0x00000002u;
}
inline void JointState::clear_joint_name() {
  joint_name_.ClearToEmptyNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
  clear_has_joint_name();
}
inline const ::std::string& JointState::joint_name() const {
  // @@protoc_insertion_point(field_get:mw.internal.robotics.gazebotransport.JointState.joint_name)
  return joint_name_.GetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline void JointState::set_joint_name(const ::std::string& value) {
  set_has_joint_name();
  joint_name_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), value);
  // @@protoc_insertion_point(field_set:mw.internal.robotics.gazebotransport.JointState.joint_name)
}
inline void JointState::set_joint_name(const char* value) {
  set_has_joint_name();
  joint_name_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::string(value));
  // @@protoc_insertion_point(field_set_char:mw.internal.robotics.gazebotransport.JointState.joint_name)
}
inline void JointState::set_joint_name(const char* value, size_t size) {
  set_has_joint_name();
  joint_name_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(),
      ::std::string(reinterpret_cast<const char*>(value), size));
  // @@protoc_insertion_point(field_set_pointer:mw.internal.robotics.gazebotransport.JointState.joint_name)
}
inline ::std::string* JointState::mutable_joint_name() {
  set_has_joint_name();
  // @@protoc_insertion_point(field_mutable:mw.internal.robotics.gazebotransport.JointState.joint_name)
  return joint_name_.MutableNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline ::std::string* JointState::release_joint_name() {
  // @@protoc_insertion_point(field_release:mw.internal.robotics.gazebotransport.JointState.joint_name)
  clear_has_joint_name();
  return joint_name_.ReleaseNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline void JointState::set_allocated_joint_name(::std::string* joint_name) {
  if (joint_name != NULL) {
    set_has_joint_name();
  } else {
    clear_has_joint_name();
  }
  joint_name_.SetAllocatedNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), joint_name);
  // @@protoc_insertion_point(field_set_allocated:mw.internal.robotics.gazebotransport.JointState.joint_name)
}

// required uint32 joint_id = 3;
inline bool JointState::has_joint_id() const {
  return (_has_bits_[0] & 0x00000004u) != 0;
}
inline void JointState::set_has_joint_id() {
  _has_bits_[0] |= 0x00000004u;
}
inline void JointState::clear_has_joint_id() {
  _has_bits_[0] &= ~0x00000004u;
}
inline void JointState::clear_joint_id() {
  joint_id_ = 0u;
  clear_has_joint_id();
}
inline ::google::protobuf::uint32 JointState::joint_id() const {
  // @@protoc_insertion_point(field_get:mw.internal.robotics.gazebotransport.JointState.joint_id)
  return joint_id_;
}
inline void JointState::set_joint_id(::google::protobuf::uint32 value) {
  set_has_joint_id();
  joint_id_ = value;
  // @@protoc_insertion_point(field_set:mw.internal.robotics.gazebotransport.JointState.joint_id)
}

// repeated double joint_position = 4;
inline int JointState::joint_position_size() const {
  return joint_position_.size();
}
inline void JointState::clear_joint_position() {
  joint_position_.Clear();
}
inline double JointState::joint_position(int index) const {
  // @@protoc_insertion_point(field_get:mw.internal.robotics.gazebotransport.JointState.joint_position)
  return joint_position_.Get(index);
}
inline void JointState::set_joint_position(int index, double value) {
  joint_position_.Set(index, value);
  // @@protoc_insertion_point(field_set:mw.internal.robotics.gazebotransport.JointState.joint_position)
}
inline void JointState::add_joint_position(double value) {
  joint_position_.Add(value);
  // @@protoc_insertion_point(field_add:mw.internal.robotics.gazebotransport.JointState.joint_position)
}
inline const ::google::protobuf::RepeatedField< double >&
JointState::joint_position() const {
  // @@protoc_insertion_point(field_list:mw.internal.robotics.gazebotransport.JointState.joint_position)
  return joint_position_;
}
inline ::google::protobuf::RepeatedField< double >*
JointState::mutable_joint_position() {
  // @@protoc_insertion_point(field_mutable_list:mw.internal.robotics.gazebotransport.JointState.joint_position)
  return &joint_position_;
}

// repeated double joint_velocity = 5;
inline int JointState::joint_velocity_size() const {
  return joint_velocity_.size();
}
inline void JointState::clear_joint_velocity() {
  joint_velocity_.Clear();
}
inline double JointState::joint_velocity(int index) const {
  // @@protoc_insertion_point(field_get:mw.internal.robotics.gazebotransport.JointState.joint_velocity)
  return joint_velocity_.Get(index);
}
inline void JointState::set_joint_velocity(int index, double value) {
  joint_velocity_.Set(index, value);
  // @@protoc_insertion_point(field_set:mw.internal.robotics.gazebotransport.JointState.joint_velocity)
}
inline void JointState::add_joint_velocity(double value) {
  joint_velocity_.Add(value);
  // @@protoc_insertion_point(field_add:mw.internal.robotics.gazebotransport.JointState.joint_velocity)
}
inline const ::google::protobuf::RepeatedField< double >&
JointState::joint_velocity() const {
  // @@protoc_insertion_point(field_list:mw.internal.robotics.gazebotransport.JointState.joint_velocity)
  return joint_velocity_;
}
inline ::google::protobuf::RepeatedField< double >*
JointState::mutable_joint_velocity() {
  // @@protoc_insertion_point(field_mutable_list:mw.internal.robotics.gazebotransport.JointState.joint_velocity)
  return &joint_velocity_;
}

// optional .mw.internal.robotics.gazebotransport.JointState.Joint_Type joint_type = 6;
inline bool JointState::has_joint_type() const {
  return (_has_bits_[0] & 0x00000020u) != 0;
}
inline void JointState::set_has_joint_type() {
  _has_bits_[0] |= 0x00000020u;
}
inline void JointState::clear_has_joint_type() {
  _has_bits_[0] &= ~0x00000020u;
}
inline void JointState::clear_joint_type() {
  joint_type_ = 1;
  clear_has_joint_type();
}
inline ::mw::internal::robotics::gazebotransport::JointState_Joint_Type JointState::joint_type() const {
  // @@protoc_insertion_point(field_get:mw.internal.robotics.gazebotransport.JointState.joint_type)
  return static_cast< ::mw::internal::robotics::gazebotransport::JointState_Joint_Type >(joint_type_);
}
inline void JointState::set_joint_type(::mw::internal::robotics::gazebotransport::JointState_Joint_Type value) {
  assert(::mw::internal::robotics::gazebotransport::JointState_Joint_Type_IsValid(value));
  set_has_joint_type();
  joint_type_ = value;
  // @@protoc_insertion_point(field_set:mw.internal.robotics.gazebotransport.JointState.joint_type)
}

// optional string parent_name = 7;
inline bool JointState::has_parent_name() const {
  return (_has_bits_[0] & 0x00000040u) != 0;
}
inline void JointState::set_has_parent_name() {
  _has_bits_[0] |= 0x00000040u;
}
inline void JointState::clear_has_parent_name() {
  _has_bits_[0] &= ~0x00000040u;
}
inline void JointState::clear_parent_name() {
  parent_name_.ClearToEmptyNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
  clear_has_parent_name();
}
inline const ::std::string& JointState::parent_name() const {
  // @@protoc_insertion_point(field_get:mw.internal.robotics.gazebotransport.JointState.parent_name)
  return parent_name_.GetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline void JointState::set_parent_name(const ::std::string& value) {
  set_has_parent_name();
  parent_name_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), value);
  // @@protoc_insertion_point(field_set:mw.internal.robotics.gazebotransport.JointState.parent_name)
}
inline void JointState::set_parent_name(const char* value) {
  set_has_parent_name();
  parent_name_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::string(value));
  // @@protoc_insertion_point(field_set_char:mw.internal.robotics.gazebotransport.JointState.parent_name)
}
inline void JointState::set_parent_name(const char* value, size_t size) {
  set_has_parent_name();
  parent_name_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(),
      ::std::string(reinterpret_cast<const char*>(value), size));
  // @@protoc_insertion_point(field_set_pointer:mw.internal.robotics.gazebotransport.JointState.parent_name)
}
inline ::std::string* JointState::mutable_parent_name() {
  set_has_parent_name();
  // @@protoc_insertion_point(field_mutable:mw.internal.robotics.gazebotransport.JointState.parent_name)
  return parent_name_.MutableNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline ::std::string* JointState::release_parent_name() {
  // @@protoc_insertion_point(field_release:mw.internal.robotics.gazebotransport.JointState.parent_name)
  clear_has_parent_name();
  return parent_name_.ReleaseNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline void JointState::set_allocated_parent_name(::std::string* parent_name) {
  if (parent_name != NULL) {
    set_has_parent_name();
  } else {
    clear_has_parent_name();
  }
  parent_name_.SetAllocatedNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), parent_name);
  // @@protoc_insertion_point(field_set_allocated:mw.internal.robotics.gazebotransport.JointState.parent_name)
}

// optional uint32 parent_id = 8;
inline bool JointState::has_parent_id() const {
  return (_has_bits_[0] & 0x00000080u) != 0;
}
inline void JointState::set_has_parent_id() {
  _has_bits_[0] |= 0x00000080u;
}
inline void JointState::clear_has_parent_id() {
  _has_bits_[0] &= ~0x00000080u;
}
inline void JointState::clear_parent_id() {
  parent_id_ = 0u;
  clear_has_parent_id();
}
inline ::google::protobuf::uint32 JointState::parent_id() const {
  // @@protoc_insertion_point(field_get:mw.internal.robotics.gazebotransport.JointState.parent_id)
  return parent_id_;
}
inline void JointState::set_parent_id(::google::protobuf::uint32 value) {
  set_has_parent_id();
  parent_id_ = value;
  // @@protoc_insertion_point(field_set:mw.internal.robotics.gazebotransport.JointState.parent_id)
}

// optional string child_name = 9;
inline bool JointState::has_child_name() const {
  return (_has_bits_[0] & 0x00000100u) != 0;
}
inline void JointState::set_has_child_name() {
  _has_bits_[0] |= 0x00000100u;
}
inline void JointState::clear_has_child_name() {
  _has_bits_[0] &= ~0x00000100u;
}
inline void JointState::clear_child_name() {
  child_name_.ClearToEmptyNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
  clear_has_child_name();
}
inline const ::std::string& JointState::child_name() const {
  // @@protoc_insertion_point(field_get:mw.internal.robotics.gazebotransport.JointState.child_name)
  return child_name_.GetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline void JointState::set_child_name(const ::std::string& value) {
  set_has_child_name();
  child_name_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), value);
  // @@protoc_insertion_point(field_set:mw.internal.robotics.gazebotransport.JointState.child_name)
}
inline void JointState::set_child_name(const char* value) {
  set_has_child_name();
  child_name_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::string(value));
  // @@protoc_insertion_point(field_set_char:mw.internal.robotics.gazebotransport.JointState.child_name)
}
inline void JointState::set_child_name(const char* value, size_t size) {
  set_has_child_name();
  child_name_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(),
      ::std::string(reinterpret_cast<const char*>(value), size));
  // @@protoc_insertion_point(field_set_pointer:mw.internal.robotics.gazebotransport.JointState.child_name)
}
inline ::std::string* JointState::mutable_child_name() {
  set_has_child_name();
  // @@protoc_insertion_point(field_mutable:mw.internal.robotics.gazebotransport.JointState.child_name)
  return child_name_.MutableNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline ::std::string* JointState::release_child_name() {
  // @@protoc_insertion_point(field_release:mw.internal.robotics.gazebotransport.JointState.child_name)
  clear_has_child_name();
  return child_name_.ReleaseNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline void JointState::set_allocated_child_name(::std::string* child_name) {
  if (child_name != NULL) {
    set_has_child_name();
  } else {
    clear_has_child_name();
  }
  child_name_.SetAllocatedNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), child_name);
  // @@protoc_insertion_point(field_set_allocated:mw.internal.robotics.gazebotransport.JointState.child_name)
}

// optional uint32 child_id = 10;
inline bool JointState::has_child_id() const {
  return (_has_bits_[0] & 0x00000200u) != 0;
}
inline void JointState::set_has_child_id() {
  _has_bits_[0] |= 0x00000200u;
}
inline void JointState::clear_has_child_id() {
  _has_bits_[0] &= ~0x00000200u;
}
inline void JointState::clear_child_id() {
  child_id_ = 0u;
  clear_has_child_id();
}
inline ::google::protobuf::uint32 JointState::child_id() const {
  // @@protoc_insertion_point(field_get:mw.internal.robotics.gazebotransport.JointState.child_id)
  return child_id_;
}
inline void JointState::set_child_id(::google::protobuf::uint32 value) {
  set_has_child_id();
  child_id_ = value;
  // @@protoc_insertion_point(field_set:mw.internal.robotics.gazebotransport.JointState.child_id)
}

// optional .mw.internal.robotics.gazebotransport.Pose initial_anchor_pose = 11;
inline bool JointState::has_initial_anchor_pose() const {
  return (_has_bits_[0] & 0x00000400u) != 0;
}
inline void JointState::set_has_initial_anchor_pose() {
  _has_bits_[0] |= 0x00000400u;
}
inline void JointState::clear_has_initial_anchor_pose() {
  _has_bits_[0] &= ~0x00000400u;
}
inline void JointState::clear_initial_anchor_pose() {
  if (initial_anchor_pose_ != NULL) initial_anchor_pose_->::mw::internal::robotics::gazebotransport::Pose::Clear();
  clear_has_initial_anchor_pose();
}
inline const ::mw::internal::robotics::gazebotransport::Pose& JointState::initial_anchor_pose() const {
  // @@protoc_insertion_point(field_get:mw.internal.robotics.gazebotransport.JointState.initial_anchor_pose)
  return initial_anchor_pose_ != NULL ? *initial_anchor_pose_ : *default_instance_->initial_anchor_pose_;
}
inline ::mw::internal::robotics::gazebotransport::Pose* JointState::mutable_initial_anchor_pose() {
  set_has_initial_anchor_pose();
  if (initial_anchor_pose_ == NULL) {
    initial_anchor_pose_ = new ::mw::internal::robotics::gazebotransport::Pose;
  }
  // @@protoc_insertion_point(field_mutable:mw.internal.robotics.gazebotransport.JointState.initial_anchor_pose)
  return initial_anchor_pose_;
}
inline ::mw::internal::robotics::gazebotransport::Pose* JointState::release_initial_anchor_pose() {
  // @@protoc_insertion_point(field_release:mw.internal.robotics.gazebotransport.JointState.initial_anchor_pose)
  clear_has_initial_anchor_pose();
  ::mw::internal::robotics::gazebotransport::Pose* temp = initial_anchor_pose_;
  initial_anchor_pose_ = NULL;
  return temp;
}
inline void JointState::set_allocated_initial_anchor_pose(::mw::internal::robotics::gazebotransport::Pose* initial_anchor_pose) {
  delete initial_anchor_pose_;
  initial_anchor_pose_ = initial_anchor_pose;
  if (initial_anchor_pose) {
    set_has_initial_anchor_pose();
  } else {
    clear_has_initial_anchor_pose();
  }
  // @@protoc_insertion_point(field_set_allocated:mw.internal.robotics.gazebotransport.JointState.initial_anchor_pose)
}

// optional .mw.internal.robotics.gazebotransport.Pose world_pose = 12;
inline bool JointState::has_world_pose() const {
  return (_has_bits_[0] & 0x00000800u) != 0;
}
inline void JointState::set_has_world_pose() {
  _has_bits_[0] |= 0x00000800u;
}
inline void JointState::clear_has_world_pose() {
  _has_bits_[0] &= ~0x00000800u;
}
inline void JointState::clear_world_pose() {
  if (world_pose_ != NULL) world_pose_->::mw::internal::robotics::gazebotransport::Pose::Clear();
  clear_has_world_pose();
}
inline const ::mw::internal::robotics::gazebotransport::Pose& JointState::world_pose() const {
  // @@protoc_insertion_point(field_get:mw.internal.robotics.gazebotransport.JointState.world_pose)
  return world_pose_ != NULL ? *world_pose_ : *default_instance_->world_pose_;
}
inline ::mw::internal::robotics::gazebotransport::Pose* JointState::mutable_world_pose() {
  set_has_world_pose();
  if (world_pose_ == NULL) {
    world_pose_ = new ::mw::internal::robotics::gazebotransport::Pose;
  }
  // @@protoc_insertion_point(field_mutable:mw.internal.robotics.gazebotransport.JointState.world_pose)
  return world_pose_;
}
inline ::mw::internal::robotics::gazebotransport::Pose* JointState::release_world_pose() {
  // @@protoc_insertion_point(field_release:mw.internal.robotics.gazebotransport.JointState.world_pose)
  clear_has_world_pose();
  ::mw::internal::robotics::gazebotransport::Pose* temp = world_pose_;
  world_pose_ = NULL;
  return temp;
}
inline void JointState::set_allocated_world_pose(::mw::internal::robotics::gazebotransport::Pose* world_pose) {
  delete world_pose_;
  world_pose_ = world_pose;
  if (world_pose) {
    set_has_world_pose();
  } else {
    clear_has_world_pose();
  }
  // @@protoc_insertion_point(field_set_allocated:mw.internal.robotics.gazebotransport.JointState.world_pose)
}

// optional .mw.internal.robotics.gazebotransport.Pose parent_world_pose = 13;
inline bool JointState::has_parent_world_pose() const {
  return (_has_bits_[0] & 0x00001000u) != 0;
}
inline void JointState::set_has_parent_world_pose() {
  _has_bits_[0] |= 0x00001000u;
}
inline void JointState::clear_has_parent_world_pose() {
  _has_bits_[0] &= ~0x00001000u;
}
inline void JointState::clear_parent_world_pose() {
  if (parent_world_pose_ != NULL) parent_world_pose_->::mw::internal::robotics::gazebotransport::Pose::Clear();
  clear_has_parent_world_pose();
}
inline const ::mw::internal::robotics::gazebotransport::Pose& JointState::parent_world_pose() const {
  // @@protoc_insertion_point(field_get:mw.internal.robotics.gazebotransport.JointState.parent_world_pose)
  return parent_world_pose_ != NULL ? *parent_world_pose_ : *default_instance_->parent_world_pose_;
}
inline ::mw::internal::robotics::gazebotransport::Pose* JointState::mutable_parent_world_pose() {
  set_has_parent_world_pose();
  if (parent_world_pose_ == NULL) {
    parent_world_pose_ = new ::mw::internal::robotics::gazebotransport::Pose;
  }
  // @@protoc_insertion_point(field_mutable:mw.internal.robotics.gazebotransport.JointState.parent_world_pose)
  return parent_world_pose_;
}
inline ::mw::internal::robotics::gazebotransport::Pose* JointState::release_parent_world_pose() {
  // @@protoc_insertion_point(field_release:mw.internal.robotics.gazebotransport.JointState.parent_world_pose)
  clear_has_parent_world_pose();
  ::mw::internal::robotics::gazebotransport::Pose* temp = parent_world_pose_;
  parent_world_pose_ = NULL;
  return temp;
}
inline void JointState::set_allocated_parent_world_pose(::mw::internal::robotics::gazebotransport::Pose* parent_world_pose) {
  delete parent_world_pose_;
  parent_world_pose_ = parent_world_pose;
  if (parent_world_pose) {
    set_has_parent_world_pose();
  } else {
    clear_has_parent_world_pose();
  }
  // @@protoc_insertion_point(field_set_allocated:mw.internal.robotics.gazebotransport.JointState.parent_world_pose)
}

// repeated .mw.internal.robotics.gazebotransport.Axis axis = 14;
inline int JointState::axis_size() const {
  return axis_.size();
}
inline void JointState::clear_axis() {
  axis_.Clear();
}
inline const ::mw::internal::robotics::gazebotransport::Axis& JointState::axis(int index) const {
  // @@protoc_insertion_point(field_get:mw.internal.robotics.gazebotransport.JointState.axis)
  return axis_.Get(index);
}
inline ::mw::internal::robotics::gazebotransport::Axis* JointState::mutable_axis(int index) {
  // @@protoc_insertion_point(field_mutable:mw.internal.robotics.gazebotransport.JointState.axis)
  return axis_.Mutable(index);
}
inline ::mw::internal::robotics::gazebotransport::Axis* JointState::add_axis() {
  // @@protoc_insertion_point(field_add:mw.internal.robotics.gazebotransport.JointState.axis)
  return axis_.Add();
}
inline ::google::protobuf::RepeatedPtrField< ::mw::internal::robotics::gazebotransport::Axis >*
JointState::mutable_axis() {
  // @@protoc_insertion_point(field_mutable_list:mw.internal.robotics.gazebotransport.JointState.axis)
  return &axis_;
}
inline const ::google::protobuf::RepeatedPtrField< ::mw::internal::robotics::gazebotransport::Axis >&
JointState::axis() const {
  // @@protoc_insertion_point(field_list:mw.internal.robotics.gazebotransport.JointState.axis)
  return axis_;
}

// -------------------------------------------------------------------

// SetLinkWorldPose

// required string model_name = 1;
inline bool SetLinkWorldPose::has_model_name() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void SetLinkWorldPose::set_has_model_name() {
  _has_bits_[0] |= 0x00000001u;
}
inline void SetLinkWorldPose::clear_has_model_name() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void SetLinkWorldPose::clear_model_name() {
  model_name_.ClearToEmptyNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
  clear_has_model_name();
}
inline const ::std::string& SetLinkWorldPose::model_name() const {
  // @@protoc_insertion_point(field_get:mw.internal.robotics.gazebotransport.SetLinkWorldPose.model_name)
  return model_name_.GetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline void SetLinkWorldPose::set_model_name(const ::std::string& value) {
  set_has_model_name();
  model_name_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), value);
  // @@protoc_insertion_point(field_set:mw.internal.robotics.gazebotransport.SetLinkWorldPose.model_name)
}
inline void SetLinkWorldPose::set_model_name(const char* value) {
  set_has_model_name();
  model_name_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::string(value));
  // @@protoc_insertion_point(field_set_char:mw.internal.robotics.gazebotransport.SetLinkWorldPose.model_name)
}
inline void SetLinkWorldPose::set_model_name(const char* value, size_t size) {
  set_has_model_name();
  model_name_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(),
      ::std::string(reinterpret_cast<const char*>(value), size));
  // @@protoc_insertion_point(field_set_pointer:mw.internal.robotics.gazebotransport.SetLinkWorldPose.model_name)
}
inline ::std::string* SetLinkWorldPose::mutable_model_name() {
  set_has_model_name();
  // @@protoc_insertion_point(field_mutable:mw.internal.robotics.gazebotransport.SetLinkWorldPose.model_name)
  return model_name_.MutableNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline ::std::string* SetLinkWorldPose::release_model_name() {
  // @@protoc_insertion_point(field_release:mw.internal.robotics.gazebotransport.SetLinkWorldPose.model_name)
  clear_has_model_name();
  return model_name_.ReleaseNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline void SetLinkWorldPose::set_allocated_model_name(::std::string* model_name) {
  if (model_name != NULL) {
    set_has_model_name();
  } else {
    clear_has_model_name();
  }
  model_name_.SetAllocatedNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), model_name);
  // @@protoc_insertion_point(field_set_allocated:mw.internal.robotics.gazebotransport.SetLinkWorldPose.model_name)
}

// required string link_name = 2;
inline bool SetLinkWorldPose::has_link_name() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void SetLinkWorldPose::set_has_link_name() {
  _has_bits_[0] |= 0x00000002u;
}
inline void SetLinkWorldPose::clear_has_link_name() {
  _has_bits_[0] &= ~0x00000002u;
}
inline void SetLinkWorldPose::clear_link_name() {
  link_name_.ClearToEmptyNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
  clear_has_link_name();
}
inline const ::std::string& SetLinkWorldPose::link_name() const {
  // @@protoc_insertion_point(field_get:mw.internal.robotics.gazebotransport.SetLinkWorldPose.link_name)
  return link_name_.GetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline void SetLinkWorldPose::set_link_name(const ::std::string& value) {
  set_has_link_name();
  link_name_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), value);
  // @@protoc_insertion_point(field_set:mw.internal.robotics.gazebotransport.SetLinkWorldPose.link_name)
}
inline void SetLinkWorldPose::set_link_name(const char* value) {
  set_has_link_name();
  link_name_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::string(value));
  // @@protoc_insertion_point(field_set_char:mw.internal.robotics.gazebotransport.SetLinkWorldPose.link_name)
}
inline void SetLinkWorldPose::set_link_name(const char* value, size_t size) {
  set_has_link_name();
  link_name_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(),
      ::std::string(reinterpret_cast<const char*>(value), size));
  // @@protoc_insertion_point(field_set_pointer:mw.internal.robotics.gazebotransport.SetLinkWorldPose.link_name)
}
inline ::std::string* SetLinkWorldPose::mutable_link_name() {
  set_has_link_name();
  // @@protoc_insertion_point(field_mutable:mw.internal.robotics.gazebotransport.SetLinkWorldPose.link_name)
  return link_name_.MutableNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline ::std::string* SetLinkWorldPose::release_link_name() {
  // @@protoc_insertion_point(field_release:mw.internal.robotics.gazebotransport.SetLinkWorldPose.link_name)
  clear_has_link_name();
  return link_name_.ReleaseNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline void SetLinkWorldPose::set_allocated_link_name(::std::string* link_name) {
  if (link_name != NULL) {
    set_has_link_name();
  } else {
    clear_has_link_name();
  }
  link_name_.SetAllocatedNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), link_name);
  // @@protoc_insertion_point(field_set_allocated:mw.internal.robotics.gazebotransport.SetLinkWorldPose.link_name)
}

// required .mw.internal.robotics.gazebotransport.Pose pose = 3;
inline bool SetLinkWorldPose::has_pose() const {
  return (_has_bits_[0] & 0x00000004u) != 0;
}
inline void SetLinkWorldPose::set_has_pose() {
  _has_bits_[0] |= 0x00000004u;
}
inline void SetLinkWorldPose::clear_has_pose() {
  _has_bits_[0] &= ~0x00000004u;
}
inline void SetLinkWorldPose::clear_pose() {
  if (pose_ != NULL) pose_->::mw::internal::robotics::gazebotransport::Pose::Clear();
  clear_has_pose();
}
inline const ::mw::internal::robotics::gazebotransport::Pose& SetLinkWorldPose::pose() const {
  // @@protoc_insertion_point(field_get:mw.internal.robotics.gazebotransport.SetLinkWorldPose.pose)
  return pose_ != NULL ? *pose_ : *default_instance_->pose_;
}
inline ::mw::internal::robotics::gazebotransport::Pose* SetLinkWorldPose::mutable_pose() {
  set_has_pose();
  if (pose_ == NULL) {
    pose_ = new ::mw::internal::robotics::gazebotransport::Pose;
  }
  // @@protoc_insertion_point(field_mutable:mw.internal.robotics.gazebotransport.SetLinkWorldPose.pose)
  return pose_;
}
inline ::mw::internal::robotics::gazebotransport::Pose* SetLinkWorldPose::release_pose() {
  // @@protoc_insertion_point(field_release:mw.internal.robotics.gazebotransport.SetLinkWorldPose.pose)
  clear_has_pose();
  ::mw::internal::robotics::gazebotransport::Pose* temp = pose_;
  pose_ = NULL;
  return temp;
}
inline void SetLinkWorldPose::set_allocated_pose(::mw::internal::robotics::gazebotransport::Pose* pose) {
  delete pose_;
  pose_ = pose;
  if (pose) {
    set_has_pose();
  } else {
    clear_has_pose();
  }
  // @@protoc_insertion_point(field_set_allocated:mw.internal.robotics.gazebotransport.SetLinkWorldPose.pose)
}

// required .mw.internal.robotics.gazebotransport.Time duration = 4;
inline bool SetLinkWorldPose::has_duration() const {
  return (_has_bits_[0] & 0x00000008u) != 0;
}
inline void SetLinkWorldPose::set_has_duration() {
  _has_bits_[0] |= 0x00000008u;
}
inline void SetLinkWorldPose::clear_has_duration() {
  _has_bits_[0] &= ~0x00000008u;
}
inline void SetLinkWorldPose::clear_duration() {
  if (duration_ != NULL) duration_->::mw::internal::robotics::gazebotransport::Time::Clear();
  clear_has_duration();
}
inline const ::mw::internal::robotics::gazebotransport::Time& SetLinkWorldPose::duration() const {
  // @@protoc_insertion_point(field_get:mw.internal.robotics.gazebotransport.SetLinkWorldPose.duration)
  return duration_ != NULL ? *duration_ : *default_instance_->duration_;
}
inline ::mw::internal::robotics::gazebotransport::Time* SetLinkWorldPose::mutable_duration() {
  set_has_duration();
  if (duration_ == NULL) {
    duration_ = new ::mw::internal::robotics::gazebotransport::Time;
  }
  // @@protoc_insertion_point(field_mutable:mw.internal.robotics.gazebotransport.SetLinkWorldPose.duration)
  return duration_;
}
inline ::mw::internal::robotics::gazebotransport::Time* SetLinkWorldPose::release_duration() {
  // @@protoc_insertion_point(field_release:mw.internal.robotics.gazebotransport.SetLinkWorldPose.duration)
  clear_has_duration();
  ::mw::internal::robotics::gazebotransport::Time* temp = duration_;
  duration_ = NULL;
  return temp;
}
inline void SetLinkWorldPose::set_allocated_duration(::mw::internal::robotics::gazebotransport::Time* duration) {
  delete duration_;
  duration_ = duration;
  if (duration) {
    set_has_duration();
  } else {
    clear_has_duration();
  }
  // @@protoc_insertion_point(field_set_allocated:mw.internal.robotics.gazebotransport.SetLinkWorldPose.duration)
}

// -------------------------------------------------------------------

// SetLinkLinearVelocity

// required string model_name = 1;
inline bool SetLinkLinearVelocity::has_model_name() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void SetLinkLinearVelocity::set_has_model_name() {
  _has_bits_[0] |= 0x00000001u;
}
inline void SetLinkLinearVelocity::clear_has_model_name() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void SetLinkLinearVelocity::clear_model_name() {
  model_name_.ClearToEmptyNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
  clear_has_model_name();
}
inline const ::std::string& SetLinkLinearVelocity::model_name() const {
  // @@protoc_insertion_point(field_get:mw.internal.robotics.gazebotransport.SetLinkLinearVelocity.model_name)
  return model_name_.GetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline void SetLinkLinearVelocity::set_model_name(const ::std::string& value) {
  set_has_model_name();
  model_name_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), value);
  // @@protoc_insertion_point(field_set:mw.internal.robotics.gazebotransport.SetLinkLinearVelocity.model_name)
}
inline void SetLinkLinearVelocity::set_model_name(const char* value) {
  set_has_model_name();
  model_name_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::string(value));
  // @@protoc_insertion_point(field_set_char:mw.internal.robotics.gazebotransport.SetLinkLinearVelocity.model_name)
}
inline void SetLinkLinearVelocity::set_model_name(const char* value, size_t size) {
  set_has_model_name();
  model_name_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(),
      ::std::string(reinterpret_cast<const char*>(value), size));
  // @@protoc_insertion_point(field_set_pointer:mw.internal.robotics.gazebotransport.SetLinkLinearVelocity.model_name)
}
inline ::std::string* SetLinkLinearVelocity::mutable_model_name() {
  set_has_model_name();
  // @@protoc_insertion_point(field_mutable:mw.internal.robotics.gazebotransport.SetLinkLinearVelocity.model_name)
  return model_name_.MutableNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline ::std::string* SetLinkLinearVelocity::release_model_name() {
  // @@protoc_insertion_point(field_release:mw.internal.robotics.gazebotransport.SetLinkLinearVelocity.model_name)
  clear_has_model_name();
  return model_name_.ReleaseNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline void SetLinkLinearVelocity::set_allocated_model_name(::std::string* model_name) {
  if (model_name != NULL) {
    set_has_model_name();
  } else {
    clear_has_model_name();
  }
  model_name_.SetAllocatedNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), model_name);
  // @@protoc_insertion_point(field_set_allocated:mw.internal.robotics.gazebotransport.SetLinkLinearVelocity.model_name)
}

// required string link_name = 2;
inline bool SetLinkLinearVelocity::has_link_name() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void SetLinkLinearVelocity::set_has_link_name() {
  _has_bits_[0] |= 0x00000002u;
}
inline void SetLinkLinearVelocity::clear_has_link_name() {
  _has_bits_[0] &= ~0x00000002u;
}
inline void SetLinkLinearVelocity::clear_link_name() {
  link_name_.ClearToEmptyNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
  clear_has_link_name();
}
inline const ::std::string& SetLinkLinearVelocity::link_name() const {
  // @@protoc_insertion_point(field_get:mw.internal.robotics.gazebotransport.SetLinkLinearVelocity.link_name)
  return link_name_.GetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline void SetLinkLinearVelocity::set_link_name(const ::std::string& value) {
  set_has_link_name();
  link_name_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), value);
  // @@protoc_insertion_point(field_set:mw.internal.robotics.gazebotransport.SetLinkLinearVelocity.link_name)
}
inline void SetLinkLinearVelocity::set_link_name(const char* value) {
  set_has_link_name();
  link_name_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::string(value));
  // @@protoc_insertion_point(field_set_char:mw.internal.robotics.gazebotransport.SetLinkLinearVelocity.link_name)
}
inline void SetLinkLinearVelocity::set_link_name(const char* value, size_t size) {
  set_has_link_name();
  link_name_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(),
      ::std::string(reinterpret_cast<const char*>(value), size));
  // @@protoc_insertion_point(field_set_pointer:mw.internal.robotics.gazebotransport.SetLinkLinearVelocity.link_name)
}
inline ::std::string* SetLinkLinearVelocity::mutable_link_name() {
  set_has_link_name();
  // @@protoc_insertion_point(field_mutable:mw.internal.robotics.gazebotransport.SetLinkLinearVelocity.link_name)
  return link_name_.MutableNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline ::std::string* SetLinkLinearVelocity::release_link_name() {
  // @@protoc_insertion_point(field_release:mw.internal.robotics.gazebotransport.SetLinkLinearVelocity.link_name)
  clear_has_link_name();
  return link_name_.ReleaseNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline void SetLinkLinearVelocity::set_allocated_link_name(::std::string* link_name) {
  if (link_name != NULL) {
    set_has_link_name();
  } else {
    clear_has_link_name();
  }
  link_name_.SetAllocatedNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), link_name);
  // @@protoc_insertion_point(field_set_allocated:mw.internal.robotics.gazebotransport.SetLinkLinearVelocity.link_name)
}

// required .mw.internal.robotics.gazebotransport.Point velocity = 3;
inline bool SetLinkLinearVelocity::has_velocity() const {
  return (_has_bits_[0] & 0x00000004u) != 0;
}
inline void SetLinkLinearVelocity::set_has_velocity() {
  _has_bits_[0] |= 0x00000004u;
}
inline void SetLinkLinearVelocity::clear_has_velocity() {
  _has_bits_[0] &= ~0x00000004u;
}
inline void SetLinkLinearVelocity::clear_velocity() {
  if (velocity_ != NULL) velocity_->::mw::internal::robotics::gazebotransport::Point::Clear();
  clear_has_velocity();
}
inline const ::mw::internal::robotics::gazebotransport::Point& SetLinkLinearVelocity::velocity() const {
  // @@protoc_insertion_point(field_get:mw.internal.robotics.gazebotransport.SetLinkLinearVelocity.velocity)
  return velocity_ != NULL ? *velocity_ : *default_instance_->velocity_;
}
inline ::mw::internal::robotics::gazebotransport::Point* SetLinkLinearVelocity::mutable_velocity() {
  set_has_velocity();
  if (velocity_ == NULL) {
    velocity_ = new ::mw::internal::robotics::gazebotransport::Point;
  }
  // @@protoc_insertion_point(field_mutable:mw.internal.robotics.gazebotransport.SetLinkLinearVelocity.velocity)
  return velocity_;
}
inline ::mw::internal::robotics::gazebotransport::Point* SetLinkLinearVelocity::release_velocity() {
  // @@protoc_insertion_point(field_release:mw.internal.robotics.gazebotransport.SetLinkLinearVelocity.velocity)
  clear_has_velocity();
  ::mw::internal::robotics::gazebotransport::Point* temp = velocity_;
  velocity_ = NULL;
  return temp;
}
inline void SetLinkLinearVelocity::set_allocated_velocity(::mw::internal::robotics::gazebotransport::Point* velocity) {
  delete velocity_;
  velocity_ = velocity;
  if (velocity) {
    set_has_velocity();
  } else {
    clear_has_velocity();
  }
  // @@protoc_insertion_point(field_set_allocated:mw.internal.robotics.gazebotransport.SetLinkLinearVelocity.velocity)
}

// required .mw.internal.robotics.gazebotransport.Time duration = 4;
inline bool SetLinkLinearVelocity::has_duration() const {
  return (_has_bits_[0] & 0x00000008u) != 0;
}
inline void SetLinkLinearVelocity::set_has_duration() {
  _has_bits_[0] |= 0x00000008u;
}
inline void SetLinkLinearVelocity::clear_has_duration() {
  _has_bits_[0] &= ~0x00000008u;
}
inline void SetLinkLinearVelocity::clear_duration() {
  if (duration_ != NULL) duration_->::mw::internal::robotics::gazebotransport::Time::Clear();
  clear_has_duration();
}
inline const ::mw::internal::robotics::gazebotransport::Time& SetLinkLinearVelocity::duration() const {
  // @@protoc_insertion_point(field_get:mw.internal.robotics.gazebotransport.SetLinkLinearVelocity.duration)
  return duration_ != NULL ? *duration_ : *default_instance_->duration_;
}
inline ::mw::internal::robotics::gazebotransport::Time* SetLinkLinearVelocity::mutable_duration() {
  set_has_duration();
  if (duration_ == NULL) {
    duration_ = new ::mw::internal::robotics::gazebotransport::Time;
  }
  // @@protoc_insertion_point(field_mutable:mw.internal.robotics.gazebotransport.SetLinkLinearVelocity.duration)
  return duration_;
}
inline ::mw::internal::robotics::gazebotransport::Time* SetLinkLinearVelocity::release_duration() {
  // @@protoc_insertion_point(field_release:mw.internal.robotics.gazebotransport.SetLinkLinearVelocity.duration)
  clear_has_duration();
  ::mw::internal::robotics::gazebotransport::Time* temp = duration_;
  duration_ = NULL;
  return temp;
}
inline void SetLinkLinearVelocity::set_allocated_duration(::mw::internal::robotics::gazebotransport::Time* duration) {
  delete duration_;
  duration_ = duration;
  if (duration) {
    set_has_duration();
  } else {
    clear_has_duration();
  }
  // @@protoc_insertion_point(field_set_allocated:mw.internal.robotics.gazebotransport.SetLinkLinearVelocity.duration)
}

// -------------------------------------------------------------------

// SetLinkAngularVelocity

// required string model_name = 1;
inline bool SetLinkAngularVelocity::has_model_name() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void SetLinkAngularVelocity::set_has_model_name() {
  _has_bits_[0] |= 0x00000001u;
}
inline void SetLinkAngularVelocity::clear_has_model_name() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void SetLinkAngularVelocity::clear_model_name() {
  model_name_.ClearToEmptyNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
  clear_has_model_name();
}
inline const ::std::string& SetLinkAngularVelocity::model_name() const {
  // @@protoc_insertion_point(field_get:mw.internal.robotics.gazebotransport.SetLinkAngularVelocity.model_name)
  return model_name_.GetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline void SetLinkAngularVelocity::set_model_name(const ::std::string& value) {
  set_has_model_name();
  model_name_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), value);
  // @@protoc_insertion_point(field_set:mw.internal.robotics.gazebotransport.SetLinkAngularVelocity.model_name)
}
inline void SetLinkAngularVelocity::set_model_name(const char* value) {
  set_has_model_name();
  model_name_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::string(value));
  // @@protoc_insertion_point(field_set_char:mw.internal.robotics.gazebotransport.SetLinkAngularVelocity.model_name)
}
inline void SetLinkAngularVelocity::set_model_name(const char* value, size_t size) {
  set_has_model_name();
  model_name_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(),
      ::std::string(reinterpret_cast<const char*>(value), size));
  // @@protoc_insertion_point(field_set_pointer:mw.internal.robotics.gazebotransport.SetLinkAngularVelocity.model_name)
}
inline ::std::string* SetLinkAngularVelocity::mutable_model_name() {
  set_has_model_name();
  // @@protoc_insertion_point(field_mutable:mw.internal.robotics.gazebotransport.SetLinkAngularVelocity.model_name)
  return model_name_.MutableNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline ::std::string* SetLinkAngularVelocity::release_model_name() {
  // @@protoc_insertion_point(field_release:mw.internal.robotics.gazebotransport.SetLinkAngularVelocity.model_name)
  clear_has_model_name();
  return model_name_.ReleaseNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline void SetLinkAngularVelocity::set_allocated_model_name(::std::string* model_name) {
  if (model_name != NULL) {
    set_has_model_name();
  } else {
    clear_has_model_name();
  }
  model_name_.SetAllocatedNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), model_name);
  // @@protoc_insertion_point(field_set_allocated:mw.internal.robotics.gazebotransport.SetLinkAngularVelocity.model_name)
}

// required string link_name = 2;
inline bool SetLinkAngularVelocity::has_link_name() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void SetLinkAngularVelocity::set_has_link_name() {
  _has_bits_[0] |= 0x00000002u;
}
inline void SetLinkAngularVelocity::clear_has_link_name() {
  _has_bits_[0] &= ~0x00000002u;
}
inline void SetLinkAngularVelocity::clear_link_name() {
  link_name_.ClearToEmptyNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
  clear_has_link_name();
}
inline const ::std::string& SetLinkAngularVelocity::link_name() const {
  // @@protoc_insertion_point(field_get:mw.internal.robotics.gazebotransport.SetLinkAngularVelocity.link_name)
  return link_name_.GetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline void SetLinkAngularVelocity::set_link_name(const ::std::string& value) {
  set_has_link_name();
  link_name_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), value);
  // @@protoc_insertion_point(field_set:mw.internal.robotics.gazebotransport.SetLinkAngularVelocity.link_name)
}
inline void SetLinkAngularVelocity::set_link_name(const char* value) {
  set_has_link_name();
  link_name_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::string(value));
  // @@protoc_insertion_point(field_set_char:mw.internal.robotics.gazebotransport.SetLinkAngularVelocity.link_name)
}
inline void SetLinkAngularVelocity::set_link_name(const char* value, size_t size) {
  set_has_link_name();
  link_name_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(),
      ::std::string(reinterpret_cast<const char*>(value), size));
  // @@protoc_insertion_point(field_set_pointer:mw.internal.robotics.gazebotransport.SetLinkAngularVelocity.link_name)
}
inline ::std::string* SetLinkAngularVelocity::mutable_link_name() {
  set_has_link_name();
  // @@protoc_insertion_point(field_mutable:mw.internal.robotics.gazebotransport.SetLinkAngularVelocity.link_name)
  return link_name_.MutableNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline ::std::string* SetLinkAngularVelocity::release_link_name() {
  // @@protoc_insertion_point(field_release:mw.internal.robotics.gazebotransport.SetLinkAngularVelocity.link_name)
  clear_has_link_name();
  return link_name_.ReleaseNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline void SetLinkAngularVelocity::set_allocated_link_name(::std::string* link_name) {
  if (link_name != NULL) {
    set_has_link_name();
  } else {
    clear_has_link_name();
  }
  link_name_.SetAllocatedNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), link_name);
  // @@protoc_insertion_point(field_set_allocated:mw.internal.robotics.gazebotransport.SetLinkAngularVelocity.link_name)
}

// required .mw.internal.robotics.gazebotransport.Point velocity = 3;
inline bool SetLinkAngularVelocity::has_velocity() const {
  return (_has_bits_[0] & 0x00000004u) != 0;
}
inline void SetLinkAngularVelocity::set_has_velocity() {
  _has_bits_[0] |= 0x00000004u;
}
inline void SetLinkAngularVelocity::clear_has_velocity() {
  _has_bits_[0] &= ~0x00000004u;
}
inline void SetLinkAngularVelocity::clear_velocity() {
  if (velocity_ != NULL) velocity_->::mw::internal::robotics::gazebotransport::Point::Clear();
  clear_has_velocity();
}
inline const ::mw::internal::robotics::gazebotransport::Point& SetLinkAngularVelocity::velocity() const {
  // @@protoc_insertion_point(field_get:mw.internal.robotics.gazebotransport.SetLinkAngularVelocity.velocity)
  return velocity_ != NULL ? *velocity_ : *default_instance_->velocity_;
}
inline ::mw::internal::robotics::gazebotransport::Point* SetLinkAngularVelocity::mutable_velocity() {
  set_has_velocity();
  if (velocity_ == NULL) {
    velocity_ = new ::mw::internal::robotics::gazebotransport::Point;
  }
  // @@protoc_insertion_point(field_mutable:mw.internal.robotics.gazebotransport.SetLinkAngularVelocity.velocity)
  return velocity_;
}
inline ::mw::internal::robotics::gazebotransport::Point* SetLinkAngularVelocity::release_velocity() {
  // @@protoc_insertion_point(field_release:mw.internal.robotics.gazebotransport.SetLinkAngularVelocity.velocity)
  clear_has_velocity();
  ::mw::internal::robotics::gazebotransport::Point* temp = velocity_;
  velocity_ = NULL;
  return temp;
}
inline void SetLinkAngularVelocity::set_allocated_velocity(::mw::internal::robotics::gazebotransport::Point* velocity) {
  delete velocity_;
  velocity_ = velocity;
  if (velocity) {
    set_has_velocity();
  } else {
    clear_has_velocity();
  }
  // @@protoc_insertion_point(field_set_allocated:mw.internal.robotics.gazebotransport.SetLinkAngularVelocity.velocity)
}

// required .mw.internal.robotics.gazebotransport.Time duration = 4;
inline bool SetLinkAngularVelocity::has_duration() const {
  return (_has_bits_[0] & 0x00000008u) != 0;
}
inline void SetLinkAngularVelocity::set_has_duration() {
  _has_bits_[0] |= 0x00000008u;
}
inline void SetLinkAngularVelocity::clear_has_duration() {
  _has_bits_[0] &= ~0x00000008u;
}
inline void SetLinkAngularVelocity::clear_duration() {
  if (duration_ != NULL) duration_->::mw::internal::robotics::gazebotransport::Time::Clear();
  clear_has_duration();
}
inline const ::mw::internal::robotics::gazebotransport::Time& SetLinkAngularVelocity::duration() const {
  // @@protoc_insertion_point(field_get:mw.internal.robotics.gazebotransport.SetLinkAngularVelocity.duration)
  return duration_ != NULL ? *duration_ : *default_instance_->duration_;
}
inline ::mw::internal::robotics::gazebotransport::Time* SetLinkAngularVelocity::mutable_duration() {
  set_has_duration();
  if (duration_ == NULL) {
    duration_ = new ::mw::internal::robotics::gazebotransport::Time;
  }
  // @@protoc_insertion_point(field_mutable:mw.internal.robotics.gazebotransport.SetLinkAngularVelocity.duration)
  return duration_;
}
inline ::mw::internal::robotics::gazebotransport::Time* SetLinkAngularVelocity::release_duration() {
  // @@protoc_insertion_point(field_release:mw.internal.robotics.gazebotransport.SetLinkAngularVelocity.duration)
  clear_has_duration();
  ::mw::internal::robotics::gazebotransport::Time* temp = duration_;
  duration_ = NULL;
  return temp;
}
inline void SetLinkAngularVelocity::set_allocated_duration(::mw::internal::robotics::gazebotransport::Time* duration) {
  delete duration_;
  duration_ = duration;
  if (duration) {
    set_has_duration();
  } else {
    clear_has_duration();
  }
  // @@protoc_insertion_point(field_set_allocated:mw.internal.robotics.gazebotransport.SetLinkAngularVelocity.duration)
}

// -------------------------------------------------------------------

// GetLinkState

// required string model_name = 1;
inline bool GetLinkState::has_model_name() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void GetLinkState::set_has_model_name() {
  _has_bits_[0] |= 0x00000001u;
}
inline void GetLinkState::clear_has_model_name() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void GetLinkState::clear_model_name() {
  model_name_.ClearToEmptyNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
  clear_has_model_name();
}
inline const ::std::string& GetLinkState::model_name() const {
  // @@protoc_insertion_point(field_get:mw.internal.robotics.gazebotransport.GetLinkState.model_name)
  return model_name_.GetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline void GetLinkState::set_model_name(const ::std::string& value) {
  set_has_model_name();
  model_name_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), value);
  // @@protoc_insertion_point(field_set:mw.internal.robotics.gazebotransport.GetLinkState.model_name)
}
inline void GetLinkState::set_model_name(const char* value) {
  set_has_model_name();
  model_name_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::string(value));
  // @@protoc_insertion_point(field_set_char:mw.internal.robotics.gazebotransport.GetLinkState.model_name)
}
inline void GetLinkState::set_model_name(const char* value, size_t size) {
  set_has_model_name();
  model_name_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(),
      ::std::string(reinterpret_cast<const char*>(value), size));
  // @@protoc_insertion_point(field_set_pointer:mw.internal.robotics.gazebotransport.GetLinkState.model_name)
}
inline ::std::string* GetLinkState::mutable_model_name() {
  set_has_model_name();
  // @@protoc_insertion_point(field_mutable:mw.internal.robotics.gazebotransport.GetLinkState.model_name)
  return model_name_.MutableNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline ::std::string* GetLinkState::release_model_name() {
  // @@protoc_insertion_point(field_release:mw.internal.robotics.gazebotransport.GetLinkState.model_name)
  clear_has_model_name();
  return model_name_.ReleaseNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline void GetLinkState::set_allocated_model_name(::std::string* model_name) {
  if (model_name != NULL) {
    set_has_model_name();
  } else {
    clear_has_model_name();
  }
  model_name_.SetAllocatedNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), model_name);
  // @@protoc_insertion_point(field_set_allocated:mw.internal.robotics.gazebotransport.GetLinkState.model_name)
}

// required string link_name = 2;
inline bool GetLinkState::has_link_name() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void GetLinkState::set_has_link_name() {
  _has_bits_[0] |= 0x00000002u;
}
inline void GetLinkState::clear_has_link_name() {
  _has_bits_[0] &= ~0x00000002u;
}
inline void GetLinkState::clear_link_name() {
  link_name_.ClearToEmptyNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
  clear_has_link_name();
}
inline const ::std::string& GetLinkState::link_name() const {
  // @@protoc_insertion_point(field_get:mw.internal.robotics.gazebotransport.GetLinkState.link_name)
  return link_name_.GetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline void GetLinkState::set_link_name(const ::std::string& value) {
  set_has_link_name();
  link_name_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), value);
  // @@protoc_insertion_point(field_set:mw.internal.robotics.gazebotransport.GetLinkState.link_name)
}
inline void GetLinkState::set_link_name(const char* value) {
  set_has_link_name();
  link_name_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::string(value));
  // @@protoc_insertion_point(field_set_char:mw.internal.robotics.gazebotransport.GetLinkState.link_name)
}
inline void GetLinkState::set_link_name(const char* value, size_t size) {
  set_has_link_name();
  link_name_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(),
      ::std::string(reinterpret_cast<const char*>(value), size));
  // @@protoc_insertion_point(field_set_pointer:mw.internal.robotics.gazebotransport.GetLinkState.link_name)
}
inline ::std::string* GetLinkState::mutable_link_name() {
  set_has_link_name();
  // @@protoc_insertion_point(field_mutable:mw.internal.robotics.gazebotransport.GetLinkState.link_name)
  return link_name_.MutableNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline ::std::string* GetLinkState::release_link_name() {
  // @@protoc_insertion_point(field_release:mw.internal.robotics.gazebotransport.GetLinkState.link_name)
  clear_has_link_name();
  return link_name_.ReleaseNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline void GetLinkState::set_allocated_link_name(::std::string* link_name) {
  if (link_name != NULL) {
    set_has_link_name();
  } else {
    clear_has_link_name();
  }
  link_name_.SetAllocatedNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), link_name);
  // @@protoc_insertion_point(field_set_allocated:mw.internal.robotics.gazebotransport.GetLinkState.link_name)
}

// -------------------------------------------------------------------

// LinkState

// required string model_name = 1;
inline bool LinkState::has_model_name() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void LinkState::set_has_model_name() {
  _has_bits_[0] |= 0x00000001u;
}
inline void LinkState::clear_has_model_name() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void LinkState::clear_model_name() {
  model_name_.ClearToEmptyNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
  clear_has_model_name();
}
inline const ::std::string& LinkState::model_name() const {
  // @@protoc_insertion_point(field_get:mw.internal.robotics.gazebotransport.LinkState.model_name)
  return model_name_.GetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline void LinkState::set_model_name(const ::std::string& value) {
  set_has_model_name();
  model_name_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), value);
  // @@protoc_insertion_point(field_set:mw.internal.robotics.gazebotransport.LinkState.model_name)
}
inline void LinkState::set_model_name(const char* value) {
  set_has_model_name();
  model_name_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::string(value));
  // @@protoc_insertion_point(field_set_char:mw.internal.robotics.gazebotransport.LinkState.model_name)
}
inline void LinkState::set_model_name(const char* value, size_t size) {
  set_has_model_name();
  model_name_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(),
      ::std::string(reinterpret_cast<const char*>(value), size));
  // @@protoc_insertion_point(field_set_pointer:mw.internal.robotics.gazebotransport.LinkState.model_name)
}
inline ::std::string* LinkState::mutable_model_name() {
  set_has_model_name();
  // @@protoc_insertion_point(field_mutable:mw.internal.robotics.gazebotransport.LinkState.model_name)
  return model_name_.MutableNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline ::std::string* LinkState::release_model_name() {
  // @@protoc_insertion_point(field_release:mw.internal.robotics.gazebotransport.LinkState.model_name)
  clear_has_model_name();
  return model_name_.ReleaseNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline void LinkState::set_allocated_model_name(::std::string* model_name) {
  if (model_name != NULL) {
    set_has_model_name();
  } else {
    clear_has_model_name();
  }
  model_name_.SetAllocatedNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), model_name);
  // @@protoc_insertion_point(field_set_allocated:mw.internal.robotics.gazebotransport.LinkState.model_name)
}

// required string link_name = 2;
inline bool LinkState::has_link_name() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void LinkState::set_has_link_name() {
  _has_bits_[0] |= 0x00000002u;
}
inline void LinkState::clear_has_link_name() {
  _has_bits_[0] &= ~0x00000002u;
}
inline void LinkState::clear_link_name() {
  link_name_.ClearToEmptyNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
  clear_has_link_name();
}
inline const ::std::string& LinkState::link_name() const {
  // @@protoc_insertion_point(field_get:mw.internal.robotics.gazebotransport.LinkState.link_name)
  return link_name_.GetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline void LinkState::set_link_name(const ::std::string& value) {
  set_has_link_name();
  link_name_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), value);
  // @@protoc_insertion_point(field_set:mw.internal.robotics.gazebotransport.LinkState.link_name)
}
inline void LinkState::set_link_name(const char* value) {
  set_has_link_name();
  link_name_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::string(value));
  // @@protoc_insertion_point(field_set_char:mw.internal.robotics.gazebotransport.LinkState.link_name)
}
inline void LinkState::set_link_name(const char* value, size_t size) {
  set_has_link_name();
  link_name_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(),
      ::std::string(reinterpret_cast<const char*>(value), size));
  // @@protoc_insertion_point(field_set_pointer:mw.internal.robotics.gazebotransport.LinkState.link_name)
}
inline ::std::string* LinkState::mutable_link_name() {
  set_has_link_name();
  // @@protoc_insertion_point(field_mutable:mw.internal.robotics.gazebotransport.LinkState.link_name)
  return link_name_.MutableNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline ::std::string* LinkState::release_link_name() {
  // @@protoc_insertion_point(field_release:mw.internal.robotics.gazebotransport.LinkState.link_name)
  clear_has_link_name();
  return link_name_.ReleaseNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline void LinkState::set_allocated_link_name(::std::string* link_name) {
  if (link_name != NULL) {
    set_has_link_name();
  } else {
    clear_has_link_name();
  }
  link_name_.SetAllocatedNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), link_name);
  // @@protoc_insertion_point(field_set_allocated:mw.internal.robotics.gazebotransport.LinkState.link_name)
}

// required uint32 link_id = 3;
inline bool LinkState::has_link_id() const {
  return (_has_bits_[0] & 0x00000004u) != 0;
}
inline void LinkState::set_has_link_id() {
  _has_bits_[0] |= 0x00000004u;
}
inline void LinkState::clear_has_link_id() {
  _has_bits_[0] &= ~0x00000004u;
}
inline void LinkState::clear_link_id() {
  link_id_ = 0u;
  clear_has_link_id();
}
inline ::google::protobuf::uint32 LinkState::link_id() const {
  // @@protoc_insertion_point(field_get:mw.internal.robotics.gazebotransport.LinkState.link_id)
  return link_id_;
}
inline void LinkState::set_link_id(::google::protobuf::uint32 value) {
  set_has_link_id();
  link_id_ = value;
  // @@protoc_insertion_point(field_set:mw.internal.robotics.gazebotransport.LinkState.link_id)
}

// required .mw.internal.robotics.gazebotransport.Point world_linear_velocity = 4;
inline bool LinkState::has_world_linear_velocity() const {
  return (_has_bits_[0] & 0x00000008u) != 0;
}
inline void LinkState::set_has_world_linear_velocity() {
  _has_bits_[0] |= 0x00000008u;
}
inline void LinkState::clear_has_world_linear_velocity() {
  _has_bits_[0] &= ~0x00000008u;
}
inline void LinkState::clear_world_linear_velocity() {
  if (world_linear_velocity_ != NULL) world_linear_velocity_->::mw::internal::robotics::gazebotransport::Point::Clear();
  clear_has_world_linear_velocity();
}
inline const ::mw::internal::robotics::gazebotransport::Point& LinkState::world_linear_velocity() const {
  // @@protoc_insertion_point(field_get:mw.internal.robotics.gazebotransport.LinkState.world_linear_velocity)
  return world_linear_velocity_ != NULL ? *world_linear_velocity_ : *default_instance_->world_linear_velocity_;
}
inline ::mw::internal::robotics::gazebotransport::Point* LinkState::mutable_world_linear_velocity() {
  set_has_world_linear_velocity();
  if (world_linear_velocity_ == NULL) {
    world_linear_velocity_ = new ::mw::internal::robotics::gazebotransport::Point;
  }
  // @@protoc_insertion_point(field_mutable:mw.internal.robotics.gazebotransport.LinkState.world_linear_velocity)
  return world_linear_velocity_;
}
inline ::mw::internal::robotics::gazebotransport::Point* LinkState::release_world_linear_velocity() {
  // @@protoc_insertion_point(field_release:mw.internal.robotics.gazebotransport.LinkState.world_linear_velocity)
  clear_has_world_linear_velocity();
  ::mw::internal::robotics::gazebotransport::Point* temp = world_linear_velocity_;
  world_linear_velocity_ = NULL;
  return temp;
}
inline void LinkState::set_allocated_world_linear_velocity(::mw::internal::robotics::gazebotransport::Point* world_linear_velocity) {
  delete world_linear_velocity_;
  world_linear_velocity_ = world_linear_velocity;
  if (world_linear_velocity) {
    set_has_world_linear_velocity();
  } else {
    clear_has_world_linear_velocity();
  }
  // @@protoc_insertion_point(field_set_allocated:mw.internal.robotics.gazebotransport.LinkState.world_linear_velocity)
}

// required .mw.internal.robotics.gazebotransport.Point world_angular_velocity = 5;
inline bool LinkState::has_world_angular_velocity() const {
  return (_has_bits_[0] & 0x00000010u) != 0;
}
inline void LinkState::set_has_world_angular_velocity() {
  _has_bits_[0] |= 0x00000010u;
}
inline void LinkState::clear_has_world_angular_velocity() {
  _has_bits_[0] &= ~0x00000010u;
}
inline void LinkState::clear_world_angular_velocity() {
  if (world_angular_velocity_ != NULL) world_angular_velocity_->::mw::internal::robotics::gazebotransport::Point::Clear();
  clear_has_world_angular_velocity();
}
inline const ::mw::internal::robotics::gazebotransport::Point& LinkState::world_angular_velocity() const {
  // @@protoc_insertion_point(field_get:mw.internal.robotics.gazebotransport.LinkState.world_angular_velocity)
  return world_angular_velocity_ != NULL ? *world_angular_velocity_ : *default_instance_->world_angular_velocity_;
}
inline ::mw::internal::robotics::gazebotransport::Point* LinkState::mutable_world_angular_velocity() {
  set_has_world_angular_velocity();
  if (world_angular_velocity_ == NULL) {
    world_angular_velocity_ = new ::mw::internal::robotics::gazebotransport::Point;
  }
  // @@protoc_insertion_point(field_mutable:mw.internal.robotics.gazebotransport.LinkState.world_angular_velocity)
  return world_angular_velocity_;
}
inline ::mw::internal::robotics::gazebotransport::Point* LinkState::release_world_angular_velocity() {
  // @@protoc_insertion_point(field_release:mw.internal.robotics.gazebotransport.LinkState.world_angular_velocity)
  clear_has_world_angular_velocity();
  ::mw::internal::robotics::gazebotransport::Point* temp = world_angular_velocity_;
  world_angular_velocity_ = NULL;
  return temp;
}
inline void LinkState::set_allocated_world_angular_velocity(::mw::internal::robotics::gazebotransport::Point* world_angular_velocity) {
  delete world_angular_velocity_;
  world_angular_velocity_ = world_angular_velocity;
  if (world_angular_velocity) {
    set_has_world_angular_velocity();
  } else {
    clear_has_world_angular_velocity();
  }
  // @@protoc_insertion_point(field_set_allocated:mw.internal.robotics.gazebotransport.LinkState.world_angular_velocity)
}

// required .mw.internal.robotics.gazebotransport.Point relative_linear_velocity = 6;
inline bool LinkState::has_relative_linear_velocity() const {
  return (_has_bits_[0] & 0x00000020u) != 0;
}
inline void LinkState::set_has_relative_linear_velocity() {
  _has_bits_[0] |= 0x00000020u;
}
inline void LinkState::clear_has_relative_linear_velocity() {
  _has_bits_[0] &= ~0x00000020u;
}
inline void LinkState::clear_relative_linear_velocity() {
  if (relative_linear_velocity_ != NULL) relative_linear_velocity_->::mw::internal::robotics::gazebotransport::Point::Clear();
  clear_has_relative_linear_velocity();
}
inline const ::mw::internal::robotics::gazebotransport::Point& LinkState::relative_linear_velocity() const {
  // @@protoc_insertion_point(field_get:mw.internal.robotics.gazebotransport.LinkState.relative_linear_velocity)
  return relative_linear_velocity_ != NULL ? *relative_linear_velocity_ : *default_instance_->relative_linear_velocity_;
}
inline ::mw::internal::robotics::gazebotransport::Point* LinkState::mutable_relative_linear_velocity() {
  set_has_relative_linear_velocity();
  if (relative_linear_velocity_ == NULL) {
    relative_linear_velocity_ = new ::mw::internal::robotics::gazebotransport::Point;
  }
  // @@protoc_insertion_point(field_mutable:mw.internal.robotics.gazebotransport.LinkState.relative_linear_velocity)
  return relative_linear_velocity_;
}
inline ::mw::internal::robotics::gazebotransport::Point* LinkState::release_relative_linear_velocity() {
  // @@protoc_insertion_point(field_release:mw.internal.robotics.gazebotransport.LinkState.relative_linear_velocity)
  clear_has_relative_linear_velocity();
  ::mw::internal::robotics::gazebotransport::Point* temp = relative_linear_velocity_;
  relative_linear_velocity_ = NULL;
  return temp;
}
inline void LinkState::set_allocated_relative_linear_velocity(::mw::internal::robotics::gazebotransport::Point* relative_linear_velocity) {
  delete relative_linear_velocity_;
  relative_linear_velocity_ = relative_linear_velocity;
  if (relative_linear_velocity) {
    set_has_relative_linear_velocity();
  } else {
    clear_has_relative_linear_velocity();
  }
  // @@protoc_insertion_point(field_set_allocated:mw.internal.robotics.gazebotransport.LinkState.relative_linear_velocity)
}

// required .mw.internal.robotics.gazebotransport.Point relative_angular_velocity = 7;
inline bool LinkState::has_relative_angular_velocity() const {
  return (_has_bits_[0] & 0x00000040u) != 0;
}
inline void LinkState::set_has_relative_angular_velocity() {
  _has_bits_[0] |= 0x00000040u;
}
inline void LinkState::clear_has_relative_angular_velocity() {
  _has_bits_[0] &= ~0x00000040u;
}
inline void LinkState::clear_relative_angular_velocity() {
  if (relative_angular_velocity_ != NULL) relative_angular_velocity_->::mw::internal::robotics::gazebotransport::Point::Clear();
  clear_has_relative_angular_velocity();
}
inline const ::mw::internal::robotics::gazebotransport::Point& LinkState::relative_angular_velocity() const {
  // @@protoc_insertion_point(field_get:mw.internal.robotics.gazebotransport.LinkState.relative_angular_velocity)
  return relative_angular_velocity_ != NULL ? *relative_angular_velocity_ : *default_instance_->relative_angular_velocity_;
}
inline ::mw::internal::robotics::gazebotransport::Point* LinkState::mutable_relative_angular_velocity() {
  set_has_relative_angular_velocity();
  if (relative_angular_velocity_ == NULL) {
    relative_angular_velocity_ = new ::mw::internal::robotics::gazebotransport::Point;
  }
  // @@protoc_insertion_point(field_mutable:mw.internal.robotics.gazebotransport.LinkState.relative_angular_velocity)
  return relative_angular_velocity_;
}
inline ::mw::internal::robotics::gazebotransport::Point* LinkState::release_relative_angular_velocity() {
  // @@protoc_insertion_point(field_release:mw.internal.robotics.gazebotransport.LinkState.relative_angular_velocity)
  clear_has_relative_angular_velocity();
  ::mw::internal::robotics::gazebotransport::Point* temp = relative_angular_velocity_;
  relative_angular_velocity_ = NULL;
  return temp;
}
inline void LinkState::set_allocated_relative_angular_velocity(::mw::internal::robotics::gazebotransport::Point* relative_angular_velocity) {
  delete relative_angular_velocity_;
  relative_angular_velocity_ = relative_angular_velocity;
  if (relative_angular_velocity) {
    set_has_relative_angular_velocity();
  } else {
    clear_has_relative_angular_velocity();
  }
  // @@protoc_insertion_point(field_set_allocated:mw.internal.robotics.gazebotransport.LinkState.relative_angular_velocity)
}

// optional .mw.internal.robotics.gazebotransport.Pose world_pose = 8;
inline bool LinkState::has_world_pose() const {
  return (_has_bits_[0] & 0x00000080u) != 0;
}
inline void LinkState::set_has_world_pose() {
  _has_bits_[0] |= 0x00000080u;
}
inline void LinkState::clear_has_world_pose() {
  _has_bits_[0] &= ~0x00000080u;
}
inline void LinkState::clear_world_pose() {
  if (world_pose_ != NULL) world_pose_->::mw::internal::robotics::gazebotransport::Pose::Clear();
  clear_has_world_pose();
}
inline const ::mw::internal::robotics::gazebotransport::Pose& LinkState::world_pose() const {
  // @@protoc_insertion_point(field_get:mw.internal.robotics.gazebotransport.LinkState.world_pose)
  return world_pose_ != NULL ? *world_pose_ : *default_instance_->world_pose_;
}
inline ::mw::internal::robotics::gazebotransport::Pose* LinkState::mutable_world_pose() {
  set_has_world_pose();
  if (world_pose_ == NULL) {
    world_pose_ = new ::mw::internal::robotics::gazebotransport::Pose;
  }
  // @@protoc_insertion_point(field_mutable:mw.internal.robotics.gazebotransport.LinkState.world_pose)
  return world_pose_;
}
inline ::mw::internal::robotics::gazebotransport::Pose* LinkState::release_world_pose() {
  // @@protoc_insertion_point(field_release:mw.internal.robotics.gazebotransport.LinkState.world_pose)
  clear_has_world_pose();
  ::mw::internal::robotics::gazebotransport::Pose* temp = world_pose_;
  world_pose_ = NULL;
  return temp;
}
inline void LinkState::set_allocated_world_pose(::mw::internal::robotics::gazebotransport::Pose* world_pose) {
  delete world_pose_;
  world_pose_ = world_pose;
  if (world_pose) {
    set_has_world_pose();
  } else {
    clear_has_world_pose();
  }
  // @@protoc_insertion_point(field_set_allocated:mw.internal.robotics.gazebotransport.LinkState.world_pose)
}

// optional .mw.internal.robotics.gazebotransport.Pose relative_pose = 9;
inline bool LinkState::has_relative_pose() const {
  return (_has_bits_[0] & 0x00000100u) != 0;
}
inline void LinkState::set_has_relative_pose() {
  _has_bits_[0] |= 0x00000100u;
}
inline void LinkState::clear_has_relative_pose() {
  _has_bits_[0] &= ~0x00000100u;
}
inline void LinkState::clear_relative_pose() {
  if (relative_pose_ != NULL) relative_pose_->::mw::internal::robotics::gazebotransport::Pose::Clear();
  clear_has_relative_pose();
}
inline const ::mw::internal::robotics::gazebotransport::Pose& LinkState::relative_pose() const {
  // @@protoc_insertion_point(field_get:mw.internal.robotics.gazebotransport.LinkState.relative_pose)
  return relative_pose_ != NULL ? *relative_pose_ : *default_instance_->relative_pose_;
}
inline ::mw::internal::robotics::gazebotransport::Pose* LinkState::mutable_relative_pose() {
  set_has_relative_pose();
  if (relative_pose_ == NULL) {
    relative_pose_ = new ::mw::internal::robotics::gazebotransport::Pose;
  }
  // @@protoc_insertion_point(field_mutable:mw.internal.robotics.gazebotransport.LinkState.relative_pose)
  return relative_pose_;
}
inline ::mw::internal::robotics::gazebotransport::Pose* LinkState::release_relative_pose() {
  // @@protoc_insertion_point(field_release:mw.internal.robotics.gazebotransport.LinkState.relative_pose)
  clear_has_relative_pose();
  ::mw::internal::robotics::gazebotransport::Pose* temp = relative_pose_;
  relative_pose_ = NULL;
  return temp;
}
inline void LinkState::set_allocated_relative_pose(::mw::internal::robotics::gazebotransport::Pose* relative_pose) {
  delete relative_pose_;
  relative_pose_ = relative_pose;
  if (relative_pose) {
    set_has_relative_pose();
  } else {
    clear_has_relative_pose();
  }
  // @@protoc_insertion_point(field_set_allocated:mw.internal.robotics.gazebotransport.LinkState.relative_pose)
}

// optional bool self_collide = 10;
inline bool LinkState::has_self_collide() const {
  return (_has_bits_[0] & 0x00000200u) != 0;
}
inline void LinkState::set_has_self_collide() {
  _has_bits_[0] |= 0x00000200u;
}
inline void LinkState::clear_has_self_collide() {
  _has_bits_[0] &= ~0x00000200u;
}
inline void LinkState::clear_self_collide() {
  self_collide_ = false;
  clear_has_self_collide();
}
inline bool LinkState::self_collide() const {
  // @@protoc_insertion_point(field_get:mw.internal.robotics.gazebotransport.LinkState.self_collide)
  return self_collide_;
}
inline void LinkState::set_self_collide(bool value) {
  set_has_self_collide();
  self_collide_ = value;
  // @@protoc_insertion_point(field_set:mw.internal.robotics.gazebotransport.LinkState.self_collide)
}

// optional bool gravity = 11;
inline bool LinkState::has_gravity() const {
  return (_has_bits_[0] & 0x00000400u) != 0;
}
inline void LinkState::set_has_gravity() {
  _has_bits_[0] |= 0x00000400u;
}
inline void LinkState::clear_has_gravity() {
  _has_bits_[0] &= ~0x00000400u;
}
inline void LinkState::clear_gravity() {
  gravity_ = false;
  clear_has_gravity();
}
inline bool LinkState::gravity() const {
  // @@protoc_insertion_point(field_get:mw.internal.robotics.gazebotransport.LinkState.gravity)
  return gravity_;
}
inline void LinkState::set_gravity(bool value) {
  set_has_gravity();
  gravity_ = value;
  // @@protoc_insertion_point(field_set:mw.internal.robotics.gazebotransport.LinkState.gravity)
}

// optional bool kinematic = 12;
inline bool LinkState::has_kinematic() const {
  return (_has_bits_[0] & 0x00000800u) != 0;
}
inline void LinkState::set_has_kinematic() {
  _has_bits_[0] |= 0x00000800u;
}
inline void LinkState::clear_has_kinematic() {
  _has_bits_[0] &= ~0x00000800u;
}
inline void LinkState::clear_kinematic() {
  kinematic_ = false;
  clear_has_kinematic();
}
inline bool LinkState::kinematic() const {
  // @@protoc_insertion_point(field_get:mw.internal.robotics.gazebotransport.LinkState.kinematic)
  return kinematic_;
}
inline void LinkState::set_kinematic(bool value) {
  set_has_kinematic();
  kinematic_ = value;
  // @@protoc_insertion_point(field_set:mw.internal.robotics.gazebotransport.LinkState.kinematic)
}

// optional bool enable_wind = 13;
inline bool LinkState::has_enable_wind() const {
  return (_has_bits_[0] & 0x00001000u) != 0;
}
inline void LinkState::set_has_enable_wind() {
  _has_bits_[0] |= 0x00001000u;
}
inline void LinkState::clear_has_enable_wind() {
  _has_bits_[0] &= ~0x00001000u;
}
inline void LinkState::clear_enable_wind() {
  enable_wind_ = false;
  clear_has_enable_wind();
}
inline bool LinkState::enable_wind() const {
  // @@protoc_insertion_point(field_get:mw.internal.robotics.gazebotransport.LinkState.enable_wind)
  return enable_wind_;
}
inline void LinkState::set_enable_wind(bool value) {
  set_has_enable_wind();
  enable_wind_ = value;
  // @@protoc_insertion_point(field_set:mw.internal.robotics.gazebotransport.LinkState.enable_wind)
}

// optional bool canonical = 14;
inline bool LinkState::has_canonical() const {
  return (_has_bits_[0] & 0x00002000u) != 0;
}
inline void LinkState::set_has_canonical() {
  _has_bits_[0] |= 0x00002000u;
}
inline void LinkState::clear_has_canonical() {
  _has_bits_[0] &= ~0x00002000u;
}
inline void LinkState::clear_canonical() {
  canonical_ = false;
  clear_has_canonical();
}
inline bool LinkState::canonical() const {
  // @@protoc_insertion_point(field_get:mw.internal.robotics.gazebotransport.LinkState.canonical)
  return canonical_;
}
inline void LinkState::set_canonical(bool value) {
  set_has_canonical();
  canonical_ = value;
  // @@protoc_insertion_point(field_set:mw.internal.robotics.gazebotransport.LinkState.canonical)
}

// -------------------------------------------------------------------

// ML_Cord

// optional double x = 1;
inline bool ML_Cord::has_x() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void ML_Cord::set_has_x() {
  _has_bits_[0] |= 0x00000001u;
}
inline void ML_Cord::clear_has_x() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void ML_Cord::clear_x() {
  x_ = 0;
  clear_has_x();
}
inline double ML_Cord::x() const {
  // @@protoc_insertion_point(field_get:mw.internal.robotics.gazebotransport.ML_Cord.x)
  return x_;
}
inline void ML_Cord::set_x(double value) {
  set_has_x();
  x_ = value;
  // @@protoc_insertion_point(field_set:mw.internal.robotics.gazebotransport.ML_Cord.x)
}

// optional double y = 2;
inline bool ML_Cord::has_y() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void ML_Cord::set_has_y() {
  _has_bits_[0] |= 0x00000002u;
}
inline void ML_Cord::clear_has_y() {
  _has_bits_[0] &= ~0x00000002u;
}
inline void ML_Cord::clear_y() {
  y_ = 0;
  clear_has_y();
}
inline double ML_Cord::y() const {
  // @@protoc_insertion_point(field_get:mw.internal.robotics.gazebotransport.ML_Cord.y)
  return y_;
}
inline void ML_Cord::set_y(double value) {
  set_has_y();
  y_ = value;
  // @@protoc_insertion_point(field_set:mw.internal.robotics.gazebotransport.ML_Cord.y)
}

// -------------------------------------------------------------------

// ML_Point

// optional double x = 1;
inline bool ML_Point::has_x() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void ML_Point::set_has_x() {
  _has_bits_[0] |= 0x00000001u;
}
inline void ML_Point::clear_has_x() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void ML_Point::clear_x() {
  x_ = 0;
  clear_has_x();
}
inline double ML_Point::x() const {
  // @@protoc_insertion_point(field_get:mw.internal.robotics.gazebotransport.ML_Point.x)
  return x_;
}
inline void ML_Point::set_x(double value) {
  set_has_x();
  x_ = value;
  // @@protoc_insertion_point(field_set:mw.internal.robotics.gazebotransport.ML_Point.x)
}

// optional double y = 2;
inline bool ML_Point::has_y() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void ML_Point::set_has_y() {
  _has_bits_[0] |= 0x00000002u;
}
inline void ML_Point::clear_has_y() {
  _has_bits_[0] &= ~0x00000002u;
}
inline void ML_Point::clear_y() {
  y_ = 0;
  clear_has_y();
}
inline double ML_Point::y() const {
  // @@protoc_insertion_point(field_get:mw.internal.robotics.gazebotransport.ML_Point.y)
  return y_;
}
inline void ML_Point::set_y(double value) {
  set_has_y();
  y_ = value;
  // @@protoc_insertion_point(field_set:mw.internal.robotics.gazebotransport.ML_Point.y)
}

// optional double z = 3;
inline bool ML_Point::has_z() const {
  return (_has_bits_[0] & 0x00000004u) != 0;
}
inline void ML_Point::set_has_z() {
  _has_bits_[0] |= 0x00000004u;
}
inline void ML_Point::clear_has_z() {
  _has_bits_[0] &= ~0x00000004u;
}
inline void ML_Point::clear_z() {
  z_ = 0;
  clear_has_z();
}
inline double ML_Point::z() const {
  // @@protoc_insertion_point(field_get:mw.internal.robotics.gazebotransport.ML_Point.z)
  return z_;
}
inline void ML_Point::set_z(double value) {
  set_has_z();
  z_ = value;
  // @@protoc_insertion_point(field_set:mw.internal.robotics.gazebotransport.ML_Point.z)
}

// -------------------------------------------------------------------

// ML_Quat

// optional double x = 1;
inline bool ML_Quat::has_x() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void ML_Quat::set_has_x() {
  _has_bits_[0] |= 0x00000001u;
}
inline void ML_Quat::clear_has_x() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void ML_Quat::clear_x() {
  x_ = 0;
  clear_has_x();
}
inline double ML_Quat::x() const {
  // @@protoc_insertion_point(field_get:mw.internal.robotics.gazebotransport.ML_Quat.x)
  return x_;
}
inline void ML_Quat::set_x(double value) {
  set_has_x();
  x_ = value;
  // @@protoc_insertion_point(field_set:mw.internal.robotics.gazebotransport.ML_Quat.x)
}

// optional double y = 2;
inline bool ML_Quat::has_y() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void ML_Quat::set_has_y() {
  _has_bits_[0] |= 0x00000002u;
}
inline void ML_Quat::clear_has_y() {
  _has_bits_[0] &= ~0x00000002u;
}
inline void ML_Quat::clear_y() {
  y_ = 0;
  clear_has_y();
}
inline double ML_Quat::y() const {
  // @@protoc_insertion_point(field_get:mw.internal.robotics.gazebotransport.ML_Quat.y)
  return y_;
}
inline void ML_Quat::set_y(double value) {
  set_has_y();
  y_ = value;
  // @@protoc_insertion_point(field_set:mw.internal.robotics.gazebotransport.ML_Quat.y)
}

// optional double z = 3;
inline bool ML_Quat::has_z() const {
  return (_has_bits_[0] & 0x00000004u) != 0;
}
inline void ML_Quat::set_has_z() {
  _has_bits_[0] |= 0x00000004u;
}
inline void ML_Quat::clear_has_z() {
  _has_bits_[0] &= ~0x00000004u;
}
inline void ML_Quat::clear_z() {
  z_ = 0;
  clear_has_z();
}
inline double ML_Quat::z() const {
  // @@protoc_insertion_point(field_get:mw.internal.robotics.gazebotransport.ML_Quat.z)
  return z_;
}
inline void ML_Quat::set_z(double value) {
  set_has_z();
  z_ = value;
  // @@protoc_insertion_point(field_set:mw.internal.robotics.gazebotransport.ML_Quat.z)
}

// optional double w = 4;
inline bool ML_Quat::has_w() const {
  return (_has_bits_[0] & 0x00000008u) != 0;
}
inline void ML_Quat::set_has_w() {
  _has_bits_[0] |= 0x00000008u;
}
inline void ML_Quat::clear_has_w() {
  _has_bits_[0] &= ~0x00000008u;
}
inline void ML_Quat::clear_w() {
  w_ = 0;
  clear_has_w();
}
inline double ML_Quat::w() const {
  // @@protoc_insertion_point(field_get:mw.internal.robotics.gazebotransport.ML_Quat.w)
  return w_;
}
inline void ML_Quat::set_w(double value) {
  set_has_w();
  w_ = value;
  // @@protoc_insertion_point(field_set:mw.internal.robotics.gazebotransport.ML_Quat.w)
}

// -------------------------------------------------------------------

// ML_Pose

// optional .mw.internal.robotics.gazebotransport.ML_Point position = 1;
inline bool ML_Pose::has_position() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void ML_Pose::set_has_position() {
  _has_bits_[0] |= 0x00000001u;
}
inline void ML_Pose::clear_has_position() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void ML_Pose::clear_position() {
  if (position_ != NULL) position_->::mw::internal::robotics::gazebotransport::ML_Point::Clear();
  clear_has_position();
}
inline const ::mw::internal::robotics::gazebotransport::ML_Point& ML_Pose::position() const {
  // @@protoc_insertion_point(field_get:mw.internal.robotics.gazebotransport.ML_Pose.position)
  return position_ != NULL ? *position_ : *default_instance_->position_;
}
inline ::mw::internal::robotics::gazebotransport::ML_Point* ML_Pose::mutable_position() {
  set_has_position();
  if (position_ == NULL) {
    position_ = new ::mw::internal::robotics::gazebotransport::ML_Point;
  }
  // @@protoc_insertion_point(field_mutable:mw.internal.robotics.gazebotransport.ML_Pose.position)
  return position_;
}
inline ::mw::internal::robotics::gazebotransport::ML_Point* ML_Pose::release_position() {
  // @@protoc_insertion_point(field_release:mw.internal.robotics.gazebotransport.ML_Pose.position)
  clear_has_position();
  ::mw::internal::robotics::gazebotransport::ML_Point* temp = position_;
  position_ = NULL;
  return temp;
}
inline void ML_Pose::set_allocated_position(::mw::internal::robotics::gazebotransport::ML_Point* position) {
  delete position_;
  position_ = position;
  if (position) {
    set_has_position();
  } else {
    clear_has_position();
  }
  // @@protoc_insertion_point(field_set_allocated:mw.internal.robotics.gazebotransport.ML_Pose.position)
}

// optional .mw.internal.robotics.gazebotransport.ML_Quat orientation = 2;
inline bool ML_Pose::has_orientation() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void ML_Pose::set_has_orientation() {
  _has_bits_[0] |= 0x00000002u;
}
inline void ML_Pose::clear_has_orientation() {
  _has_bits_[0] &= ~0x00000002u;
}
inline void ML_Pose::clear_orientation() {
  if (orientation_ != NULL) orientation_->::mw::internal::robotics::gazebotransport::ML_Quat::Clear();
  clear_has_orientation();
}
inline const ::mw::internal::robotics::gazebotransport::ML_Quat& ML_Pose::orientation() const {
  // @@protoc_insertion_point(field_get:mw.internal.robotics.gazebotransport.ML_Pose.orientation)
  return orientation_ != NULL ? *orientation_ : *default_instance_->orientation_;
}
inline ::mw::internal::robotics::gazebotransport::ML_Quat* ML_Pose::mutable_orientation() {
  set_has_orientation();
  if (orientation_ == NULL) {
    orientation_ = new ::mw::internal::robotics::gazebotransport::ML_Quat;
  }
  // @@protoc_insertion_point(field_mutable:mw.internal.robotics.gazebotransport.ML_Pose.orientation)
  return orientation_;
}
inline ::mw::internal::robotics::gazebotransport::ML_Quat* ML_Pose::release_orientation() {
  // @@protoc_insertion_point(field_release:mw.internal.robotics.gazebotransport.ML_Pose.orientation)
  clear_has_orientation();
  ::mw::internal::robotics::gazebotransport::ML_Quat* temp = orientation_;
  orientation_ = NULL;
  return temp;
}
inline void ML_Pose::set_allocated_orientation(::mw::internal::robotics::gazebotransport::ML_Quat* orientation) {
  delete orientation_;
  orientation_ = orientation;
  if (orientation) {
    set_has_orientation();
  } else {
    clear_has_orientation();
  }
  // @@protoc_insertion_point(field_set_allocated:mw.internal.robotics.gazebotransport.ML_Pose.orientation)
}

// -------------------------------------------------------------------

// ML_Inertial

// optional double mass = 1;
inline bool ML_Inertial::has_mass() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void ML_Inertial::set_has_mass() {
  _has_bits_[0] |= 0x00000001u;
}
inline void ML_Inertial::clear_has_mass() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void ML_Inertial::clear_mass() {
  mass_ = 0;
  clear_has_mass();
}
inline double ML_Inertial::mass() const {
  // @@protoc_insertion_point(field_get:mw.internal.robotics.gazebotransport.ML_Inertial.mass)
  return mass_;
}
inline void ML_Inertial::set_mass(double value) {
  set_has_mass();
  mass_ = value;
  // @@protoc_insertion_point(field_set:mw.internal.robotics.gazebotransport.ML_Inertial.mass)
}

// optional double ixx = 2;
inline bool ML_Inertial::has_ixx() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void ML_Inertial::set_has_ixx() {
  _has_bits_[0] |= 0x00000002u;
}
inline void ML_Inertial::clear_has_ixx() {
  _has_bits_[0] &= ~0x00000002u;
}
inline void ML_Inertial::clear_ixx() {
  ixx_ = 0;
  clear_has_ixx();
}
inline double ML_Inertial::ixx() const {
  // @@protoc_insertion_point(field_get:mw.internal.robotics.gazebotransport.ML_Inertial.ixx)
  return ixx_;
}
inline void ML_Inertial::set_ixx(double value) {
  set_has_ixx();
  ixx_ = value;
  // @@protoc_insertion_point(field_set:mw.internal.robotics.gazebotransport.ML_Inertial.ixx)
}

// optional double ixy = 3;
inline bool ML_Inertial::has_ixy() const {
  return (_has_bits_[0] & 0x00000004u) != 0;
}
inline void ML_Inertial::set_has_ixy() {
  _has_bits_[0] |= 0x00000004u;
}
inline void ML_Inertial::clear_has_ixy() {
  _has_bits_[0] &= ~0x00000004u;
}
inline void ML_Inertial::clear_ixy() {
  ixy_ = 0;
  clear_has_ixy();
}
inline double ML_Inertial::ixy() const {
  // @@protoc_insertion_point(field_get:mw.internal.robotics.gazebotransport.ML_Inertial.ixy)
  return ixy_;
}
inline void ML_Inertial::set_ixy(double value) {
  set_has_ixy();
  ixy_ = value;
  // @@protoc_insertion_point(field_set:mw.internal.robotics.gazebotransport.ML_Inertial.ixy)
}

// optional double ixz = 4;
inline bool ML_Inertial::has_ixz() const {
  return (_has_bits_[0] & 0x00000008u) != 0;
}
inline void ML_Inertial::set_has_ixz() {
  _has_bits_[0] |= 0x00000008u;
}
inline void ML_Inertial::clear_has_ixz() {
  _has_bits_[0] &= ~0x00000008u;
}
inline void ML_Inertial::clear_ixz() {
  ixz_ = 0;
  clear_has_ixz();
}
inline double ML_Inertial::ixz() const {
  // @@protoc_insertion_point(field_get:mw.internal.robotics.gazebotransport.ML_Inertial.ixz)
  return ixz_;
}
inline void ML_Inertial::set_ixz(double value) {
  set_has_ixz();
  ixz_ = value;
  // @@protoc_insertion_point(field_set:mw.internal.robotics.gazebotransport.ML_Inertial.ixz)
}

// optional double iyy = 5;
inline bool ML_Inertial::has_iyy() const {
  return (_has_bits_[0] & 0x00000010u) != 0;
}
inline void ML_Inertial::set_has_iyy() {
  _has_bits_[0] |= 0x00000010u;
}
inline void ML_Inertial::clear_has_iyy() {
  _has_bits_[0] &= ~0x00000010u;
}
inline void ML_Inertial::clear_iyy() {
  iyy_ = 0;
  clear_has_iyy();
}
inline double ML_Inertial::iyy() const {
  // @@protoc_insertion_point(field_get:mw.internal.robotics.gazebotransport.ML_Inertial.iyy)
  return iyy_;
}
inline void ML_Inertial::set_iyy(double value) {
  set_has_iyy();
  iyy_ = value;
  // @@protoc_insertion_point(field_set:mw.internal.robotics.gazebotransport.ML_Inertial.iyy)
}

// optional double iyz = 6;
inline bool ML_Inertial::has_iyz() const {
  return (_has_bits_[0] & 0x00000020u) != 0;
}
inline void ML_Inertial::set_has_iyz() {
  _has_bits_[0] |= 0x00000020u;
}
inline void ML_Inertial::clear_has_iyz() {
  _has_bits_[0] &= ~0x00000020u;
}
inline void ML_Inertial::clear_iyz() {
  iyz_ = 0;
  clear_has_iyz();
}
inline double ML_Inertial::iyz() const {
  // @@protoc_insertion_point(field_get:mw.internal.robotics.gazebotransport.ML_Inertial.iyz)
  return iyz_;
}
inline void ML_Inertial::set_iyz(double value) {
  set_has_iyz();
  iyz_ = value;
  // @@protoc_insertion_point(field_set:mw.internal.robotics.gazebotransport.ML_Inertial.iyz)
}

// optional double izz = 7;
inline bool ML_Inertial::has_izz() const {
  return (_has_bits_[0] & 0x00000040u) != 0;
}
inline void ML_Inertial::set_has_izz() {
  _has_bits_[0] |= 0x00000040u;
}
inline void ML_Inertial::clear_has_izz() {
  _has_bits_[0] &= ~0x00000040u;
}
inline void ML_Inertial::clear_izz() {
  izz_ = 0;
  clear_has_izz();
}
inline double ML_Inertial::izz() const {
  // @@protoc_insertion_point(field_get:mw.internal.robotics.gazebotransport.ML_Inertial.izz)
  return izz_;
}
inline void ML_Inertial::set_izz(double value) {
  set_has_izz();
  izz_ = value;
  // @@protoc_insertion_point(field_set:mw.internal.robotics.gazebotransport.ML_Inertial.izz)
}

// -------------------------------------------------------------------

// ML_Links

// optional string name = 1;
inline bool ML_Links::has_name() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void ML_Links::set_has_name() {
  _has_bits_[0] |= 0x00000001u;
}
inline void ML_Links::clear_has_name() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void ML_Links::clear_name() {
  name_.ClearToEmptyNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
  clear_has_name();
}
inline const ::std::string& ML_Links::name() const {
  // @@protoc_insertion_point(field_get:mw.internal.robotics.gazebotransport.ML_Links.name)
  return name_.GetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline void ML_Links::set_name(const ::std::string& value) {
  set_has_name();
  name_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), value);
  // @@protoc_insertion_point(field_set:mw.internal.robotics.gazebotransport.ML_Links.name)
}
inline void ML_Links::set_name(const char* value) {
  set_has_name();
  name_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::string(value));
  // @@protoc_insertion_point(field_set_char:mw.internal.robotics.gazebotransport.ML_Links.name)
}
inline void ML_Links::set_name(const char* value, size_t size) {
  set_has_name();
  name_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(),
      ::std::string(reinterpret_cast<const char*>(value), size));
  // @@protoc_insertion_point(field_set_pointer:mw.internal.robotics.gazebotransport.ML_Links.name)
}
inline ::std::string* ML_Links::mutable_name() {
  set_has_name();
  // @@protoc_insertion_point(field_mutable:mw.internal.robotics.gazebotransport.ML_Links.name)
  return name_.MutableNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline ::std::string* ML_Links::release_name() {
  // @@protoc_insertion_point(field_release:mw.internal.robotics.gazebotransport.ML_Links.name)
  clear_has_name();
  return name_.ReleaseNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline void ML_Links::set_allocated_name(::std::string* name) {
  if (name != NULL) {
    set_has_name();
  } else {
    clear_has_name();
  }
  name_.SetAllocatedNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), name);
  // @@protoc_insertion_point(field_set_allocated:mw.internal.robotics.gazebotransport.ML_Links.name)
}

// optional .mw.internal.robotics.gazebotransport.ML_Pose pose = 2;
inline bool ML_Links::has_pose() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void ML_Links::set_has_pose() {
  _has_bits_[0] |= 0x00000002u;
}
inline void ML_Links::clear_has_pose() {
  _has_bits_[0] &= ~0x00000002u;
}
inline void ML_Links::clear_pose() {
  if (pose_ != NULL) pose_->::mw::internal::robotics::gazebotransport::ML_Pose::Clear();
  clear_has_pose();
}
inline const ::mw::internal::robotics::gazebotransport::ML_Pose& ML_Links::pose() const {
  // @@protoc_insertion_point(field_get:mw.internal.robotics.gazebotransport.ML_Links.pose)
  return pose_ != NULL ? *pose_ : *default_instance_->pose_;
}
inline ::mw::internal::robotics::gazebotransport::ML_Pose* ML_Links::mutable_pose() {
  set_has_pose();
  if (pose_ == NULL) {
    pose_ = new ::mw::internal::robotics::gazebotransport::ML_Pose;
  }
  // @@protoc_insertion_point(field_mutable:mw.internal.robotics.gazebotransport.ML_Links.pose)
  return pose_;
}
inline ::mw::internal::robotics::gazebotransport::ML_Pose* ML_Links::release_pose() {
  // @@protoc_insertion_point(field_release:mw.internal.robotics.gazebotransport.ML_Links.pose)
  clear_has_pose();
  ::mw::internal::robotics::gazebotransport::ML_Pose* temp = pose_;
  pose_ = NULL;
  return temp;
}
inline void ML_Links::set_allocated_pose(::mw::internal::robotics::gazebotransport::ML_Pose* pose) {
  delete pose_;
  pose_ = pose;
  if (pose) {
    set_has_pose();
  } else {
    clear_has_pose();
  }
  // @@protoc_insertion_point(field_set_allocated:mw.internal.robotics.gazebotransport.ML_Links.pose)
}

// optional .mw.internal.robotics.gazebotransport.ML_Inertial inertial = 3;
inline bool ML_Links::has_inertial() const {
  return (_has_bits_[0] & 0x00000004u) != 0;
}
inline void ML_Links::set_has_inertial() {
  _has_bits_[0] |= 0x00000004u;
}
inline void ML_Links::clear_has_inertial() {
  _has_bits_[0] &= ~0x00000004u;
}
inline void ML_Links::clear_inertial() {
  if (inertial_ != NULL) inertial_->::mw::internal::robotics::gazebotransport::ML_Inertial::Clear();
  clear_has_inertial();
}
inline const ::mw::internal::robotics::gazebotransport::ML_Inertial& ML_Links::inertial() const {
  // @@protoc_insertion_point(field_get:mw.internal.robotics.gazebotransport.ML_Links.inertial)
  return inertial_ != NULL ? *inertial_ : *default_instance_->inertial_;
}
inline ::mw::internal::robotics::gazebotransport::ML_Inertial* ML_Links::mutable_inertial() {
  set_has_inertial();
  if (inertial_ == NULL) {
    inertial_ = new ::mw::internal::robotics::gazebotransport::ML_Inertial;
  }
  // @@protoc_insertion_point(field_mutable:mw.internal.robotics.gazebotransport.ML_Links.inertial)
  return inertial_;
}
inline ::mw::internal::robotics::gazebotransport::ML_Inertial* ML_Links::release_inertial() {
  // @@protoc_insertion_point(field_release:mw.internal.robotics.gazebotransport.ML_Links.inertial)
  clear_has_inertial();
  ::mw::internal::robotics::gazebotransport::ML_Inertial* temp = inertial_;
  inertial_ = NULL;
  return temp;
}
inline void ML_Links::set_allocated_inertial(::mw::internal::robotics::gazebotransport::ML_Inertial* inertial) {
  delete inertial_;
  inertial_ = inertial;
  if (inertial) {
    set_has_inertial();
  } else {
    clear_has_inertial();
  }
  // @@protoc_insertion_point(field_set_allocated:mw.internal.robotics.gazebotransport.ML_Links.inertial)
}

// optional bool self_collide = 4;
inline bool ML_Links::has_self_collide() const {
  return (_has_bits_[0] & 0x00000008u) != 0;
}
inline void ML_Links::set_has_self_collide() {
  _has_bits_[0] |= 0x00000008u;
}
inline void ML_Links::clear_has_self_collide() {
  _has_bits_[0] &= ~0x00000008u;
}
inline void ML_Links::clear_self_collide() {
  self_collide_ = false;
  clear_has_self_collide();
}
inline bool ML_Links::self_collide() const {
  // @@protoc_insertion_point(field_get:mw.internal.robotics.gazebotransport.ML_Links.self_collide)
  return self_collide_;
}
inline void ML_Links::set_self_collide(bool value) {
  set_has_self_collide();
  self_collide_ = value;
  // @@protoc_insertion_point(field_set:mw.internal.robotics.gazebotransport.ML_Links.self_collide)
}

// optional bool gravity = 5;
inline bool ML_Links::has_gravity() const {
  return (_has_bits_[0] & 0x00000010u) != 0;
}
inline void ML_Links::set_has_gravity() {
  _has_bits_[0] |= 0x00000010u;
}
inline void ML_Links::clear_has_gravity() {
  _has_bits_[0] &= ~0x00000010u;
}
inline void ML_Links::clear_gravity() {
  gravity_ = false;
  clear_has_gravity();
}
inline bool ML_Links::gravity() const {
  // @@protoc_insertion_point(field_get:mw.internal.robotics.gazebotransport.ML_Links.gravity)
  return gravity_;
}
inline void ML_Links::set_gravity(bool value) {
  set_has_gravity();
  gravity_ = value;
  // @@protoc_insertion_point(field_set:mw.internal.robotics.gazebotransport.ML_Links.gravity)
}

// optional bool kinematic = 6;
inline bool ML_Links::has_kinematic() const {
  return (_has_bits_[0] & 0x00000020u) != 0;
}
inline void ML_Links::set_has_kinematic() {
  _has_bits_[0] |= 0x00000020u;
}
inline void ML_Links::clear_has_kinematic() {
  _has_bits_[0] &= ~0x00000020u;
}
inline void ML_Links::clear_kinematic() {
  kinematic_ = false;
  clear_has_kinematic();
}
inline bool ML_Links::kinematic() const {
  // @@protoc_insertion_point(field_get:mw.internal.robotics.gazebotransport.ML_Links.kinematic)
  return kinematic_;
}
inline void ML_Links::set_kinematic(bool value) {
  set_has_kinematic();
  kinematic_ = value;
  // @@protoc_insertion_point(field_set:mw.internal.robotics.gazebotransport.ML_Links.kinematic)
}

// optional bool enabled_wind = 7;
inline bool ML_Links::has_enabled_wind() const {
  return (_has_bits_[0] & 0x00000040u) != 0;
}
inline void ML_Links::set_has_enabled_wind() {
  _has_bits_[0] |= 0x00000040u;
}
inline void ML_Links::clear_has_enabled_wind() {
  _has_bits_[0] &= ~0x00000040u;
}
inline void ML_Links::clear_enabled_wind() {
  enabled_wind_ = false;
  clear_has_enabled_wind();
}
inline bool ML_Links::enabled_wind() const {
  // @@protoc_insertion_point(field_get:mw.internal.robotics.gazebotransport.ML_Links.enabled_wind)
  return enabled_wind_;
}
inline void ML_Links::set_enabled_wind(bool value) {
  set_has_enabled_wind();
  enabled_wind_ = value;
  // @@protoc_insertion_point(field_set:mw.internal.robotics.gazebotransport.ML_Links.enabled_wind)
}

// optional bool is_static = 8;
inline bool ML_Links::has_is_static() const {
  return (_has_bits_[0] & 0x00000080u) != 0;
}
inline void ML_Links::set_has_is_static() {
  _has_bits_[0] |= 0x00000080u;
}
inline void ML_Links::clear_has_is_static() {
  _has_bits_[0] &= ~0x00000080u;
}
inline void ML_Links::clear_is_static() {
  is_static_ = false;
  clear_has_is_static();
}
inline bool ML_Links::is_static() const {
  // @@protoc_insertion_point(field_get:mw.internal.robotics.gazebotransport.ML_Links.is_static)
  return is_static_;
}
inline void ML_Links::set_is_static(bool value) {
  set_has_is_static();
  is_static_ = value;
  // @@protoc_insertion_point(field_set:mw.internal.robotics.gazebotransport.ML_Links.is_static)
}

// optional bool canonical = 9;
inline bool ML_Links::has_canonical() const {
  return (_has_bits_[0] & 0x00000100u) != 0;
}
inline void ML_Links::set_has_canonical() {
  _has_bits_[0] |= 0x00000100u;
}
inline void ML_Links::clear_has_canonical() {
  _has_bits_[0] &= ~0x00000100u;
}
inline void ML_Links::clear_canonical() {
  canonical_ = false;
  clear_has_canonical();
}
inline bool ML_Links::canonical() const {
  // @@protoc_insertion_point(field_get:mw.internal.robotics.gazebotransport.ML_Links.canonical)
  return canonical_;
}
inline void ML_Links::set_canonical(bool value) {
  set_has_canonical();
  canonical_ = value;
  // @@protoc_insertion_point(field_set:mw.internal.robotics.gazebotransport.ML_Links.canonical)
}

// -------------------------------------------------------------------

// ML_Axis

// optional .mw.internal.robotics.gazebotransport.ML_Point xyz = 1;
inline bool ML_Axis::has_xyz() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void ML_Axis::set_has_xyz() {
  _has_bits_[0] |= 0x00000001u;
}
inline void ML_Axis::clear_has_xyz() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void ML_Axis::clear_xyz() {
  if (xyz_ != NULL) xyz_->::mw::internal::robotics::gazebotransport::ML_Point::Clear();
  clear_has_xyz();
}
inline const ::mw::internal::robotics::gazebotransport::ML_Point& ML_Axis::xyz() const {
  // @@protoc_insertion_point(field_get:mw.internal.robotics.gazebotransport.ML_Axis.xyz)
  return xyz_ != NULL ? *xyz_ : *default_instance_->xyz_;
}
inline ::mw::internal::robotics::gazebotransport::ML_Point* ML_Axis::mutable_xyz() {
  set_has_xyz();
  if (xyz_ == NULL) {
    xyz_ = new ::mw::internal::robotics::gazebotransport::ML_Point;
  }
  // @@protoc_insertion_point(field_mutable:mw.internal.robotics.gazebotransport.ML_Axis.xyz)
  return xyz_;
}
inline ::mw::internal::robotics::gazebotransport::ML_Point* ML_Axis::release_xyz() {
  // @@protoc_insertion_point(field_release:mw.internal.robotics.gazebotransport.ML_Axis.xyz)
  clear_has_xyz();
  ::mw::internal::robotics::gazebotransport::ML_Point* temp = xyz_;
  xyz_ = NULL;
  return temp;
}
inline void ML_Axis::set_allocated_xyz(::mw::internal::robotics::gazebotransport::ML_Point* xyz) {
  delete xyz_;
  xyz_ = xyz;
  if (xyz) {
    set_has_xyz();
  } else {
    clear_has_xyz();
  }
  // @@protoc_insertion_point(field_set_allocated:mw.internal.robotics.gazebotransport.ML_Axis.xyz)
}

// optional double damping = 2;
inline bool ML_Axis::has_damping() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void ML_Axis::set_has_damping() {
  _has_bits_[0] |= 0x00000002u;
}
inline void ML_Axis::clear_has_damping() {
  _has_bits_[0] &= ~0x00000002u;
}
inline void ML_Axis::clear_damping() {
  damping_ = 0;
  clear_has_damping();
}
inline double ML_Axis::damping() const {
  // @@protoc_insertion_point(field_get:mw.internal.robotics.gazebotransport.ML_Axis.damping)
  return damping_;
}
inline void ML_Axis::set_damping(double value) {
  set_has_damping();
  damping_ = value;
  // @@protoc_insertion_point(field_set:mw.internal.robotics.gazebotransport.ML_Axis.damping)
}

// optional double friction = 3;
inline bool ML_Axis::has_friction() const {
  return (_has_bits_[0] & 0x00000004u) != 0;
}
inline void ML_Axis::set_has_friction() {
  _has_bits_[0] |= 0x00000004u;
}
inline void ML_Axis::clear_has_friction() {
  _has_bits_[0] &= ~0x00000004u;
}
inline void ML_Axis::clear_friction() {
  friction_ = 0;
  clear_has_friction();
}
inline double ML_Axis::friction() const {
  // @@protoc_insertion_point(field_get:mw.internal.robotics.gazebotransport.ML_Axis.friction)
  return friction_;
}
inline void ML_Axis::set_friction(double value) {
  set_has_friction();
  friction_ = value;
  // @@protoc_insertion_point(field_set:mw.internal.robotics.gazebotransport.ML_Axis.friction)
}

// optional double angle = 4;
inline bool ML_Axis::has_angle() const {
  return (_has_bits_[0] & 0x00000008u) != 0;
}
inline void ML_Axis::set_has_angle() {
  _has_bits_[0] |= 0x00000008u;
}
inline void ML_Axis::clear_has_angle() {
  _has_bits_[0] &= ~0x00000008u;
}
inline void ML_Axis::clear_angle() {
  angle_ = 0;
  clear_has_angle();
}
inline double ML_Axis::angle() const {
  // @@protoc_insertion_point(field_get:mw.internal.robotics.gazebotransport.ML_Axis.angle)
  return angle_;
}
inline void ML_Axis::set_angle(double value) {
  set_has_angle();
  angle_ = value;
  // @@protoc_insertion_point(field_set:mw.internal.robotics.gazebotransport.ML_Axis.angle)
}

// -------------------------------------------------------------------

// ML_Joints

// optional string name = 1;
inline bool ML_Joints::has_name() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void ML_Joints::set_has_name() {
  _has_bits_[0] |= 0x00000001u;
}
inline void ML_Joints::clear_has_name() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void ML_Joints::clear_name() {
  name_.ClearToEmptyNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
  clear_has_name();
}
inline const ::std::string& ML_Joints::name() const {
  // @@protoc_insertion_point(field_get:mw.internal.robotics.gazebotransport.ML_Joints.name)
  return name_.GetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline void ML_Joints::set_name(const ::std::string& value) {
  set_has_name();
  name_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), value);
  // @@protoc_insertion_point(field_set:mw.internal.robotics.gazebotransport.ML_Joints.name)
}
inline void ML_Joints::set_name(const char* value) {
  set_has_name();
  name_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::string(value));
  // @@protoc_insertion_point(field_set_char:mw.internal.robotics.gazebotransport.ML_Joints.name)
}
inline void ML_Joints::set_name(const char* value, size_t size) {
  set_has_name();
  name_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(),
      ::std::string(reinterpret_cast<const char*>(value), size));
  // @@protoc_insertion_point(field_set_pointer:mw.internal.robotics.gazebotransport.ML_Joints.name)
}
inline ::std::string* ML_Joints::mutable_name() {
  set_has_name();
  // @@protoc_insertion_point(field_mutable:mw.internal.robotics.gazebotransport.ML_Joints.name)
  return name_.MutableNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline ::std::string* ML_Joints::release_name() {
  // @@protoc_insertion_point(field_release:mw.internal.robotics.gazebotransport.ML_Joints.name)
  clear_has_name();
  return name_.ReleaseNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline void ML_Joints::set_allocated_name(::std::string* name) {
  if (name != NULL) {
    set_has_name();
  } else {
    clear_has_name();
  }
  name_.SetAllocatedNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), name);
  // @@protoc_insertion_point(field_set_allocated:mw.internal.robotics.gazebotransport.ML_Joints.name)
}

// optional .mw.internal.robotics.gazebotransport.ML_Pose pose = 2;
inline bool ML_Joints::has_pose() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void ML_Joints::set_has_pose() {
  _has_bits_[0] |= 0x00000002u;
}
inline void ML_Joints::clear_has_pose() {
  _has_bits_[0] &= ~0x00000002u;
}
inline void ML_Joints::clear_pose() {
  if (pose_ != NULL) pose_->::mw::internal::robotics::gazebotransport::ML_Pose::Clear();
  clear_has_pose();
}
inline const ::mw::internal::robotics::gazebotransport::ML_Pose& ML_Joints::pose() const {
  // @@protoc_insertion_point(field_get:mw.internal.robotics.gazebotransport.ML_Joints.pose)
  return pose_ != NULL ? *pose_ : *default_instance_->pose_;
}
inline ::mw::internal::robotics::gazebotransport::ML_Pose* ML_Joints::mutable_pose() {
  set_has_pose();
  if (pose_ == NULL) {
    pose_ = new ::mw::internal::robotics::gazebotransport::ML_Pose;
  }
  // @@protoc_insertion_point(field_mutable:mw.internal.robotics.gazebotransport.ML_Joints.pose)
  return pose_;
}
inline ::mw::internal::robotics::gazebotransport::ML_Pose* ML_Joints::release_pose() {
  // @@protoc_insertion_point(field_release:mw.internal.robotics.gazebotransport.ML_Joints.pose)
  clear_has_pose();
  ::mw::internal::robotics::gazebotransport::ML_Pose* temp = pose_;
  pose_ = NULL;
  return temp;
}
inline void ML_Joints::set_allocated_pose(::mw::internal::robotics::gazebotransport::ML_Pose* pose) {
  delete pose_;
  pose_ = pose;
  if (pose) {
    set_has_pose();
  } else {
    clear_has_pose();
  }
  // @@protoc_insertion_point(field_set_allocated:mw.internal.robotics.gazebotransport.ML_Joints.pose)
}

// optional .mw.internal.robotics.gazebotransport.ML_Axis axis1 = 3;
inline bool ML_Joints::has_axis1() const {
  return (_has_bits_[0] & 0x00000004u) != 0;
}
inline void ML_Joints::set_has_axis1() {
  _has_bits_[0] |= 0x00000004u;
}
inline void ML_Joints::clear_has_axis1() {
  _has_bits_[0] &= ~0x00000004u;
}
inline void ML_Joints::clear_axis1() {
  if (axis1_ != NULL) axis1_->::mw::internal::robotics::gazebotransport::ML_Axis::Clear();
  clear_has_axis1();
}
inline const ::mw::internal::robotics::gazebotransport::ML_Axis& ML_Joints::axis1() const {
  // @@protoc_insertion_point(field_get:mw.internal.robotics.gazebotransport.ML_Joints.axis1)
  return axis1_ != NULL ? *axis1_ : *default_instance_->axis1_;
}
inline ::mw::internal::robotics::gazebotransport::ML_Axis* ML_Joints::mutable_axis1() {
  set_has_axis1();
  if (axis1_ == NULL) {
    axis1_ = new ::mw::internal::robotics::gazebotransport::ML_Axis;
  }
  // @@protoc_insertion_point(field_mutable:mw.internal.robotics.gazebotransport.ML_Joints.axis1)
  return axis1_;
}
inline ::mw::internal::robotics::gazebotransport::ML_Axis* ML_Joints::release_axis1() {
  // @@protoc_insertion_point(field_release:mw.internal.robotics.gazebotransport.ML_Joints.axis1)
  clear_has_axis1();
  ::mw::internal::robotics::gazebotransport::ML_Axis* temp = axis1_;
  axis1_ = NULL;
  return temp;
}
inline void ML_Joints::set_allocated_axis1(::mw::internal::robotics::gazebotransport::ML_Axis* axis1) {
  delete axis1_;
  axis1_ = axis1;
  if (axis1) {
    set_has_axis1();
  } else {
    clear_has_axis1();
  }
  // @@protoc_insertion_point(field_set_allocated:mw.internal.robotics.gazebotransport.ML_Joints.axis1)
}

// optional .mw.internal.robotics.gazebotransport.ML_Axis axis2 = 4;
inline bool ML_Joints::has_axis2() const {
  return (_has_bits_[0] & 0x00000008u) != 0;
}
inline void ML_Joints::set_has_axis2() {
  _has_bits_[0] |= 0x00000008u;
}
inline void ML_Joints::clear_has_axis2() {
  _has_bits_[0] &= ~0x00000008u;
}
inline void ML_Joints::clear_axis2() {
  if (axis2_ != NULL) axis2_->::mw::internal::robotics::gazebotransport::ML_Axis::Clear();
  clear_has_axis2();
}
inline const ::mw::internal::robotics::gazebotransport::ML_Axis& ML_Joints::axis2() const {
  // @@protoc_insertion_point(field_get:mw.internal.robotics.gazebotransport.ML_Joints.axis2)
  return axis2_ != NULL ? *axis2_ : *default_instance_->axis2_;
}
inline ::mw::internal::robotics::gazebotransport::ML_Axis* ML_Joints::mutable_axis2() {
  set_has_axis2();
  if (axis2_ == NULL) {
    axis2_ = new ::mw::internal::robotics::gazebotransport::ML_Axis;
  }
  // @@protoc_insertion_point(field_mutable:mw.internal.robotics.gazebotransport.ML_Joints.axis2)
  return axis2_;
}
inline ::mw::internal::robotics::gazebotransport::ML_Axis* ML_Joints::release_axis2() {
  // @@protoc_insertion_point(field_release:mw.internal.robotics.gazebotransport.ML_Joints.axis2)
  clear_has_axis2();
  ::mw::internal::robotics::gazebotransport::ML_Axis* temp = axis2_;
  axis2_ = NULL;
  return temp;
}
inline void ML_Joints::set_allocated_axis2(::mw::internal::robotics::gazebotransport::ML_Axis* axis2) {
  delete axis2_;
  axis2_ = axis2;
  if (axis2) {
    set_has_axis2();
  } else {
    clear_has_axis2();
  }
  // @@protoc_insertion_point(field_set_allocated:mw.internal.robotics.gazebotransport.ML_Joints.axis2)
}

// optional double cfm = 5;
inline bool ML_Joints::has_cfm() const {
  return (_has_bits_[0] & 0x00000010u) != 0;
}
inline void ML_Joints::set_has_cfm() {
  _has_bits_[0] |= 0x00000010u;
}
inline void ML_Joints::clear_has_cfm() {
  _has_bits_[0] &= ~0x00000010u;
}
inline void ML_Joints::clear_cfm() {
  cfm_ = 0;
  clear_has_cfm();
}
inline double ML_Joints::cfm() const {
  // @@protoc_insertion_point(field_get:mw.internal.robotics.gazebotransport.ML_Joints.cfm)
  return cfm_;
}
inline void ML_Joints::set_cfm(double value) {
  set_has_cfm();
  cfm_ = value;
  // @@protoc_insertion_point(field_set:mw.internal.robotics.gazebotransport.ML_Joints.cfm)
}

// optional double fudge_factor = 6;
inline bool ML_Joints::has_fudge_factor() const {
  return (_has_bits_[0] & 0x00000020u) != 0;
}
inline void ML_Joints::set_has_fudge_factor() {
  _has_bits_[0] |= 0x00000020u;
}
inline void ML_Joints::clear_has_fudge_factor() {
  _has_bits_[0] &= ~0x00000020u;
}
inline void ML_Joints::clear_fudge_factor() {
  fudge_factor_ = 0;
  clear_has_fudge_factor();
}
inline double ML_Joints::fudge_factor() const {
  // @@protoc_insertion_point(field_get:mw.internal.robotics.gazebotransport.ML_Joints.fudge_factor)
  return fudge_factor_;
}
inline void ML_Joints::set_fudge_factor(double value) {
  set_has_fudge_factor();
  fudge_factor_ = value;
  // @@protoc_insertion_point(field_set:mw.internal.robotics.gazebotransport.ML_Joints.fudge_factor)
}

// optional double suspension_cfm = 7;
inline bool ML_Joints::has_suspension_cfm() const {
  return (_has_bits_[0] & 0x00000040u) != 0;
}
inline void ML_Joints::set_has_suspension_cfm() {
  _has_bits_[0] |= 0x00000040u;
}
inline void ML_Joints::clear_has_suspension_cfm() {
  _has_bits_[0] &= ~0x00000040u;
}
inline void ML_Joints::clear_suspension_cfm() {
  suspension_cfm_ = 0;
  clear_has_suspension_cfm();
}
inline double ML_Joints::suspension_cfm() const {
  // @@protoc_insertion_point(field_get:mw.internal.robotics.gazebotransport.ML_Joints.suspension_cfm)
  return suspension_cfm_;
}
inline void ML_Joints::set_suspension_cfm(double value) {
  set_has_suspension_cfm();
  suspension_cfm_ = value;
  // @@protoc_insertion_point(field_set:mw.internal.robotics.gazebotransport.ML_Joints.suspension_cfm)
}

// optional double suspension_erp = 8;
inline bool ML_Joints::has_suspension_erp() const {
  return (_has_bits_[0] & 0x00000080u) != 0;
}
inline void ML_Joints::set_has_suspension_erp() {
  _has_bits_[0] |= 0x00000080u;
}
inline void ML_Joints::clear_has_suspension_erp() {
  _has_bits_[0] &= ~0x00000080u;
}
inline void ML_Joints::clear_suspension_erp() {
  suspension_erp_ = 0;
  clear_has_suspension_erp();
}
inline double ML_Joints::suspension_erp() const {
  // @@protoc_insertion_point(field_get:mw.internal.robotics.gazebotransport.ML_Joints.suspension_erp)
  return suspension_erp_;
}
inline void ML_Joints::set_suspension_erp(double value) {
  set_has_suspension_erp();
  suspension_erp_ = value;
  // @@protoc_insertion_point(field_set:mw.internal.robotics.gazebotransport.ML_Joints.suspension_erp)
}

// optional uint32 dof = 9;
inline bool ML_Joints::has_dof() const {
  return (_has_bits_[0] & 0x00000100u) != 0;
}
inline void ML_Joints::set_has_dof() {
  _has_bits_[0] |= 0x00000100u;
}
inline void ML_Joints::clear_has_dof() {
  _has_bits_[0] &= ~0x00000100u;
}
inline void ML_Joints::clear_dof() {
  dof_ = 0u;
  clear_has_dof();
}
inline ::google::protobuf::uint32 ML_Joints::dof() const {
  // @@protoc_insertion_point(field_get:mw.internal.robotics.gazebotransport.ML_Joints.dof)
  return dof_;
}
inline void ML_Joints::set_dof(::google::protobuf::uint32 value) {
  set_has_dof();
  dof_ = value;
  // @@protoc_insertion_point(field_set:mw.internal.robotics.gazebotransport.ML_Joints.dof)
}

// -------------------------------------------------------------------

// Gazebomodel

// required string name = 1;
inline bool Gazebomodel::has_name() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void Gazebomodel::set_has_name() {
  _has_bits_[0] |= 0x00000001u;
}
inline void Gazebomodel::clear_has_name() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void Gazebomodel::clear_name() {
  name_.ClearToEmptyNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
  clear_has_name();
}
inline const ::std::string& Gazebomodel::name() const {
  // @@protoc_insertion_point(field_get:mw.internal.robotics.gazebotransport.Gazebomodel.name)
  return name_.GetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline void Gazebomodel::set_name(const ::std::string& value) {
  set_has_name();
  name_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), value);
  // @@protoc_insertion_point(field_set:mw.internal.robotics.gazebotransport.Gazebomodel.name)
}
inline void Gazebomodel::set_name(const char* value) {
  set_has_name();
  name_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::string(value));
  // @@protoc_insertion_point(field_set_char:mw.internal.robotics.gazebotransport.Gazebomodel.name)
}
inline void Gazebomodel::set_name(const char* value, size_t size) {
  set_has_name();
  name_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(),
      ::std::string(reinterpret_cast<const char*>(value), size));
  // @@protoc_insertion_point(field_set_pointer:mw.internal.robotics.gazebotransport.Gazebomodel.name)
}
inline ::std::string* Gazebomodel::mutable_name() {
  set_has_name();
  // @@protoc_insertion_point(field_mutable:mw.internal.robotics.gazebotransport.Gazebomodel.name)
  return name_.MutableNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline ::std::string* Gazebomodel::release_name() {
  // @@protoc_insertion_point(field_release:mw.internal.robotics.gazebotransport.Gazebomodel.name)
  clear_has_name();
  return name_.ReleaseNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline void Gazebomodel::set_allocated_name(::std::string* name) {
  if (name != NULL) {
    set_has_name();
  } else {
    clear_has_name();
  }
  name_.SetAllocatedNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), name);
  // @@protoc_insertion_point(field_set_allocated:mw.internal.robotics.gazebotransport.Gazebomodel.name)
}

// repeated .mw.internal.robotics.gazebotransport.ML_Links links = 2;
inline int Gazebomodel::links_size() const {
  return links_.size();
}
inline void Gazebomodel::clear_links() {
  links_.Clear();
}
inline const ::mw::internal::robotics::gazebotransport::ML_Links& Gazebomodel::links(int index) const {
  // @@protoc_insertion_point(field_get:mw.internal.robotics.gazebotransport.Gazebomodel.links)
  return links_.Get(index);
}
inline ::mw::internal::robotics::gazebotransport::ML_Links* Gazebomodel::mutable_links(int index) {
  // @@protoc_insertion_point(field_mutable:mw.internal.robotics.gazebotransport.Gazebomodel.links)
  return links_.Mutable(index);
}
inline ::mw::internal::robotics::gazebotransport::ML_Links* Gazebomodel::add_links() {
  // @@protoc_insertion_point(field_add:mw.internal.robotics.gazebotransport.Gazebomodel.links)
  return links_.Add();
}
inline ::google::protobuf::RepeatedPtrField< ::mw::internal::robotics::gazebotransport::ML_Links >*
Gazebomodel::mutable_links() {
  // @@protoc_insertion_point(field_mutable_list:mw.internal.robotics.gazebotransport.Gazebomodel.links)
  return &links_;
}
inline const ::google::protobuf::RepeatedPtrField< ::mw::internal::robotics::gazebotransport::ML_Links >&
Gazebomodel::links() const {
  // @@protoc_insertion_point(field_list:mw.internal.robotics.gazebotransport.Gazebomodel.links)
  return links_;
}

// repeated .mw.internal.robotics.gazebotransport.ML_Joints joints = 3;
inline int Gazebomodel::joints_size() const {
  return joints_.size();
}
inline void Gazebomodel::clear_joints() {
  joints_.Clear();
}
inline const ::mw::internal::robotics::gazebotransport::ML_Joints& Gazebomodel::joints(int index) const {
  // @@protoc_insertion_point(field_get:mw.internal.robotics.gazebotransport.Gazebomodel.joints)
  return joints_.Get(index);
}
inline ::mw::internal::robotics::gazebotransport::ML_Joints* Gazebomodel::mutable_joints(int index) {
  // @@protoc_insertion_point(field_mutable:mw.internal.robotics.gazebotransport.Gazebomodel.joints)
  return joints_.Mutable(index);
}
inline ::mw::internal::robotics::gazebotransport::ML_Joints* Gazebomodel::add_joints() {
  // @@protoc_insertion_point(field_add:mw.internal.robotics.gazebotransport.Gazebomodel.joints)
  return joints_.Add();
}
inline ::google::protobuf::RepeatedPtrField< ::mw::internal::robotics::gazebotransport::ML_Joints >*
Gazebomodel::mutable_joints() {
  // @@protoc_insertion_point(field_mutable_list:mw.internal.robotics.gazebotransport.Gazebomodel.joints)
  return &joints_;
}
inline const ::google::protobuf::RepeatedPtrField< ::mw::internal::robotics::gazebotransport::ML_Joints >&
Gazebomodel::joints() const {
  // @@protoc_insertion_point(field_list:mw.internal.robotics.gazebotransport.Gazebomodel.joints)
  return joints_;
}

// optional .mw.internal.robotics.gazebotransport.ML_Pose pose = 4;
inline bool Gazebomodel::has_pose() const {
  return (_has_bits_[0] & 0x00000008u) != 0;
}
inline void Gazebomodel::set_has_pose() {
  _has_bits_[0] |= 0x00000008u;
}
inline void Gazebomodel::clear_has_pose() {
  _has_bits_[0] &= ~0x00000008u;
}
inline void Gazebomodel::clear_pose() {
  if (pose_ != NULL) pose_->::mw::internal::robotics::gazebotransport::ML_Pose::Clear();
  clear_has_pose();
}
inline const ::mw::internal::robotics::gazebotransport::ML_Pose& Gazebomodel::pose() const {
  // @@protoc_insertion_point(field_get:mw.internal.robotics.gazebotransport.Gazebomodel.pose)
  return pose_ != NULL ? *pose_ : *default_instance_->pose_;
}
inline ::mw::internal::robotics::gazebotransport::ML_Pose* Gazebomodel::mutable_pose() {
  set_has_pose();
  if (pose_ == NULL) {
    pose_ = new ::mw::internal::robotics::gazebotransport::ML_Pose;
  }
  // @@protoc_insertion_point(field_mutable:mw.internal.robotics.gazebotransport.Gazebomodel.pose)
  return pose_;
}
inline ::mw::internal::robotics::gazebotransport::ML_Pose* Gazebomodel::release_pose() {
  // @@protoc_insertion_point(field_release:mw.internal.robotics.gazebotransport.Gazebomodel.pose)
  clear_has_pose();
  ::mw::internal::robotics::gazebotransport::ML_Pose* temp = pose_;
  pose_ = NULL;
  return temp;
}
inline void Gazebomodel::set_allocated_pose(::mw::internal::robotics::gazebotransport::ML_Pose* pose) {
  delete pose_;
  pose_ = pose;
  if (pose) {
    set_has_pose();
  } else {
    clear_has_pose();
  }
  // @@protoc_insertion_point(field_set_allocated:mw.internal.robotics.gazebotransport.Gazebomodel.pose)
}

// optional bool enable_wind = 5;
inline bool Gazebomodel::has_enable_wind() const {
  return (_has_bits_[0] & 0x00000010u) != 0;
}
inline void Gazebomodel::set_has_enable_wind() {
  _has_bits_[0] |= 0x00000010u;
}
inline void Gazebomodel::clear_has_enable_wind() {
  _has_bits_[0] &= ~0x00000010u;
}
inline void Gazebomodel::clear_enable_wind() {
  enable_wind_ = false;
  clear_has_enable_wind();
}
inline bool Gazebomodel::enable_wind() const {
  // @@protoc_insertion_point(field_get:mw.internal.robotics.gazebotransport.Gazebomodel.enable_wind)
  return enable_wind_;
}
inline void Gazebomodel::set_enable_wind(bool value) {
  set_has_enable_wind();
  enable_wind_ = value;
  // @@protoc_insertion_point(field_set:mw.internal.robotics.gazebotransport.Gazebomodel.enable_wind)
}

// optional bool self_collide = 6;
inline bool Gazebomodel::has_self_collide() const {
  return (_has_bits_[0] & 0x00000020u) != 0;
}
inline void Gazebomodel::set_has_self_collide() {
  _has_bits_[0] |= 0x00000020u;
}
inline void Gazebomodel::clear_has_self_collide() {
  _has_bits_[0] &= ~0x00000020u;
}
inline void Gazebomodel::clear_self_collide() {
  self_collide_ = false;
  clear_has_self_collide();
}
inline bool Gazebomodel::self_collide() const {
  // @@protoc_insertion_point(field_get:mw.internal.robotics.gazebotransport.Gazebomodel.self_collide)
  return self_collide_;
}
inline void Gazebomodel::set_self_collide(bool value) {
  set_has_self_collide();
  self_collide_ = value;
  // @@protoc_insertion_point(field_set:mw.internal.robotics.gazebotransport.Gazebomodel.self_collide)
}

// optional bool is_static = 7;
inline bool Gazebomodel::has_is_static() const {
  return (_has_bits_[0] & 0x00000040u) != 0;
}
inline void Gazebomodel::set_has_is_static() {
  _has_bits_[0] |= 0x00000040u;
}
inline void Gazebomodel::clear_has_is_static() {
  _has_bits_[0] &= ~0x00000040u;
}
inline void Gazebomodel::clear_is_static() {
  is_static_ = false;
  clear_has_is_static();
}
inline bool Gazebomodel::is_static() const {
  // @@protoc_insertion_point(field_get:mw.internal.robotics.gazebotransport.Gazebomodel.is_static)
  return is_static_;
}
inline void Gazebomodel::set_is_static(bool value) {
  set_has_is_static();
  is_static_ = value;
  // @@protoc_insertion_point(field_set:mw.internal.robotics.gazebotransport.Gazebomodel.is_static)
}

// -------------------------------------------------------------------

// GetGazeboModelParam

// required string model_name = 1;
inline bool GetGazeboModelParam::has_model_name() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void GetGazeboModelParam::set_has_model_name() {
  _has_bits_[0] |= 0x00000001u;
}
inline void GetGazeboModelParam::clear_has_model_name() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void GetGazeboModelParam::clear_model_name() {
  model_name_.ClearToEmptyNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
  clear_has_model_name();
}
inline const ::std::string& GetGazeboModelParam::model_name() const {
  // @@protoc_insertion_point(field_get:mw.internal.robotics.gazebotransport.GetGazeboModelParam.model_name)
  return model_name_.GetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline void GetGazeboModelParam::set_model_name(const ::std::string& value) {
  set_has_model_name();
  model_name_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), value);
  // @@protoc_insertion_point(field_set:mw.internal.robotics.gazebotransport.GetGazeboModelParam.model_name)
}
inline void GetGazeboModelParam::set_model_name(const char* value) {
  set_has_model_name();
  model_name_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::string(value));
  // @@protoc_insertion_point(field_set_char:mw.internal.robotics.gazebotransport.GetGazeboModelParam.model_name)
}
inline void GetGazeboModelParam::set_model_name(const char* value, size_t size) {
  set_has_model_name();
  model_name_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(),
      ::std::string(reinterpret_cast<const char*>(value), size));
  // @@protoc_insertion_point(field_set_pointer:mw.internal.robotics.gazebotransport.GetGazeboModelParam.model_name)
}
inline ::std::string* GetGazeboModelParam::mutable_model_name() {
  set_has_model_name();
  // @@protoc_insertion_point(field_mutable:mw.internal.robotics.gazebotransport.GetGazeboModelParam.model_name)
  return model_name_.MutableNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline ::std::string* GetGazeboModelParam::release_model_name() {
  // @@protoc_insertion_point(field_release:mw.internal.robotics.gazebotransport.GetGazeboModelParam.model_name)
  clear_has_model_name();
  return model_name_.ReleaseNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline void GetGazeboModelParam::set_allocated_model_name(::std::string* model_name) {
  if (model_name != NULL) {
    set_has_model_name();
  } else {
    clear_has_model_name();
  }
  model_name_.SetAllocatedNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), model_name);
  // @@protoc_insertion_point(field_set_allocated:mw.internal.robotics.gazebotransport.GetGazeboModelParam.model_name)
}

// optional bool is_link = 2;
inline bool GetGazeboModelParam::has_is_link() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void GetGazeboModelParam::set_has_is_link() {
  _has_bits_[0] |= 0x00000002u;
}
inline void GetGazeboModelParam::clear_has_is_link() {
  _has_bits_[0] &= ~0x00000002u;
}
inline void GetGazeboModelParam::clear_is_link() {
  is_link_ = false;
  clear_has_is_link();
}
inline bool GetGazeboModelParam::is_link() const {
  // @@protoc_insertion_point(field_get:mw.internal.robotics.gazebotransport.GetGazeboModelParam.is_link)
  return is_link_;
}
inline void GetGazeboModelParam::set_is_link(bool value) {
  set_has_is_link();
  is_link_ = value;
  // @@protoc_insertion_point(field_set:mw.internal.robotics.gazebotransport.GetGazeboModelParam.is_link)
}

// optional string link_joint_name = 3;
inline bool GetGazeboModelParam::has_link_joint_name() const {
  return (_has_bits_[0] & 0x00000004u) != 0;
}
inline void GetGazeboModelParam::set_has_link_joint_name() {
  _has_bits_[0] |= 0x00000004u;
}
inline void GetGazeboModelParam::clear_has_link_joint_name() {
  _has_bits_[0] &= ~0x00000004u;
}
inline void GetGazeboModelParam::clear_link_joint_name() {
  link_joint_name_.ClearToEmptyNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
  clear_has_link_joint_name();
}
inline const ::std::string& GetGazeboModelParam::link_joint_name() const {
  // @@protoc_insertion_point(field_get:mw.internal.robotics.gazebotransport.GetGazeboModelParam.link_joint_name)
  return link_joint_name_.GetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline void GetGazeboModelParam::set_link_joint_name(const ::std::string& value) {
  set_has_link_joint_name();
  link_joint_name_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), value);
  // @@protoc_insertion_point(field_set:mw.internal.robotics.gazebotransport.GetGazeboModelParam.link_joint_name)
}
inline void GetGazeboModelParam::set_link_joint_name(const char* value) {
  set_has_link_joint_name();
  link_joint_name_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::string(value));
  // @@protoc_insertion_point(field_set_char:mw.internal.robotics.gazebotransport.GetGazeboModelParam.link_joint_name)
}
inline void GetGazeboModelParam::set_link_joint_name(const char* value, size_t size) {
  set_has_link_joint_name();
  link_joint_name_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(),
      ::std::string(reinterpret_cast<const char*>(value), size));
  // @@protoc_insertion_point(field_set_pointer:mw.internal.robotics.gazebotransport.GetGazeboModelParam.link_joint_name)
}
inline ::std::string* GetGazeboModelParam::mutable_link_joint_name() {
  set_has_link_joint_name();
  // @@protoc_insertion_point(field_mutable:mw.internal.robotics.gazebotransport.GetGazeboModelParam.link_joint_name)
  return link_joint_name_.MutableNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline ::std::string* GetGazeboModelParam::release_link_joint_name() {
  // @@protoc_insertion_point(field_release:mw.internal.robotics.gazebotransport.GetGazeboModelParam.link_joint_name)
  clear_has_link_joint_name();
  return link_joint_name_.ReleaseNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline void GetGazeboModelParam::set_allocated_link_joint_name(::std::string* link_joint_name) {
  if (link_joint_name != NULL) {
    set_has_link_joint_name();
  } else {
    clear_has_link_joint_name();
  }
  link_joint_name_.SetAllocatedNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), link_joint_name);
  // @@protoc_insertion_point(field_set_allocated:mw.internal.robotics.gazebotransport.GetGazeboModelParam.link_joint_name)
}

// -------------------------------------------------------------------

// GazeboModelSDF

// required string model_name = 1;
inline bool GazeboModelSDF::has_model_name() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void GazeboModelSDF::set_has_model_name() {
  _has_bits_[0] |= 0x00000001u;
}
inline void GazeboModelSDF::clear_has_model_name() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void GazeboModelSDF::clear_model_name() {
  model_name_.ClearToEmptyNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
  clear_has_model_name();
}
inline const ::std::string& GazeboModelSDF::model_name() const {
  // @@protoc_insertion_point(field_get:mw.internal.robotics.gazebotransport.GazeboModelSDF.model_name)
  return model_name_.GetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline void GazeboModelSDF::set_model_name(const ::std::string& value) {
  set_has_model_name();
  model_name_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), value);
  // @@protoc_insertion_point(field_set:mw.internal.robotics.gazebotransport.GazeboModelSDF.model_name)
}
inline void GazeboModelSDF::set_model_name(const char* value) {
  set_has_model_name();
  model_name_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::string(value));
  // @@protoc_insertion_point(field_set_char:mw.internal.robotics.gazebotransport.GazeboModelSDF.model_name)
}
inline void GazeboModelSDF::set_model_name(const char* value, size_t size) {
  set_has_model_name();
  model_name_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(),
      ::std::string(reinterpret_cast<const char*>(value), size));
  // @@protoc_insertion_point(field_set_pointer:mw.internal.robotics.gazebotransport.GazeboModelSDF.model_name)
}
inline ::std::string* GazeboModelSDF::mutable_model_name() {
  set_has_model_name();
  // @@protoc_insertion_point(field_mutable:mw.internal.robotics.gazebotransport.GazeboModelSDF.model_name)
  return model_name_.MutableNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline ::std::string* GazeboModelSDF::release_model_name() {
  // @@protoc_insertion_point(field_release:mw.internal.robotics.gazebotransport.GazeboModelSDF.model_name)
  clear_has_model_name();
  return model_name_.ReleaseNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline void GazeboModelSDF::set_allocated_model_name(::std::string* model_name) {
  if (model_name != NULL) {
    set_has_model_name();
  } else {
    clear_has_model_name();
  }
  model_name_.SetAllocatedNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), model_name);
  // @@protoc_insertion_point(field_set_allocated:mw.internal.robotics.gazebotransport.GazeboModelSDF.model_name)
}

// required string sdf_string = 2;
inline bool GazeboModelSDF::has_sdf_string() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void GazeboModelSDF::set_has_sdf_string() {
  _has_bits_[0] |= 0x00000002u;
}
inline void GazeboModelSDF::clear_has_sdf_string() {
  _has_bits_[0] &= ~0x00000002u;
}
inline void GazeboModelSDF::clear_sdf_string() {
  sdf_string_.ClearToEmptyNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
  clear_has_sdf_string();
}
inline const ::std::string& GazeboModelSDF::sdf_string() const {
  // @@protoc_insertion_point(field_get:mw.internal.robotics.gazebotransport.GazeboModelSDF.sdf_string)
  return sdf_string_.GetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline void GazeboModelSDF::set_sdf_string(const ::std::string& value) {
  set_has_sdf_string();
  sdf_string_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), value);
  // @@protoc_insertion_point(field_set:mw.internal.robotics.gazebotransport.GazeboModelSDF.sdf_string)
}
inline void GazeboModelSDF::set_sdf_string(const char* value) {
  set_has_sdf_string();
  sdf_string_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::string(value));
  // @@protoc_insertion_point(field_set_char:mw.internal.robotics.gazebotransport.GazeboModelSDF.sdf_string)
}
inline void GazeboModelSDF::set_sdf_string(const char* value, size_t size) {
  set_has_sdf_string();
  sdf_string_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(),
      ::std::string(reinterpret_cast<const char*>(value), size));
  // @@protoc_insertion_point(field_set_pointer:mw.internal.robotics.gazebotransport.GazeboModelSDF.sdf_string)
}
inline ::std::string* GazeboModelSDF::mutable_sdf_string() {
  set_has_sdf_string();
  // @@protoc_insertion_point(field_mutable:mw.internal.robotics.gazebotransport.GazeboModelSDF.sdf_string)
  return sdf_string_.MutableNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline ::std::string* GazeboModelSDF::release_sdf_string() {
  // @@protoc_insertion_point(field_release:mw.internal.robotics.gazebotransport.GazeboModelSDF.sdf_string)
  clear_has_sdf_string();
  return sdf_string_.ReleaseNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline void GazeboModelSDF::set_allocated_sdf_string(::std::string* sdf_string) {
  if (sdf_string != NULL) {
    set_has_sdf_string();
  } else {
    clear_has_sdf_string();
  }
  sdf_string_.SetAllocatedNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), sdf_string);
  // @@protoc_insertion_point(field_set_allocated:mw.internal.robotics.gazebotransport.GazeboModelSDF.sdf_string)
}

// -------------------------------------------------------------------

// GetGazeboModelSDF

// required string model_name = 1;
inline bool GetGazeboModelSDF::has_model_name() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void GetGazeboModelSDF::set_has_model_name() {
  _has_bits_[0] |= 0x00000001u;
}
inline void GetGazeboModelSDF::clear_has_model_name() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void GetGazeboModelSDF::clear_model_name() {
  model_name_.ClearToEmptyNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
  clear_has_model_name();
}
inline const ::std::string& GetGazeboModelSDF::model_name() const {
  // @@protoc_insertion_point(field_get:mw.internal.robotics.gazebotransport.GetGazeboModelSDF.model_name)
  return model_name_.GetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline void GetGazeboModelSDF::set_model_name(const ::std::string& value) {
  set_has_model_name();
  model_name_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), value);
  // @@protoc_insertion_point(field_set:mw.internal.robotics.gazebotransport.GetGazeboModelSDF.model_name)
}
inline void GetGazeboModelSDF::set_model_name(const char* value) {
  set_has_model_name();
  model_name_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::string(value));
  // @@protoc_insertion_point(field_set_char:mw.internal.robotics.gazebotransport.GetGazeboModelSDF.model_name)
}
inline void GetGazeboModelSDF::set_model_name(const char* value, size_t size) {
  set_has_model_name();
  model_name_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(),
      ::std::string(reinterpret_cast<const char*>(value), size));
  // @@protoc_insertion_point(field_set_pointer:mw.internal.robotics.gazebotransport.GetGazeboModelSDF.model_name)
}
inline ::std::string* GetGazeboModelSDF::mutable_model_name() {
  set_has_model_name();
  // @@protoc_insertion_point(field_mutable:mw.internal.robotics.gazebotransport.GetGazeboModelSDF.model_name)
  return model_name_.MutableNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline ::std::string* GetGazeboModelSDF::release_model_name() {
  // @@protoc_insertion_point(field_release:mw.internal.robotics.gazebotransport.GetGazeboModelSDF.model_name)
  clear_has_model_name();
  return model_name_.ReleaseNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline void GetGazeboModelSDF::set_allocated_model_name(::std::string* model_name) {
  if (model_name != NULL) {
    set_has_model_name();
  } else {
    clear_has_model_name();
  }
  model_name_.SetAllocatedNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), model_name);
  // @@protoc_insertion_point(field_set_allocated:mw.internal.robotics.gazebotransport.GetGazeboModelSDF.model_name)
}

#endif  // !PROTOBUF_INLINE_NOT_IN_HEADERS
// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------


// @@protoc_insertion_point(namespace_scope)

}  // namespace gazebotransport
}  // namespace robotics
}  // namespace internal
}  // namespace mw

#ifndef SWIG
namespace google {
namespace protobuf {

template <> struct is_proto_enum< ::mw::internal::robotics::gazebotransport::PacketHeader_MsgID> : ::google::protobuf::internal::true_type {};
template <>
inline const EnumDescriptor* GetEnumDescriptor< ::mw::internal::robotics::gazebotransport::PacketHeader_MsgID>() {
  return ::mw::internal::robotics::gazebotransport::PacketHeader_MsgID_descriptor();
}
template <> struct is_proto_enum< ::mw::internal::robotics::gazebotransport::Packet_CoSimError> : ::google::protobuf::internal::true_type {};
template <>
inline const EnumDescriptor* GetEnumDescriptor< ::mw::internal::robotics::gazebotransport::Packet_CoSimError>() {
  return ::mw::internal::robotics::gazebotransport::Packet_CoSimError_descriptor();
}
template <> struct is_proto_enum< ::mw::internal::robotics::gazebotransport::ResetSimulation_ResetBehavior> : ::google::protobuf::internal::true_type {};
template <>
inline const EnumDescriptor* GetEnumDescriptor< ::mw::internal::robotics::gazebotransport::ResetSimulation_ResetBehavior>() {
  return ::mw::internal::robotics::gazebotransport::ResetSimulation_ResetBehavior_descriptor();
}
template <> struct is_proto_enum< ::mw::internal::robotics::gazebotransport::MaxStepSize_TYPE> : ::google::protobuf::internal::true_type {};
template <>
inline const EnumDescriptor* GetEnumDescriptor< ::mw::internal::robotics::gazebotransport::MaxStepSize_TYPE>() {
  return ::mw::internal::robotics::gazebotransport::MaxStepSize_TYPE_descriptor();
}
template <> struct is_proto_enum< ::mw::internal::robotics::gazebotransport::JointState_Joint_Type> : ::google::protobuf::internal::true_type {};
template <>
inline const EnumDescriptor* GetEnumDescriptor< ::mw::internal::robotics::gazebotransport::JointState_Joint_Type>() {
  return ::mw::internal::robotics::gazebotransport::JointState_Joint_Type_descriptor();
}

}  // namespace protobuf
}  // namespace google
#endif  // SWIG

// @@protoc_insertion_point(global_scope)

#endif  // PROTOBUF_mw_2einternal_2erobotics_2egazebotransport_2eCoSimMsgs_2eproto__INCLUDED
